/*! Copyright Elasticsearch B.V. and/or license to Elasticsearch B.V. under one or more contributor license agreements
 * Licensed under the Elastic License; you may not use this file except in compliance with the Elastic License. */
webpackJsonp([2],
{
	1686: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.checkTimestamp = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(appState, genericReq, $location, wzMisc)
		{
			var data, current;
			return regeneratorRuntime.wrap(function _callee$(_context)
			{
				while (1) switch (_context.prev = _context.next)
				{
				case 0:
					_context.prev = 0;
					_context.next = 3;
					return genericReq.request("GET", "/elastic/timestamp");
				case 3:
					data = _context.sent;
					current = appState.getCreatedAt();
					if (data && data.data)
					{
						current || appState.setCreatedAt(data.data.lastRestart);
						wzMisc.setLastRestart(data.data.lastRestart)
					}
					else
					{
						wzMisc.setBlankScr("Your .threat-analytics-version index is empty or corrupt.");
						$location.search("tab", null);
						$location.path("/blank-screen")
					}
					return _context.abrupt("return");
				case 9:
					_context.prev = 9;
					_context.t0 = _context["catch"](0);
					wzMisc.setBlankScr(_context.t0.message || _context.t0);
					$location.search("tab", null);
					$location.path("/blank-screen");
				case 14:
				case "end":
					return _context.stop()
				}
			}, _callee, this, [
				[0, 9]
			])
		})), function checkTimestamp(_x, _x2, _x3, _x4)
		{
			return _ref.apply(this, arguments)
		});
		var _ref;

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
	},
	1687: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.totalRAM = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(genericReq, errorHandler)
		{
			var data, _totalRAM;
			return regeneratorRuntime.wrap(function _callee$(_context)
			{
				while (1) switch (_context.prev = _context.next)
				{
				case 0:
					_context.prev = 0;
					_context.next = 3;
					return genericReq.request("GET", "/utils/memory");
				case 3:
					data = _context.sent;
					_totalRAM = data.data.ram;
					_totalRAM < 1600 && _totalRAM > 1024 ? errorHandler.handle("Kibana server has " + _totalRAM + "MB of RAM, performance will suffer. Please increase it.", "RAM", true) : _totalRAM <= 1024 && errorHandler.handle("Kibana server has " + _totalRAM + "MB of RAM, performance will suffer. Please increase it.", "RAM");
					_context.next = 11;
					break;
				case 8:
					_context.prev = 8;
					_context.t0 = _context["catch"](0);
					errorHandler.handle("Kibana server has an unknown amount of RAM, please review it.", "RAM", true);
				case 11:
				case "end":
					return _context.stop()
				}
			}, _callee, this, [
				[0, 8]
			])
		})), function totalRAM(_x, _x2)
		{
			return _ref.apply(this, arguments)
		});
		var _ref;

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
	},
	1688: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'global-configuration\'" ng-init="switchConfigurationSubTab(\'global\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Global configuration</span>\n        </div>\n        <span class="md-subheader">Global and remote settings</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Global configuration navigation bar -->\n    <md-nav-bar\n        ng-if="!agent || agent.id === \'000\'"\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Global configuration navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'global\')" name="global">Global</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'remote\')" name="remote">Remote</md-nav-item>\n    </md-nav-bar>\n    <!-- End global configuration navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'global\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'analysis-global\']"\n      ng-if="currentConfig[\'analysis-global\'] && isString(currentConfig[\'analysis-global\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="currentConfig[\'com-logging\']"\n      ng-if="agent && agent.id !== \'000\' && currentConfig[\'com-logging\'] && isString(currentConfig[\'com-logging\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'analysis-global\'] && !isString(currentConfig[\'analysis-global\']) && !currentConfig[\'analysis-global\'].global"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="(currentConfig[\'analysis-global\'] && currentConfig[\'analysis-global\'].global) || (currentConfig[\'com-logging\'] && currentConfig[\'com-logging\'].logging)">\n\n        <!-- The main card will all the settings -->\n        <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content>\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Main settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Basic alerts and logging settings</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div class="wz-padding-top-10">\n\n                    <wz-config-item\n                        label="Write alerts to alerts.log file"\n                        value="currentConfig[\'analysis-global\'].global.alerts_log">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Write JSON formatted alerts to alerts.json file"\n                        value="currentConfig[\'analysis-global\'].global.jsonout_output">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Archive all the alerts in plain text format"\n                        value="currentConfig[\'analysis-global\'].global.logall">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Archive all the alerts in JSON format"\n                        value="currentConfig[\'analysis-global\'].global.logall_json">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Customized alerts format for alerts.log file"\n                        value="currentConfig[\'analysis-global\'].global.custom_alert_output">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Write internal logs in plain text"\n                        value="currentConfig[\'com-logging\'].logging.plain">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Write internal logs in JSON format"\n                        value="currentConfig[\'com-logging\'].logging.json">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Size limit of alert files"\n                        value="currentConfig[\'analysis-global\'].global.max_output_size">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="File rotation interval"\n                        value="currentConfig[\'analysis-global\'].global.rotate_interval">\n                    </wz-config-item>\n\n                </div>\n                <!-- End configuration block -->\n\n                <div ng-if="!agent || agent.id === \'000\'" class="wz-margin-top-10">\n                    <span class="font-size-16">Email settings</span>\n                    <div class="wz-margin-top-10">\n                        <span class="md-subheader small">Basic email settings (needed for granular email settings)</span>\n                    </div>\n                </div>\n                <md-divider ng-if="!agent || agent.id === \'000\'" class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div ng-if="!agent || agent.id === \'000\'" class="wz-padding-top-10">\n\n                    <wz-config-item\n                        label="Enable alerts sent by email"\n                        value="currentConfig[\'analysis-global\'].global.email_notification">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Sender address for email alerts"\n                        value="currentConfig[\'analysis-global\'].global.email_from">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Recipient address for email alerts "\n                        value="currentConfig[\'analysis-global\'].global.email_to">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Reply-to address for email alerts"\n                        value="currentConfig[\'analysis-global\'].global.email_reply_to">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Address for SMTP mail server"\n                        value="currentConfig[\'analysis-global\'].global.smtp_server">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Maximum number of email alerts sent per hour"\n                        value="currentConfig[\'analysis-global\'].global.email_maxperhour">\n                    </wz-config-item>\n                    <wz-config-item \n                        label="File to read data from" \n                        value="currentConfig[\'analysis-global\'].global.email_log_source">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Name used for email alerts headers"\n                        value="currentConfig[\'analysis-global\'].global.email_idsname">\n                    </wz-config-item>\n\n                </div>\n                <!-- End configuration block -->\n\n                <div ng-if="!agent || agent.id === \'000\'" class="wz-margin-top-10">\n                    <span class="font-size-16">Other settings</span>\n                    <div class="wz-margin-top-10">\n                        <span class="md-subheader small">Settings not directly related to any specific component</span>\n                    </div>\n                </div>\n                <md-divider ng-if="!agent || agent.id === \'000\'" class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div ng-if="!agent || agent.id === \'000\'" class="wz-padding-top-10">\n\n                    <wz-config-item\n                        label="Severity level for alerts generated by statistical analysis"\n                        value="currentConfig[\'analysis-global\'].global.stats">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Severity level for alerts generated by host change monitor"\n                        value="currentConfig[\'analysis-global\'].global.host_information">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Analysisd message input buffer size"\n                        value="currentConfig[\'analysis-global\'].global.queue_size">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Memory size for the alert correlation engine"\n                        value="currentConfig[\'analysis-global\'].global.memory_size">\n                    </wz-config-item>\n                    <wz-config-item\n                        is-array="true"\n                        label="White-listed IP addresses"\n                        value="currentConfig[\'analysis-global\'].global.white_list">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Full path to MaxMind GeoIP IPv4 database file"\n                        value="currentConfig[\'analysis-global\'].global.geoip_db_path">\n                    </wz-config-item>\n\n                </div>\n                <!-- End configuration block -->\n\n                <div ng-if="!agent || agent.id === \'000\'" class="wz-margin-top-10">\n                    <span class="font-size-16">Prelude and ZeroMQ output</span>\n                </div>\n                <md-divider ng-if="!agent || agent.id === \'000\'" class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div ng-if="!agent || agent.id === \'000\'" class="wz-padding-top-10">\n\n                    <wz-config-item\n                        label="Enable Prelude output"\n                        value="currentConfig[\'analysis-global\'].global.prelude_output">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Enable ZeroMQ output"\n                        value="currentConfig[\'analysis-global\'].global.zeromq_output">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="ZeroMQ URI to bind publisher socket"\n                        value="currentConfig[\'analysis-global\'].global.zeromq_uri">\n                    </wz-config-item>\n\n                </div>\n                <!-- End configuration block -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>2_More info about this section</md-subheader--!>\n            <md-list-item ng-if="!agent || agent.id === \'000\'" target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/reference/ossec-conf/global.html">Global reference</md-list-item>\n            <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/reference/ossec-conf/logging.html">2_Logging reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'remote\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'request-remote\']"\n      ng-if="currentConfig[\'request-remote\'] && isString(currentConfig[\'request-remote\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'request-remote\'] && !isString(currentConfig[\'request-remote\']) && !currentConfig[\'request-remote\'].remote"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'request-remote\'] && currentConfig[\'request-remote\'].remote">\n\n        <!-- The main card will all the settings -->\n        <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content>\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Remote settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Configuration to listen for events from the agents or a syslog client</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div class="wz-padding-top-10">\n\n                    <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                        <thead class="wz-text-bold">\n                            <th class="wz-text-left col-lg-2">Connection</th>\n                            <th class="wz-text-left">Port</th>\n                            <th class="wz-text-left">Protocol</th>\n                            <th class="wz-text-left">IPv6</th>\n                            <th class="wz-text-left col-lg-2">Allowed IPs</th>\n                            <th class="wz-text-left col-lg-2">Denied IPs</th>\n                            <th class="wz-text-left col-lg-2">Local IP</th>\n                            <th class="wz-text-left">Queue size</th>\n                        </thead>\n                        <tbody class="wz-word-wrap">\n                            <tr ng-repeat="item in currentConfig[\'request-remote\'].remote">\n                                <td>{{ item.connection || \'-\' }}</td>\n                                <td>{{ item.port || \'-\' }}</td>\n                                <td>{{ item.protocol || \'udp\' }}</td>\n                                <td>{{ item.ipv6 || \'-\' }}</td>\n                                <td>\n                                  <ul ng-if="item[\'allowed-ips\']">\n                                    <li ng-repeat="ip in item[\'allowed-ips\']">{{ ip }}</li>\n                                  </ul>\n                                  <span ng-if="!item[\'allowed-ips\']">-</span>\n                                </td>\n                                <td>\n                                  <ul ng-if="item[\'denied-ips\']">\n                                    <li ng-repeat="ip in item[\'denied-ips\']">{{ ip }}</li>\n                                  </ul>\n                                  <span ng-if="!item[\'denied-ips\']">-</span>\n                                </td>\n                                <td>{{ item.local_ip || \'All interfaces\' }}</td>\n                                <td>{{ item.queue_size || \'16384\' }}</td>\n                            </tr>\n                        </tbody>\n                    </table>\n\n                </div>\n                <!-- End configuration block -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/reference/daemons/ossec-remoted.html">Remote daemon reference</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/reference/ossec-conf/remote.html">Remote configuration reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	1689: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'alerts\'" ng-init="(!agent || agent.id === \'000\') ? switchConfigurationSubTab(\'general-alerts\') : switchConfigurationSubTab(\'labels\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span ng-if="!agent || agent.id === \'000\'" class="font-size-18">Alerts</span>\n            <span ng-if="agent && agent.id !== \'000\'" class="font-size-18">Labels</span>\n        </div>\n        <span ng-if="!agent || agent.id === \'000\'" class="md-subheader">Settings related to the alerts and their format</span>\n        <span ng-if="agent && agent.id !== \'000\'" class="md-subheader">User-defined information about the agent included in alerts</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Alerts navigation bar -->\n    <md-nav-bar\n        ng-if="!agent || agent.id === \'000\'"\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Alerts navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'general-alerts\')" name="general-alerts">General</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'labels\')" name="labels">Labels</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'email-alerts\')" name="email-alerts">Email alerts</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'reports\')" name="reports">Reports</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'syslog\')" name="syslog">Syslog output</md-nav-item>\n    </md-nav-bar>\n    <!-- End Alerts navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'email-alerts\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'mail-alerts\']"\n      ng-if="currentConfig[\'mail-alerts\'] && isString(currentConfig[\'mail-alerts\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'mail-alerts\'] && !isString(currentConfig[\'mail-alerts\']) && (!currentConfig[\'mail-alerts\'].email_alerts || !currentConfig[\'mail-alerts\'].email_alerts.length)"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'mail-alerts\'] && !isString(currentConfig[\'mail-alerts\']) && currentConfig[\'mail-alerts\'].email_alerts && currentConfig[\'mail-alerts\'].email_alerts.length">\n\n        <!-- The main card will all the settings -->\n        <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content flex layout="column">\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Main settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Granular email alert options</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                    <!-- List container -->\n                    <div flex="30" layout="column">\n\n                        <md-list flex="auto" class="wz-item-list">\n                            <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'mail-alerts\'].email_alerts">{{item.email_to}}</md-list-item>\n                        </md-list>\n\n                    </div>\n                    <!-- End list container -->\n\n                    <!-- Detail container -->\n                    <div flex layout="column" ng-if="currentConfig[\'mail-alerts\'].email_alerts.length">\n\n                        <div flex="auto" class="wz-item-detail">\n                            <wz-config-item\n                                label="Send alerts to this email address"\n                                value="currentConfig[\'mail-alerts\'].email_alerts[selectedItem].email_to">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Minimum severity level to send the alert by email"\n                                value="currentConfig[\'mail-alerts\'].email_alerts[selectedItem].level">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Send only alerts that belong to one of these groups"\n                                value="currentConfig[\'mail-alerts\'].email_alerts[selectedItem].group">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Send alerts when they match this event location"\n                                value="currentConfig[\'mail-alerts\'].email_alerts[selectedItem].event_location">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Format for email alerts"\n                                value="currentConfig[\'mail-alerts\'].email_alerts[selectedItem].format">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Send only alerts that belong to one of these rule IDs"\n                                value="currentConfig[\'mail-alerts\'].email_alerts[selectedItem].rule_id">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Disable delayed email delivery"\n                                value="currentConfig[\'mail-alerts\'].email_alerts[selectedItem].do_not_delay">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Disable alerts grouping into the same email"\n                                value="currentConfig[\'mail-alerts\'].email_alerts[selectedItem].do_not_group">\n                            </wz-config-item>\n                        </div>\n\n                    </div>\n                    <!-- End detail container -->\n                </div>\n\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/manager/manual-email-report/index.html">How to configure email alerts</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/manager/manual-email-report/smtp_authentication.html">How to configure authenticated SMTP server</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/reference/ossec-conf/email_alerts.html">Email alerts reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'general-alerts\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'analysis-alerts\']"\n      ng-if="currentConfig[\'analysis-alerts\'] && isString(currentConfig[\'analysis-alerts\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'analysis-alerts\'] && !isString(currentConfig[\'analysis-alerts\']) && !currentConfig[\'analysis-alerts\'].alerts"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'analysis-alerts\'] && !isString(currentConfig[\'analysis-alerts\']) && currentConfig[\'analysis-alerts\'].alerts">\n\n        <!-- The main card will all the settings -->\n        <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content>\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Main settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">General alert settings</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div class="wz-padding-top-10">\n\n                    <wz-config-item\n                        label="Minimum severity level to store the alert"\n                        value="currentConfig[\'analysis-alerts\'].alerts.log_alert_level">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Minimum severity level to send the alert by email"\n                        value="currentConfig[\'analysis-alerts\'].alerts.email_alert_level">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Enable GeoIP lookups"\n                        value="currentConfig[\'analysis-alerts\'].use_geoip || \'no\'">\n                    </wz-config-item>\n\n                </div>\n                <!-- End configuration block -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/getting-started/use-cases.html">Use cases about alerts generation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/reference/ossec-conf/alerts.html">Alerts reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'labels\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\']"\n      ng-if="currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\'] && isString(currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\'] && !isString(currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\']) && !hasSize(currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\'].labels)"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\'] && !isString(currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\']) && hasSize(currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\'].labels)">\n\n        <!-- The main card will all the settings -->\n        <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content>\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Defined labels</span>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div class="wz-padding-top-10">\n\n                    <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                        <thead class="wz-text-bold">\n                            <th class="wz-text-left">Label key</th>\n                            <th class="wz-text-left">Label value</th>\n                        </thead>\n                        <tbody class="wz-word-wrap">\n                            <tr ng-repeat="(key, value) in currentConfig[(agent && agent.id !== \'000\') ? \'agent-labels\' : \'analysis-labels\'].labels">\n                                <td>{{ key }}</td>\n                                <td>{{ value }}</td>\n                            </tr>\n                        </tbody>\n                    </table>\n\n                </div>\n                <!-- End configuration block -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>More info about this section</md-subheader--!>\n            <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/capabilities/labels.html">Labels documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/reference/ossec-conf/labels.html">Labels reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'reports\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'monitor-reports\']"\n      ng-if="currentConfig[\'monitor-reports\'] && isString(currentConfig[\'monitor-reports\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'monitor-reports\'] && !isString(currentConfig[\'monitor-reports\']) && (!currentConfig[\'monitor-reports\'].reports || !currentConfig[\'monitor-reports\'].reports.length)"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'monitor-reports\'] && !isString(currentConfig[\'monitor-reports\']) && currentConfig[\'monitor-reports\'].reports && currentConfig[\'monitor-reports\'].reports.length">\n\n        <!-- The main card will all the settings -->\n        <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content flex layout="column">\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Main settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Daily reports about alerts</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- The container for both list and detail -->\n                <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                    <!-- List container -->\n                    <div flex="30" layout="column">\n\n                        <md-list flex="auto" class="wz-item-list">\n                            <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'monitor-reports\'].reports">{{ item.title }}</md-list-item>\n                        </md-list>\n\n                    </div>\n                    <!-- End list container -->\n\n                    <!-- Detail container -->\n                    <div flex layout="column" ng-if="currentConfig[\'monitor-reports\'].reports.length">\n                        <div flex="auto" class="wz-item-detail">\n\n                            <wz-config-item\n                                label="Report name"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].title">\n                            </wz-config-item>\n                            <wz-config-item\n                                is-array="true"\n                                label="Send report to this email addresses"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].mail_to">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Include logs when creating a report"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].showlogs">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Filter by this group"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].group">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Filter by this category"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].category">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Filter by this rule ID"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].rule">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Filter by this alert level and above"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].level">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Filter by this log location"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].location">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Filter by this source IP address"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].srcip">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Filter by this user name"\n                                value="currentConfig[\'monitor-reports\'].reports[selectedItem].user">\n                            </wz-config-item>\n\n                        </div>\n\n                    </div>\n                    <!-- End detail container -->\n                </div>\n                <!-- End container for both list and detail -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/manager/automatic-reports.html">How to generate automatic reports</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/reference/ossec-conf/reports.html">Reports reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'syslog\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'csyslog-csyslog\']"\n      ng-if="currentConfig[\'csyslog-csyslog\'] && isString(currentConfig[\'csyslog-csyslog\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'csyslog-csyslog\'] && !isString(currentConfig[\'csyslog-csyslog\']) && (!currentConfig[\'csyslog-csyslog\'].syslog_output || !currentConfig[\'csyslog-csyslog\'].syslog_output.length)"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'csyslog-csyslog\'] && !isString(currentConfig[\'csyslog-csyslog\']) && currentConfig[\'csyslog-csyslog\'].syslog_output && currentConfig[\'csyslog-csyslog\'].syslog_output.length">\n\n        <!-- The main card will all the settings -->\n        <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content>\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Main settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Output alerts to a syslog server</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div class="wz-padding-top-10">\n\n                    <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                        <thead class="wz-text-bold">\n                            <th class="wz-text-left col-lg-2">Server</th>\n                            <th class="wz-text-left col-lg-1">Port</th>\n                            <th class="wz-text-left col-lg-1">Level</th>\n                            <th class="wz-text-left col-lg-1">Format</th>\n                            <th class="wz-text-left col-lg-1">FQDN</th>\n                            <th class="wz-text-left col-lg-2">Rule ID</th>\n                            <th class="wz-text-left col-lg-2">Group</th>\n                            <th class="wz-text-left col-lg-2">Location</th>\n                        </thead>\n                        <tbody class="wz-word-wrap">\n                            <tr ng-repeat="item in currentConfig[\'csyslog-csyslog\'].syslog_output">\n                                <td>{{ item.server }}</td>\n                                <td>{{ item.port }}</td>\n                                <td>{{ item.level }}</td>\n                                <td>{{ item.format || \'default\' }}</td>\n                                <td>{{ item.use_fqdn || \'no\' }}</td>\n                                <td>{{ item.rule_id || \'all\' }}</td>\n                                <td>{{ item.group || \'all\' }}</td>\n                                <td>{{ item.location || \'all\' }}</td>\n                            </tr>\n                        </tbody>\n                    </table>\n\n                </div>\n                <!-- End configuration block -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.ossec.com/current/user-manual/manager/manual-syslog-output.html">How to configure the syslog output</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/syslog-output.html">Syslog output reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	1690: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'policy-monitoring\'" ng-init="switchConfigurationSubTab(\'pm-general\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Policy monitoring</span>\n            <span\n              ng-if="currentConfig[\'syscheck-rootcheck\']\n              && currentConfig[\'syscheck-rootcheck\'].rootcheck\n              && currentConfig[\'syscheck-rootcheck\'].rootcheck.disabled\n              && currentConfig[\'syscheck-rootcheck\'].rootcheck.disabled === \'no\'"\n              class="wz-agent-status-indicator small teal">Enabled</span>\n            <span\n              ng-if="(currentConfig[\'syscheck-rootcheck\']\n              && currentConfig[\'syscheck-rootcheck\'].rootcheck\n              && currentConfig[\'syscheck-rootcheck\'].rootcheck.disabled\n              && currentConfig[\'syscheck-rootcheck\'].rootcheck.disabled === \'yes\')\n              ||\n              (currentConfig[\'syscheck-rootcheck\']\n              && isString(currentConfig[\'syscheck-rootcheck\']))" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Configuration to ensure compliance with security policies, standards and hardening guides</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Policy monitoring navigation bar -->\n    <md-nav-bar\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Policy monitoring navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'pm-general\')" name="pm-general">General</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'pm-unix\')" name="pm-unix">System audit</md-nav-item>\n    </md-nav-bar>\n    <!-- End Policy monitoring navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n      <!-- No configuration section -->\n      <wz-no-config\n        flex\n        error="currentConfig[\'syscheck-rootcheck\']"\n        ng-if="currentConfig[\'syscheck-rootcheck\'] && isString(currentConfig[\'syscheck-rootcheck\'])"></wz-no-config>\n      <wz-no-config\n        flex\n        error="\'not-present\'"\n        ng-if="currentConfig[\'syscheck-rootcheck\'] && !isString(currentConfig[\'syscheck-rootcheck\']) && !currentConfig[\'syscheck-rootcheck\'].rootcheck"></wz-no-config>\n      <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig[\'syscheck-rootcheck\'] && !isString(currentConfig[\'syscheck-rootcheck\']) && currentConfig[\'syscheck-rootcheck\'].rootcheck">\n<!-- The main card will all the settings -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'pm-general\'">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">All settings</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">General settings for the rootcheck daemon</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <wz-config-item\n                label="Policy monitoring service status"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.disabled === \'no\' ? \'enabled\' : \'disabled\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Base directory"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.base_directory">\n            </wz-config-item>\n            <wz-config-item\n                label="Scan the entire system"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.scanall">\n            </wz-config-item>\n            <wz-config-item\n                label="Frequency (in seconds) to run the scan"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.frequency">\n            </wz-config-item>\n            <wz-config-item\n                label="Check /dev path"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_dev">\n            </wz-config-item>\n            <wz-config-item\n                label="Check files"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_files">\n            </wz-config-item>\n            <wz-config-item\n                label="Check network interfaces"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_if">\n            </wz-config-item>\n            <wz-config-item\n                label="Check processes IDs"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_pids">\n            </wz-config-item>\n            <wz-config-item\n                label="Check network ports"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_ports">\n            </wz-config-item>\n            <wz-config-item\n                label="Check anomalous system objects"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_sys">\n            </wz-config-item>\n            <wz-config-item\n                label="Check trojans"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_trojans">\n            </wz-config-item>\n            <wz-config-item\n                label="Check UNIX audit"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_unixaudit">\n            </wz-config-item>\n            <wz-config-item\n                label="Check Windows apps"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_winapps">\n            </wz-config-item>\n            <wz-config-item\n                label="Check Windows audit"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_winaudit">\n            </wz-config-item>\n            <wz-config-item\n                label="Check Windows malware"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.check_winmalware">\n            </wz-config-item>\n            <wz-config-item\n                label="Skip scan on CIFS/NFS mounts"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.skip_nfs">\n            </wz-config-item>\n            <wz-config-item\n                label="Rootkit files database path"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.rootkit_files">\n            </wz-config-item>\n            <wz-config-item\n                label="Rootkit trojans database path"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.rootkit_trojans">\n            </wz-config-item>\n            <wz-config-item\n                label="Rootkit trojans database path"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.windows_audit">\n            </wz-config-item>\n            <wz-config-item\n                label="Rootkit trojans database path"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.windows_apps">\n            </wz-config-item>\n            <wz-config-item\n                label="Rootkit trojans database path"\n                value="currentConfig[\'syscheck-rootcheck\'].rootcheck.windows_malware">\n            </wz-config-item>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End main card with all the settings -->\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="configurationSubTab === \'pm-unix\' && currentConfig && currentConfig[\'syscheck-rootcheck\'] && currentConfig[\'syscheck-rootcheck\'].rootcheck && !currentConfig[\'syscheck-rootcheck\'].rootcheck.system_audit"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- The main card will all the settings -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'pm-unix\' && currentConfig && currentConfig[\'syscheck-rootcheck\'] && currentConfig[\'syscheck-rootcheck\'].rootcheck && currentConfig[\'syscheck-rootcheck\'].rootcheck.system_audit">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">UNIX audit files</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">Specified paths to audit definition files for Unix-like systems</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Path</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="item in currentConfig[\'syscheck-rootcheck\'].rootcheck.system_audit">\n                        <td>{{ item }}</td>\n                    </tr>\n                </tbody>\n            </table>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End main card with all the settings -->\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>More info about this section</md-subheader--!>\n            <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.wazuh.com/current/user-manual/capabilities/anomalies-detection/index.html">Anomaly and malware detection documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.wazuh.com/current/user-manual/capabilities/policy-monitoring/index.html">Policy monitoring documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/rootcheck.html">Rootcheck reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	1691: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'open-scap\'" ng-init="switchConfigurationSubTab(\'openscap-general\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">OpenSCAP</span>\n            <span ng-if="currentConfig && currentConfig[\'open-scap\'] && currentConfig[\'open-scap\'].disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="(currentConfig && currentConfig[\'open-scap\'] && currentConfig[\'open-scap\'].disabled === \'yes\') || (currentConfig && !currentConfig[\'open-scap\'])" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Configuration assessment and automation of compliance monitoring using SCAP checks</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- OpenSCAP navigation bar -->\n    <md-nav-bar\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="OpenSCAP navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'openscap-general\')" name="openscap-general">General</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'openscap-evaluations\')" name="openscap-evaluations">Evaluations</md-nav-item>\n    </md-nav-bar>\n    <!-- End OpenSCAP navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'wmodules-wmodules\']"\n          ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <wz-no-config\n          flex\n          error="\'not-present\'"\n          ng-if="currentConfig && !currentConfig[\'open-scap\'] && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig[\'open-scap\']">\n<!-- General card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'openscap-general\'">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Main settings</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">These settings apply to all OpenSCAP evaluations</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n            <wz-config-item\n                label="OpenSCAP integration status"\n                value="currentConfig[\'open-scap\'].disabled === \'yes\' ? \'disabled\' : \'enabled\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Timeout (in seconds) for scan executions"\n                value="currentConfig[\'open-scap\'].timeout">\n            </wz-config-item>\n            <wz-config-item\n                label="Interval between scan executions"\n                value="currentConfig[\'open-scap\'].interval">\n            </wz-config-item>\n            <wz-config-item\n                label="Scan on start"\n                value="currentConfig[\'open-scap\'][\'scan-on-start\']">\n            </wz-config-item>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End general card -->\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="configurationSubTab === \'openscap-evaluations\' && currentConfig && currentConfig[\'open-scap\'] && !currentConfig[\'open-scap\'].content"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- Evaluations card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'openscap-evaluations\' && currentConfig && currentConfig[\'open-scap\'] && currentConfig[\'open-scap\'].content">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Evaluations</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">Scans executed according to specific security policies and their profiles</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Path</th>\n                    <th class="wz-text-left">Profile</th>\n                    <th class="wz-text-left">Type</th>\n                    <th class="wz-text-left">Timeout</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="item in currentConfig[\'open-scap\'].content">\n                        <td>{{item.path}}</td>\n                        <td>\n                          <ul>\n                            <li ng-repeat="profile in item.profile">{{profile}}</li>\n                          </ul>\n                          <span ng-if="!item.profile">-</span>\n                        </td>\n                        <td>{{ item.type }}</td>\n                        <td>{{ item.timeout }}</td>\n                    </tr>\n                </tbody>\n            </table>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End evaluations card -->\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>More info about this section</md-subheader--!>\n            <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.wazuh.com/current/user-manual/capabilities/policy-monitoring/openscap/index.html">OpenSCAP module documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/wodle-openscap.html">OpenSCAP module reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	1692: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'cis-cat\'" ng-init="switchConfigurationSubTab(\'ciscat-general\')">\n\n    <!-- Headline -->\n    <!--div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">CIS-CAT</span>\n            <span ng-if="currentConfig && currentConfig[\'cis-cat\'] && currentConfig[\'cis-cat\'].disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="(currentConfig && currentConfig[\'cis-cat\'] && currentConfig[\'cis-cat\'].disabled === \'yes\') || (currentConfig && !currentConfig[\'cis-cat\'])" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Configuration assessment using CIS scanner and SCAP checks</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- CIS-CAT navigation bar -->\n    <md-nav-bar\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="CIS-CAT navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'ciscat-general\')" name="ciscat-general">General</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'ciscat-benchmarks\')" name="ciscat-benchmarks">Benchmarks</md-nav-item>\n    </md-nav-bar>\n    <!-- End CIS-CAT navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'wmodules-wmodules\']"\n          ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <wz-no-config\n          flex\n          error="\'not-present\'"\n          ng-if="currentConfig && !currentConfig[\'cis-cat\'] && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig[\'cis-cat\']">\n<!-- The main card will all the settings -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'ciscat-general\'">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Main settings</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">General settings applied to all benchmarks</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <wz-config-item\n                label="CIS-CAT integration status"\n                value="currentConfig[\'cis-cat\'].disabled === \'yes\' ? \'disabled\' : \'enabled\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Timeout (in seconds) for scan executions"\n                value="currentConfig[\'cis-cat\'].timeout">\n            </wz-config-item>\n            <wz-config-item\n                label="Path to Java executable directory"\n                value="currentConfig[\'cis-cat\'].java_path">\n            </wz-config-item>\n            <wz-config-item\n                label="Path to CIS-CAT executable directory"\n                value="currentConfig[\'cis-cat\'].ciscat_path">\n            </wz-config-item>\n\n        </div>\n        <!-- End configuration block -->\n\n        <div class="wz-margin-top-10">\n            <span class="font-size-16">Scheduling settings</span>\n            <div class="wz-margin-top-10">\n                <span class="md-subheader small">Customize CIS-CAT scans scheduling</span>\n            </div>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <wz-config-item\n                label="Interval between scan executions"\n                value="currentConfig[\'cis-cat\'].interval">\n            </wz-config-item>\n            <wz-config-item\n                label="Scan on start"\n                value="currentConfig[\'cis-cat\'][\'scan-on-start\']">\n            </wz-config-item>\n            <wz-config-item\n                label="Day of the month to run scans"\n                value="currentConfig[\'cis-cat\'].day">\n            </wz-config-item>\n            <wz-config-item\n                label="Day of the week to run scans"\n                value="currentConfig[\'cis-cat\'].wday">\n            </wz-config-item>\n            <wz-config-item\n                label="Time of the day to run scans"\n                value="currentConfig[\'cis-cat\'].time">\n            </wz-config-item>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End main card with all the settings -->\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="configurationSubTab === \'ciscat-benchmarks\' && currentConfig && currentConfig[\'cis-cat\'] && !currentConfig[\'cis-cat\'].content"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- The main card will all the settings -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'ciscat-benchmarks\' && currentConfig && currentConfig[\'cis-cat\'] && currentConfig[\'cis-cat\'].content">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Benchmarks</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">List of CIS-CAT benchmark templates to perform scans</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Path</th>\n                    <th class="wz-text-left">Profile</th>\n                    <th class="wz-text-left">Timeout</th>\n                    <th class="wz-text-left">Type</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="item in currentConfig[\'cis-cat\'].content">\n                        <td>{{item.path}}</td>\n                        <td>{{item.profile}}</td>\n                        <td>{{item.timeout}}</td>\n                        <td>{{item.type}}</td>\n                    </tr>\n                </tbody>\n            </table>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End main card with all the settings -->\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/policy-monitoring/ciscat/ciscat.html">CIS-CAT module documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-ciscat.html">CIS-CAT module reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	1693: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'integrity-monitoring\'" ng-init="switchConfigurationSubTab(\'fim-general\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Integrity monitoring</span>\n            <span\n              ng-if="currentConfig[\'syscheck-syscheck\']\n              && currentConfig[\'syscheck-syscheck\'].syscheck\n              && currentConfig[\'syscheck-syscheck\'].syscheck.disabled\n              && currentConfig[\'syscheck-syscheck\'].syscheck.disabled === \'no\'"\n              class="wz-agent-status-indicator small teal">Enabled</span>\n            <span\n              ng-if="(currentConfig[\'syscheck-syscheck\']\n              && currentConfig[\'syscheck-syscheck\'].syscheck\n              && currentConfig[\'syscheck-syscheck\'].syscheck.disabled\n              && currentConfig[\'syscheck-syscheck\'].syscheck.disabled === \'yes\')\n              ||\n              (currentConfig[\'syscheck-syscheck\']\n              && isString(currentConfig[\'syscheck-syscheck\']))" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Identify changes in content, permissions, ownership and attributes of files</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Integrity monitoring navigation bar -->\n    <md-nav-bar\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Integrity monitoring navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'fim-general\')" name="fim-general">General</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'fim-monitored\')" name="fim-monitored">Monitored</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'fim-ignored\')" name="fim-ignored">Ignored</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'fim-nodiff\')" name="fim-nodiff">No diff</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'fim-whodata\')" ng-if="!agent || agent.isLinuxOS" name="fim-whodata">Who-data</md-nav-item>\n    </md-nav-bar>\n    <!-- End Integrity monitoring navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'syscheck-syscheck\']"\n          ng-if="currentConfig[\'syscheck-syscheck\'] && isString(currentConfig[\'syscheck-syscheck\'])"></wz-no-config>\n        <wz-no-config\n          flex\n          error="\'not-present\'"\n          ng-if="currentConfig[\'syscheck-syscheck\'] && !isString(currentConfig[\'syscheck-syscheck\']) && !currentConfig[\'syscheck-syscheck\'].syscheck"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig[\'syscheck-syscheck\'] && !isString(currentConfig[\'syscheck-syscheck\']) && currentConfig[\'syscheck-syscheck\'].syscheck">\n<!-- General card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'fim-general\'">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">General</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">The settings shown below are applied globally</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <wz-config-item\n                label="Integrity monitoring status"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.disabled === \'no\' ? \'enabled\' : \'disabled\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Interval (in seconds) to run the integrity scan"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.frequency">\n            </wz-config-item>\n            <wz-config-item\n                label="Time of day to run integrity scans"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.scan_time || \'-\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Day of the week to run integrity scans"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.scan_day || \'-\'">\n            </wz-config-item>\n            <wz-config-item\n                ng-if="!agent || agent.id === \'000\'"\n                label="Ignore files that change too many times"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.auto_ignore || \'no\'">\n            </wz-config-item>\n            <wz-config-item\n                ng-if="!agent || agent.id === \'000\'"\n                label="Alert when new files are created"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.alert_new_files || \'no\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Scan on start"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.scan_on_start">\n            </wz-config-item>\n            <wz-config-item\n                label="Skip scan on CIFS/NFS mounts"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.skip_nfs">\n            </wz-config-item>\n            <wz-config-item\n                label="Remove old local snapshots"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.remove_old_diff || \'yes\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Restart the Audit daemon"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.restart_audit">\n            </wz-config-item>\n            <wz-config-item\n                label="Interval (in seconds) to check directories\' SACLs"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.windows_audit_interval || \'300\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Command to prevent prelinking"\n                value="currentConfig[\'syscheck-syscheck\'].syscheck.prefilter_cmd || \'-\'">\n            </wz-config-item>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End general card -->\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="((agent || {}).os || {}).platform !== \'windows\' && configurationSubTab === \'fim-ignored\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && !currentConfig[\'syscheck-syscheck\'].syscheck.ignore"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- Ignored card -->\n<md-card class="wz-md-card" ng-if="((agent || {}).os || {}).platform !== \'windows\' && !JSONContent && !XMLContent && configurationSubTab === \'fim-ignored\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && currentConfig[\'syscheck-syscheck\'].syscheck.ignore">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Ignored files and directories</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">These files and directories are ignored from the integrity scan</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Path</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="path in currentConfig[\'syscheck-syscheck\'].syscheck.ignore">\n                        <td>{{path}}</td>\n                    </tr>\n                </tbody>\n            </table>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End ignored card -->\n\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="((agent || {}).os || {}).platform === \'windows\' && configurationSubTab === \'fim-ignored\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && !currentConfig[\'syscheck-syscheck\'].syscheck.registry && !currentConfig[\'syscheck-syscheck\'].syscheck.registry_ignore"></wz-no-config>\n<!-- End no configuration section -->\n\n\n<md-card class="wz-md-card" ng-if="((agent || {}).os || {}).platform === \'windows\' && configurationSubTab === \'fim-ignored\' && !JSONContent && !XMLContent && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && (currentConfig[\'syscheck-syscheck\'].syscheck.registry || currentConfig[\'syscheck-syscheck\'].syscheck.registry_ignore)">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Ignored</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">A list of registry entries that will be ignored</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Entry</th>\n                    <th class="wz-text-left">Arch</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="registry in currentConfig[\'syscheck-syscheck\'].syscheck.registry_ignore">\n                        <td>{{registry.entry}}</td>\n                        <td>{{registry.arch}}</td>\n                    </tr>\n                </tbody>\n            </table>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card><!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="configurationSubTab === \'fim-monitored\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && currentConfig[\'syscheck-syscheck\'].syscheck.directories && !currentConfig[\'syscheck-syscheck\'].syscheck.directories.length"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- Monitored card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'fim-monitored\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && currentConfig[\'syscheck-syscheck\'].syscheck.directories && currentConfig[\'syscheck-syscheck\'].syscheck.directories.length">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Monitored directories</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">These directories are included on the integrity scan</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- The container for both list and detail -->\n        <div layout="row" class="wz-margin-top-10 min-height-300">\n\n            <!-- List container -->\n            <div flex="30" layout="column">\n\n                <md-list flex="auto" class="wz-item-list">\n                    <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'syscheck-syscheck\'].syscheck.directories">{{item.dir}}</md-list-item>\n                </md-list>\n\n            </div>\n            <!-- End list container -->\n\n            <!-- Detail container -->\n            <div flex layout="column" ng-if="currentConfig[\'syscheck-syscheck\'].syscheck.directories.length">\n\n                <div flex="auto" class="wz-item-detail">\n                    <wz-config-item\n                        label="Selected item"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].dir">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Enable realtime monitoring"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'realtime\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Enable auditing (who-data)"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_whodata\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Report file changes"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'report_changes\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Perform all checksums"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_all\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check sums (MD5 & SHA1)"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_sum\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check MD5 sum"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_md5sum\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check SHA1 sum"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_sha1sum\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check SHA256 sum"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_sha256sum\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check files size"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_size\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check files owner"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_owner\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check files groups"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_group\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check files permissions"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_perm\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check files modification time"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_mtime\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Check files inodes"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].opts.includes(\'check_inode\') ? \'yes\' : \'no\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Restrict to files containing this string"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].restrict">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Custom tags for alerts"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].tags">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Recursion level"\n                        value="currentConfig[\'syscheck-syscheck\'].syscheck.directories[selectedItem].recursion_level">\n                    </wz-config-item>\n                </div>\n\n            </div>\n            <!-- End detail container -->\n        </div>\n        <!-- End container for both list and detail -->\n    </md-card-content>\n</md-card>\n<!-- End monitored card -->\n\n\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="((agent || {}).os || {}).platform === \'windows\' && configurationSubTab === \'fim-monitored\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && !currentConfig[\'syscheck-syscheck\'].syscheck.registry && !currentConfig[\'syscheck-syscheck\'].syscheck.registry_ignore"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- Windows card -->\n<md-card class="wz-md-card" ng-if="((agent || {}).os || {}).platform === \'windows\' && configurationSubTab === \'fim-monitored\' && !JSONContent && !XMLContent && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && (currentConfig[\'syscheck-syscheck\'].syscheck.registry || currentConfig[\'syscheck-syscheck\'].syscheck.registry_ignore)">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Monitored</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">A list of registry entries that will be monitored</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Entry</th>\n                    <th class="wz-text-left">Arch</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="registry in currentConfig[\'syscheck-syscheck\'].syscheck.registry">\n                        <td>{{registry.entry}}</td>\n                        <td>{{registry.arch}}</td>\n                    </tr>\n                </tbody>\n            </table>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End Windows card -->\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="configurationSubTab === \'fim-nodiff\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && !currentConfig[\'syscheck-syscheck\'].syscheck.nodiff"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- No diff card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'fim-nodiff\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && currentConfig[\'syscheck-syscheck\'].syscheck.nodiff">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">No diff directories</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">This files won\'t have their diff calculated</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Path</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="path in currentConfig[\'syscheck-syscheck\'].syscheck.nodiff">\n                        <td>{{path}}</td>\n                    </tr>\n                </tbody>\n            </table>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End no diff card -->\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="configurationSubTab === \'fim-whodata\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && !currentConfig[\'syscheck-syscheck\'].syscheck.ignore"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- Who-data card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'fim-whodata\' && currentConfig && currentConfig[\'syscheck-syscheck\'] && currentConfig[\'syscheck-syscheck\'].syscheck && currentConfig[\'syscheck-syscheck\'].syscheck.ignore">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Who-data audit keys</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">Wazuh will include in its FIM baseline those events being monitored by Audit using audit_key.</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10" ng-show="currentConfig[\'syscheck-syscheck\'].syscheck.whodata">\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Keys</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="auditkey in currentConfig[\'syscheck-syscheck\'].syscheck.whodata.audit_key">\n                        <td>{{auditkey}}</td>\n                    </tr>\n                </tbody>\n            </table>\n        </div>\n        <div class="wz-padding-top-10" ng-show="!currentConfig[\'syscheck-syscheck\'].syscheck.whodata">\n            <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> No audit keys were found. Visit the documentation on <a href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/syscheck.html#whodata">this link</a> to enable it. \n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End auditkeys card -->\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/file-integrity/index.html">Integrity monitoring documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/syscheck.html">Syscheck reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	1694: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'log-collection\'" ng-init="switchConfigurationSubTab(\'localfile\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Log collection</span>\n        </div>\n        <span class="md-subheader">Log analysis from text files, Windows events or syslog outputs</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Log collection navigation bar -->\n    <md-nav-bar\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Log collection navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'localfile\')" name="localfile">Localfiles</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'socket\')" name="socket">Sockets</md-nav-item>\n    </md-nav-bar>\n    <!-- End Log collection navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'localfile\'">\n\n  <!-- No configuration section -->\n  <wz-no-config\n    flex\n    error="currentConfig[\'logcollector-localfile\']"\n    ng-if="currentConfig[\'logcollector-localfile\'] && isString(currentConfig[\'logcollector-localfile\'])"></wz-no-config>\n  <wz-no-config\n    flex\n    error="\'not-present\'"\n    ng-if="currentConfig[\'logcollector-localfile\'] && !isString(currentConfig[\'logcollector-localfile\']) && !currentConfig[\'logcollector-localfile\'].localfile"></wz-no-config>\n  <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'logcollector-localfile\'] && !isString(currentConfig[\'logcollector-localfile\']) && currentConfig[\'logcollector-localfile\'].localfile && currentConfig[\'logcollector-localfile\'].localfile.length">\n\n        <!-- The main card will all the settings -->\n        <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content flex layout="column">\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Logs files and command monitoring</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">List of log files that will be analyzed</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- The container for both list and detail -->\n                <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                    <!-- List container -->\n                    <div flex="30" layout="column">\n\n                        <md-list flex="auto" class="wz-item-list">\n                            <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'logcollector-localfile\'].localfile">\n                                <span ng-if=\'item.file || item.alias || item.command\'>{{ item.file || item.alias || item.command }}</span>\n                                <span ng-if=\'!item.file && !item.alias && !item.command\'>{{ item.logformat }} - {{ item.targetStr }}</span></md-list-item>\n                        </md-list>\n\n                    </div>\n                    <!-- End list container -->\n\n                    <!-- Detail container -->\n                    <div flex layout="column" ng-if="currentConfig[\'logcollector-localfile\'].localfile.length">\n\n                        <div flex="auto" class="wz-item-detail">\n                            <wz-config-item\n                                label="Log format"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].logformat">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Log location"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].file || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Run this command"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].command || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Command alias"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].alias || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Interval between command executions"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].frequency || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Only receive logs occured after start"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem][\'only-future-events\'] || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Filter logs using this XPATH query"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].query || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Log labels"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].labels || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                is-array="true"\n                                label="Redirect output to this socket"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].target || \'agent\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                is-array="true"\n                                label="Log collection output format"\n                                value="currentConfig[\'logcollector-localfile\'].localfile[selectedItem].target">\n                            </wz-config-item>\n                        </div>\n\n                    </div>\n                    <!-- End detail container -->\n                </div>\n                <!-- End container for both list and detail -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/log-data-collection/index.html">Log data collection documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/localfile.html">Localfile reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'socket\'">\n\n  <!-- No configuration section -->\n  <wz-no-config\n    flex\n    error="currentConfig[\'logcollector-socket\']"\n    ng-if="currentConfig[\'logcollector-socket\'] && isString(currentConfig[\'logcollector-socket\'])"></wz-no-config>\n  <wz-no-config\n    flex\n    error="\'not-present\'"\n    ng-if="currentConfig[\'logcollector-socket\'] && !isString(currentConfig[\'logcollector-socket\']) && !currentConfig[\'logcollector-socket\'].target"></wz-no-config>\n  <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'logcollector-socket\'] && !isString(currentConfig[\'logcollector-socket\']) && currentConfig[\'logcollector-socket\'].target && currentConfig[\'logcollector-socket\'].target.length">\n\n        <!-- The main card will all the settings -->\n        <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content flex layout="column">\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Output sockets</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Define custom outputs to send log data</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- The container for both list and detail -->\n                <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                    <!-- List container -->\n                    <div flex="30" layout="column">\n\n                        <md-list flex="auto" class="wz-item-list">\n                            <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'logcollector-socket\'].target">{{ item.name }}</md-list-item>\n                        </md-list>\n\n                    </div>\n                    <!-- End list container -->\n\n                    <!-- Detail container -->\n                    <div flex layout="column" ng-if="currentConfig[\'logcollector-socket\'].target.length">\n\n                        <div flex="auto" class="wz-item-detail">\n                            <wz-config-item\n                                label="Socket name"\n                                value="currentConfig[\'logcollector-socket\'].target[selectedItem].name || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Socket location"\n                                value="currentConfig[\'logcollector-socket\'].target[selectedItem].location || \'-\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="UNIX socket protocol"\n                                value="currentConfig[\'logcollector-socket\'].target[selectedItem].mode || \'udp\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Prefix to place before the message"\n                                value="currentConfig[\'logcollector-socket\'].target[selectedItem].prefix || \'-\'">\n                            </wz-config-item>\n                        </div>\n\n                    </div>\n                    <!-- End detail container -->\n                </div>\n                <!-- End container for both list and detail -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/log-data-collection/log-data-configuration.html#using-multiple-outputs">Using multiple outputs</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/socket.html">Socket reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	1695: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.generateMetric = generateMetric;
		var _jquery = __webpack_require__(16);
		var _jquery2 = _interopRequireDefault(_jquery);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function generateMetric(id)
		{
			var html = (0, _jquery2.default)(id).html();
			if (html.split("ng-non-bindable") && html.split("ng-non-bindable")[1] && html.split("ng-non-bindable")[1].split(">") && html.split("ng-non-bindable")[1].split(">")[1] && html.split("ng-non-bindable")[1].split(">")[1].split("</") && html.split("ng-non-bindable")[1].split(">")[1].split("</")[0]) return html.split("ng-non-bindable")[1].split(">")[1].split("</")[0];
			if ("undefined" !== typeof html && html.includes("<span"))
			{
				if ("undefined" !== typeof html.split("<span>")[1]) return html.split("<span>")[1].split("</span")[0];
				if (html.includes("table") && html.includes("cell-hover"))
				{
					var nonB = html.split("ng-non-bindable")[1];
					if (nonB && nonB.split(">")[1] && nonB.split(">")[1].split("</")[0]) return nonB.split(">")[1].split("</")[0]
				}
			}
			return ""
		}
	},
	1696: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.TabDescription = {
			general:
			{
				title: "Security events",
				description: "Browse through your security alerts, identifying issues and threats in your environment."
			},
			fim:
			{
				title: "Integrity monitoring",
				description: "Alerts related to file changes, including permissions, content, ownership and attributes."
			},
			pm:
			{
				title: "Policy monitoring",
				description: "Verify that your systems are configured according to your security policies baseline."
			},
			vuls:
			{
				title: "Vulnerabilities",
				description: "Discover what applications in your environment are affected by well-known vulnerabilities."
			},
			oscap:
			{
				title: "OpenSCAP",
				description: "Configuration assessment and automation of compliance monitoring using SCAP checks."
			},
			audit:
			{
				title: "System auditing",
				description: "Audit users behavior, monitoring command execution and alerting on access to critical files."
			},
			pci:
			{
				title: "PCI DSS",
				description: "Global security standard for entities that process, store or transmit payment cardholder data."
			},
			gdpr:
			{
				title: "GDPR",
				description: "General Data Protection Regulation (GDPR) sets guidelines for processing of personal data."
			},
			ciscat:
			{
				title: "CIS-CAT",
				description: "Configuration assessment using Center of Internet Security scanner and SCAP checks."
			},
			aws:
			{
				title: "Amazon AWS",
				description: "Security events related to your Amazon AWS services, collected directly via AWS API."
			},
			virustotal:
			{
				title: "VirusTotal",
				description: "Alerts resulting from VirusTotal analysis of suspicious files via an integration with their API."
			},
			syscollector:
			{
				title: "Inventory data",
				description: "Applications, network configuration, open ports and processes running on your monitored systems."
			},
			configuration:
			{
				title: "Configuration",
				description: "Check the current agent configuration remotely applied by its group."
			},
			osquery:
			{
				title: "Osquery",
				description: "Osquery can be used to expose an operating system as a high-performance relational database."
			}
		}
	},
	1697: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var replacer = function replacer(match, pIndent, pKey, pVal, pEnd)
		{
			var key = "<span class=json-key>";
			var val = "<span class=json-value>";
			var str = "<span class=json-string>";
			var r = pIndent || "";
			pKey && (r = r + key + pKey.replace(/[": ]/g, "") + "</span>: ");
			pVal && (r = r + ('"' == pVal[0] ? str : val) + pVal + "</span>");
			return r + (pEnd || "")
		};
		var prettyPrint = function prettyPrint(obj)
		{
			var jsonLine = /^( *)("[\w]+": )?("[^"]*"|[\w.+-]*)?([,[{])?$/gm;
			return JSON.stringify(obj, null, 3).replace(/&/g, "&amp;").replace(/\\"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(jsonLine, replacer)
		};
		exports.default = {
			replacer: replacer,
			prettyPrint: prettyPrint
		};
		module.exports = exports["default"]
	},
	1698: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.ConfigurationHandler = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _js2xmlparser = __webpack_require__(5329);
		var _js2xmlparser2 = _interopRequireDefault(_js2xmlparser);
		var _xmlBeautifier = __webpack_require__(5333);
		var _xmlBeautifier2 = _interopRequireDefault(_xmlBeautifier);
		var _jsonBeautifier = __webpack_require__(1697);
		var _jsonBeautifier2 = _interopRequireDefault(_jsonBeautifier);
		var _queryConfig = __webpack_require__(5334);
		var _removeHashKey = __webpack_require__(5335);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ConfigurationHandler = function ()
		{
			function ConfigurationHandler(apiReq, errorHandler)
			{
				_classCallCheck(this, ConfigurationHandler);
				this.apiReq = apiReq;
				this.errorHandler = errorHandler
			}
			_createClass(ConfigurationHandler, [
			{
				key: "buildIntegrations",
				value: function buildIntegrations(list, $scope)
				{
					if (!list || !list.length) return;
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = void 0;
					try
					{
						for (var _step, _iterator = list[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
						{
							var integration = _step.value;
							$scope.integrations[integration.name] = integration
						}
					}
					catch (err)
					{
						_didIteratorError = true;
						_iteratorError = err
					}
					finally
					{
						try
						{
							!_iteratorNormalCompletion && _iterator.return && _iterator.return()
						}
						finally
						{
							if (_didIteratorError) throw _iteratorError
						}
					}
				}
			},
			{
				key: "switchConfigTab",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(configurationTab, sections, $scope)
					{
						var agentId = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								$scope.load = true;
								$scope.currentConfig = null;
								$scope.XMLContent = false;
								$scope.JSONContent = false;
								$scope.configurationSubTab = false;
								$scope.configurationTab = configurationTab;
								_context.next = 9;
								return (0, _queryConfig.queryConfig)(agentId || "000", sections, this.apiReq, this.errorHandler);
							case 9:
								$scope.currentConfig = _context.sent;
								"integrator" === sections[0].component ? this.buildIntegrations($scope.currentConfig["integrator-integration"].integration, $scope) : $scope.integrations = {};
								$scope.currentConfig["logcollector-localfile"] && $scope.currentConfig["logcollector-localfile"].localfile && $scope.currentConfig["logcollector-localfile"].localfile.forEach(function (file)
								{
									if (file.target)
									{
										file.targetStr = "";
										file.target.forEach(function (target, idx)
										{
											file.targetStr = file.targetStr.concat(target);
											idx != file.target.length - 1 && (file.targetStr = file.targetStr.concat(", "))
										})
									}
								});
								$scope.load = false;
								$scope.$$phase || $scope.$digest();
								_context.next = 20;
								break;
							case 16:
								_context.prev = 16;
								_context.t0 = _context["catch"](0);
								this.errorHandler.handle(_context.t0, "Manager");
								$scope.load = false;
							case 20:
								return _context.abrupt("return");
							case 21:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 16]
						])
					}));

					function switchConfigTab(_x2, _x3, _x4)
					{
						return _ref.apply(this, arguments)
					}
					return switchConfigTab
				}()
			},
			{
				key: "switchWodle",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(wodleName, $scope)
					{
						var agentId = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
						var result;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								$scope.load = true;
								$scope.currentConfig = null;
								$scope.XMLContent = false;
								$scope.JSONContent = false;
								$scope.configurationSubTab = false;
								$scope.configurationTab = wodleName;
								_context2.next = 9;
								return (0, _queryConfig.queryConfig)(agentId || "000", [
								{
									component: "wmodules",
									configuration: "wmodules"
								}], this.apiReq, this.errorHandler);
							case 9:
								$scope.currentConfig = _context2.sent;
								result = [];
								wodleName && $scope.currentConfig && $scope.currentConfig["wmodules-wmodules"] && $scope.currentConfig["wmodules-wmodules"].wmodules && (result = $scope.currentConfig["wmodules-wmodules"].wmodules.filter(function (item)
								{
									return "undefined" !== typeof item[wodleName]
								}));
								result.length && ($scope.currentConfig = "command" === wodleName ?
								{
									commands: result.map(function (item)
									{
										return item.command
									})
								} : result[0]);
								$scope.load = false;
								$scope.$$phase || $scope.$digest();
								_context2.next = 21;
								break;
							case 17:
								_context2.prev = 17;
								_context2.t0 = _context2["catch"](0);
								this.errorHandler.handle(_context2.t0, "Manager");
								$scope.load = false;
							case 21:
								return _context2.abrupt("return");
							case 22:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 17]
						])
					}));

					function switchWodle(_x6, _x7)
					{
						return _ref2.apply(this, arguments)
					}
					return switchWodle
				}()
			},
			{
				key: "isWodleEnabled",
				value: function ()
				{
					var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(wodleName)
					{
						var agentId = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						var wodlesConfig, result;
						return regeneratorRuntime.wrap(function _callee3$(_context3)
						{
							while (1) switch (_context3.prev = _context3.next)
							{
							case 0:
								_context3.prev = 0;
								_context3.next = 3;
								return (0, _queryConfig.queryConfig)(agentId || "000", [
								{
									component: "wmodules",
									configuration: "wmodules"
								}], this.apiReq, this.errorHandler);
							case 3:
								wodlesConfig = _context3.sent;
								result = [];
								wodleName && "command" !== wodleName && wodlesConfig && wodlesConfig["wmodules-wmodules"] && wodlesConfig["wmodules-wmodules"].wmodules && (result = wodlesConfig["wmodules-wmodules"].wmodules.filter(function (item)
								{
									return "undefined" !== typeof item[wodleName] && "no" === item[wodleName].disabled
								}));
								return _context3.abrupt("return", !!result.length);
							case 9:
								_context3.prev = 9;
								_context3.t0 = _context3["catch"](0);
								return _context3.abrupt("return", false);
							case 12:
							case "end":
								return _context3.stop()
							}
						}, _callee3, this, [
							[0, 9]
						])
					}));

					function isWodleEnabled(_x9)
					{
						return _ref3.apply(this, arguments)
					}
					return isWodleEnabled
				}()
			},
			{
				key: "switchConfigurationTab",
				value: function switchConfigurationTab(configurationTab, $scope)
				{
					$scope.selectedItem = 0;
					$scope.currentConfig = null;
					$scope.XMLContent = false;
					$scope.JSONContent = false;
					$scope.configurationSubTab = false;
					$scope.configurationTab = configurationTab;
					$scope.$$phase || $scope.$digest()
				}
			},
			{
				key: "switchConfigurationSubTab",
				value: function switchConfigurationSubTab(configurationSubTab, $scope)
				{
					$scope.selectedItem = 0;
					$scope.XMLContent = false;
					$scope.JSONContent = false;
					$scope.configurationSubTab = configurationSubTab;
					$scope.$$phase || $scope.$digest()
				}
			},
			{
				key: "getXML",
				value: function getXML($scope)
				{
					var config = {};
					Object.assign(config, $scope.currentConfig);
					$scope.JSONContent = false;
					if ($scope.XMLContent) $scope.XMLContent = false;
					else try
					{
						var cleaned = (0, _removeHashKey.objectWithoutProperties)(config);
						$scope.XMLContent = (0, _xmlBeautifier2.default)(_js2xmlparser2.default.parse("configuration", cleaned))
					}
					catch (error)
					{
						$scope.XMLContent = false
					}
					$scope.$$phase || $scope.$digest()
				}
			},
			{
				key: "getJSON",
				value: function getJSON($scope)
				{
					var config = {};
					Object.assign(config, $scope.currentConfig);
					$scope.XMLContent = false;
					if ($scope.JSONContent) $scope.JSONContent = false;
					else try
					{
						var cleaned = (0, _removeHashKey.objectWithoutProperties)(config);
						$scope.JSONContent = _jsonBeautifier2.default.prettyPrint(cleaned)
					}
					catch (error)
					{
						$scope.JSONContent = false
					}
					$scope.$$phase || $scope.$digest()
				}
			},
			{
				key: "reset",
				value: function reset($scope)
				{
					$scope.currentConfig = null;
					$scope.configurationTab = "";
					$scope.configurationSubTab = "";
					$scope.integrations = {};
					$scope.selectedItem = 0
				}
			}]);
			return ConfigurationHandler
		}()
	},
	1699: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var escape_1 = __webpack_require__(955);
		var options_1 = __webpack_require__(485);
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlAttributeText_1 = __webpack_require__(956);
		var XmlCharRef_1 = __webpack_require__(957);
		var XmlEntityRef_1 = __webpack_require__(958);
		var XmlNode_1 = __webpack_require__(72);
		var XmlAttribute = function (_super)
		{
			__extends(XmlAttribute, _super);

			function XmlAttribute(name, value)
			{
				var _this = _super.call(this) || this;
				_this.name = name;
				if (utils_1.isArray(value))
					for (var _i = 0, value_1 = value; _i < value_1.length; _i++)
					{
						var node = value_1[_i];
						_this.insertChild(node)
					}
				else _this.insertChild(value);
				return _this
			}
			Object.defineProperty(XmlAttribute.prototype, "name",
			{
				get: function ()
				{
					return this._name
				},
				set: function (name)
				{
					if (!utils_1.isString(name)) throw new TypeError("name should be a string");
					if (!validate_1.validateName(name)) throw new Error("name should not contain characters not allowed in XML names");
					this._name = name
				},
				enumerable: true,
				configurable: true
			});
			XmlAttribute.prototype.charRef = function (char, hex, index)
			{
				var charRef = new XmlCharRef_1.default(char, hex);
				this.insertChild(charRef, index);
				return charRef
			};
			XmlAttribute.prototype.entityRef = function (entity, index)
			{
				var charRef = new XmlEntityRef_1.default(entity);
				this.insertChild(charRef, index);
				return charRef
			};
			XmlAttribute.prototype.insertChild = function (node, index)
			{
				if (!(node instanceof XmlCharRef_1.default || node instanceof XmlEntityRef_1.default || node instanceof XmlAttributeText_1.default)) throw new TypeError("node should be an instance of XmlCharRef, XmlEntityRef, or XmlAttributeText");
				return _super.prototype.insertChild.call(this, node, index)
			};
			XmlAttribute.prototype.removeChild = function (node)
			{
				if (1 === this._children.length) throw new Error("XmlAttribute nodes must have at least one child");
				return _super.prototype.removeChild.call(this, node)
			};
			XmlAttribute.prototype.removeChildAtIndex = function (index)
			{
				if (1 === this._children.length) throw new Error("XmlAttribute nodes must have at least one child");
				return _super.prototype.removeChildAtIndex.call(this, index)
			};
			XmlAttribute.prototype.text = function (text, index)
			{
				var textNode = new XmlAttributeText_1.default(text);
				this.insertChild(textNode, index);
				return textNode
			};
			XmlAttribute.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				var optionsObj = new options_1.StringOptions(options);
				var quote = optionsObj.doubleQuotes ? '"' : "'";
				var str = this.name + "=" + quote;
				for (var _i = 0, _a = this._children; _i < _a.length; _i++)
				{
					var child = _a[_i];
					optionsObj.doubleQuotes ? str += escape_1.escapeDoubleQuotes(child.toString(options)) : str += escape_1.escapeSingleQuotes(child.toString(options))
				}
				str += quote;
				return str
			};
			return XmlAttribute
		}(XmlNode_1.default);
		exports.default = XmlAttribute
	},
	1700: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlCdata = function (_super)
		{
			__extends(XmlCdata, _super);

			function XmlCdata(data)
			{
				var _this = _super.call(this) || this;
				_this.data = data;
				return _this
			}
			Object.defineProperty(XmlCdata.prototype, "data",
			{
				get: function ()
				{
					return this._data
				},
				set: function (data)
				{
					if (!utils_1.isString(data)) throw new TypeError("character data should be a string");
					if (!validate_1.validateChar(data)) throw new Error("character data should not contain characters not allowed in XML");
					if (/]]>/.test(data)) throw new Error("data should not contain the string ']]>'");
					this._data = data
				},
				enumerable: true,
				configurable: true
			});
			XmlCdata.prototype.children = function ()
			{
				throw new Error("XmlCdata nodes cannot have children")
			};
			XmlCdata.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlCdata nodes cannot have children")
			};
			XmlCdata.prototype.removeChild = function (node)
			{
				throw new Error("XmlCdata nodes cannot have children")
			};
			XmlCdata.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlCdata nodes cannot have children")
			};
			XmlCdata.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return "<![CDATA[" + this.data + "]]>"
			};
			return XmlCdata
		}(XmlNode_1.default);
		exports.default = XmlCdata
	},
	1701: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var escape_1 = __webpack_require__(955);
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlCharData = function (_super)
		{
			__extends(XmlCharData, _super);

			function XmlCharData(charData)
			{
				var _this = _super.call(this) || this;
				_this.charData = charData;
				return _this
			}
			Object.defineProperty(XmlCharData.prototype, "charData",
			{
				get: function ()
				{
					return this._charData
				},
				set: function (charData)
				{
					if (!utils_1.isString(charData)) throw new TypeError("charData should be a string");
					if (!validate_1.validateChar(charData)) throw new Error("charData should not contain characters not allowed in XML");
					this._charData = charData
				},
				enumerable: true,
				configurable: true
			});
			XmlCharData.prototype.children = function ()
			{
				throw new Error("XmlCharData nodes cannot have children")
			};
			XmlCharData.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlCharData nodes cannot have children")
			};
			XmlCharData.prototype.removeChild = function (node)
			{
				throw new Error("XmlCharData nodes cannot have children")
			};
			XmlCharData.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlCharData nodes cannot have children")
			};
			XmlCharData.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				var str = this.charData;
				str = escape_1.escapeAmpersands(str);
				str = escape_1.escapeLeftAngleBrackets(str);
				str = escape_1.escapeRightAngleBracketsInCdataTerminator(str);
				return str
			};
			return XmlCharData
		}(XmlNode_1.default);
		exports.default = XmlCharData
	},
	1702: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var options_1 = __webpack_require__(485);
		var utils_1 = __webpack_require__(64);
		var XmlNode_1 = __webpack_require__(72);
		var XmlDecl = function (_super)
		{
			__extends(XmlDecl, _super);

			function XmlDecl(options)
			{
				void 0 === options && (options = {});
				var _this = _super.call(this) || this;
				var optionsObj = new options_1.DeclarationOptions(options);
				_this.encoding = optionsObj.encoding;
				_this.standalone = optionsObj.standalone;
				_this.version = optionsObj.version;
				return _this
			}
			Object.defineProperty(XmlDecl.prototype, "encoding",
			{
				get: function ()
				{
					return this._encoding
				},
				set: function (encoding)
				{
					if (utils_1.isString(encoding))
					{
						if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(encoding)) throw new Error("encoding should be a valid XML encoding")
					}
					else if (!utils_1.isUndefined(encoding)) throw new TypeError("name should be a string or undefined");
					this._encoding = encoding
				},
				enumerable: true,
				configurable: true
			});
			Object.defineProperty(XmlDecl.prototype, "standalone",
			{
				get: function ()
				{
					return this._standalone
				},
				set: function (standalone)
				{
					if (utils_1.isString(standalone))
					{
						if (!/^(yes|no)$/.test(standalone)) throw new Error("standalone should be either the string 'yes' or the string 'no'")
					}
					else if (!utils_1.isUndefined(standalone)) throw new TypeError("standalone should be a string or undefined");
					this._standalone = standalone
				},
				enumerable: true,
				configurable: true
			});
			Object.defineProperty(XmlDecl.prototype, "version",
			{
				get: function ()
				{
					return this._version
				},
				set: function (version)
				{
					if (!utils_1.isString(version)) throw new TypeError("version should be a string");
					if (!/^1\.[0-9]+$/.test(version)) throw new Error("version should be a valid XML version");
					this._version = version
				},
				enumerable: true,
				configurable: true
			});
			XmlDecl.prototype.children = function ()
			{
				throw new Error("XmlDecl nodes cannot have children")
			};
			XmlDecl.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlDecl nodes cannot have children")
			};
			XmlDecl.prototype.removeChild = function (node)
			{
				throw new Error("XmlDecl nodes cannot have children")
			};
			XmlDecl.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlDecl nodes cannot have children")
			};
			XmlDecl.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				var optionsObj = new options_1.StringOptions(options);
				var quote = optionsObj.doubleQuotes ? '"' : "'";
				var str = "<?xml version=" + quote + this.version + quote;
				utils_1.isString(this.encoding) && (str += " encoding=" + quote + this.encoding + quote);
				utils_1.isString(this.standalone) && (str += " standalone=" + quote + this.standalone + quote);
				str += "?>";
				return str
			};
			return XmlDecl
		}(XmlNode_1.default);
		exports.default = XmlDecl
	},
	1703: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var options_1 = __webpack_require__(485);
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlComment_1 = __webpack_require__(647);
		var XmlDtdAttlist_1 = __webpack_require__(1704);
		var XmlDtdElement_1 = __webpack_require__(1705);
		var XmlDtdEntity_1 = __webpack_require__(1706);
		var XmlDtdNotation_1 = __webpack_require__(1707);
		var XmlDtdParamEntityRef_1 = __webpack_require__(1708);
		var XmlNode_1 = __webpack_require__(72);
		var XmlProcInst_1 = __webpack_require__(648);
		var XmlDtd = function (_super)
		{
			__extends(XmlDtd, _super);

			function XmlDtd(name, sysId, pubId)
			{
				var _this = _super.call(this) || this;
				_this.name = name;
				_this.sysId = sysId;
				_this.pubId = pubId;
				return _this
			}
			Object.defineProperty(XmlDtd.prototype, "name",
			{
				get: function ()
				{
					return this._name
				},
				set: function (name)
				{
					if (!utils_1.isString(name)) throw new TypeError("name should be a string");
					if (!validate_1.validateName(name)) throw new Error("name should not contain characters not allowed in XML names");
					this._name = name
				},
				enumerable: true,
				configurable: true
			});
			Object.defineProperty(XmlDtd.prototype, "pubId",
			{
				get: function ()
				{
					return this._pubId
				},
				set: function (pubId)
				{
					if (utils_1.isString(pubId))
					{
						if (!/^(\u0020|\u000D|\u000A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/.test(pubId)) throw new Error("pubId should not contain characters not allowed in public identifiers");
						if (utils_1.isUndefined(this.sysId)) throw new Error("pubId should not be defined if sysId is undefined")
					}
					else if (!utils_1.isUndefined(pubId)) throw new TypeError("pubId should be a string or undefined");
					this._pubId = pubId
				},
				enumerable: true,
				configurable: true
			});
			Object.defineProperty(XmlDtd.prototype, "sysId",
			{
				get: function ()
				{
					return this._sysId
				},
				set: function (sysId)
				{
					if (utils_1.isString(sysId))
					{
						if (!validate_1.validateChar(sysId)) throw new Error("sysId should not contain characters not allowed in XML");
						if (-1 !== sysId.indexOf("'") && -1 !== sysId.indexOf('"')) throw new Error("sysId should not contain both single quotes and double quotes")
					}
					else
					{
						if (!utils_1.isUndefined(sysId)) throw new TypeError("sysId should be a string or undefined");
						if (!utils_1.isUndefined(this.pubId)) throw new Error("sysId should not be undefined if pubId is defined")
					}
					this._sysId = sysId
				},
				enumerable: true,
				configurable: true
			});
			XmlDtd.prototype.attlist = function (text, index)
			{
				var attlist = new XmlDtdAttlist_1.default(text);
				this.insertChild(attlist, index);
				return attlist
			};
			XmlDtd.prototype.comment = function (content, index)
			{
				var comment = new XmlComment_1.default(content);
				this.insertChild(comment, index);
				return comment
			};
			XmlDtd.prototype.element = function (text, index)
			{
				var element = new XmlDtdElement_1.default(text);
				this.insertChild(element, index);
				return element
			};
			XmlDtd.prototype.entity = function (text, index)
			{
				var entity = new XmlDtdEntity_1.default(text);
				this.insertChild(entity, index);
				return entity
			};
			XmlDtd.prototype.insertChild = function (node, index)
			{
				if (!(node instanceof XmlComment_1.default || node instanceof XmlDtdAttlist_1.default || node instanceof XmlDtdElement_1.default || node instanceof XmlDtdEntity_1.default || node instanceof XmlDtdNotation_1.default || node instanceof XmlDtdParamEntityRef_1.default || node instanceof XmlProcInst_1.default)) throw new TypeError("node should be an instance of XmlComment, XmlDtdAttlist, XmlDtdElement, XmlDtdEntity, XmlDtdNotation, XmlDtdParamEntityRef, or XmlProcInst");
				return _super.prototype.insertChild.call(this, node, index)
			};
			XmlDtd.prototype.notation = function (text, index)
			{
				var notation = new XmlDtdNotation_1.default(text);
				this.insertChild(notation, index);
				return notation
			};
			XmlDtd.prototype.paramEntityRef = function (entity, index)
			{
				var paramEntity = new XmlDtdParamEntityRef_1.default(entity);
				this.insertChild(paramEntity, index);
				return paramEntity
			};
			XmlDtd.prototype.procInst = function (target, content, index)
			{
				var procInst = new XmlProcInst_1.default(target, content);
				this.insertChild(procInst, index);
				return procInst
			};
			XmlDtd.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				var optionsObj = new options_1.StringOptions(options);
				var str = "<!DOCTYPE " + this.name;
				if (utils_1.isUndefined(this.pubId))
				{
					if (!utils_1.isUndefined(this.sysId))
					{
						str += " ";
						str = appendId("SYSTEM", this.sysId, str, optionsObj)
					}
				}
				else
				{
					str += " ";
					str = appendId("PUBLIC", this.pubId, str, optionsObj);
					str = appendId("", this.sysId, str, optionsObj)
				}
				if (0 !== this._children.length)
				{
					str += " [";
					for (var _i = 0, _a = this._children; _i < _a.length; _i++)
					{
						var node = _a[_i];
						optionsObj.pretty && (str += optionsObj.newline + optionsObj.indent);
						str += node.toString(options)
					}
					optionsObj.pretty && (str += optionsObj.newline);
					str += "]>"
				}
				else str += ">";
				return str
			};
			return XmlDtd
		}(XmlNode_1.default);
		exports.default = XmlDtd;

		function appendId(type, value, str, options)
		{
			str += type + " ";
			if (options.doubleQuotes)
			{
				if (-1 !== value.indexOf('"')) throw new Error("options.doubleQuotes inconsistent with sysId or pubId");
				str += '"' + value + '"'
			}
			else
			{
				if (-1 !== value.indexOf("'")) throw new Error("options.doubleQuotes inconsistent with sysId or pubId");
				str += "'" + value + "'"
			}
			return str
		}
	},
	1704: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlDtdAttlist = function (_super)
		{
			__extends(XmlDtdAttlist, _super);

			function XmlDtdAttlist(text)
			{
				var _this = _super.call(this) || this;
				_this.text = text;
				return _this
			}
			Object.defineProperty(XmlDtdAttlist.prototype, "text",
			{
				get: function ()
				{
					return this._text
				},
				set: function (text)
				{
					if (!utils_1.isString(text)) throw new TypeError("text should be a string");
					if (!validate_1.validateChar(text)) throw new Error("data should not contain characters not allowed in XML");
					this._text = text
				},
				enumerable: true,
				configurable: true
			});
			XmlDtdAttlist.prototype.children = function ()
			{
				throw new Error("XmlDtdAttlist nodes cannot have children")
			};
			XmlDtdAttlist.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlDtdAttlist nodes cannot have children")
			};
			XmlDtdAttlist.prototype.removeChild = function (node)
			{
				throw new Error("XmlDtdAttlist nodes cannot have children")
			};
			XmlDtdAttlist.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlDtdAttlist nodes cannot have children")
			};
			XmlDtdAttlist.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return "<!ATTLIST " + this.text + ">"
			};
			return XmlDtdAttlist
		}(XmlNode_1.default);
		exports.default = XmlDtdAttlist
	},
	1705: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlDtdElement = function (_super)
		{
			__extends(XmlDtdElement, _super);

			function XmlDtdElement(text)
			{
				var _this = _super.call(this) || this;
				_this.text = text;
				return _this
			}
			Object.defineProperty(XmlDtdElement.prototype, "text",
			{
				get: function ()
				{
					return this._text
				},
				set: function (text)
				{
					if (!utils_1.isString(text)) throw new TypeError("text should be a string");
					if (!validate_1.validateChar(text)) throw new Error("data should not contain characters not allowed in XML");
					this._text = text
				},
				enumerable: true,
				configurable: true
			});
			XmlDtdElement.prototype.children = function ()
			{
				throw new Error("XmlDtdElement nodes cannot have children")
			};
			XmlDtdElement.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlDtdElement nodes cannot have children")
			};
			XmlDtdElement.prototype.removeChild = function (node)
			{
				throw new Error("XmlDtdElement nodes cannot have children")
			};
			XmlDtdElement.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlDtdElement nodes cannot have children")
			};
			XmlDtdElement.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return "<!ELEMENT " + this.text + ">"
			};
			return XmlDtdElement
		}(XmlNode_1.default);
		exports.default = XmlDtdElement
	},
	1706: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlDtdEntity = function (_super)
		{
			__extends(XmlDtdEntity, _super);

			function XmlDtdEntity(text)
			{
				var _this = _super.call(this) || this;
				_this.text = text;
				return _this
			}
			Object.defineProperty(XmlDtdEntity.prototype, "text",
			{
				get: function ()
				{
					return this._text
				},
				set: function (text)
				{
					if (!utils_1.isString(text)) throw new TypeError("text should be a string");
					if (!validate_1.validateChar(text)) throw new Error("data should not contain characters not allowed in XML");
					this._text = text
				},
				enumerable: true,
				configurable: true
			});
			XmlDtdEntity.prototype.children = function ()
			{
				throw new Error("XmlDtdEntity nodes cannot have children")
			};
			XmlDtdEntity.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlDtdEntity nodes cannot have children")
			};
			XmlDtdEntity.prototype.removeChild = function (node)
			{
				throw new Error("XmlDtdEntity nodes cannot have children")
			};
			XmlDtdEntity.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlDtdEntity nodes cannot have children")
			};
			XmlDtdEntity.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return "<!ENTITY " + this.text + ">"
			};
			return XmlDtdEntity
		}(XmlNode_1.default);
		exports.default = XmlDtdEntity
	},
	1707: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlDtdNotation = function (_super)
		{
			__extends(XmlDtdNotation, _super);

			function XmlDtdNotation(text)
			{
				var _this = _super.call(this) || this;
				_this.text = text;
				return _this
			}
			Object.defineProperty(XmlDtdNotation.prototype, "text",
			{
				get: function ()
				{
					return this._text
				},
				set: function (text)
				{
					if (!utils_1.isString(text)) throw new TypeError("text should be a string");
					if (!validate_1.validateChar(text)) throw new Error("data should not contain characters not allowed in XML");
					this._text = text
				},
				enumerable: true,
				configurable: true
			});
			XmlDtdNotation.prototype.children = function ()
			{
				throw new Error("XmlDtdNotation nodes cannot have children")
			};
			XmlDtdNotation.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlDtdNotation nodes cannot have children")
			};
			XmlDtdNotation.prototype.removeChild = function (node)
			{
				throw new Error("XmlDtdNotation nodes cannot have children")
			};
			XmlDtdNotation.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlDtdNotation nodes cannot have children")
			};
			XmlDtdNotation.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return "<!NOTATION " + this.text + ">"
			};
			return XmlDtdNotation
		}(XmlNode_1.default);
		exports.default = XmlDtdNotation
	},
	1708: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlDtdParamEntityRef = function (_super)
		{
			__extends(XmlDtdParamEntityRef, _super);

			function XmlDtdParamEntityRef(entity)
			{
				var _this = _super.call(this) || this;
				_this.entity = entity;
				return _this
			}
			Object.defineProperty(XmlDtdParamEntityRef.prototype, "entity",
			{
				get: function ()
				{
					return this._entity
				},
				set: function (entity)
				{
					if (!utils_1.isString(entity)) throw new TypeError("entity should be a string");
					if (!validate_1.validateName(entity)) throw new Error("entity should not contain characters not allowed in XML names");
					this._entity = entity
				},
				enumerable: true,
				configurable: true
			});
			XmlDtdParamEntityRef.prototype.children = function ()
			{
				throw new Error("XmlDtdParamEntityRef nodes cannot have children")
			};
			XmlDtdParamEntityRef.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlDtdParamEntityRef nodes cannot have children")
			};
			XmlDtdParamEntityRef.prototype.removeChild = function (node)
			{
				throw new Error("XmlDtdParamEntityRef nodes cannot have children")
			};
			XmlDtdParamEntityRef.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlDtdParamEntityRef nodes cannot have children")
			};
			XmlDtdParamEntityRef.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return "%" + this.entity + ";"
			};
			return XmlDtdParamEntityRef
		}(XmlNode_1.default);
		exports.default = XmlDtdParamEntityRef
	},
	1709: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var options_1 = __webpack_require__(485);
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlAttribute_1 = __webpack_require__(1699);
		var XmlAttributeText_1 = __webpack_require__(956);
		var XmlCdata_1 = __webpack_require__(1700);
		var XmlCharData_1 = __webpack_require__(1701);
		var XmlCharRef_1 = __webpack_require__(957);
		var XmlComment_1 = __webpack_require__(647);
		var XmlEntityRef_1 = __webpack_require__(958);
		var XmlNode_1 = __webpack_require__(72);
		var XmlProcInst_1 = __webpack_require__(648);
		var XmlElement = function (_super)
		{
			__extends(XmlElement, _super);

			function XmlElement(name)
			{
				var _this = _super.call(this) || this;
				_this.name = name;
				return _this
			}
			Object.defineProperty(XmlElement.prototype, "name",
			{
				get: function ()
				{
					return this._name
				},
				set: function (name)
				{
					if (!utils_1.isString(name)) throw new TypeError("name should be a string");
					if (!validate_1.validateName(name)) throw new Error("name should not contain characters not allowed in XML names");
					this._name = name
				},
				enumerable: true,
				configurable: true
			});
			XmlElement.prototype.attribute = function (name, value, index)
			{
				if (utils_1.isString(value)) value = new XmlAttributeText_1.default(value);
				else if (utils_1.isArray(value))
					for (var i = 0; i < value.length; i++) utils_1.isString(value[i]) && (value[i] = new XmlAttributeText_1.default(value[i]));
				var attribute = new XmlAttribute_1.default(name, value);
				this.insertChild(attribute, index);
				return attribute
			};
			XmlElement.prototype.attributes = function ()
			{
				return this._children.filter(function (node)
				{
					return node instanceof XmlAttribute_1.default
				})
			};
			XmlElement.prototype.cdata = function (content, index)
			{
				var cdata = new XmlCdata_1.default(content);
				this.insertChild(cdata, index);
				return cdata
			};
			XmlElement.prototype.charData = function (charData, index)
			{
				var charDataNode = new XmlCharData_1.default(charData);
				this.insertChild(charDataNode, index);
				return charDataNode
			};
			XmlElement.prototype.charRef = function (char, hex, index)
			{
				var charRef = new XmlCharRef_1.default(char, hex);
				this.insertChild(charRef, index);
				return charRef
			};
			XmlElement.prototype.comment = function (content, index)
			{
				var comment = new XmlComment_1.default(content);
				this.insertChild(comment, index);
				return comment
			};
			XmlElement.prototype.element = function (name, index)
			{
				var element = new XmlElement(name);
				this.insertChild(element, index);
				return element
			};
			XmlElement.prototype.entityRef = function (entity, index)
			{
				var entityRef = new XmlEntityRef_1.default(entity);
				this.insertChild(entityRef, index);
				return entityRef
			};
			XmlElement.prototype.insertChild = function (node, index)
			{
				if (!(node instanceof XmlAttribute_1.default || node instanceof XmlCdata_1.default || node instanceof XmlCharRef_1.default || node instanceof XmlComment_1.default || node instanceof XmlElement || node instanceof XmlEntityRef_1.default || node instanceof XmlProcInst_1.default || node instanceof XmlCharData_1.default)) throw new TypeError("node should be an instance of XmlAttribute, XmlCdata, XmlCharRef, XmlComment, XmlElement, XmlEntityRef, XmlProcInst, or XmlText");
				if (node instanceof XmlAttribute_1.default)
				{
					var attributes = this._children.filter(function (n)
					{
						return n instanceof XmlAttribute_1.default
					});
					for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++)
					{
						var attribute = attributes_1[_i];
						if (attribute.name === node.name) throw new Error("element already contains an XmlAttribute object with name " + node.name)
					}
				}
				return _super.prototype.insertChild.call(this, node, index)
			};
			XmlElement.prototype.procInst = function (target, content, index)
			{
				var procInst = new XmlProcInst_1.default(target, content);
				this.insertChild(procInst, index);
				return procInst
			};
			XmlElement.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				var optionsObj = new options_1.StringOptions(options);
				var attributes = this.attributes();
				var nodes = this._children.filter(function (node)
				{
					return -1 === attributes.indexOf(node)
				});
				var str = "<" + this._name;
				for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++)
				{
					var attribute = attributes_2[_i];
					str += " " + attribute.toString(options)
				}
				if (nodes.length > 0)
				{
					str += ">";
					var indenter = function (line)
					{
						return optionsObj.indent + line
					};
					for (var i = 0; i < nodes.length; i++)
					{
						var next = nodes[i];
						var nextStr = next.toString(options);
						var prev = i > 0 ? nodes[i - 1] : void 0;
						if (optionsObj.pretty && !allSameLineNodes(nodes) && !(i > 0 && onSameLine(next, prev)))
						{
							str += optionsObj.newline;
							nextStr = nextStr.split(optionsObj.newline).map(indenter).join(optionsObj.newline)
						}
						str += nextStr
					}
					optionsObj.pretty && (allSameLineNodes(nodes) || (str += optionsObj.newline));
					str += "</" + this._name + ">"
				}
				else str += "/>";
				return str
			};
			return XmlElement
		}(XmlNode_1.default);
		exports.default = XmlElement;

		function allSameLineNodes(nodes)
		{
			for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++)
			{
				var node = nodes_1[_i];
				if (!(node instanceof XmlCharRef_1.default || node instanceof XmlEntityRef_1.default || node instanceof XmlCharData_1.default)) return false
			}
			return true
		}

		function onSameLine(prev, next)
		{
			return (prev instanceof XmlCharRef_1.default || prev instanceof XmlEntityRef_1.default || prev instanceof XmlCharData_1.default) && (next instanceof XmlCharRef_1.default || next instanceof XmlEntityRef_1.default || next instanceof XmlCharData_1.default)
		}
	},
	1710: function (module, exports, __webpack_require__)
	{
		"use strict";

		function isString(val)
		{
			return "[object String]" === Object.prototype.toString.call(val)
		}
		exports.isString = isString;

		function isNumber(val)
		{
			return "[object Number]" === Object.prototype.toString.call(val)
		}
		exports.isNumber = isNumber;

		function isBoolean(val)
		{
			return "[object Boolean]" === Object.prototype.toString.call(val)
		}
		exports.isBoolean = isBoolean;

		function isUndefined(val)
		{
			return "[object Undefined]" === Object.prototype.toString.call(val)
		}
		exports.isUndefined = isUndefined;

		function isNull(val)
		{
			return "[object Null]" === Object.prototype.toString.call(val)
		}
		exports.isNull = isNull;

		function isPrimitive(val)
		{
			return isString(val) || isNumber(val) || isBoolean(val) || isUndefined(val) || isNull(val)
		}
		exports.isPrimitive = isPrimitive;

		function isObject(val)
		{
			return "[object Object]" === Object.prototype.toString.call(val)
		}
		exports.isObject = isObject;

		function isArray(val)
		{
			return "[object Array]" === Object.prototype.toString.call(val)
		}
		exports.isArray = isArray;

		function isStringArray(val)
		{
			if (!isArray(val)) return false;
			for (var _i = 0, val_1 = val; _i < val_1.length; _i++)
			{
				var entry = val_1[_i];
				if (!isString(entry)) return false
			}
			return true
		}
		exports.isStringArray = isStringArray;

		function isFunction(val)
		{
			return "[object Function]" === Object.prototype.toString.call(val)
		}
		exports.isFunction = isFunction;

		function isSet(val)
		{
			return "[object Set]" === Object.prototype.toString.call(val)
		}
		exports.isSet = isSet;

		function isMap(val)
		{
			return "[object Map]" === Object.prototype.toString.call(val)
		}
		exports.isMap = isMap;

		function stringify(value)
		{
			isUndefined(value) || isNull(value) || isFunction(value.toString) || (value = value.toString());
			return String(value)
		}
		exports.stringify = stringify
	},
	1711: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.colors = ["#004A65", "#00665F", "#BF4B45", "#BF9037", "#1D8C2E", "BB3ABF", "#00B1F1", "#00F2E2", "#7F322E", "#7F6025", "#104C19", "7C267F", "#0079A5", "#00A69B", "#FF645C", "#FFC04A", "#2ACC43", "F94DFF", "#0082B2", "#00B3A7", "#401917", "#403012", "#2DD947", "3E1340", "#00668B", "#008C83", "#E55A53", "#E5AD43", "#25B23B", "E045E5"]
	},
	1712: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);

		function _toConsumableArray(arr)
		{
			if (Array.isArray(arr))
			{
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2
			}
			return Array.from(arr)
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		app.service("wzTableFilter", function ()
		{
			var filters = [];
			return {
				set: function set(array)
				{
					if (Array.isArray(array))
					{
						filters.length = 0;
						filters.push.apply(filters, _toConsumableArray(array))
					}
				},
				get: function get()
				{
					return filters
				}
			}
		})
	},
	1713: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.KeyEquivalenece = {
			id: "ID",
			timestamp: "Timestamp",
			url: "URL",
			version: "Version",
			"os.name": "OS name",
			"os.version": "OS version",
			status: "Status",
			group: "Group",
			ip: "IP",
			description: "Description",
			tag: "Tag",
			level: "Level",
			conf_sum: "Group checksum",
			merged_sum: "Configuration checksum",
			hash: "Checksum",
			filename: "File",
			file: "File",
			gdpr: "GDPR",
			pci: "PCI",
			groups: "Groups",
			name: "Name",
			count: "Count",
			"details.program_name": "Program name",
			"details.order": "Order",
			vendor: "Vendor",
			type: "Type",
			architecture: "Architecture",
			node_name: "Node",
			dateAdd: "Registration date",
			manager_host: "Manager",
			manager: "Manager",
			lastKeepAlive: "Last keep alive",
			os: "OS",
			path: "Path",
			details: "Details",
			position: "Position",
			configSum: "Group checksum",
			mergedSum: "Configuration checksum",
			key: "Key",
			scan_id: "Scan ID",
			format: "Format",
			scan_time: "Scan date",
			state: "State",
			mac: "MAC",
			gateway: "Gateway",
			dhcp: "DHCP",
			iface: "Interface",
			broadcast: "Broadcast",
			proto: "Protocol",
			address: "Address",
			protocol: "Protocol",
			netmask: "Netmask",
			"local.ip": "Local IP",
			"remote.ip": "Remote IP",
			"local.port": "Local port",
			"remote.port": "Remote port",
			euser: "Effective user",
			nice: "Priority",
			size: "Size",
			uname: "User",
			gname: "Group",
			perm: "Permissions",
			inode: "Inode",
			uid: "User ID",
			gid: "Group ID",
			mtime: "Last modified",
			priority: "Priority",
			cmd: "CMD",
			nlwp: "NLWP",
			process: "Process"
		}
	},
	1714: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.calcTableRows = calcTableRows;

		function calcTableRows(windowHeight, sizes)
		{
			if (windowHeight >= 950) return sizes[0];
			if (windowHeight >= 850 && windowHeight < 950) return sizes[1];
			if (windowHeight >= 750 && windowHeight < 850) return sizes[2];
			return 4 === sizes.length ? sizes[3] : 8
		}
	},
	1715: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.nextPage = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(currentPage, $scope, errorHandler, fetch)
		{
			var copy, currentNonNull;
			return regeneratorRuntime.wrap(function _callee$(_context)
			{
				while (1) switch (_context.prev = _context.next)
				{
				case 0:
					_context.prev = 0;
					$scope.error = false;
					!currentPage && 0 !== currentPage && $scope.currentPage < $scope.pagedItems.length - 1 && $scope.currentPage++;
					if (!$scope.pagedItems[currentPage || $scope.currentPage].includes(null))
					{
						_context.next = 12;
						break
					}
					copy = $scope.currentPage;
					$scope.wazuh_table_loading = true;
					currentNonNull = $scope.items.filter(function (item)
					{
						return !!item
					});
					_context.next = 9;
					return fetch(
					{
						offset: currentNonNull.length
					});
				case 9:
					$scope.wazuh_table_loading = false;
					$scope.currentPage = copy;
					$scope.$$phase || $scope.$digest();
				case 12:
					_context.next = 19;
					break;
				case 14:
					_context.prev = 14;
					_context.t0 = _context["catch"](0);
					$scope.wazuh_table_loading = false;
					$scope.error = "Error paginating table - " + (_context.t0.message || _context.t0) + ".";
					errorHandler.handle("Error paginating table due to " + (_context.t0.message || _context.t0), "Data factory");
				case 19:
					return _context.abrupt("return");
				case 20:
				case "end":
					return _context.stop()
				}
			}, _callee, this, [
				[0, 14]
			])
		})), function nextPage(_x, _x2, _x3, _x4)
		{
			return _ref.apply(this, arguments)
		});
		var _ref;
		exports.range = range;
		exports.groupToPages = groupToPages;
		exports.prevPage = prevPage;
		exports.searchTable = searchTable;

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function range(size, start, end, gap)
		{
			var ret = [];
			if (size < end)
			{
				end = size;
				start = size - gap
			}
			for (var i = start; i < end; i++) ret.push(i);
			return ret
		}

		function groupToPages($scope)
		{
			$scope.pagedItems = [];
			for (var i = 0; i < $scope.filteredItems.length; i++) i % $scope.itemsPerPage === 0 ? $scope.pagedItems[Math.floor(i / $scope.itemsPerPage)] = [$scope.filteredItems[i]] : $scope.pagedItems[Math.floor(i / $scope.itemsPerPage)].push($scope.filteredItems[i])
		}

		function prevPage($scope)
		{
			$scope.currentPage > 0 && $scope.currentPage--
		}

		function searchTable($scope, items)
		{
			$scope.filteredItems = items;
			$scope.currentPage = 0;
			$scope.groupToPages()
		}
	},
	1716: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.checkGap = checkGap;

		function checkGap($scope, items)
		{
			var gap = items.length / $scope.itemsPerPage;
			var gapInteger = parseInt(gap);
			$scope.gap = gap - gapInteger > 0 ? gapInteger + 1 : gapInteger;
			$scope.gap > 5 && ($scope.gap = 5)
		}
	},
	291: function (module, exports, __webpack_require__)
	{
		(function (global, module)
		{
			var __WEBPACK_AMD_DEFINE_RESULT__;
			/**
			 * @license
			 * Lodash <https://lodash.com/>
			 * Copyright JS Foundation and other contributors <https://js.foundation/>
			 * Released under MIT license <https://lodash.com/license>
			 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
			 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
			 */
			(function ()
			{
				var undefined;
				var VERSION = "4.17.11";
				var LARGE_ARRAY_SIZE = 200;
				var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
					FUNC_ERROR_TEXT = "Expected a function";
				var HASH_UNDEFINED = "__lodash_hash_undefined__";
				var MAX_MEMOIZE_SIZE = 500;
				var PLACEHOLDER = "__lodash_placeholder__";
				var CLONE_DEEP_FLAG = 1,
					CLONE_FLAT_FLAG = 2,
					CLONE_SYMBOLS_FLAG = 4;
				var COMPARE_PARTIAL_FLAG = 1,
					COMPARE_UNORDERED_FLAG = 2;
				var WRAP_BIND_FLAG = 1,
					WRAP_BIND_KEY_FLAG = 2,
					WRAP_CURRY_BOUND_FLAG = 4,
					WRAP_CURRY_FLAG = 8,
					WRAP_CURRY_RIGHT_FLAG = 16,
					WRAP_PARTIAL_FLAG = 32,
					WRAP_PARTIAL_RIGHT_FLAG = 64,
					WRAP_ARY_FLAG = 128,
					WRAP_REARG_FLAG = 256,
					WRAP_FLIP_FLAG = 512;
				var DEFAULT_TRUNC_LENGTH = 30,
					DEFAULT_TRUNC_OMISSION = "...";
				var HOT_COUNT = 800,
					HOT_SPAN = 16;
				var LAZY_FILTER_FLAG = 1,
					LAZY_MAP_FLAG = 2,
					LAZY_WHILE_FLAG = 3;
				var INFINITY = 1 / 0,
					MAX_SAFE_INTEGER = 9007199254740991,
					MAX_INTEGER = 1.7976931348623157e308,
					NAN = NaN;
				var MAX_ARRAY_LENGTH = 4294967295,
					MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
					HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
				var wrapFlags = [
					["ary", WRAP_ARY_FLAG],
					["bind", WRAP_BIND_FLAG],
					["bindKey", WRAP_BIND_KEY_FLAG],
					["curry", WRAP_CURRY_FLAG],
					["curryRight", WRAP_CURRY_RIGHT_FLAG],
					["flip", WRAP_FLIP_FLAG],
					["partial", WRAP_PARTIAL_FLAG],
					["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
					["rearg", WRAP_REARG_FLAG]
				];
				var argsTag = "[object Arguments]",
					arrayTag = "[object Array]",
					asyncTag = "[object AsyncFunction]",
					boolTag = "[object Boolean]",
					dateTag = "[object Date]",
					domExcTag = "[object DOMException]",
					errorTag = "[object Error]",
					funcTag = "[object Function]",
					genTag = "[object GeneratorFunction]",
					mapTag = "[object Map]",
					numberTag = "[object Number]",
					nullTag = "[object Null]",
					objectTag = "[object Object]",
					promiseTag = "[object Promise]",
					proxyTag = "[object Proxy]",
					regexpTag = "[object RegExp]",
					setTag = "[object Set]",
					stringTag = "[object String]",
					symbolTag = "[object Symbol]",
					undefinedTag = "[object Undefined]",
					weakMapTag = "[object WeakMap]",
					weakSetTag = "[object WeakSet]";
				var arrayBufferTag = "[object ArrayBuffer]",
					dataViewTag = "[object DataView]",
					float32Tag = "[object Float32Array]",
					float64Tag = "[object Float64Array]",
					int8Tag = "[object Int8Array]",
					int16Tag = "[object Int16Array]",
					int32Tag = "[object Int32Array]",
					uint8Tag = "[object Uint8Array]",
					uint8ClampedTag = "[object Uint8ClampedArray]",
					uint16Tag = "[object Uint16Array]",
					uint32Tag = "[object Uint32Array]";
				var reEmptyStringLeading = /\b__p \+= '';/g,
					reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
					reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
				var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
					reUnescapedHtml = /[&<>"']/g,
					reHasEscapedHtml = RegExp(reEscapedHtml.source),
					reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
				var reEscape = /<%-([\s\S]+?)%>/g,
					reEvaluate = /<%([\s\S]+?)%>/g,
					reInterpolate = /<%=([\s\S]+?)%>/g;
				var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
					reIsPlainProp = /^\w*$/,
					rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
				var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
					reHasRegExpChar = RegExp(reRegExpChar.source);
				var reTrim = /^\s+|\s+$/g,
					reTrimStart = /^\s+/,
					reTrimEnd = /\s+$/;
				var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
					reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
					reSplitDetails = /,? & /;
				var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
				var reEscapeChar = /\\(\\)?/g;
				var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
				var reFlags = /\w*$/;
				var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
				var reIsBinary = /^0b[01]+$/i;
				var reIsHostCtor = /^\[object .+?Constructor\]$/;
				var reIsOctal = /^0o[0-7]+$/i;
				var reIsUint = /^(?:0|[1-9]\d*)$/;
				var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
				var reNoMatch = /($^)/;
				var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
				var rsAstralRange = "\\ud800-\\udfff",
					rsComboMarksRange = "\\u0300-\\u036f",
					reComboHalfMarksRange = "\\ufe20-\\ufe2f",
					rsComboSymbolsRange = "\\u20d0-\\u20ff",
					rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
					rsDingbatRange = "\\u2700-\\u27bf",
					rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
					rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
					rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
					rsPunctuationRange = "\\u2000-\\u206f",
					rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
					rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
					rsVarRange = "\\ufe0e\\ufe0f",
					rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
				var rsApos = "[']",
					rsAstral = "[" + rsAstralRange + "]",
					rsBreak = "[" + rsBreakRange + "]",
					rsCombo = "[" + rsComboRange + "]",
					rsDigits = "\\d+",
					rsDingbat = "[" + rsDingbatRange + "]",
					rsLower = "[" + rsLowerRange + "]",
					rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]",
					rsFitz = "\\ud83c[\\udffb-\\udfff]",
					rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
					rsNonAstral = "[^" + rsAstralRange + "]",
					rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
					rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
					rsUpper = "[" + rsUpperRange + "]",
					rsZWJ = "\\u200d";
				var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
					rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
					rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
					rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
					reOptMod = rsModifier + "?",
					rsOptVar = "[" + rsVarRange + "]?",
					rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*",
					rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
					rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
					rsSeq = rsOptVar + reOptMod + rsOptJoin,
					rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
					rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
				var reApos = RegExp(rsApos, "g");
				var reComboMark = RegExp(rsCombo, "g");
				var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
				var reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");
				var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
				var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
				var contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"];
				var templateCounter = -1;
				var typedArrayTags = {};
				typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
				typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
				var cloneableTags = {};
				cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
				cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
				var deburredLetters = {
					"": "A",
					"": "A",
					"": "A",
					"": "A",
					"": "A",
					"": "A",
					"": "a",
					"": "a",
					"": "a",
					"": "a",
					"": "a",
					"": "a",
					"": "C",
					"": "c",
					"": "D",
					"": "d",
					"": "E",
					"": "E",
					"": "E",
					"": "E",
					"": "e",
					"": "e",
					"": "e",
					"": "e",
					"": "I",
					"": "I",
					"": "I",
					"": "I",
					"": "i",
					"": "i",
					"": "i",
					"": "i",
					"": "N",
					"": "n",
					"": "O",
					"": "O",
					"": "O",
					"": "O",
					"": "O",
					"": "O",
					"": "o",
					"": "o",
					"": "o",
					"": "o",
					"": "o",
					"": "o",
					"": "U",
					"": "U",
					"": "U",
					"": "U",
					"": "u",
					"": "u",
					"": "u",
					"": "u",
					"": "Y",
					"": "y",
					"": "y",
					"": "Ae",
					"": "ae",
					"": "Th",
					"": "th",
					"": "ss",
					"": "A",
					"": "A",
					"": "A",
					"": "a",
					"": "a",
					"": "a",
					"": "C",
					"": "C",
					"": "C",
					"": "C",
					"": "c",
					"": "c",
					"": "c",
					"": "c",
					"": "D",
					"": "D",
					"": "d",
					"": "d",
					"": "E",
					"": "E",
					"": "E",
					"": "E",
					"": "E",
					"": "e",
					"": "e",
					"": "e",
					"": "e",
					"": "e",
					"": "G",
					"": "G",
					"": "G",
					"": "G",
					"": "g",
					"": "g",
					"": "g",
					"": "g",
					"": "H",
					"": "H",
					"": "h",
					"": "h",
					"": "I",
					"": "I",
					"": "I",
					"": "I",
					"": "I",
					"": "i",
					"": "i",
					"": "i",
					"": "i",
					"": "i",
					"": "J",
					"": "j",
					"": "K",
					"": "k",
					"": "k",
					"": "L",
					"": "L",
					"": "L",
					"": "L",
					"": "L",
					"": "l",
					"": "l",
					"": "l",
					"": "l",
					"": "l",
					"": "N",
					"": "N",
					"": "N",
					"": "N",
					"": "n",
					"": "n",
					"": "n",
					"": "n",
					"": "O",
					"": "O",
					"": "O",
					"": "o",
					"": "o",
					"": "o",
					"": "R",
					"": "R",
					"": "R",
					"": "r",
					"": "r",
					"": "r",
					"": "S",
					"": "S",
					"": "S",
					"": "S",
					"": "s",
					"": "s",
					"": "s",
					"": "s",
					"": "T",
					"": "T",
					"": "T",
					"": "t",
					"": "t",
					"": "t",
					"": "U",
					"": "U",
					"": "U",
					"": "U",
					"": "U",
					"": "U",
					"": "u",
					"": "u",
					"": "u",
					"": "u",
					"": "u",
					"": "u",
					"": "W",
					"": "w",
					"": "Y",
					"": "y",
					"": "Y",
					"": "Z",
					"": "Z",
					"": "Z",
					"": "z",
					"": "z",
					"": "z",
					"": "IJ",
					"": "ij",
					"": "Oe",
					"": "oe",
					"": "'n",
					"": "s"
				};
				var htmlEscapes = {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					'"': "&quot;",
					"'": "&#39;"
				};
				var htmlUnescapes = {
					"&amp;": "&",
					"&lt;": "<",
					"&gt;": ">",
					"&quot;": '"',
					"&#39;": "'"
				};
				var stringEscapes = {
					"\\": "\\",
					"'": "'",
					"\n": "n",
					"\r": "r",
					"": "u2028",
					"": "u2029"
				};
				var freeParseFloat = parseFloat,
					freeParseInt = parseInt;
				var freeGlobal = "object" == typeof global && global && global.Object === Object && global;
				var freeSelf = "object" == typeof self && self && self.Object === Object && self;
				var root = freeGlobal || freeSelf || Function("return this")();
				var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports;
				var freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module;
				var moduleExports = freeModule && freeModule.exports === freeExports;
				var freeProcess = moduleExports && freeGlobal.process;
				var nodeUtil = function ()
				{
					try
					{
						var types = freeModule && freeModule.require && freeModule.require("util").types;
						if (types) return types;
						return freeProcess && freeProcess.binding && freeProcess.binding("util")
					}
					catch (e)
					{}
				}();
				var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
					nodeIsDate = nodeUtil && nodeUtil.isDate,
					nodeIsMap = nodeUtil && nodeUtil.isMap,
					nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
					nodeIsSet = nodeUtil && nodeUtil.isSet,
					nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

				function apply(func, thisArg, args)
				{
					switch (args.length)
					{
					case 0:
						return func.call(thisArg);
					case 1:
						return func.call(thisArg, args[0]);
					case 2:
						return func.call(thisArg, args[0], args[1]);
					case 3:
						return func.call(thisArg, args[0], args[1], args[2])
					}
					return func.apply(thisArg, args)
				}

				function arrayAggregator(array, setter, iteratee, accumulator)
				{
					var index = -1,
						length = null == array ? 0 : array.length;
					while (++index < length)
					{
						var value = array[index];
						setter(accumulator, value, iteratee(value), array)
					}
					return accumulator
				}

				function arrayEach(array, iteratee)
				{
					var index = -1,
						length = null == array ? 0 : array.length;
					while (++index < length)
						if (false === iteratee(array[index], index, array)) break;
					return array
				}

				function arrayEachRight(array, iteratee)
				{
					var length = null == array ? 0 : array.length;
					while (length--)
						if (false === iteratee(array[length], length, array)) break;
					return array
				}

				function arrayEvery(array, predicate)
				{
					var index = -1,
						length = null == array ? 0 : array.length;
					while (++index < length)
						if (!predicate(array[index], index, array)) return false;
					return true
				}

				function arrayFilter(array, predicate)
				{
					var index = -1,
						length = null == array ? 0 : array.length,
						resIndex = 0,
						result = [];
					while (++index < length)
					{
						var value = array[index];
						predicate(value, index, array) && (result[resIndex++] = value)
					}
					return result
				}

				function arrayIncludes(array, value)
				{
					var length = null == array ? 0 : array.length;
					return !!length && baseIndexOf(array, value, 0) > -1
				}

				function arrayIncludesWith(array, value, comparator)
				{
					var index = -1,
						length = null == array ? 0 : array.length;
					while (++index < length)
						if (comparator(value, array[index])) return true;
					return false
				}

				function arrayMap(array, iteratee)
				{
					var index = -1,
						length = null == array ? 0 : array.length,
						result = Array(length);
					while (++index < length) result[index] = iteratee(array[index], index, array);
					return result
				}

				function arrayPush(array, values)
				{
					var index = -1,
						length = values.length,
						offset = array.length;
					while (++index < length) array[offset + index] = values[index];
					return array
				}

				function arrayReduce(array, iteratee, accumulator, initAccum)
				{
					var index = -1,
						length = null == array ? 0 : array.length;
					initAccum && length && (accumulator = array[++index]);
					while (++index < length) accumulator = iteratee(accumulator, array[index], index, array);
					return accumulator
				}

				function arrayReduceRight(array, iteratee, accumulator, initAccum)
				{
					var length = null == array ? 0 : array.length;
					initAccum && length && (accumulator = array[--length]);
					while (length--) accumulator = iteratee(accumulator, array[length], length, array);
					return accumulator
				}

				function arraySome(array, predicate)
				{
					var index = -1,
						length = null == array ? 0 : array.length;
					while (++index < length)
						if (predicate(array[index], index, array)) return true;
					return false
				}
				var asciiSize = baseProperty("length");

				function asciiToArray(string)
				{
					return string.split("")
				}

				function asciiWords(string)
				{
					return string.match(reAsciiWord) || []
				}

				function baseFindKey(collection, predicate, eachFunc)
				{
					var result;
					eachFunc(collection, function (value, key, collection)
					{
						if (predicate(value, key, collection))
						{
							result = key;
							return false
						}
					});
					return result
				}

				function baseFindIndex(array, predicate, fromIndex, fromRight)
				{
					var length = array.length,
						index = fromIndex + (fromRight ? 1 : -1);
					while (fromRight ? index-- : ++index < length)
						if (predicate(array[index], index, array)) return index;
					return -1
				}

				function baseIndexOf(array, value, fromIndex)
				{
					return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)
				}

				function baseIndexOfWith(array, value, fromIndex, comparator)
				{
					var index = fromIndex - 1,
						length = array.length;
					while (++index < length)
						if (comparator(array[index], value)) return index;
					return -1
				}

				function baseIsNaN(value)
				{
					return value !== value
				}

				function baseMean(array, iteratee)
				{
					var length = null == array ? 0 : array.length;
					return length ? baseSum(array, iteratee) / length : NAN
				}

				function baseProperty(key)
				{
					return function (object)
					{
						return null == object ? undefined : object[key]
					}
				}

				function basePropertyOf(object)
				{
					return function (key)
					{
						return null == object ? undefined : object[key]
					}
				}

				function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc)
				{
					eachFunc(collection, function (value, index, collection)
					{
						accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection)
					});
					return accumulator
				}

				function baseSortBy(array, comparer)
				{
					var length = array.length;
					array.sort(comparer);
					while (length--) array[length] = array[length].value;
					return array
				}

				function baseSum(array, iteratee)
				{
					var result, index = -1,
						length = array.length;
					while (++index < length)
					{
						var current = iteratee(array[index]);
						current !== undefined && (result = result === undefined ? current : result + current)
					}
					return result
				}

				function baseTimes(n, iteratee)
				{
					var index = -1,
						result = Array(n);
					while (++index < n) result[index] = iteratee(index);
					return result
				}

				function baseToPairs(object, props)
				{
					return arrayMap(props, function (key)
					{
						return [key, object[key]]
					})
				}

				function baseUnary(func)
				{
					return function (value)
					{
						return func(value)
					}
				}

				function baseValues(object, props)
				{
					return arrayMap(props, function (key)
					{
						return object[key]
					})
				}

				function cacheHas(cache, key)
				{
					return cache.has(key)
				}

				function charsStartIndex(strSymbols, chrSymbols)
				{
					var index = -1,
						length = strSymbols.length;
					while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1);
					return index
				}

				function charsEndIndex(strSymbols, chrSymbols)
				{
					var index = strSymbols.length;
					while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1);
					return index
				}

				function countHolders(array, placeholder)
				{
					var length = array.length,
						result = 0;
					while (length--) array[length] === placeholder && ++result;
					return result
				}
				var deburrLetter = basePropertyOf(deburredLetters);
				var escapeHtmlChar = basePropertyOf(htmlEscapes);

				function escapeStringChar(chr)
				{
					return "\\" + stringEscapes[chr]
				}

				function getValue(object, key)
				{
					return null == object ? undefined : object[key]
				}

				function hasUnicode(string)
				{
					return reHasUnicode.test(string)
				}

				function hasUnicodeWord(string)
				{
					return reHasUnicodeWord.test(string)
				}

				function iteratorToArray(iterator)
				{
					var data, result = [];
					while (!(data = iterator.next()).done) result.push(data.value);
					return result
				}

				function mapToArray(map)
				{
					var index = -1,
						result = Array(map.size);
					map.forEach(function (value, key)
					{
						result[++index] = [key, value]
					});
					return result
				}

				function overArg(func, transform)
				{
					return function (arg)
					{
						return func(transform(arg))
					}
				}

				function replaceHolders(array, placeholder)
				{
					var index = -1,
						length = array.length,
						resIndex = 0,
						result = [];
					while (++index < length)
					{
						var value = array[index];
						if (value === placeholder || value === PLACEHOLDER)
						{
							array[index] = PLACEHOLDER;
							result[resIndex++] = index
						}
					}
					return result
				}

				function setToArray(set)
				{
					var index = -1,
						result = Array(set.size);
					set.forEach(function (value)
					{
						result[++index] = value
					});
					return result
				}

				function setToPairs(set)
				{
					var index = -1,
						result = Array(set.size);
					set.forEach(function (value)
					{
						result[++index] = [value, value]
					});
					return result
				}

				function strictIndexOf(array, value, fromIndex)
				{
					var index = fromIndex - 1,
						length = array.length;
					while (++index < length)
						if (array[index] === value) return index;
					return -1
				}

				function strictLastIndexOf(array, value, fromIndex)
				{
					var index = fromIndex + 1;
					while (index--)
						if (array[index] === value) return index;
					return index
				}

				function stringSize(string)
				{
					return hasUnicode(string) ? unicodeSize(string) : asciiSize(string)
				}

				function stringToArray(string)
				{
					return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string)
				}
				var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

				function unicodeSize(string)
				{
					var result = reUnicode.lastIndex = 0;
					while (reUnicode.test(string)) ++result;
					return result
				}

				function unicodeToArray(string)
				{
					return string.match(reUnicode) || []
				}

				function unicodeWords(string)
				{
					return string.match(reUnicodeWord) || []
				}
				var runInContext = function runInContext(context)
				{
					context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
					var Array = context.Array,
						Date = context.Date,
						Error = context.Error,
						Function = context.Function,
						Math = context.Math,
						Object = context.Object,
						RegExp = context.RegExp,
						String = context.String,
						TypeError = context.TypeError;
					var arrayProto = Array.prototype,
						funcProto = Function.prototype,
						objectProto = Object.prototype;
					var coreJsData = context["__core-js_shared__"];
					var funcToString = funcProto.toString;
					var hasOwnProperty = objectProto.hasOwnProperty;
					var idCounter = 0;
					var maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ""), uid ? "Symbol(src)_1." + uid : "");
					var uid;
					var nativeObjectToString = objectProto.toString;
					var objectCtorString = funcToString.call(Object);
					var oldDash = root._;
					var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
					var Buffer = moduleExports ? context.Buffer : undefined,
						Symbol = context.Symbol,
						Uint8Array = context.Uint8Array,
						allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
						getPrototype = overArg(Object.getPrototypeOf, Object),
						objectCreate = Object.create,
						propertyIsEnumerable = objectProto.propertyIsEnumerable,
						splice = arrayProto.splice,
						spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
						symIterator = Symbol ? Symbol.iterator : undefined,
						symToStringTag = Symbol ? Symbol.toStringTag : undefined;
					var defineProperty = function ()
					{
						try
						{
							var func = getNative(Object, "defineProperty");
							func(
							{}, "",
							{});
							return func
						}
						catch (e)
						{}
					}();
					var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
						ctxNow = Date && Date.now !== root.Date.now && Date.now,
						ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
					var nativeCeil = Math.ceil,
						nativeFloor = Math.floor,
						nativeGetSymbols = Object.getOwnPropertySymbols,
						nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
						nativeIsFinite = context.isFinite,
						nativeJoin = arrayProto.join,
						nativeKeys = overArg(Object.keys, Object),
						nativeMax = Math.max,
						nativeMin = Math.min,
						nativeNow = Date.now,
						nativeParseInt = context.parseInt,
						nativeRandom = Math.random,
						nativeReverse = arrayProto.reverse;
					var DataView = getNative(context, "DataView"),
						Map = getNative(context, "Map"),
						Promise = getNative(context, "Promise"),
						Set = getNative(context, "Set"),
						WeakMap = getNative(context, "WeakMap"),
						nativeCreate = getNative(Object, "create");
					var metaMap = WeakMap && new WeakMap;
					var realNames = {};
					var dataViewCtorString = toSource(DataView),
						mapCtorString = toSource(Map),
						promiseCtorString = toSource(Promise),
						setCtorString = toSource(Set),
						weakMapCtorString = toSource(WeakMap);
					var symbolProto = Symbol ? Symbol.prototype : undefined,
						symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
						symbolToString = symbolProto ? symbolProto.toString : undefined;

					function lodash(value)
					{
						if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper))
						{
							if (value instanceof LodashWrapper) return value;
							if (hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value)
						}
						return new LodashWrapper(value)
					}
					var baseCreate = function ()
					{
						function object()
						{}
						return function (proto)
						{
							if (!isObject(proto)) return {};
							if (objectCreate) return objectCreate(proto);
							object.prototype = proto;
							var result = new object;
							object.prototype = undefined;
							return result
						}
					}();

					function baseLodash()
					{}

					function LodashWrapper(value, chainAll)
					{
						this.__wrapped__ = value;
						this.__actions__ = [];
						this.__chain__ = !!chainAll;
						this.__index__ = 0;
						this.__values__ = undefined
					}
					lodash.templateSettings = {
						escape: reEscape,
						evaluate: reEvaluate,
						interpolate: reInterpolate,
						variable: "",
						imports:
						{
							_: lodash
						}
					};
					lodash.prototype = baseLodash.prototype;
					lodash.prototype.constructor = lodash;
					LodashWrapper.prototype = baseCreate(baseLodash.prototype);
					LodashWrapper.prototype.constructor = LodashWrapper;

					function LazyWrapper(value)
					{
						this.__wrapped__ = value;
						this.__actions__ = [];
						this.__dir__ = 1;
						this.__filtered__ = false;
						this.__iteratees__ = [];
						this.__takeCount__ = MAX_ARRAY_LENGTH;
						this.__views__ = []
					}

					function lazyClone()
					{
						var result = new LazyWrapper(this.__wrapped__);
						result.__actions__ = copyArray(this.__actions__);
						result.__dir__ = this.__dir__;
						result.__filtered__ = this.__filtered__;
						result.__iteratees__ = copyArray(this.__iteratees__);
						result.__takeCount__ = this.__takeCount__;
						result.__views__ = copyArray(this.__views__);
						return result
					}

					function lazyReverse()
					{
						if (this.__filtered__)
						{
							var result = new LazyWrapper(this);
							result.__dir__ = -1;
							result.__filtered__ = true
						}
						else
						{
							result = this.clone();
							result.__dir__ *= -1
						}
						return result
					}

					function lazyValue()
					{
						var array = this.__wrapped__.value(),
							dir = this.__dir__,
							isArr = isArray(array),
							isRight = dir < 0,
							arrLength = isArr ? array.length : 0,
							view = getView(0, arrLength, this.__views__),
							start = view.start,
							end = view.end,
							length = end - start,
							index = isRight ? end : start - 1,
							iteratees = this.__iteratees__,
							iterLength = iteratees.length,
							resIndex = 0,
							takeCount = nativeMin(length, this.__takeCount__);
						if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
						var result = [];
						outer: while (length-- && resIndex < takeCount)
						{
							index += dir;
							var iterIndex = -1,
								value = array[index];
							while (++iterIndex < iterLength)
							{
								var data = iteratees[iterIndex],
									iteratee = data.iteratee,
									type = data.type,
									computed = iteratee(value);
								if (type == LAZY_MAP_FLAG) value = computed;
								else if (!computed)
								{
									if (type == LAZY_FILTER_FLAG) continue outer;
									break outer
								}
							}
							result[resIndex++] = value
						}
						return result
					}
					LazyWrapper.prototype = baseCreate(baseLodash.prototype);
					LazyWrapper.prototype.constructor = LazyWrapper;

					function Hash(entries)
					{
						var index = -1,
							length = null == entries ? 0 : entries.length;
						this.clear();
						while (++index < length)
						{
							var entry = entries[index];
							this.set(entry[0], entry[1])
						}
					}

					function hashClear()
					{
						this.__data__ = nativeCreate ? nativeCreate(null) :
						{};
						this.size = 0
					}

					function hashDelete(key)
					{
						var result = this.has(key) && delete this.__data__[key];
						this.size -= result ? 1 : 0;
						return result
					}

					function hashGet(key)
					{
						var data = this.__data__;
						if (nativeCreate)
						{
							var result = data[key];
							return result === HASH_UNDEFINED ? undefined : result
						}
						return hasOwnProperty.call(data, key) ? data[key] : undefined
					}

					function hashHas(key)
					{
						var data = this.__data__;
						return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key)
					}

					function hashSet(key, value)
					{
						var data = this.__data__;
						this.size += this.has(key) ? 0 : 1;
						data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
						return this
					}
					Hash.prototype.clear = hashClear;
					Hash.prototype["delete"] = hashDelete;
					Hash.prototype.get = hashGet;
					Hash.prototype.has = hashHas;
					Hash.prototype.set = hashSet;

					function ListCache(entries)
					{
						var index = -1,
							length = null == entries ? 0 : entries.length;
						this.clear();
						while (++index < length)
						{
							var entry = entries[index];
							this.set(entry[0], entry[1])
						}
					}

					function listCacheClear()
					{
						this.__data__ = [];
						this.size = 0
					}

					function listCacheDelete(key)
					{
						var data = this.__data__,
							index = assocIndexOf(data, key);
						if (index < 0) return false;
						var lastIndex = data.length - 1;
						index == lastIndex ? data.pop() : splice.call(data, index, 1);
						--this.size;
						return true
					}

					function listCacheGet(key)
					{
						var data = this.__data__,
							index = assocIndexOf(data, key);
						return index < 0 ? undefined : data[index][1]
					}

					function listCacheHas(key)
					{
						return assocIndexOf(this.__data__, key) > -1
					}

					function listCacheSet(key, value)
					{
						var data = this.__data__,
							index = assocIndexOf(data, key);
						if (index < 0)
						{
							++this.size;
							data.push([key, value])
						}
						else data[index][1] = value;
						return this
					}
					ListCache.prototype.clear = listCacheClear;
					ListCache.prototype["delete"] = listCacheDelete;
					ListCache.prototype.get = listCacheGet;
					ListCache.prototype.has = listCacheHas;
					ListCache.prototype.set = listCacheSet;

					function MapCache(entries)
					{
						var index = -1,
							length = null == entries ? 0 : entries.length;
						this.clear();
						while (++index < length)
						{
							var entry = entries[index];
							this.set(entry[0], entry[1])
						}
					}

					function mapCacheClear()
					{
						this.size = 0;
						this.__data__ = {
							hash: new Hash,
							map: new(Map || ListCache),
							string: new Hash
						}
					}

					function mapCacheDelete(key)
					{
						var result = getMapData(this, key)["delete"](key);
						this.size -= result ? 1 : 0;
						return result
					}

					function mapCacheGet(key)
					{
						return getMapData(this, key).get(key)
					}

					function mapCacheHas(key)
					{
						return getMapData(this, key).has(key)
					}

					function mapCacheSet(key, value)
					{
						var data = getMapData(this, key),
							size = data.size;
						data.set(key, value);
						this.size += data.size == size ? 0 : 1;
						return this
					}
					MapCache.prototype.clear = mapCacheClear;
					MapCache.prototype["delete"] = mapCacheDelete;
					MapCache.prototype.get = mapCacheGet;
					MapCache.prototype.has = mapCacheHas;
					MapCache.prototype.set = mapCacheSet;

					function SetCache(values)
					{
						var index = -1,
							length = null == values ? 0 : values.length;
						this.__data__ = new MapCache;
						while (++index < length) this.add(values[index])
					}

					function setCacheAdd(value)
					{
						this.__data__.set(value, HASH_UNDEFINED);
						return this
					}

					function setCacheHas(value)
					{
						return this.__data__.has(value)
					}
					SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
					SetCache.prototype.has = setCacheHas;

					function Stack(entries)
					{
						var data = this.__data__ = new ListCache(entries);
						this.size = data.size
					}

					function stackClear()
					{
						this.__data__ = new ListCache;
						this.size = 0
					}

					function stackDelete(key)
					{
						var data = this.__data__,
							result = data["delete"](key);
						this.size = data.size;
						return result
					}

					function stackGet(key)
					{
						return this.__data__.get(key)
					}

					function stackHas(key)
					{
						return this.__data__.has(key)
					}

					function stackSet(key, value)
					{
						var data = this.__data__;
						if (data instanceof ListCache)
						{
							var pairs = data.__data__;
							if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1)
							{
								pairs.push([key, value]);
								this.size = ++data.size;
								return this
							}
							data = this.__data__ = new MapCache(pairs)
						}
						data.set(key, value);
						this.size = data.size;
						return this
					}
					Stack.prototype.clear = stackClear;
					Stack.prototype["delete"] = stackDelete;
					Stack.prototype.get = stackGet;
					Stack.prototype.has = stackHas;
					Stack.prototype.set = stackSet;

					function arrayLikeKeys(value, inherited)
					{
						var isArr = isArray(value),
							isArg = !isArr && isArguments(value),
							isBuff = !isArr && !isArg && isBuffer(value),
							isType = !isArr && !isArg && !isBuff && isTypedArray(value),
							skipIndexes = isArr || isArg || isBuff || isType,
							result = skipIndexes ? baseTimes(value.length, String) : [],
							length = result.length;
						for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
						return result
					}

					function arraySample(array)
					{
						var length = array.length;
						return length ? array[baseRandom(0, length - 1)] : undefined
					}

					function arraySampleSize(array, n)
					{
						return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length))
					}

					function arrayShuffle(array)
					{
						return shuffleSelf(copyArray(array))
					}

					function assignMergeValue(object, key, value)
					{
						(value === undefined || eq(object[key], value)) && (value !== undefined || key in object) || baseAssignValue(object, key, value)
					}

					function assignValue(object, key, value)
					{
						var objValue = object[key];
						hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || baseAssignValue(object, key, value)
					}

					function assocIndexOf(array, key)
					{
						var length = array.length;
						while (length--)
							if (eq(array[length][0], key)) return length;
						return -1
					}

					function baseAggregator(collection, setter, iteratee, accumulator)
					{
						baseEach(collection, function (value, key, collection)
						{
							setter(accumulator, value, iteratee(value), collection)
						});
						return accumulator
					}

					function baseAssign(object, source)
					{
						return object && copyObject(source, keys(source), object)
					}

					function baseAssignIn(object, source)
					{
						return object && copyObject(source, keysIn(source), object)
					}

					function baseAssignValue(object, key, value)
					{
						"__proto__" == key && defineProperty ? defineProperty(object, key,
						{
							configurable: true,
							enumerable: true,
							value: value,
							writable: true
						}) : object[key] = value
					}

					function baseAt(object, paths)
					{
						var index = -1,
							length = paths.length,
							result = Array(length),
							skip = null == object;
						while (++index < length) result[index] = skip ? undefined : get(object, paths[index]);
						return result
					}

					function baseClamp(number, lower, upper)
					{
						if (number === number)
						{
							upper !== undefined && (number = number <= upper ? number : upper);
							lower !== undefined && (number = number >= lower ? number : lower)
						}
						return number
					}

					function baseClone(value, bitmask, customizer, key, object, stack)
					{
						var result, isDeep = bitmask & CLONE_DEEP_FLAG,
							isFlat = bitmask & CLONE_FLAT_FLAG,
							isFull = bitmask & CLONE_SYMBOLS_FLAG;
						customizer && (result = object ? customizer(value, key, object, stack) : customizer(value));
						if (result !== undefined) return result;
						if (!isObject(value)) return value;
						var isArr = isArray(value);
						if (isArr)
						{
							result = initCloneArray(value);
							if (!isDeep) return copyArray(value, result)
						}
						else
						{
							var tag = getTag(value),
								isFunc = tag == funcTag || tag == genTag;
							if (isBuffer(value)) return cloneBuffer(value, isDeep);
							if (tag == objectTag || tag == argsTag || isFunc && !object)
							{
								result = isFlat || isFunc ?
								{} : initCloneObject(value);
								if (!isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value))
							}
							else
							{
								if (!cloneableTags[tag]) return object ? value :
								{};
								result = initCloneByTag(value, tag, isDeep)
							}
						}
						stack || (stack = new Stack);
						var stacked = stack.get(value);
						if (stacked) return stacked;
						stack.set(value, result);
						if (isSet(value))
						{
							value.forEach(function (subValue)
							{
								result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
							});
							return result
						}
						if (isMap(value))
						{
							value.forEach(function (subValue, key)
							{
								result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
							});
							return result
						}
						var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
						var props = isArr ? undefined : keysFunc(value);
						arrayEach(props || value, function (subValue, key)
						{
							if (props)
							{
								key = subValue;
								subValue = value[key]
							}
							assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
						});
						return result
					}

					function baseConforms(source)
					{
						var props = keys(source);
						return function (object)
						{
							return baseConformsTo(object, source, props)
						}
					}

					function baseConformsTo(object, source, props)
					{
						var length = props.length;
						if (null == object) return !length;
						object = Object(object);
						while (length--)
						{
							var key = props[length],
								predicate = source[key],
								value = object[key];
							if (value === undefined && !(key in object) || !predicate(value)) return false
						}
						return true
					}

					function baseDelay(func, wait, args)
					{
						if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
						return setTimeout(function ()
						{
							func.apply(undefined, args)
						}, wait)
					}

					function baseDifference(array, values, iteratee, comparator)
					{
						var index = -1,
							includes = arrayIncludes,
							isCommon = true,
							length = array.length,
							result = [],
							valuesLength = values.length;
						if (!length) return result;
						iteratee && (values = arrayMap(values, baseUnary(iteratee)));
						if (comparator)
						{
							includes = arrayIncludesWith;
							isCommon = false
						}
						else if (values.length >= LARGE_ARRAY_SIZE)
						{
							includes = cacheHas;
							isCommon = false;
							values = new SetCache(values)
						}
						outer: while (++index < length)
						{
							var value = array[index],
								computed = null == iteratee ? value : iteratee(value);
							value = comparator || 0 !== value ? value : 0;
							if (isCommon && computed === computed)
							{
								var valuesIndex = valuesLength;
								while (valuesIndex--)
									if (values[valuesIndex] === computed) continue outer;
								result.push(value)
							}
							else includes(values, computed, comparator) || result.push(value)
						}
						return result
					}
					var baseEach = createBaseEach(baseForOwn);
					var baseEachRight = createBaseEach(baseForOwnRight, true);

					function baseEvery(collection, predicate)
					{
						var result = true;
						baseEach(collection, function (value, index, collection)
						{
							result = !!predicate(value, index, collection);
							return result
						});
						return result
					}

					function baseExtremum(array, iteratee, comparator)
					{
						var index = -1,
							length = array.length;
						while (++index < length)
						{
							var value = array[index],
								current = iteratee(value);
							if (null != current && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current,
								result = value
						}
						return result
					}

					function baseFill(array, value, start, end)
					{
						var length = array.length;
						start = toInteger(start);
						start < 0 && (start = -start > length ? 0 : length + start);
						end = end === undefined || end > length ? length : toInteger(end);
						end < 0 && (end += length);
						end = start > end ? 0 : toLength(end);
						while (start < end) array[start++] = value;
						return array
					}

					function baseFilter(collection, predicate)
					{
						var result = [];
						baseEach(collection, function (value, index, collection)
						{
							predicate(value, index, collection) && result.push(value)
						});
						return result
					}

					function baseFlatten(array, depth, predicate, isStrict, result)
					{
						var index = -1,
							length = array.length;
						predicate || (predicate = isFlattenable);
						result || (result = []);
						while (++index < length)
						{
							var value = array[index];
							depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value)
						}
						return result
					}
					var baseFor = createBaseFor();
					var baseForRight = createBaseFor(true);

					function baseForOwn(object, iteratee)
					{
						return object && baseFor(object, iteratee, keys)
					}

					function baseForOwnRight(object, iteratee)
					{
						return object && baseForRight(object, iteratee, keys)
					}

					function baseFunctions(object, props)
					{
						return arrayFilter(props, function (key)
						{
							return isFunction(object[key])
						})
					}

					function baseGet(object, path)
					{
						path = castPath(path, object);
						var index = 0,
							length = path.length;
						while (null != object && index < length) object = object[toKey(path[index++])];
						return index && index == length ? object : undefined
					}

					function baseGetAllKeys(object, keysFunc, symbolsFunc)
					{
						var result = keysFunc(object);
						return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
					}

					function baseGetTag(value)
					{
						if (null == value) return value === undefined ? undefinedTag : nullTag;
						return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value)
					}

					function baseGt(value, other)
					{
						return value > other
					}

					function baseHas(object, key)
					{
						return null != object && hasOwnProperty.call(object, key)
					}

					function baseHasIn(object, key)
					{
						return null != object && key in Object(object)
					}

					function baseInRange(number, start, end)
					{
						return number >= nativeMin(start, end) && number < nativeMax(start, end)
					}

					function baseIntersection(arrays, iteratee, comparator)
					{
						var includes = comparator ? arrayIncludesWith : arrayIncludes,
							length = arrays[0].length,
							othLength = arrays.length,
							othIndex = othLength,
							caches = Array(othLength),
							maxLength = Infinity,
							result = [];
						while (othIndex--)
						{
							var array = arrays[othIndex];
							othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee)));
							maxLength = nativeMin(array.length, maxLength);
							caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined
						}
						array = arrays[0];
						var index = -1,
							seen = caches[0];
						outer: while (++index < length && result.length < maxLength)
						{
							var value = array[index],
								computed = iteratee ? iteratee(value) : value;
							value = comparator || 0 !== value ? value : 0;
							if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator)))
							{
								othIndex = othLength;
								while (--othIndex)
								{
									var cache = caches[othIndex];
									if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer
								}
								seen && seen.push(computed);
								result.push(value)
							}
						}
						return result
					}

					function baseInverter(object, setter, iteratee, accumulator)
					{
						baseForOwn(object, function (value, key, object)
						{
							setter(accumulator, iteratee(value), key, object)
						});
						return accumulator
					}

					function baseInvoke(object, path, args)
					{
						path = castPath(path, object);
						object = parent(object, path);
						var func = null == object ? object : object[toKey(last(path))];
						return null == func ? undefined : apply(func, object, args)
					}

					function baseIsArguments(value)
					{
						return isObjectLike(value) && baseGetTag(value) == argsTag
					}

					function baseIsArrayBuffer(value)
					{
						return isObjectLike(value) && baseGetTag(value) == arrayBufferTag
					}

					function baseIsDate(value)
					{
						return isObjectLike(value) && baseGetTag(value) == dateTag
					}

					function baseIsEqual(value, other, bitmask, customizer, stack)
					{
						if (value === other) return true;
						if (null == value || null == other || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;
						return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack)
					}

					function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack)
					{
						var objIsArr = isArray(object),
							othIsArr = isArray(other),
							objTag = objIsArr ? arrayTag : getTag(object),
							othTag = othIsArr ? arrayTag : getTag(other);
						objTag = objTag == argsTag ? objectTag : objTag;
						othTag = othTag == argsTag ? objectTag : othTag;
						var objIsObj = objTag == objectTag,
							othIsObj = othTag == objectTag,
							isSameTag = objTag == othTag;
						if (isSameTag && isBuffer(object))
						{
							if (!isBuffer(other)) return false;
							objIsArr = true;
							objIsObj = false
						}
						if (isSameTag && !objIsObj)
						{
							stack || (stack = new Stack);
							return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack)
						}
						if (!(bitmask & COMPARE_PARTIAL_FLAG))
						{
							var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"),
								othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
							if (objIsWrapped || othIsWrapped)
							{
								var objUnwrapped = objIsWrapped ? object.value() : object,
									othUnwrapped = othIsWrapped ? other.value() : other;
								stack || (stack = new Stack);
								return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)
							}
						}
						if (!isSameTag) return false;
						stack || (stack = new Stack);
						return equalObjects(object, other, bitmask, customizer, equalFunc, stack)
					}

					function baseIsMap(value)
					{
						return isObjectLike(value) && getTag(value) == mapTag
					}

					function baseIsMatch(object, source, matchData, customizer)
					{
						var index = matchData.length,
							length = index,
							noCustomizer = !customizer;
						if (null == object) return !length;
						object = Object(object);
						while (index--)
						{
							var data = matchData[index];
							if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false
						}
						while (++index < length)
						{
							data = matchData[index];
							var key = data[0],
								objValue = object[key],
								srcValue = data[1];
							if (noCustomizer && data[2])
							{
								if (objValue === undefined && !(key in object)) return false
							}
							else
							{
								var stack = new Stack;
								if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
								if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return false
							}
						}
						return true
					}

					function baseIsNative(value)
					{
						if (!isObject(value) || isMasked(value)) return false;
						var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
						return pattern.test(toSource(value))
					}

					function baseIsRegExp(value)
					{
						return isObjectLike(value) && baseGetTag(value) == regexpTag
					}

					function baseIsSet(value)
					{
						return isObjectLike(value) && getTag(value) == setTag
					}

					function baseIsTypedArray(value)
					{
						return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]
					}

					function baseIteratee(value)
					{
						if ("function" == typeof value) return value;
						if (null == value) return identity;
						if ("object" == typeof value) return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
						return property(value)
					}

					function baseKeys(object)
					{
						if (!isPrototype(object)) return nativeKeys(object);
						var result = [];
						for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
						return result
					}

					function baseKeysIn(object)
					{
						if (!isObject(object)) return nativeKeysIn(object);
						var isProto = isPrototype(object),
							result = [];
						for (var key in object) "constructor" == key && (isProto || !hasOwnProperty.call(object, key)) || result.push(key);
						return result
					}

					function baseLt(value, other)
					{
						return value < other
					}

					function baseMap(collection, iteratee)
					{
						var index = -1,
							result = isArrayLike(collection) ? Array(collection.length) : [];
						baseEach(collection, function (value, key, collection)
						{
							result[++index] = iteratee(value, key, collection)
						});
						return result
					}

					function baseMatches(source)
					{
						var matchData = getMatchData(source);
						if (1 == matchData.length && matchData[0][2]) return matchesStrictComparable(matchData[0][0], matchData[0][1]);
						return function (object)
						{
							return object === source || baseIsMatch(object, source, matchData)
						}
					}

					function baseMatchesProperty(path, srcValue)
					{
						if (isKey(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey(path), srcValue);
						return function (object)
						{
							var objValue = get(object, path);
							return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
						}
					}

					function baseMerge(object, source, srcIndex, customizer, stack)
					{
						if (object === source) return;
						baseFor(source, function (srcValue, key)
						{
							if (isObject(srcValue))
							{
								stack || (stack = new Stack);
								baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack)
							}
							else
							{
								var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
								newValue === undefined && (newValue = srcValue);
								assignMergeValue(object, key, newValue)
							}
						}, keysIn)
					}

					function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack)
					{
						var objValue = safeGet(object, key),
							srcValue = safeGet(source, key),
							stacked = stack.get(srcValue);
						if (stacked)
						{
							assignMergeValue(object, key, stacked);
							return
						}
						var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
						var isCommon = newValue === undefined;
						if (isCommon)
						{
							var isArr = isArray(srcValue),
								isBuff = !isArr && isBuffer(srcValue),
								isTyped = !isArr && !isBuff && isTypedArray(srcValue);
							newValue = srcValue;
							if (isArr || isBuff || isTyped)
								if (isArray(objValue)) newValue = objValue;
								else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue);
							else if (isBuff)
							{
								isCommon = false;
								newValue = cloneBuffer(srcValue, true)
							}
							else if (isTyped)
							{
								isCommon = false;
								newValue = cloneTypedArray(srcValue, true)
							}
							else newValue = [];
							else if (isPlainObject(srcValue) || isArguments(srcValue))
							{
								newValue = objValue;
								isArguments(objValue) ? newValue = toPlainObject(objValue) : isObject(objValue) && !isFunction(objValue) || (newValue = initCloneObject(srcValue))
							}
							else isCommon = false
						}
						if (isCommon)
						{
							stack.set(srcValue, newValue);
							mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
							stack["delete"](srcValue)
						}
						assignMergeValue(object, key, newValue)
					}

					function baseNth(array, n)
					{
						var length = array.length;
						if (!length) return;
						n += n < 0 ? length : 0;
						return isIndex(n, length) ? array[n] : undefined
					}

					function baseOrderBy(collection, iteratees, orders)
					{
						var index = -1;
						iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
						var result = baseMap(collection, function (value, key, collection)
						{
							var criteria = arrayMap(iteratees, function (iteratee)
							{
								return iteratee(value)
							});
							return {
								criteria: criteria,
								index: ++index,
								value: value
							}
						});
						return baseSortBy(result, function (object, other)
						{
							return compareMultiple(object, other, orders)
						})
					}

					function basePick(object, paths)
					{
						return basePickBy(object, paths, function (value, path)
						{
							return hasIn(object, path)
						})
					}

					function basePickBy(object, paths, predicate)
					{
						var index = -1,
							length = paths.length,
							result = {};
						while (++index < length)
						{
							var path = paths[index],
								value = baseGet(object, path);
							predicate(value, path) && baseSet(result, castPath(path, object), value)
						}
						return result
					}

					function basePropertyDeep(path)
					{
						return function (object)
						{
							return baseGet(object, path)
						}
					}

					function basePullAll(array, values, iteratee, comparator)
					{
						var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
							index = -1,
							length = values.length,
							seen = array;
						array === values && (values = copyArray(values));
						iteratee && (seen = arrayMap(array, baseUnary(iteratee)));
						while (++index < length)
						{
							var fromIndex = 0,
								value = values[index],
								computed = iteratee ? iteratee(value) : value;
							while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1)
							{
								seen !== array && splice.call(seen, fromIndex, 1);
								splice.call(array, fromIndex, 1)
							}
						}
						return array
					}

					function basePullAt(array, indexes)
					{
						var length = array ? indexes.length : 0,
							lastIndex = length - 1;
						while (length--)
						{
							var index = indexes[length];
							if (length == lastIndex || index !== previous)
							{
								var previous = index;
								isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index)
							}
						}
						return array
					}

					function baseRandom(lower, upper)
					{
						return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
					}

					function baseRange(start, end, step, fromRight)
					{
						var index = -1,
							length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
							result = Array(length);
						while (length--)
						{
							result[fromRight ? length : ++index] = start;
							start += step
						}
						return result
					}

					function baseRepeat(string, n)
					{
						var result = "";
						if (!string || n < 1 || n > MAX_SAFE_INTEGER) return result;
						do {
							n % 2 && (result += string);
							n = nativeFloor(n / 2);
							n && (string += string)
						} while (n);
						return result
					}

					function baseRest(func, start)
					{
						return setToString(overRest(func, start, identity), func + "")
					}

					function baseSample(collection)
					{
						return arraySample(values(collection))
					}

					function baseSampleSize(collection, n)
					{
						var array = values(collection);
						return shuffleSelf(array, baseClamp(n, 0, array.length))
					}

					function baseSet(object, path, value, customizer)
					{
						if (!isObject(object)) return object;
						path = castPath(path, object);
						var index = -1,
							length = path.length,
							lastIndex = length - 1,
							nested = object;
						while (null != nested && ++index < length)
						{
							var key = toKey(path[index]),
								newValue = value;
							if (index != lastIndex)
							{
								var objValue = nested[key];
								newValue = customizer ? customizer(objValue, key, nested) : undefined;
								newValue === undefined && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] :
								{})
							}
							assignValue(nested, key, newValue);
							nested = nested[key]
						}
						return object
					}
					var baseSetData = metaMap ? function (func, data)
					{
						metaMap.set(func, data);
						return func
					} : identity;
					var baseSetToString = defineProperty ? function (func, string)
					{
						return defineProperty(func, "toString",
						{
							configurable: true,
							enumerable: false,
							value: constant(string),
							writable: true
						})
					} : identity;

					function baseShuffle(collection)
					{
						return shuffleSelf(values(collection))
					}

					function baseSlice(array, start, end)
					{
						var index = -1,
							length = array.length;
						start < 0 && (start = -start > length ? 0 : length + start);
						end = end > length ? length : end;
						end < 0 && (end += length);
						length = start > end ? 0 : end - start >>> 0;
						start >>>= 0;
						var result = Array(length);
						while (++index < length) result[index] = array[index + start];
						return result
					}

					function baseSome(collection, predicate)
					{
						var result;
						baseEach(collection, function (value, index, collection)
						{
							result = predicate(value, index, collection);
							return !result
						});
						return !!result
					}

					function baseSortedIndex(array, value, retHighest)
					{
						var low = 0,
							high = null == array ? low : array.length;
						if ("number" == typeof value && value === value && high <= HALF_MAX_ARRAY_LENGTH)
						{
							while (low < high)
							{
								var mid = low + high >>> 1,
									computed = array[mid];
								null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid
							}
							return high
						}
						return baseSortedIndexBy(array, value, identity, retHighest)
					}

					function baseSortedIndexBy(array, value, iteratee, retHighest)
					{
						value = iteratee(value);
						var low = 0,
							high = null == array ? 0 : array.length,
							valIsNaN = value !== value,
							valIsNull = null === value,
							valIsSymbol = isSymbol(value),
							valIsUndefined = value === undefined;
						while (low < high)
						{
							var mid = nativeFloor((low + high) / 2),
								computed = iteratee(array[mid]),
								othIsDefined = computed !== undefined,
								othIsNull = null === computed,
								othIsReflexive = computed === computed,
								othIsSymbol = isSymbol(computed);
							if (valIsNaN) var setLow = retHighest || othIsReflexive;
							else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value);
							setLow ? low = mid + 1 : high = mid
						}
						return nativeMin(high, MAX_ARRAY_INDEX)
					}

					function baseSortedUniq(array, iteratee)
					{
						var index = -1,
							length = array.length,
							resIndex = 0,
							result = [];
						while (++index < length)
						{
							var value = array[index],
								computed = iteratee ? iteratee(value) : value;
							if (!index || !eq(computed, seen))
							{
								var seen = computed;
								result[resIndex++] = 0 === value ? 0 : value
							}
						}
						return result
					}

					function baseToNumber(value)
					{
						if ("number" == typeof value) return value;
						if (isSymbol(value)) return NAN;
						return +value
					}

					function baseToString(value)
					{
						if ("string" == typeof value) return value;
						if (isArray(value)) return arrayMap(value, baseToString) + "";
						if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
						var result = value + "";
						return "0" == result && 1 / value == -INFINITY ? "-0" : result
					}

					function baseUniq(array, iteratee, comparator)
					{
						var index = -1,
							includes = arrayIncludes,
							length = array.length,
							isCommon = true,
							result = [],
							seen = result;
						if (comparator)
						{
							isCommon = false;
							includes = arrayIncludesWith
						}
						else if (length >= LARGE_ARRAY_SIZE)
						{
							var set = iteratee ? null : createSet(array);
							if (set) return setToArray(set);
							isCommon = false;
							includes = cacheHas;
							seen = new SetCache
						}
						else seen = iteratee ? [] : result;
						outer: while (++index < length)
						{
							var value = array[index],
								computed = iteratee ? iteratee(value) : value;
							value = comparator || 0 !== value ? value : 0;
							if (isCommon && computed === computed)
							{
								var seenIndex = seen.length;
								while (seenIndex--)
									if (seen[seenIndex] === computed) continue outer;
								iteratee && seen.push(computed);
								result.push(value)
							}
							else if (!includes(seen, computed, comparator))
							{
								seen !== result && seen.push(computed);
								result.push(value)
							}
						}
						return result
					}

					function baseUnset(object, path)
					{
						path = castPath(path, object);
						object = parent(object, path);
						return null == object || delete object[toKey(last(path))]
					}

					function baseUpdate(object, path, updater, customizer)
					{
						return baseSet(object, path, updater(baseGet(object, path)), customizer)
					}

					function baseWhile(array, predicate, isDrop, fromRight)
					{
						var length = array.length,
							index = fromRight ? length : -1;
						while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array));
						return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
					}

					function baseWrapperValue(value, actions)
					{
						var result = value;
						result instanceof LazyWrapper && (result = result.value());
						return arrayReduce(actions, function (result, action)
						{
							return action.func.apply(action.thisArg, arrayPush([result], action.args))
						}, result)
					}

					function baseXor(arrays, iteratee, comparator)
					{
						var length = arrays.length;
						if (length < 2) return length ? baseUniq(arrays[0]) : [];
						var index = -1,
							result = Array(length);
						while (++index < length)
						{
							var array = arrays[index],
								othIndex = -1;
							while (++othIndex < length) othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator))
						}
						return baseUniq(baseFlatten(result, 1), iteratee, comparator)
					}

					function baseZipObject(props, values, assignFunc)
					{
						var index = -1,
							length = props.length,
							valsLength = values.length,
							result = {};
						while (++index < length)
						{
							var value = index < valsLength ? values[index] : undefined;
							assignFunc(result, props[index], value)
						}
						return result
					}

					function castArrayLikeObject(value)
					{
						return isArrayLikeObject(value) ? value : []
					}

					function castFunction(value)
					{
						return "function" == typeof value ? value : identity
					}

					function castPath(value, object)
					{
						if (isArray(value)) return value;
						return isKey(value, object) ? [value] : stringToPath(toString(value))
					}
					var castRest = baseRest;

					function castSlice(array, start, end)
					{
						var length = array.length;
						end = end === undefined ? length : end;
						return !start && end >= length ? array : baseSlice(array, start, end)
					}
					var clearTimeout = ctxClearTimeout || function (id)
					{
						return root.clearTimeout(id)
					};

					function cloneBuffer(buffer, isDeep)
					{
						if (isDeep) return buffer.slice();
						var length = buffer.length,
							result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
						buffer.copy(result);
						return result
					}

					function cloneArrayBuffer(arrayBuffer)
					{
						var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
						new Uint8Array(result).set(new Uint8Array(arrayBuffer));
						return result
					}

					function cloneDataView(dataView, isDeep)
					{
						var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
						return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
					}

					function cloneRegExp(regexp)
					{
						var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
						result.lastIndex = regexp.lastIndex;
						return result
					}

					function cloneSymbol(symbol)
					{
						return symbolValueOf ? Object(symbolValueOf.call(symbol)) :
						{}
					}

					function cloneTypedArray(typedArray, isDeep)
					{
						var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
						return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)
					}

					function compareAscending(value, other)
					{
						if (value !== other)
						{
							var valIsDefined = value !== undefined,
								valIsNull = null === value,
								valIsReflexive = value === value,
								valIsSymbol = isSymbol(value);
							var othIsDefined = other !== undefined,
								othIsNull = null === other,
								othIsReflexive = other === other,
								othIsSymbol = isSymbol(other);
							if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
							if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1
						}
						return 0
					}

					function compareMultiple(object, other, orders)
					{
						var index = -1,
							objCriteria = object.criteria,
							othCriteria = other.criteria,
							length = objCriteria.length,
							ordersLength = orders.length;
						while (++index < length)
						{
							var result = compareAscending(objCriteria[index], othCriteria[index]);
							if (result)
							{
								if (index >= ordersLength) return result;
								var order = orders[index];
								return result * ("desc" == order ? -1 : 1)
							}
						}
						return object.index - other.index
					}

					function composeArgs(args, partials, holders, isCurried)
					{
						var argsIndex = -1,
							argsLength = args.length,
							holdersLength = holders.length,
							leftIndex = -1,
							leftLength = partials.length,
							rangeLength = nativeMax(argsLength - holdersLength, 0),
							result = Array(leftLength + rangeLength),
							isUncurried = !isCurried;
						while (++leftIndex < leftLength) result[leftIndex] = partials[leftIndex];
						while (++argsIndex < holdersLength)(isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex]);
						while (rangeLength--) result[leftIndex++] = args[argsIndex++];
						return result
					}

					function composeArgsRight(args, partials, holders, isCurried)
					{
						var argsIndex = -1,
							argsLength = args.length,
							holdersIndex = -1,
							holdersLength = holders.length,
							rightIndex = -1,
							rightLength = partials.length,
							rangeLength = nativeMax(argsLength - holdersLength, 0),
							result = Array(rangeLength + rightLength),
							isUncurried = !isCurried;
						while (++argsIndex < rangeLength) result[argsIndex] = args[argsIndex];
						var offset = argsIndex;
						while (++rightIndex < rightLength) result[offset + rightIndex] = partials[rightIndex];
						while (++holdersIndex < holdersLength)(isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
						return result
					}

					function copyArray(source, array)
					{
						var index = -1,
							length = source.length;
						array || (array = Array(length));
						while (++index < length) array[index] = source[index];
						return array
					}

					function copyObject(source, props, object, customizer)
					{
						var isNew = !object;
						object || (object = {});
						var index = -1,
							length = props.length;
						while (++index < length)
						{
							var key = props[index];
							var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
							newValue === undefined && (newValue = source[key]);
							isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue)
						}
						return object
					}

					function copySymbols(source, object)
					{
						return copyObject(source, getSymbols(source), object)
					}

					function copySymbolsIn(source, object)
					{
						return copyObject(source, getSymbolsIn(source), object)
					}

					function createAggregator(setter, initializer)
					{
						return function (collection, iteratee)
						{
							var func = isArray(collection) ? arrayAggregator : baseAggregator,
								accumulator = initializer ? initializer() :
								{};
							return func(collection, setter, getIteratee(iteratee, 2), accumulator)
						}
					}

					function createAssigner(assigner)
					{
						return baseRest(function (object, sources)
						{
							var index = -1,
								length = sources.length,
								customizer = length > 1 ? sources[length - 1] : undefined,
								guard = length > 2 ? sources[2] : undefined;
							customizer = assigner.length > 3 && "function" == typeof customizer ? (length--, customizer) : undefined;
							if (guard && isIterateeCall(sources[0], sources[1], guard))
							{
								customizer = length < 3 ? undefined : customizer;
								length = 1
							}
							object = Object(object);
							while (++index < length)
							{
								var source = sources[index];
								source && assigner(object, source, index, customizer)
							}
							return object
						})
					}

					function createBaseEach(eachFunc, fromRight)
					{
						return function (collection, iteratee)
						{
							if (null == collection) return collection;
							if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
							var length = collection.length,
								index = fromRight ? length : -1,
								iterable = Object(collection);
							while (fromRight ? index-- : ++index < length)
								if (false === iteratee(iterable[index], index, iterable)) break;
							return collection
						}
					}

					function createBaseFor(fromRight)
					{
						return function (object, iteratee, keysFunc)
						{
							var index = -1,
								iterable = Object(object),
								props = keysFunc(object),
								length = props.length;
							while (length--)
							{
								var key = props[fromRight ? length : ++index];
								if (false === iteratee(iterable[key], key, iterable)) break
							}
							return object
						}
					}

					function createBind(func, bitmask, thisArg)
					{
						var isBind = bitmask & WRAP_BIND_FLAG,
							Ctor = createCtor(func);

						function wrapper()
						{
							var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
							return fn.apply(isBind ? thisArg : this, arguments)
						}
						return wrapper
					}

					function createCaseFirst(methodName)
					{
						return function (string)
						{
							string = toString(string);
							var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
							var chr = strSymbols ? strSymbols[0] : string.charAt(0);
							var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
							return chr[methodName]() + trailing
						}
					}

					function createCompounder(callback)
					{
						return function (string)
						{
							return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "")
						}
					}

					function createCtor(Ctor)
					{
						return function ()
						{
							var args = arguments;
							switch (args.length)
							{
							case 0:
								return new Ctor;
							case 1:
								return new Ctor(args[0]);
							case 2:
								return new Ctor(args[0], args[1]);
							case 3:
								return new Ctor(args[0], args[1], args[2]);
							case 4:
								return new Ctor(args[0], args[1], args[2], args[3]);
							case 5:
								return new Ctor(args[0], args[1], args[2], args[3], args[4]);
							case 6:
								return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
							case 7:
								return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
							}
							var thisBinding = baseCreate(Ctor.prototype),
								result = Ctor.apply(thisBinding, args);
							return isObject(result) ? result : thisBinding
						}
					}

					function createCurry(func, bitmask, arity)
					{
						var Ctor = createCtor(func);

						function wrapper()
						{
							var length = arguments.length,
								args = Array(length),
								index = length,
								placeholder = getHolder(wrapper);
							while (index--) args[index] = arguments[index];
							var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
							length -= holders.length;
							if (length < arity) return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
							var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
							return apply(fn, this, args)
						}
						return wrapper
					}

					function createFind(findIndexFunc)
					{
						return function (collection, predicate, fromIndex)
						{
							var iterable = Object(collection);
							if (!isArrayLike(collection))
							{
								var iteratee = getIteratee(predicate, 3);
								collection = keys(collection);
								predicate = function (key)
								{
									return iteratee(iterable[key], key, iterable)
								}
							}
							var index = findIndexFunc(collection, predicate, fromIndex);
							return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined
						}
					}

					function createFlow(fromRight)
					{
						return flatRest(function (funcs)
						{
							var length = funcs.length,
								index = length,
								prereq = LodashWrapper.prototype.thru;
							fromRight && funcs.reverse();
							while (index--)
							{
								var func = funcs[index];
								if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
								if (prereq && !wrapper && "wrapper" == getFuncName(func)) var wrapper = new LodashWrapper([], true)
							}
							index = wrapper ? index : length;
							while (++index < length)
							{
								func = funcs[index];
								var funcName = getFuncName(func),
									data = "wrapper" == funcName ? getData(func) : undefined;
								wrapper = data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func)
							}
							return function ()
							{
								var args = arguments,
									value = args[0];
								if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value();
								var index = 0,
									result = length ? funcs[index].apply(this, args) : value;
								while (++index < length) result = funcs[index].call(this, result);
								return result
							}
						})
					}

					function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity)
					{
						var isAry = bitmask & WRAP_ARY_FLAG,
							isBind = bitmask & WRAP_BIND_FLAG,
							isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
							isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
							isFlip = bitmask & WRAP_FLIP_FLAG,
							Ctor = isBindKey ? undefined : createCtor(func);

						function wrapper()
						{
							var length = arguments.length,
								args = Array(length),
								index = length;
							while (index--) args[index] = arguments[index];
							if (isCurried) var placeholder = getHolder(wrapper),
								holdersCount = countHolders(args, placeholder);
							partials && (args = composeArgs(args, partials, holders, isCurried));
							partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried));
							length -= holdersCount;
							if (isCurried && length < arity)
							{
								var newHolders = replaceHolders(args, placeholder);
								return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length)
							}
							var thisBinding = isBind ? thisArg : this,
								fn = isBindKey ? thisBinding[func] : func;
							length = args.length;
							argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse();
							isAry && ary < length && (args.length = ary);
							this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn));
							return fn.apply(thisBinding, args)
						}
						return wrapper
					}

					function createInverter(setter, toIteratee)
					{
						return function (object, iteratee)
						{
							return baseInverter(object, setter, toIteratee(iteratee),
							{})
						}
					}

					function createMathOperation(operator, defaultValue)
					{
						return function (value, other)
						{
							var result;
							if (value === undefined && other === undefined) return defaultValue;
							value !== undefined && (result = value);
							if (other !== undefined)
							{
								if (result === undefined) return other;
								if ("string" == typeof value || "string" == typeof other)
								{
									value = baseToString(value);
									other = baseToString(other)
								}
								else
								{
									value = baseToNumber(value);
									other = baseToNumber(other)
								}
								result = operator(value, other)
							}
							return result
						}
					}

					function createOver(arrayFunc)
					{
						return flatRest(function (iteratees)
						{
							iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
							return baseRest(function (args)
							{
								var thisArg = this;
								return arrayFunc(iteratees, function (iteratee)
								{
									return apply(iteratee, thisArg, args)
								})
							})
						})
					}

					function createPadding(length, chars)
					{
						chars = chars === undefined ? " " : baseToString(chars);
						var charsLength = chars.length;
						if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
						var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
						return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length)
					}

					function createPartial(func, bitmask, thisArg, partials)
					{
						var isBind = bitmask & WRAP_BIND_FLAG,
							Ctor = createCtor(func);

						function wrapper()
						{
							var argsIndex = -1,
								argsLength = arguments.length,
								leftIndex = -1,
								leftLength = partials.length,
								args = Array(leftLength + argsLength),
								fn = this && this !== root && this instanceof wrapper ? Ctor : func;
							while (++leftIndex < leftLength) args[leftIndex] = partials[leftIndex];
							while (argsLength--) args[leftIndex++] = arguments[++argsIndex];
							return apply(fn, isBind ? thisArg : this, args)
						}
						return wrapper
					}

					function createRange(fromRight)
					{
						return function (start, end, step)
						{
							step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined);
							start = toFinite(start);
							if (end === undefined)
							{
								end = start;
								start = 0
							}
							else end = toFinite(end);
							step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
							return baseRange(start, end, step, fromRight)
						}
					}

					function createRelationalOperation(operator)
					{
						return function (value, other)
						{
							if (!("string" == typeof value && "string" == typeof other))
							{
								value = toNumber(value);
								other = toNumber(other)
							}
							return operator(value, other)
						}
					}

					function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity)
					{
						var isCurry = bitmask & WRAP_CURRY_FLAG,
							newHolders = isCurry ? holders : undefined,
							newHoldersRight = isCurry ? undefined : holders,
							newPartials = isCurry ? partials : undefined,
							newPartialsRight = isCurry ? undefined : partials;
						bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
						bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
						bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
						var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
						var result = wrapFunc.apply(undefined, newData);
						isLaziable(func) && setData(result, newData);
						result.placeholder = placeholder;
						return setWrapToString(result, func, bitmask)
					}

					function createRound(methodName)
					{
						var func = Math[methodName];
						return function (number, precision)
						{
							number = toNumber(number);
							precision = null == precision ? 0 : nativeMin(toInteger(precision), 292);
							if (precision)
							{
								var pair = (toString(number) + "e").split("e"),
									value = func(pair[0] + "e" + (+pair[1] + precision));
								pair = (toString(value) + "e").split("e");
								return +(pair[0] + "e" + (+pair[1] - precision))
							}
							return func(number)
						}
					}
					var createSet = Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY ? function (values)
					{
						return new Set(values)
					} : noop;

					function createToPairs(keysFunc)
					{
						return function (object)
						{
							var tag = getTag(object);
							if (tag == mapTag) return mapToArray(object);
							if (tag == setTag) return setToPairs(object);
							return baseToPairs(object, keysFunc(object))
						}
					}

					function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity)
					{
						var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
						if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
						var length = partials ? partials.length : 0;
						if (!length)
						{
							bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
							partials = holders = undefined
						}
						ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
						arity = arity === undefined ? arity : toInteger(arity);
						length -= holders ? holders.length : 0;
						if (bitmask & WRAP_PARTIAL_RIGHT_FLAG)
						{
							var partialsRight = partials,
								holdersRight = holders;
							partials = holders = undefined
						}
						var data = isBindKey ? undefined : getData(func);
						var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
						data && mergeData(newData, data);
						func = newData[0];
						bitmask = newData[1];
						thisArg = newData[2];
						partials = newData[3];
						holders = newData[4];
						arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
						!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG));
						if (bitmask && bitmask != WRAP_BIND_FLAG) result = bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? createCurry(func, bitmask, arity) : bitmask != WRAP_PARTIAL_FLAG && bitmask != (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG) || holders.length ? createHybrid.apply(undefined, newData) : createPartial(func, bitmask, thisArg, partials);
						else var result = createBind(func, bitmask, thisArg);
						var setter = data ? baseSetData : setData;
						return setWrapToString(setter(result, newData), func, bitmask)
					}

					function customDefaultsAssignIn(objValue, srcValue, key, object)
					{
						if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) return srcValue;
						return objValue
					}

					function customDefaultsMerge(objValue, srcValue, key, object, source, stack)
					{
						if (isObject(objValue) && isObject(srcValue))
						{
							stack.set(srcValue, objValue);
							baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
							stack["delete"](srcValue)
						}
						return objValue
					}

					function customOmitClone(value)
					{
						return isPlainObject(value) ? undefined : value
					}

					function equalArrays(array, other, bitmask, customizer, equalFunc, stack)
					{
						var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
							arrLength = array.length,
							othLength = other.length;
						if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
						var stacked = stack.get(array);
						if (stacked && stack.get(other)) return stacked == other;
						var index = -1,
							result = true,
							seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
						stack.set(array, other);
						stack.set(other, array);
						while (++index < arrLength)
						{
							var arrValue = array[index],
								othValue = other[index];
							if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
							if (compared !== undefined)
							{
								if (compared) continue;
								result = false;
								break
							}
							if (seen)
							{
								if (!arraySome(other, function (othValue, othIndex)
									{
										if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex)
									}))
								{
									result = false;
									break
								}
							}
							else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack)))
							{
								result = false;
								break
							}
						}
						stack["delete"](array);
						stack["delete"](other);
						return result
					}

					function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack)
					{
						switch (tag)
						{
						case dataViewTag:
							if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
							object = object.buffer;
							other = other.buffer;
						case arrayBufferTag:
							if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) return false;
							return true;
						case boolTag:
						case dateTag:
						case numberTag:
							return eq(+object, +other);
						case errorTag:
							return object.name == other.name && object.message == other.message;
						case regexpTag:
						case stringTag:
							return object == other + "";
						case mapTag:
							var convert = mapToArray;
						case setTag:
							var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
							convert || (convert = setToArray);
							if (object.size != other.size && !isPartial) return false;
							var stacked = stack.get(object);
							if (stacked) return stacked == other;
							bitmask |= COMPARE_UNORDERED_FLAG;
							stack.set(object, other);
							var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
							stack["delete"](object);
							return result;
						case symbolTag:
							if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other)
						}
						return false
					}

					function equalObjects(object, other, bitmask, customizer, equalFunc, stack)
					{
						var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
							objProps = getAllKeys(object),
							objLength = objProps.length,
							othProps = getAllKeys(other),
							othLength = othProps.length;
						if (objLength != othLength && !isPartial) return false;
						var index = objLength;
						while (index--)
						{
							var key = objProps[index];
							if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false
						}
						var stacked = stack.get(object);
						if (stacked && stack.get(other)) return stacked == other;
						var result = true;
						stack.set(object, other);
						stack.set(other, object);
						var skipCtor = isPartial;
						while (++index < objLength)
						{
							key = objProps[index];
							var objValue = object[key],
								othValue = other[key];
							if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
							if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared))
							{
								result = false;
								break
							}
							skipCtor || (skipCtor = "constructor" == key)
						}
						if (result && !skipCtor)
						{
							var objCtor = object.constructor,
								othCtor = other.constructor;
							objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = false)
						}
						stack["delete"](object);
						stack["delete"](other);
						return result
					}

					function flatRest(func)
					{
						return setToString(overRest(func, undefined, flatten), func + "")
					}

					function getAllKeys(object)
					{
						return baseGetAllKeys(object, keys, getSymbols)
					}

					function getAllKeysIn(object)
					{
						return baseGetAllKeys(object, keysIn, getSymbolsIn)
					}
					var getData = metaMap ? function (func)
					{
						return metaMap.get(func)
					} : noop;

					function getFuncName(func)
					{
						var result = func.name + "",
							array = realNames[result],
							length = hasOwnProperty.call(realNames, result) ? array.length : 0;
						while (length--)
						{
							var data = array[length],
								otherFunc = data.func;
							if (null == otherFunc || otherFunc == func) return data.name
						}
						return result
					}

					function getHolder(func)
					{
						var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
						return object.placeholder
					}

					function getIteratee()
					{
						var result = lodash.iteratee || iteratee;
						result = result === iteratee ? baseIteratee : result;
						return arguments.length ? result(arguments[0], arguments[1]) : result
					}

					function getMapData(map, key)
					{
						var data = map.__data__;
						return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map
					}

					function getMatchData(object)
					{
						var result = keys(object),
							length = result.length;
						while (length--)
						{
							var key = result[length],
								value = object[key];
							result[length] = [key, value, isStrictComparable(value)]
						}
						return result
					}

					function getNative(object, key)
					{
						var value = getValue(object, key);
						return baseIsNative(value) ? value : undefined
					}

					function getRawTag(value)
					{
						var isOwn = hasOwnProperty.call(value, symToStringTag),
							tag = value[symToStringTag];
						try
						{
							value[symToStringTag] = undefined;
							var unmasked = true
						}
						catch (e)
						{}
						var result = nativeObjectToString.call(value);
						unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]);
						return result
					}
					var getSymbols = nativeGetSymbols ? function (object)
					{
						if (null == object) return [];
						object = Object(object);
						return arrayFilter(nativeGetSymbols(object), function (symbol)
						{
							return propertyIsEnumerable.call(object, symbol)
						})
					} : stubArray;
					var getSymbolsIn = nativeGetSymbols ? function (object)
					{
						var result = [];
						while (object)
						{
							arrayPush(result, getSymbols(object));
							object = getPrototype(object)
						}
						return result
					} : stubArray;
					var getTag = baseGetTag;
					(DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) && (getTag = function (value)
					{
						var result = baseGetTag(value),
							Ctor = result == objectTag ? value.constructor : undefined,
							ctorString = Ctor ? toSource(Ctor) : "";
						if (ctorString) switch (ctorString)
						{
						case dataViewCtorString:
							return dataViewTag;
						case mapCtorString:
							return mapTag;
						case promiseCtorString:
							return promiseTag;
						case setCtorString:
							return setTag;
						case weakMapCtorString:
							return weakMapTag
						}
						return result
					});

					function getView(start, end, transforms)
					{
						var index = -1,
							length = transforms.length;
						while (++index < length)
						{
							var data = transforms[index],
								size = data.size;
							switch (data.type)
							{
							case "drop":
								start += size;
								break;
							case "dropRight":
								end -= size;
								break;
							case "take":
								end = nativeMin(end, start + size);
								break;
							case "takeRight":
								start = nativeMax(start, end - size)
							}
						}
						return {
							start: start,
							end: end
						}
					}

					function getWrapDetails(source)
					{
						var match = source.match(reWrapDetails);
						return match ? match[1].split(reSplitDetails) : []
					}

					function hasPath(object, path, hasFunc)
					{
						path = castPath(path, object);
						var index = -1,
							length = path.length,
							result = false;
						while (++index < length)
						{
							var key = toKey(path[index]);
							if (!(result = null != object && hasFunc(object, key))) break;
							object = object[key]
						}
						if (result || ++index != length) return result;
						length = null == object ? 0 : object.length;
						return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object))
					}

					function initCloneArray(array)
					{
						var length = array.length,
							result = new array.constructor(length);
						if (length && "string" == typeof array[0] && hasOwnProperty.call(array, "index"))
						{
							result.index = array.index;
							result.input = array.input
						}
						return result
					}

					function initCloneObject(object)
					{
						return "function" != typeof object.constructor || isPrototype(object) ?
						{} : baseCreate(getPrototype(object))
					}

					function initCloneByTag(object, tag, isDeep)
					{
						var Ctor = object.constructor;
						switch (tag)
						{
						case arrayBufferTag:
							return cloneArrayBuffer(object);
						case boolTag:
						case dateTag:
							return new Ctor(+object);
						case dataViewTag:
							return cloneDataView(object, isDeep);
						case float32Tag:
						case float64Tag:
						case int8Tag:
						case int16Tag:
						case int32Tag:
						case uint8Tag:
						case uint8ClampedTag:
						case uint16Tag:
						case uint32Tag:
							return cloneTypedArray(object, isDeep);
						case mapTag:
							return new Ctor;
						case numberTag:
						case stringTag:
							return new Ctor(object);
						case regexpTag:
							return cloneRegExp(object);
						case setTag:
							return new Ctor;
						case symbolTag:
							return cloneSymbol(object)
						}
					}

					function insertWrapDetails(source, details)
					{
						var length = details.length;
						if (!length) return source;
						var lastIndex = length - 1;
						details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
						details = details.join(length > 2 ? ", " : " ");
						return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n")
					}

					function isFlattenable(value)
					{
						return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol])
					}

					function isIndex(value, length)
					{
						var type = typeof value;
						length = null == length ? MAX_SAFE_INTEGER : length;
						return !!length && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length
					}

					function isIterateeCall(value, index, object)
					{
						if (!isObject(object)) return false;
						var type = typeof index;
						if ("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) return eq(object[index], value);
						return false
					}

					function isKey(value, object)
					{
						if (isArray(value)) return false;
						var type = typeof value;
						if ("number" == type || "symbol" == type || "boolean" == type || null == value || isSymbol(value)) return true;
						return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object)
					}

					function isKeyable(value)
					{
						var type = typeof value;
						return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value
					}

					function isLaziable(func)
					{
						var funcName = getFuncName(func),
							other = lodash[funcName];
						if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return false;
						if (func === other) return true;
						var data = getData(other);
						return !!data && func === data[0]
					}

					function isMasked(func)
					{
						return !!maskSrcKey && maskSrcKey in func
					}
					var isMaskable = coreJsData ? isFunction : stubFalse;

					function isPrototype(value)
					{
						var Ctor = value && value.constructor,
							proto = "function" == typeof Ctor && Ctor.prototype || objectProto;
						return value === proto
					}

					function isStrictComparable(value)
					{
						return value === value && !isObject(value)
					}

					function matchesStrictComparable(key, srcValue)
					{
						return function (object)
						{
							if (null == object) return false;
							return object[key] === srcValue && (srcValue !== undefined || key in Object(object))
						}
					}

					function memoizeCapped(func)
					{
						var result = memoize(func, function (key)
						{
							cache.size === MAX_MEMOIZE_SIZE && cache.clear();
							return key
						});
						var cache = result.cache;
						return result
					}

					function mergeData(data, source)
					{
						var bitmask = data[1],
							srcBitmask = source[1],
							newBitmask = bitmask | srcBitmask,
							isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
						var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
						if (!(isCommon || isCombo)) return data;
						if (srcBitmask & WRAP_BIND_FLAG)
						{
							data[2] = source[2];
							newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG
						}
						var value = source[3];
						if (value)
						{
							var partials = data[3];
							data[3] = partials ? composeArgs(partials, value, source[4]) : value;
							data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]
						}
						value = source[5];
						if (value)
						{
							partials = data[5];
							data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
							data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]
						}
						value = source[7];
						value && (data[7] = value);
						srcBitmask & WRAP_ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8]));
						null == data[9] && (data[9] = source[9]);
						data[0] = source[0];
						data[1] = newBitmask;
						return data
					}

					function nativeKeysIn(object)
					{
						var result = [];
						if (null != object)
							for (var key in Object(object)) result.push(key);
						return result
					}

					function objectToString(value)
					{
						return nativeObjectToString.call(value)
					}

					function overRest(func, start, transform)
					{
						start = nativeMax(start === undefined ? func.length - 1 : start, 0);
						return function ()
						{
							var args = arguments,
								index = -1,
								length = nativeMax(args.length - start, 0),
								array = Array(length);
							while (++index < length) array[index] = args[start + index];
							index = -1;
							var otherArgs = Array(start + 1);
							while (++index < start) otherArgs[index] = args[index];
							otherArgs[start] = transform(array);
							return apply(func, this, otherArgs)
						}
					}

					function parent(object, path)
					{
						return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1))
					}

					function reorder(array, indexes)
					{
						var arrLength = array.length,
							length = nativeMin(indexes.length, arrLength),
							oldArray = copyArray(array);
						while (length--)
						{
							var index = indexes[length];
							array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
						}
						return array
					}

					function safeGet(object, key)
					{
						if ("__proto__" == key) return;
						return object[key]
					}
					var setData = shortOut(baseSetData);
					var setTimeout = ctxSetTimeout || function (func, wait)
					{
						return root.setTimeout(func, wait)
					};
					var setToString = shortOut(baseSetToString);

					function setWrapToString(wrapper, reference, bitmask)
					{
						var source = reference + "";
						return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
					}

					function shortOut(func)
					{
						var count = 0,
							lastCalled = 0;
						return function ()
						{
							var stamp = nativeNow(),
								remaining = HOT_SPAN - (stamp - lastCalled);
							lastCalled = stamp;
							if (remaining > 0)
							{
								if (++count >= HOT_COUNT) return arguments[0]
							}
							else count = 0;
							return func.apply(undefined, arguments)
						}
					}

					function shuffleSelf(array, size)
					{
						var index = -1,
							length = array.length,
							lastIndex = length - 1;
						size = size === undefined ? length : size;
						while (++index < size)
						{
							var rand = baseRandom(index, lastIndex),
								value = array[rand];
							array[rand] = array[index];
							array[index] = value
						}
						array.length = size;
						return array
					}
					var stringToPath = memoizeCapped(function (string)
					{
						var result = [];
						46 === string.charCodeAt(0) && result.push("");
						string.replace(rePropName, function (match, number, quote, subString)
						{
							result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match)
						});
						return result
					});

					function toKey(value)
					{
						if ("string" == typeof value || isSymbol(value)) return value;
						var result = value + "";
						return "0" == result && 1 / value == -INFINITY ? "-0" : result
					}

					function toSource(func)
					{
						if (null != func)
						{
							try
							{
								return funcToString.call(func)
							}
							catch (e)
							{}
							try
							{
								return func + ""
							}
							catch (e)
							{}
						}
						return ""
					}

					function updateWrapDetails(details, bitmask)
					{
						arrayEach(wrapFlags, function (pair)
						{
							var value = "_." + pair[0];
							bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value)
						});
						return details.sort()
					}

					function wrapperClone(wrapper)
					{
						if (wrapper instanceof LazyWrapper) return wrapper.clone();
						var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
						result.__actions__ = copyArray(wrapper.__actions__);
						result.__index__ = wrapper.__index__;
						result.__values__ = wrapper.__values__;
						return result
					}

					function chunk(array, size, guard)
					{
						size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
						var length = null == array ? 0 : array.length;
						if (!length || size < 1) return [];
						var index = 0,
							resIndex = 0,
							result = Array(nativeCeil(length / size));
						while (index < length) result[resIndex++] = baseSlice(array, index, index += size);
						return result
					}

					function compact(array)
					{
						var index = -1,
							length = null == array ? 0 : array.length,
							resIndex = 0,
							result = [];
						while (++index < length)
						{
							var value = array[index];
							value && (result[resIndex++] = value)
						}
						return result
					}

					function concat()
					{
						var length = arguments.length;
						if (!length) return [];
						var args = Array(length - 1),
							array = arguments[0],
							index = length;
						while (index--) args[index - 1] = arguments[index];
						return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1))
					}
					var difference = baseRest(function (array, values)
					{
						return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []
					});
					var differenceBy = baseRest(function (array, values)
					{
						var iteratee = last(values);
						isArrayLikeObject(iteratee) && (iteratee = undefined);
						return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : []
					});
					var differenceWith = baseRest(function (array, values)
					{
						var comparator = last(values);
						isArrayLikeObject(comparator) && (comparator = undefined);
						return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : []
					});

					function drop(array, n, guard)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return [];
						n = guard || n === undefined ? 1 : toInteger(n);
						return baseSlice(array, n < 0 ? 0 : n, length)
					}

					function dropRight(array, n, guard)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return [];
						n = guard || n === undefined ? 1 : toInteger(n);
						n = length - n;
						return baseSlice(array, 0, n < 0 ? 0 : n)
					}

					function dropRightWhile(array, predicate)
					{
						return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : []
					}

					function dropWhile(array, predicate)
					{
						return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : []
					}

					function fill(array, value, start, end)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return [];
						if (start && "number" != typeof start && isIterateeCall(array, value, start))
						{
							start = 0;
							end = length
						}
						return baseFill(array, value, start, end)
					}

					function findIndex(array, predicate, fromIndex)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return -1;
						var index = null == fromIndex ? 0 : toInteger(fromIndex);
						index < 0 && (index = nativeMax(length + index, 0));
						return baseFindIndex(array, getIteratee(predicate, 3), index)
					}

					function findLastIndex(array, predicate, fromIndex)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return -1;
						var index = length - 1;
						if (fromIndex !== undefined)
						{
							index = toInteger(fromIndex);
							index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)
						}
						return baseFindIndex(array, getIteratee(predicate, 3), index, true)
					}

					function flatten(array)
					{
						var length = null == array ? 0 : array.length;
						return length ? baseFlatten(array, 1) : []
					}

					function flattenDeep(array)
					{
						var length = null == array ? 0 : array.length;
						return length ? baseFlatten(array, INFINITY) : []
					}

					function flattenDepth(array, depth)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return [];
						depth = depth === undefined ? 1 : toInteger(depth);
						return baseFlatten(array, depth)
					}

					function fromPairs(pairs)
					{
						var index = -1,
							length = null == pairs ? 0 : pairs.length,
							result = {};
						while (++index < length)
						{
							var pair = pairs[index];
							result[pair[0]] = pair[1]
						}
						return result
					}

					function head(array)
					{
						return array && array.length ? array[0] : undefined
					}

					function indexOf(array, value, fromIndex)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return -1;
						var index = null == fromIndex ? 0 : toInteger(fromIndex);
						index < 0 && (index = nativeMax(length + index, 0));
						return baseIndexOf(array, value, index)
					}

					function initial(array)
					{
						var length = null == array ? 0 : array.length;
						return length ? baseSlice(array, 0, -1) : []
					}
					var intersection = baseRest(function (arrays)
					{
						var mapped = arrayMap(arrays, castArrayLikeObject);
						return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : []
					});
					var intersectionBy = baseRest(function (arrays)
					{
						var iteratee = last(arrays),
							mapped = arrayMap(arrays, castArrayLikeObject);
						iteratee === last(mapped) ? iteratee = undefined : mapped.pop();
						return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : []
					});
					var intersectionWith = baseRest(function (arrays)
					{
						var comparator = last(arrays),
							mapped = arrayMap(arrays, castArrayLikeObject);
						comparator = "function" == typeof comparator ? comparator : undefined;
						comparator && mapped.pop();
						return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : []
					});

					function join(array, separator)
					{
						return null == array ? "" : nativeJoin.call(array, separator)
					}

					function last(array)
					{
						var length = null == array ? 0 : array.length;
						return length ? array[length - 1] : undefined
					}

					function lastIndexOf(array, value, fromIndex)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return -1;
						var index = length;
						if (fromIndex !== undefined)
						{
							index = toInteger(fromIndex);
							index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)
						}
						return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true)
					}

					function nth(array, n)
					{
						return array && array.length ? baseNth(array, toInteger(n)) : undefined
					}
					var pull = baseRest(pullAll);

					function pullAll(array, values)
					{
						return array && array.length && values && values.length ? basePullAll(array, values) : array
					}

					function pullAllBy(array, values, iteratee)
					{
						return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array
					}

					function pullAllWith(array, values, comparator)
					{
						return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array
					}
					var pullAt = flatRest(function (array, indexes)
					{
						var length = null == array ? 0 : array.length,
							result = baseAt(array, indexes);
						basePullAt(array, arrayMap(indexes, function (index)
						{
							return isIndex(index, length) ? +index : index
						}).sort(compareAscending));
						return result
					});

					function remove(array, predicate)
					{
						var result = [];
						if (!(array && array.length)) return result;
						var index = -1,
							indexes = [],
							length = array.length;
						predicate = getIteratee(predicate, 3);
						while (++index < length)
						{
							var value = array[index];
							if (predicate(value, index, array))
							{
								result.push(value);
								indexes.push(index)
							}
						}
						basePullAt(array, indexes);
						return result
					}

					function reverse(array)
					{
						return null == array ? array : nativeReverse.call(array)
					}

					function slice(array, start, end)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return [];
						if (end && "number" != typeof end && isIterateeCall(array, start, end))
						{
							start = 0;
							end = length
						}
						else
						{
							start = null == start ? 0 : toInteger(start);
							end = end === undefined ? length : toInteger(end)
						}
						return baseSlice(array, start, end)
					}

					function sortedIndex(array, value)
					{
						return baseSortedIndex(array, value)
					}

					function sortedIndexBy(array, value, iteratee)
					{
						return baseSortedIndexBy(array, value, getIteratee(iteratee, 2))
					}

					function sortedIndexOf(array, value)
					{
						var length = null == array ? 0 : array.length;
						if (length)
						{
							var index = baseSortedIndex(array, value);
							if (index < length && eq(array[index], value)) return index
						}
						return -1
					}

					function sortedLastIndex(array, value)
					{
						return baseSortedIndex(array, value, true)
					}

					function sortedLastIndexBy(array, value, iteratee)
					{
						return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true)
					}

					function sortedLastIndexOf(array, value)
					{
						var length = null == array ? 0 : array.length;
						if (length)
						{
							var index = baseSortedIndex(array, value, true) - 1;
							if (eq(array[index], value)) return index
						}
						return -1
					}

					function sortedUniq(array)
					{
						return array && array.length ? baseSortedUniq(array) : []
					}

					function sortedUniqBy(array, iteratee)
					{
						return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : []
					}

					function tail(array)
					{
						var length = null == array ? 0 : array.length;
						return length ? baseSlice(array, 1, length) : []
					}

					function take(array, n, guard)
					{
						if (!(array && array.length)) return [];
						n = guard || n === undefined ? 1 : toInteger(n);
						return baseSlice(array, 0, n < 0 ? 0 : n)
					}

					function takeRight(array, n, guard)
					{
						var length = null == array ? 0 : array.length;
						if (!length) return [];
						n = guard || n === undefined ? 1 : toInteger(n);
						n = length - n;
						return baseSlice(array, n < 0 ? 0 : n, length)
					}

					function takeRightWhile(array, predicate)
					{
						return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : []
					}

					function takeWhile(array, predicate)
					{
						return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : []
					}
					var union = baseRest(function (arrays)
					{
						return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true))
					});
					var unionBy = baseRest(function (arrays)
					{
						var iteratee = last(arrays);
						isArrayLikeObject(iteratee) && (iteratee = undefined);
						return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
					});
					var unionWith = baseRest(function (arrays)
					{
						var comparator = last(arrays);
						comparator = "function" == typeof comparator ? comparator : undefined;
						return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator)
					});

					function uniq(array)
					{
						return array && array.length ? baseUniq(array) : []
					}

					function uniqBy(array, iteratee)
					{
						return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : []
					}

					function uniqWith(array, comparator)
					{
						comparator = "function" == typeof comparator ? comparator : undefined;
						return array && array.length ? baseUniq(array, undefined, comparator) : []
					}

					function unzip(array)
					{
						if (!(array && array.length)) return [];
						var length = 0;
						array = arrayFilter(array, function (group)
						{
							if (isArrayLikeObject(group))
							{
								length = nativeMax(group.length, length);
								return true
							}
						});
						return baseTimes(length, function (index)
						{
							return arrayMap(array, baseProperty(index))
						})
					}

					function unzipWith(array, iteratee)
					{
						if (!(array && array.length)) return [];
						var result = unzip(array);
						if (null == iteratee) return result;
						return arrayMap(result, function (group)
						{
							return apply(iteratee, undefined, group)
						})
					}
					var without = baseRest(function (array, values)
					{
						return isArrayLikeObject(array) ? baseDifference(array, values) : []
					});
					var xor = baseRest(function (arrays)
					{
						return baseXor(arrayFilter(arrays, isArrayLikeObject))
					});
					var xorBy = baseRest(function (arrays)
					{
						var iteratee = last(arrays);
						isArrayLikeObject(iteratee) && (iteratee = undefined);
						return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2))
					});
					var xorWith = baseRest(function (arrays)
					{
						var comparator = last(arrays);
						comparator = "function" == typeof comparator ? comparator : undefined;
						return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator)
					});
					var zip = baseRest(unzip);

					function zipObject(props, values)
					{
						return baseZipObject(props || [], values || [], assignValue)
					}

					function zipObjectDeep(props, values)
					{
						return baseZipObject(props || [], values || [], baseSet)
					}
					var zipWith = baseRest(function (arrays)
					{
						var length = arrays.length,
							iteratee = length > 1 ? arrays[length - 1] : undefined;
						iteratee = "function" == typeof iteratee ? (arrays.pop(), iteratee) : undefined;
						return unzipWith(arrays, iteratee)
					});

					function chain(value)
					{
						var result = lodash(value);
						result.__chain__ = true;
						return result
					}

					function tap(value, interceptor)
					{
						interceptor(value);
						return value
					}

					function thru(value, interceptor)
					{
						return interceptor(value)
					}
					var wrapperAt = flatRest(function (paths)
					{
						var length = paths.length,
							start = length ? paths[0] : 0,
							value = this.__wrapped__,
							interceptor = function (object)
							{
								return baseAt(object, paths)
							};
						if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) return this.thru(interceptor);
						value = value.slice(start, +start + (length ? 1 : 0));
						value.__actions__.push(
						{
							func: thru,
							args: [interceptor],
							thisArg: undefined
						});
						return new LodashWrapper(value, this.__chain__).thru(function (array)
						{
							length && !array.length && array.push(undefined);
							return array
						})
					});

					function wrapperChain()
					{
						return chain(this)
					}

					function wrapperCommit()
					{
						return new LodashWrapper(this.value(), this.__chain__)
					}

					function wrapperNext()
					{
						this.__values__ === undefined && (this.__values__ = toArray(this.value()));
						var done = this.__index__ >= this.__values__.length,
							value = done ? undefined : this.__values__[this.__index__++];
						return {
							done: done,
							value: value
						}
					}

					function wrapperToIterator()
					{
						return this
					}

					function wrapperPlant(value)
					{
						var result, parent = this;
						while (parent instanceof baseLodash)
						{
							var clone = wrapperClone(parent);
							clone.__index__ = 0;
							clone.__values__ = undefined;
							result ? previous.__wrapped__ = clone : result = clone;
							var previous = clone;
							parent = parent.__wrapped__
						}
						previous.__wrapped__ = value;
						return result
					}

					function wrapperReverse()
					{
						var value = this.__wrapped__;
						if (value instanceof LazyWrapper)
						{
							var wrapped = value;
							this.__actions__.length && (wrapped = new LazyWrapper(this));
							wrapped = wrapped.reverse();
							wrapped.__actions__.push(
							{
								func: thru,
								args: [reverse],
								thisArg: undefined
							});
							return new LodashWrapper(wrapped, this.__chain__)
						}
						return this.thru(reverse)
					}

					function wrapperValue()
					{
						return baseWrapperValue(this.__wrapped__, this.__actions__)
					}
					var countBy = createAggregator(function (result, value, key)
					{
						hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1)
					});

					function every(collection, predicate, guard)
					{
						var func = isArray(collection) ? arrayEvery : baseEvery;
						guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined);
						return func(collection, getIteratee(predicate, 3))
					}

					function filter(collection, predicate)
					{
						var func = isArray(collection) ? arrayFilter : baseFilter;
						return func(collection, getIteratee(predicate, 3))
					}
					var find = createFind(findIndex);
					var findLast = createFind(findLastIndex);

					function flatMap(collection, iteratee)
					{
						return baseFlatten(map(collection, iteratee), 1)
					}

					function flatMapDeep(collection, iteratee)
					{
						return baseFlatten(map(collection, iteratee), INFINITY)
					}

					function flatMapDepth(collection, iteratee, depth)
					{
						depth = depth === undefined ? 1 : toInteger(depth);
						return baseFlatten(map(collection, iteratee), depth)
					}

					function forEach(collection, iteratee)
					{
						var func = isArray(collection) ? arrayEach : baseEach;
						return func(collection, getIteratee(iteratee, 3))
					}

					function forEachRight(collection, iteratee)
					{
						var func = isArray(collection) ? arrayEachRight : baseEachRight;
						return func(collection, getIteratee(iteratee, 3))
					}
					var groupBy = createAggregator(function (result, value, key)
					{
						hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [value])
					});

					function includes(collection, value, fromIndex, guard)
					{
						collection = isArrayLike(collection) ? collection : values(collection);
						fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
						var length = collection.length;
						fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0));
						return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1
					}
					var invokeMap = baseRest(function (collection, path, args)
					{
						var index = -1,
							isFunc = "function" == typeof path,
							result = isArrayLike(collection) ? Array(collection.length) : [];
						baseEach(collection, function (value)
						{
							result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args)
						});
						return result
					});
					var keyBy = createAggregator(function (result, value, key)
					{
						baseAssignValue(result, key, value)
					});

					function map(collection, iteratee)
					{
						var func = isArray(collection) ? arrayMap : baseMap;
						return func(collection, getIteratee(iteratee, 3))
					}

					function orderBy(collection, iteratees, orders, guard)
					{
						if (null == collection) return [];
						isArray(iteratees) || (iteratees = null == iteratees ? [] : [iteratees]);
						orders = guard ? undefined : orders;
						isArray(orders) || (orders = null == orders ? [] : [orders]);
						return baseOrderBy(collection, iteratees, orders)
					}
					var partition = createAggregator(function (result, value, key)
					{
						result[key ? 0 : 1].push(value)
					}, function ()
					{
						return [
							[],
							[]
						]
					});

					function reduce(collection, iteratee, accumulator)
					{
						var func = isArray(collection) ? arrayReduce : baseReduce,
							initAccum = arguments.length < 3;
						return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach)
					}

					function reduceRight(collection, iteratee, accumulator)
					{
						var func = isArray(collection) ? arrayReduceRight : baseReduce,
							initAccum = arguments.length < 3;
						return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight)
					}

					function reject(collection, predicate)
					{
						var func = isArray(collection) ? arrayFilter : baseFilter;
						return func(collection, negate(getIteratee(predicate, 3)))
					}

					function sample(collection)
					{
						var func = isArray(collection) ? arraySample : baseSample;
						return func(collection)
					}

					function sampleSize(collection, n, guard)
					{
						n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : toInteger(n);
						var func = isArray(collection) ? arraySampleSize : baseSampleSize;
						return func(collection, n)
					}

					function shuffle(collection)
					{
						var func = isArray(collection) ? arrayShuffle : baseShuffle;
						return func(collection)
					}

					function size(collection)
					{
						if (null == collection) return 0;
						if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
						var tag = getTag(collection);
						if (tag == mapTag || tag == setTag) return collection.size;
						return baseKeys(collection).length
					}

					function some(collection, predicate, guard)
					{
						var func = isArray(collection) ? arraySome : baseSome;
						guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined);
						return func(collection, getIteratee(predicate, 3))
					}
					var sortBy = baseRest(function (collection, iteratees)
					{
						if (null == collection) return [];
						var length = iteratees.length;
						length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]);
						return baseOrderBy(collection, baseFlatten(iteratees, 1), [])
					});
					var now = ctxNow || function ()
					{
						return root.Date.now()
					};

					function after(n, func)
					{
						if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
						n = toInteger(n);
						return function ()
						{
							if (--n < 1) return func.apply(this, arguments)
						}
					}

					function ary(func, n, guard)
					{
						n = guard ? undefined : n;
						n = func && null == n ? func.length : n;
						return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n)
					}

					function before(n, func)
					{
						var result;
						if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
						n = toInteger(n);
						return function ()
						{
							--n > 0 && (result = func.apply(this, arguments));
							n <= 1 && (func = undefined);
							return result
						}
					}
					var bind = baseRest(function (func, thisArg, partials)
					{
						var bitmask = WRAP_BIND_FLAG;
						if (partials.length)
						{
							var holders = replaceHolders(partials, getHolder(bind));
							bitmask |= WRAP_PARTIAL_FLAG
						}
						return createWrap(func, bitmask, thisArg, partials, holders)
					});
					var bindKey = baseRest(function (object, key, partials)
					{
						var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
						if (partials.length)
						{
							var holders = replaceHolders(partials, getHolder(bindKey));
							bitmask |= WRAP_PARTIAL_FLAG
						}
						return createWrap(key, bitmask, object, partials, holders)
					});

					function curry(func, arity, guard)
					{
						arity = guard ? undefined : arity;
						var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
						result.placeholder = curry.placeholder;
						return result
					}

					function curryRight(func, arity, guard)
					{
						arity = guard ? undefined : arity;
						var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
						result.placeholder = curryRight.placeholder;
						return result
					}

					function debounce(func, wait, options)
					{
						var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0,
							leading = false,
							maxing = false,
							trailing = true;
						if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
						wait = toNumber(wait) || 0;
						if (isObject(options))
						{
							leading = !!options.leading;
							maxing = "maxWait" in options;
							maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
							trailing = "trailing" in options ? !!options.trailing : trailing
						}

						function invokeFunc(time)
						{
							var args = lastArgs,
								thisArg = lastThis;
							lastArgs = lastThis = undefined;
							lastInvokeTime = time;
							result = func.apply(thisArg, args);
							return result
						}

						function leadingEdge(time)
						{
							lastInvokeTime = time;
							timerId = setTimeout(timerExpired, wait);
							return leading ? invokeFunc(time) : result
						}

						function remainingWait(time)
						{
							var timeSinceLastCall = time - lastCallTime,
								timeSinceLastInvoke = time - lastInvokeTime,
								timeWaiting = wait - timeSinceLastCall;
							return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting
						}

						function shouldInvoke(time)
						{
							var timeSinceLastCall = time - lastCallTime,
								timeSinceLastInvoke = time - lastInvokeTime;
							return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait
						}

						function timerExpired()
						{
							var time = now();
							if (shouldInvoke(time)) return trailingEdge(time);
							timerId = setTimeout(timerExpired, remainingWait(time))
						}

						function trailingEdge(time)
						{
							timerId = undefined;
							if (trailing && lastArgs) return invokeFunc(time);
							lastArgs = lastThis = undefined;
							return result
						}

						function cancel()
						{
							timerId !== undefined && clearTimeout(timerId);
							lastInvokeTime = 0;
							lastArgs = lastCallTime = lastThis = timerId = undefined
						}

						function flush()
						{
							return timerId === undefined ? result : trailingEdge(now())
						}

						function debounced()
						{
							var time = now(),
								isInvoking = shouldInvoke(time);
							lastArgs = arguments;
							lastThis = this;
							lastCallTime = time;
							if (isInvoking)
							{
								if (timerId === undefined) return leadingEdge(lastCallTime);
								if (maxing)
								{
									timerId = setTimeout(timerExpired, wait);
									return invokeFunc(lastCallTime)
								}
							}
							timerId === undefined && (timerId = setTimeout(timerExpired, wait));
							return result
						}
						debounced.cancel = cancel;
						debounced.flush = flush;
						return debounced
					}
					var defer = baseRest(function (func, args)
					{
						return baseDelay(func, 1, args)
					});
					var delay = baseRest(function (func, wait, args)
					{
						return baseDelay(func, toNumber(wait) || 0, args)
					});

					function flip(func)
					{
						return createWrap(func, WRAP_FLIP_FLAG)
					}

					function memoize(func, resolver)
					{
						if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT);
						var memoized = function ()
						{
							var args = arguments,
								key = resolver ? resolver.apply(this, args) : args[0],
								cache = memoized.cache;
							if (cache.has(key)) return cache.get(key);
							var result = func.apply(this, args);
							memoized.cache = cache.set(key, result) || cache;
							return result
						};
						memoized.cache = new(memoize.Cache || MapCache);
						return memoized
					}
					memoize.Cache = MapCache;

					function negate(predicate)
					{
						if ("function" != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT);
						return function ()
						{
							var args = arguments;
							switch (args.length)
							{
							case 0:
								return !predicate.call(this);
							case 1:
								return !predicate.call(this, args[0]);
							case 2:
								return !predicate.call(this, args[0], args[1]);
							case 3:
								return !predicate.call(this, args[0], args[1], args[2])
							}
							return !predicate.apply(this, args)
						}
					}

					function once(func)
					{
						return before(2, func)
					}
					var overArgs = castRest(function (func, transforms)
					{
						transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
						var funcsLength = transforms.length;
						return baseRest(function (args)
						{
							var index = -1,
								length = nativeMin(args.length, funcsLength);
							while (++index < length) args[index] = transforms[index].call(this, args[index]);
							return apply(func, this, args)
						})
					});
					var partial = baseRest(function (func, partials)
					{
						var holders = replaceHolders(partials, getHolder(partial));
						return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders)
					});
					var partialRight = baseRest(function (func, partials)
					{
						var holders = replaceHolders(partials, getHolder(partialRight));
						return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders)
					});
					var rearg = flatRest(function (func, indexes)
					{
						return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes)
					});

					function rest(func, start)
					{
						if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
						start = start === undefined ? start : toInteger(start);
						return baseRest(func, start)
					}

					function spread(func, start)
					{
						if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
						start = null == start ? 0 : nativeMax(toInteger(start), 0);
						return baseRest(function (args)
						{
							var array = args[start],
								otherArgs = castSlice(args, 0, start);
							array && arrayPush(otherArgs, array);
							return apply(func, this, otherArgs)
						})
					}

					function throttle(func, wait, options)
					{
						var leading = true,
							trailing = true;
						if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
						if (isObject(options))
						{
							leading = "leading" in options ? !!options.leading : leading;
							trailing = "trailing" in options ? !!options.trailing : trailing
						}
						return debounce(func, wait,
						{
							leading: leading,
							maxWait: wait,
							trailing: trailing
						})
					}

					function unary(func)
					{
						return ary(func, 1)
					}

					function wrap(value, wrapper)
					{
						return partial(castFunction(wrapper), value)
					}

					function castArray()
					{
						if (!arguments.length) return [];
						var value = arguments[0];
						return isArray(value) ? value : [value]
					}

					function clone(value)
					{
						return baseClone(value, CLONE_SYMBOLS_FLAG)
					}

					function cloneWith(value, customizer)
					{
						customizer = "function" == typeof customizer ? customizer : undefined;
						return baseClone(value, CLONE_SYMBOLS_FLAG, customizer)
					}

					function cloneDeep(value)
					{
						return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
					}

					function cloneDeepWith(value, customizer)
					{
						customizer = "function" == typeof customizer ? customizer : undefined;
						return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer)
					}

					function conformsTo(object, source)
					{
						return null == source || baseConformsTo(object, source, keys(source))
					}

					function eq(value, other)
					{
						return value === other || value !== value && other !== other
					}
					var gt = createRelationalOperation(baseGt);
					var gte = createRelationalOperation(function (value, other)
					{
						return value >= other
					});
					var isArguments = baseIsArguments(function ()
					{
						return arguments
					}()) ? baseIsArguments : function (value)
					{
						return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee")
					};
					var isArray = Array.isArray;
					var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

					function isArrayLike(value)
					{
						return null != value && isLength(value.length) && !isFunction(value)
					}

					function isArrayLikeObject(value)
					{
						return isObjectLike(value) && isArrayLike(value)
					}

					function isBoolean(value)
					{
						return true === value || false === value || isObjectLike(value) && baseGetTag(value) == boolTag
					}
					var isBuffer = nativeIsBuffer || stubFalse;
					var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

					function isElement(value)
					{
						return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value)
					}

					function isEmpty(value)
					{
						if (null == value) return true;
						if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
						var tag = getTag(value);
						if (tag == mapTag || tag == setTag) return !value.size;
						if (isPrototype(value)) return !baseKeys(value).length;
						for (var key in value)
							if (hasOwnProperty.call(value, key)) return false;
						return true
					}

					function isEqual(value, other)
					{
						return baseIsEqual(value, other)
					}

					function isEqualWith(value, other, customizer)
					{
						customizer = "function" == typeof customizer ? customizer : undefined;
						var result = customizer ? customizer(value, other) : undefined;
						return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result
					}

					function isError(value)
					{
						if (!isObjectLike(value)) return false;
						var tag = baseGetTag(value);
						return tag == errorTag || tag == domExcTag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value)
					}

					function isFinite(value)
					{
						return "number" == typeof value && nativeIsFinite(value)
					}

					function isFunction(value)
					{
						if (!isObject(value)) return false;
						var tag = baseGetTag(value);
						return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
					}

					function isInteger(value)
					{
						return "number" == typeof value && value == toInteger(value)
					}

					function isLength(value)
					{
						return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
					}

					function isObject(value)
					{
						var type = typeof value;
						return null != value && ("object" == type || "function" == type)
					}

					function isObjectLike(value)
					{
						return null != value && "object" == typeof value
					}
					var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

					function isMatch(object, source)
					{
						return object === source || baseIsMatch(object, source, getMatchData(source))
					}

					function isMatchWith(object, source, customizer)
					{
						customizer = "function" == typeof customizer ? customizer : undefined;
						return baseIsMatch(object, source, getMatchData(source), customizer)
					}

					function isNaN(value)
					{
						return isNumber(value) && value != +value
					}

					function isNative(value)
					{
						if (isMaskable(value)) throw new Error(CORE_ERROR_TEXT);
						return baseIsNative(value)
					}

					function isNull(value)
					{
						return null === value
					}

					function isNil(value)
					{
						return null == value
					}

					function isNumber(value)
					{
						return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag
					}

					function isPlainObject(value)
					{
						if (!isObjectLike(value) || baseGetTag(value) != objectTag) return false;
						var proto = getPrototype(value);
						if (null === proto) return true;
						var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
						return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
					}
					var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

					function isSafeInteger(value)
					{
						return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER
					}
					var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

					function isString(value)
					{
						return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag
					}

					function isSymbol(value)
					{
						return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag
					}
					var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

					function isUndefined(value)
					{
						return value === undefined
					}

					function isWeakMap(value)
					{
						return isObjectLike(value) && getTag(value) == weakMapTag
					}

					function isWeakSet(value)
					{
						return isObjectLike(value) && baseGetTag(value) == weakSetTag
					}
					var lt = createRelationalOperation(baseLt);
					var lte = createRelationalOperation(function (value, other)
					{
						return value <= other
					});

					function toArray(value)
					{
						if (!value) return [];
						if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
						if (symIterator && value[symIterator]) return iteratorToArray(value[symIterator]());
						var tag = getTag(value),
							func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
						return func(value)
					}

					function toFinite(value)
					{
						if (!value) return 0 === value ? value : 0;
						value = toNumber(value);
						if (value === INFINITY || value === -INFINITY)
						{
							var sign = value < 0 ? -1 : 1;
							return sign * MAX_INTEGER
						}
						return value === value ? value : 0
					}

					function toInteger(value)
					{
						var result = toFinite(value),
							remainder = result % 1;
						return result === result ? remainder ? result - remainder : result : 0
					}

					function toLength(value)
					{
						return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
					}

					function toNumber(value)
					{
						if ("number" == typeof value) return value;
						if (isSymbol(value)) return NAN;
						if (isObject(value))
						{
							var other = "function" == typeof value.valueOf ? value.valueOf() : value;
							value = isObject(other) ? other + "" : other
						}
						if ("string" != typeof value) return 0 === value ? value : +value;
						value = value.replace(reTrim, "");
						var isBinary = reIsBinary.test(value);
						return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value
					}

					function toPlainObject(value)
					{
						return copyObject(value, keysIn(value))
					}

					function toSafeInteger(value)
					{
						return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : 0 === value ? value : 0
					}

					function toString(value)
					{
						return null == value ? "" : baseToString(value)
					}
					var assign = createAssigner(function (object, source)
					{
						if (isPrototype(source) || isArrayLike(source))
						{
							copyObject(source, keys(source), object);
							return
						}
						for (var key in source) hasOwnProperty.call(source, key) && assignValue(object, key, source[key])
					});
					var assignIn = createAssigner(function (object, source)
					{
						copyObject(source, keysIn(source), object)
					});
					var assignInWith = createAssigner(function (object, source, srcIndex, customizer)
					{
						copyObject(source, keysIn(source), object, customizer)
					});
					var assignWith = createAssigner(function (object, source, srcIndex, customizer)
					{
						copyObject(source, keys(source), object, customizer)
					});
					var at = flatRest(baseAt);

					function create(prototype, properties)
					{
						var result = baseCreate(prototype);
						return null == properties ? result : baseAssign(result, properties)
					}
					var defaults = baseRest(function (object, sources)
					{
						object = Object(object);
						var index = -1;
						var length = sources.length;
						var guard = length > 2 ? sources[2] : undefined;
						guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1);
						while (++index < length)
						{
							var source = sources[index];
							var props = keysIn(source);
							var propsIndex = -1;
							var propsLength = props.length;
							while (++propsIndex < propsLength)
							{
								var key = props[propsIndex];
								var value = object[key];
								(value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) && (object[key] = source[key])
							}
						}
						return object
					});
					var defaultsDeep = baseRest(function (args)
					{
						args.push(undefined, customDefaultsMerge);
						return apply(mergeWith, undefined, args)
					});

					function findKey(object, predicate)
					{
						return baseFindKey(object, getIteratee(predicate, 3), baseForOwn)
					}

					function findLastKey(object, predicate)
					{
						return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight)
					}

					function forIn(object, iteratee)
					{
						return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn)
					}

					function forInRight(object, iteratee)
					{
						return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn)
					}

					function forOwn(object, iteratee)
					{
						return object && baseForOwn(object, getIteratee(iteratee, 3))
					}

					function forOwnRight(object, iteratee)
					{
						return object && baseForOwnRight(object, getIteratee(iteratee, 3))
					}

					function functions(object)
					{
						return null == object ? [] : baseFunctions(object, keys(object))
					}

					function functionsIn(object)
					{
						return null == object ? [] : baseFunctions(object, keysIn(object))
					}

					function get(object, path, defaultValue)
					{
						var result = null == object ? undefined : baseGet(object, path);
						return result === undefined ? defaultValue : result
					}

					function has(object, path)
					{
						return null != object && hasPath(object, path, baseHas)
					}

					function hasIn(object, path)
					{
						return null != object && hasPath(object, path, baseHasIn)
					}
					var invert = createInverter(function (result, value, key)
					{
						null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value));
						result[value] = key
					}, constant(identity));
					var invertBy = createInverter(function (result, value, key)
					{
						null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value));
						hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [key]
					}, getIteratee);
					var invoke = baseRest(baseInvoke);

					function keys(object)
					{
						return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
					}

					function keysIn(object)
					{
						return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object)
					}

					function mapKeys(object, iteratee)
					{
						var result = {};
						iteratee = getIteratee(iteratee, 3);
						baseForOwn(object, function (value, key, object)
						{
							baseAssignValue(result, iteratee(value, key, object), value)
						});
						return result
					}

					function mapValues(object, iteratee)
					{
						var result = {};
						iteratee = getIteratee(iteratee, 3);
						baseForOwn(object, function (value, key, object)
						{
							baseAssignValue(result, key, iteratee(value, key, object))
						});
						return result
					}
					var merge = createAssigner(function (object, source, srcIndex)
					{
						baseMerge(object, source, srcIndex)
					});
					var mergeWith = createAssigner(function (object, source, srcIndex, customizer)
					{
						baseMerge(object, source, srcIndex, customizer)
					});
					var omit = flatRest(function (object, paths)
					{
						var result = {};
						if (null == object) return result;
						var isDeep = false;
						paths = arrayMap(paths, function (path)
						{
							path = castPath(path, object);
							isDeep || (isDeep = path.length > 1);
							return path
						});
						copyObject(object, getAllKeysIn(object), result);
						isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
						var length = paths.length;
						while (length--) baseUnset(result, paths[length]);
						return result
					});

					function omitBy(object, predicate)
					{
						return pickBy(object, negate(getIteratee(predicate)))
					}
					var pick = flatRest(function (object, paths)
					{
						return null == object ?
						{} : basePick(object, paths)
					});

					function pickBy(object, predicate)
					{
						if (null == object) return {};
						var props = arrayMap(getAllKeysIn(object), function (prop)
						{
							return [prop]
						});
						predicate = getIteratee(predicate);
						return basePickBy(object, props, function (value, path)
						{
							return predicate(value, path[0])
						})
					}

					function result(object, path, defaultValue)
					{
						path = castPath(path, object);
						var index = -1,
							length = path.length;
						if (!length)
						{
							length = 1;
							object = undefined
						}
						while (++index < length)
						{
							var value = null == object ? undefined : object[toKey(path[index])];
							if (value === undefined)
							{
								index = length;
								value = defaultValue
							}
							object = isFunction(value) ? value.call(object) : value
						}
						return object
					}

					function set(object, path, value)
					{
						return null == object ? object : baseSet(object, path, value)
					}

					function setWith(object, path, value, customizer)
					{
						customizer = "function" == typeof customizer ? customizer : undefined;
						return null == object ? object : baseSet(object, path, value, customizer)
					}
					var toPairs = createToPairs(keys);
					var toPairsIn = createToPairs(keysIn);

					function transform(object, iteratee, accumulator)
					{
						var isArr = isArray(object),
							isArrLike = isArr || isBuffer(object) || isTypedArray(object);
						iteratee = getIteratee(iteratee, 4);
						if (null == accumulator)
						{
							var Ctor = object && object.constructor;
							accumulator = isArrLike ? isArr ? new Ctor : [] : isObject(object) && isFunction(Ctor) ? baseCreate(getPrototype(object)) :
							{}
						}(isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object)
						{
							return iteratee(accumulator, value, index, object)
						});
						return accumulator
					}

					function unset(object, path)
					{
						return null == object || baseUnset(object, path)
					}

					function update(object, path, updater)
					{
						return null == object ? object : baseUpdate(object, path, castFunction(updater))
					}

					function updateWith(object, path, updater, customizer)
					{
						customizer = "function" == typeof customizer ? customizer : undefined;
						return null == object ? object : baseUpdate(object, path, castFunction(updater), customizer)
					}

					function values(object)
					{
						return null == object ? [] : baseValues(object, keys(object))
					}

					function valuesIn(object)
					{
						return null == object ? [] : baseValues(object, keysIn(object))
					}

					function clamp(number, lower, upper)
					{
						if (upper === undefined)
						{
							upper = lower;
							lower = undefined
						}
						if (upper !== undefined)
						{
							upper = toNumber(upper);
							upper = upper === upper ? upper : 0
						}
						if (lower !== undefined)
						{
							lower = toNumber(lower);
							lower = lower === lower ? lower : 0
						}
						return baseClamp(toNumber(number), lower, upper)
					}

					function inRange(number, start, end)
					{
						start = toFinite(start);
						if (end === undefined)
						{
							end = start;
							start = 0
						}
						else end = toFinite(end);
						number = toNumber(number);
						return baseInRange(number, start, end)
					}

					function random(lower, upper, floating)
					{
						floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined);
						if (floating === undefined)
							if ("boolean" == typeof upper)
							{
								floating = upper;
								upper = undefined
							}
						else if ("boolean" == typeof lower)
						{
							floating = lower;
							lower = undefined
						}
						if (lower === undefined && upper === undefined)
						{
							lower = 0;
							upper = 1
						}
						else
						{
							lower = toFinite(lower);
							if (upper === undefined)
							{
								upper = lower;
								lower = 0
							}
							else upper = toFinite(upper)
						}
						if (lower > upper)
						{
							var temp = lower;
							lower = upper;
							upper = temp
						}
						if (floating || lower % 1 || upper % 1)
						{
							var rand = nativeRandom();
							return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper)
						}
						return baseRandom(lower, upper)
					}
					var camelCase = createCompounder(function (result, word, index)
					{
						word = word.toLowerCase();
						return result + (index ? capitalize(word) : word)
					});

					function capitalize(string)
					{
						return upperFirst(toString(string).toLowerCase())
					}

					function deburr(string)
					{
						string = toString(string);
						return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "")
					}

					function endsWith(string, target, position)
					{
						string = toString(string);
						target = baseToString(target);
						var length = string.length;
						position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
						var end = position;
						position -= target.length;
						return position >= 0 && string.slice(position, end) == target
					}

					function escape(string)
					{
						string = toString(string);
						return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string
					}

					function escapeRegExp(string)
					{
						string = toString(string);
						return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string
					}
					var kebabCase = createCompounder(function (result, word, index)
					{
						return result + (index ? "-" : "") + word.toLowerCase()
					});
					var lowerCase = createCompounder(function (result, word, index)
					{
						return result + (index ? " " : "") + word.toLowerCase()
					});
					var lowerFirst = createCaseFirst("toLowerCase");

					function pad(string, length, chars)
					{
						string = toString(string);
						length = toInteger(length);
						var strLength = length ? stringSize(string) : 0;
						if (!length || strLength >= length) return string;
						var mid = (length - strLength) / 2;
						return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars)
					}

					function padEnd(string, length, chars)
					{
						string = toString(string);
						length = toInteger(length);
						var strLength = length ? stringSize(string) : 0;
						return length && strLength < length ? string + createPadding(length - strLength, chars) : string
					}

					function padStart(string, length, chars)
					{
						string = toString(string);
						length = toInteger(length);
						var strLength = length ? stringSize(string) : 0;
						return length && strLength < length ? createPadding(length - strLength, chars) + string : string
					}

					function parseInt(string, radix, guard)
					{
						guard || null == radix ? radix = 0 : radix && (radix = +radix);
						return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0)
					}

					function repeat(string, n, guard)
					{
						n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n);
						return baseRepeat(toString(string), n)
					}

					function replace()
					{
						var args = arguments,
							string = toString(args[0]);
						return args.length < 3 ? string : string.replace(args[1], args[2])
					}
					var snakeCase = createCompounder(function (result, word, index)
					{
						return result + (index ? "_" : "") + word.toLowerCase()
					});

					function split(string, separator, limit)
					{
						limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined);
						limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
						if (!limit) return [];
						string = toString(string);
						if (string && ("string" == typeof separator || null != separator && !isRegExp(separator)))
						{
							separator = baseToString(separator);
							if (!separator && hasUnicode(string)) return castSlice(stringToArray(string), 0, limit)
						}
						return string.split(separator, limit)
					}
					var startCase = createCompounder(function (result, word, index)
					{
						return result + (index ? " " : "") + upperFirst(word)
					});

					function startsWith(string, target, position)
					{
						string = toString(string);
						position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length);
						target = baseToString(target);
						return string.slice(position, position + target.length) == target
					}

					function template(string, options, guard)
					{
						var settings = lodash.templateSettings;
						guard && isIterateeCall(string, options, guard) && (options = undefined);
						string = toString(string);
						options = assignInWith(
						{}, options, settings, customDefaultsAssignIn);
						var imports = assignInWith(
							{}, options.imports, settings.imports, customDefaultsAssignIn),
							importsKeys = keys(imports),
							importsValues = baseValues(imports, importsKeys);
						var isEscaping, isEvaluating, index = 0,
							interpolate = options.interpolate || reNoMatch,
							source = "__p += '";
						var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
						var sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
						string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset)
						{
							interpolateValue || (interpolateValue = esTemplateValue);
							source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
							if (escapeValue)
							{
								isEscaping = true;
								source += "' +\n__e(" + escapeValue + ") +\n'"
							}
							if (evaluateValue)
							{
								isEvaluating = true;
								source += "';\n" + evaluateValue + ";\n__p += '"
							}
							interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'");
							index = offset + match.length;
							return match
						});
						source += "';\n";
						var variable = options.variable;
						variable || (source = "with (obj) {\n" + source + "\n}\n");
						source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
						source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
						var result = attempt(function ()
						{
							return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues)
						});
						result.source = source;
						if (isError(result)) throw result;
						return result
					}

					function toLower(value)
					{
						return toString(value).toLowerCase()
					}

					function toUpper(value)
					{
						return toString(value).toUpperCase()
					}

					function trim(string, chars, guard)
					{
						string = toString(string);
						if (string && (guard || chars === undefined)) return string.replace(reTrim, "");
						if (!string || !(chars = baseToString(chars))) return string;
						var strSymbols = stringToArray(string),
							chrSymbols = stringToArray(chars),
							start = charsStartIndex(strSymbols, chrSymbols),
							end = charsEndIndex(strSymbols, chrSymbols) + 1;
						return castSlice(strSymbols, start, end).join("")
					}

					function trimEnd(string, chars, guard)
					{
						string = toString(string);
						if (string && (guard || chars === undefined)) return string.replace(reTrimEnd, "");
						if (!string || !(chars = baseToString(chars))) return string;
						var strSymbols = stringToArray(string),
							end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
						return castSlice(strSymbols, 0, end).join("")
					}

					function trimStart(string, chars, guard)
					{
						string = toString(string);
						if (string && (guard || chars === undefined)) return string.replace(reTrimStart, "");
						if (!string || !(chars = baseToString(chars))) return string;
						var strSymbols = stringToArray(string),
							start = charsStartIndex(strSymbols, stringToArray(chars));
						return castSlice(strSymbols, start).join("")
					}

					function truncate(string, options)
					{
						var length = DEFAULT_TRUNC_LENGTH,
							omission = DEFAULT_TRUNC_OMISSION;
						if (isObject(options))
						{
							var separator = "separator" in options ? options.separator : separator;
							length = "length" in options ? toInteger(options.length) : length;
							omission = "omission" in options ? baseToString(options.omission) : omission
						}
						string = toString(string);
						var strLength = string.length;
						if (hasUnicode(string))
						{
							var strSymbols = stringToArray(string);
							strLength = strSymbols.length
						}
						if (length >= strLength) return string;
						var end = length - stringSize(omission);
						if (end < 1) return omission;
						var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
						if (separator === undefined) return result + omission;
						strSymbols && (end += result.length - end);
						if (isRegExp(separator))
						{
							if (string.slice(end).search(separator))
							{
								var match, substring = result;
								separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g"));
								separator.lastIndex = 0;
								while (match = separator.exec(substring)) var newEnd = match.index;
								result = result.slice(0, newEnd === undefined ? end : newEnd)
							}
						}
						else if (string.indexOf(baseToString(separator), end) != end)
						{
							var index = result.lastIndexOf(separator);
							index > -1 && (result = result.slice(0, index))
						}
						return result + omission
					}

					function unescape(string)
					{
						string = toString(string);
						return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string
					}
					var upperCase = createCompounder(function (result, word, index)
					{
						return result + (index ? " " : "") + word.toUpperCase()
					});
					var upperFirst = createCaseFirst("toUpperCase");

					function words(string, pattern, guard)
					{
						string = toString(string);
						pattern = guard ? undefined : pattern;
						if (pattern === undefined) return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
						return string.match(pattern) || []
					}
					var attempt = baseRest(function (func, args)
					{
						try
						{
							return apply(func, undefined, args)
						}
						catch (e)
						{
							return isError(e) ? e : new Error(e)
						}
					});
					var bindAll = flatRest(function (object, methodNames)
					{
						arrayEach(methodNames, function (key)
						{
							key = toKey(key);
							baseAssignValue(object, key, bind(object[key], object))
						});
						return object
					});

					function cond(pairs)
					{
						var length = null == pairs ? 0 : pairs.length,
							toIteratee = getIteratee();
						pairs = length ? arrayMap(pairs, function (pair)
						{
							if ("function" != typeof pair[1]) throw new TypeError(FUNC_ERROR_TEXT);
							return [toIteratee(pair[0]), pair[1]]
						}) : [];
						return baseRest(function (args)
						{
							var index = -1;
							while (++index < length)
							{
								var pair = pairs[index];
								if (apply(pair[0], this, args)) return apply(pair[1], this, args)
							}
						})
					}

					function conforms(source)
					{
						return baseConforms(baseClone(source, CLONE_DEEP_FLAG))
					}

					function constant(value)
					{
						return function ()
						{
							return value
						}
					}

					function defaultTo(value, defaultValue)
					{
						return null == value || value !== value ? defaultValue : value
					}
					var flow = createFlow();
					var flowRight = createFlow(true);

					function identity(value)
					{
						return value
					}

					function iteratee(func)
					{
						return baseIteratee("function" == typeof func ? func : baseClone(func, CLONE_DEEP_FLAG))
					}

					function matches(source)
					{
						return baseMatches(baseClone(source, CLONE_DEEP_FLAG))
					}

					function matchesProperty(path, srcValue)
					{
						return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG))
					}
					var method = baseRest(function (path, args)
					{
						return function (object)
						{
							return baseInvoke(object, path, args)
						}
					});
					var methodOf = baseRest(function (object, args)
					{
						return function (path)
						{
							return baseInvoke(object, path, args)
						}
					});

					function mixin(object, source, options)
					{
						var props = keys(source),
							methodNames = baseFunctions(source, props);
						if (null == options && !(isObject(source) && (methodNames.length || !props.length)))
						{
							options = source;
							source = object;
							object = this;
							methodNames = baseFunctions(source, keys(source))
						}
						var chain = !(isObject(options) && "chain" in options) || !!options.chain,
							isFunc = isFunction(object);
						arrayEach(methodNames, function (methodName)
						{
							var func = source[methodName];
							object[methodName] = func;
							isFunc && (object.prototype[methodName] = function ()
							{
								var chainAll = this.__chain__;
								if (chain || chainAll)
								{
									var result = object(this.__wrapped__),
										actions = result.__actions__ = copyArray(this.__actions__);
									actions.push(
									{
										func: func,
										args: arguments,
										thisArg: object
									});
									result.__chain__ = chainAll;
									return result
								}
								return func.apply(object, arrayPush([this.value()], arguments))
							})
						});
						return object
					}

					function noConflict()
					{
						root._ === this && (root._ = oldDash);
						return this
					}

					function noop()
					{}

					function nthArg(n)
					{
						n = toInteger(n);
						return baseRest(function (args)
						{
							return baseNth(args, n)
						})
					}
					var over = createOver(arrayMap);
					var overEvery = createOver(arrayEvery);
					var overSome = createOver(arraySome);

					function property(path)
					{
						return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
					}

					function propertyOf(object)
					{
						return function (path)
						{
							return null == object ? undefined : baseGet(object, path)
						}
					}
					var range = createRange();
					var rangeRight = createRange(true);

					function stubArray()
					{
						return []
					}

					function stubFalse()
					{
						return false
					}

					function stubObject()
					{
						return {}
					}

					function stubString()
					{
						return ""
					}

					function stubTrue()
					{
						return true
					}

					function times(n, iteratee)
					{
						n = toInteger(n);
						if (n < 1 || n > MAX_SAFE_INTEGER) return [];
						var index = MAX_ARRAY_LENGTH,
							length = nativeMin(n, MAX_ARRAY_LENGTH);
						iteratee = getIteratee(iteratee);
						n -= MAX_ARRAY_LENGTH;
						var result = baseTimes(length, iteratee);
						while (++index < n) iteratee(index);
						return result
					}

					function toPath(value)
					{
						if (isArray(value)) return arrayMap(value, toKey);
						return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)))
					}

					function uniqueId(prefix)
					{
						var id = ++idCounter;
						return toString(prefix) + id
					}
					var add = createMathOperation(function (augend, addend)
					{
						return augend + addend
					}, 0);
					var ceil = createRound("ceil");
					var divide = createMathOperation(function (dividend, divisor)
					{
						return dividend / divisor
					}, 1);
					var floor = createRound("floor");

					function max(array)
					{
						return array && array.length ? baseExtremum(array, identity, baseGt) : undefined
					}

					function maxBy(array, iteratee)
					{
						return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined
					}

					function mean(array)
					{
						return baseMean(array, identity)
					}

					function meanBy(array, iteratee)
					{
						return baseMean(array, getIteratee(iteratee, 2))
					}

					function min(array)
					{
						return array && array.length ? baseExtremum(array, identity, baseLt) : undefined
					}

					function minBy(array, iteratee)
					{
						return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined
					}
					var multiply = createMathOperation(function (multiplier, multiplicand)
					{
						return multiplier * multiplicand
					}, 1);
					var round = createRound("round");
					var subtract = createMathOperation(function (minuend, subtrahend)
					{
						return minuend - subtrahend
					}, 0);

					function sum(array)
					{
						return array && array.length ? baseSum(array, identity) : 0
					}

					function sumBy(array, iteratee)
					{
						return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0
					}
					lodash.after = after;
					lodash.ary = ary;
					lodash.assign = assign;
					lodash.assignIn = assignIn;
					lodash.assignInWith = assignInWith;
					lodash.assignWith = assignWith;
					lodash.at = at;
					lodash.before = before;
					lodash.bind = bind;
					lodash.bindAll = bindAll;
					lodash.bindKey = bindKey;
					lodash.castArray = castArray;
					lodash.chain = chain;
					lodash.chunk = chunk;
					lodash.compact = compact;
					lodash.concat = concat;
					lodash.cond = cond;
					lodash.conforms = conforms;
					lodash.constant = constant;
					lodash.countBy = countBy;
					lodash.create = create;
					lodash.curry = curry;
					lodash.curryRight = curryRight;
					lodash.debounce = debounce;
					lodash.defaults = defaults;
					lodash.defaultsDeep = defaultsDeep;
					lodash.defer = defer;
					lodash.delay = delay;
					lodash.difference = difference;
					lodash.differenceBy = differenceBy;
					lodash.differenceWith = differenceWith;
					lodash.drop = drop;
					lodash.dropRight = dropRight;
					lodash.dropRightWhile = dropRightWhile;
					lodash.dropWhile = dropWhile;
					lodash.fill = fill;
					lodash.filter = filter;
					lodash.flatMap = flatMap;
					lodash.flatMapDeep = flatMapDeep;
					lodash.flatMapDepth = flatMapDepth;
					lodash.flatten = flatten;
					lodash.flattenDeep = flattenDeep;
					lodash.flattenDepth = flattenDepth;
					lodash.flip = flip;
					lodash.flow = flow;
					lodash.flowRight = flowRight;
					lodash.fromPairs = fromPairs;
					lodash.functions = functions;
					lodash.functionsIn = functionsIn;
					lodash.groupBy = groupBy;
					lodash.initial = initial;
					lodash.intersection = intersection;
					lodash.intersectionBy = intersectionBy;
					lodash.intersectionWith = intersectionWith;
					lodash.invert = invert;
					lodash.invertBy = invertBy;
					lodash.invokeMap = invokeMap;
					lodash.iteratee = iteratee;
					lodash.keyBy = keyBy;
					lodash.keys = keys;
					lodash.keysIn = keysIn;
					lodash.map = map;
					lodash.mapKeys = mapKeys;
					lodash.mapValues = mapValues;
					lodash.matches = matches;
					lodash.matchesProperty = matchesProperty;
					lodash.memoize = memoize;
					lodash.merge = merge;
					lodash.mergeWith = mergeWith;
					lodash.method = method;
					lodash.methodOf = methodOf;
					lodash.mixin = mixin;
					lodash.negate = negate;
					lodash.nthArg = nthArg;
					lodash.omit = omit;
					lodash.omitBy = omitBy;
					lodash.once = once;
					lodash.orderBy = orderBy;
					lodash.over = over;
					lodash.overArgs = overArgs;
					lodash.overEvery = overEvery;
					lodash.overSome = overSome;
					lodash.partial = partial;
					lodash.partialRight = partialRight;
					lodash.partition = partition;
					lodash.pick = pick;
					lodash.pickBy = pickBy;
					lodash.property = property;
					lodash.propertyOf = propertyOf;
					lodash.pull = pull;
					lodash.pullAll = pullAll;
					lodash.pullAllBy = pullAllBy;
					lodash.pullAllWith = pullAllWith;
					lodash.pullAt = pullAt;
					lodash.range = range;
					lodash.rangeRight = rangeRight;
					lodash.rearg = rearg;
					lodash.reject = reject;
					lodash.remove = remove;
					lodash.rest = rest;
					lodash.reverse = reverse;
					lodash.sampleSize = sampleSize;
					lodash.set = set;
					lodash.setWith = setWith;
					lodash.shuffle = shuffle;
					lodash.slice = slice;
					lodash.sortBy = sortBy;
					lodash.sortedUniq = sortedUniq;
					lodash.sortedUniqBy = sortedUniqBy;
					lodash.split = split;
					lodash.spread = spread;
					lodash.tail = tail;
					lodash.take = take;
					lodash.takeRight = takeRight;
					lodash.takeRightWhile = takeRightWhile;
					lodash.takeWhile = takeWhile;
					lodash.tap = tap;
					lodash.throttle = throttle;
					lodash.thru = thru;
					lodash.toArray = toArray;
					lodash.toPairs = toPairs;
					lodash.toPairsIn = toPairsIn;
					lodash.toPath = toPath;
					lodash.toPlainObject = toPlainObject;
					lodash.transform = transform;
					lodash.unary = unary;
					lodash.union = union;
					lodash.unionBy = unionBy;
					lodash.unionWith = unionWith;
					lodash.uniq = uniq;
					lodash.uniqBy = uniqBy;
					lodash.uniqWith = uniqWith;
					lodash.unset = unset;
					lodash.unzip = unzip;
					lodash.unzipWith = unzipWith;
					lodash.update = update;
					lodash.updateWith = updateWith;
					lodash.values = values;
					lodash.valuesIn = valuesIn;
					lodash.without = without;
					lodash.words = words;
					lodash.wrap = wrap;
					lodash.xor = xor;
					lodash.xorBy = xorBy;
					lodash.xorWith = xorWith;
					lodash.zip = zip;
					lodash.zipObject = zipObject;
					lodash.zipObjectDeep = zipObjectDeep;
					lodash.zipWith = zipWith;
					lodash.entries = toPairs;
					lodash.entriesIn = toPairsIn;
					lodash.extend = assignIn;
					lodash.extendWith = assignInWith;
					mixin(lodash, lodash);
					lodash.add = add;
					lodash.attempt = attempt;
					lodash.camelCase = camelCase;
					lodash.capitalize = capitalize;
					lodash.ceil = ceil;
					lodash.clamp = clamp;
					lodash.clone = clone;
					lodash.cloneDeep = cloneDeep;
					lodash.cloneDeepWith = cloneDeepWith;
					lodash.cloneWith = cloneWith;
					lodash.conformsTo = conformsTo;
					lodash.deburr = deburr;
					lodash.defaultTo = defaultTo;
					lodash.divide = divide;
					lodash.endsWith = endsWith;
					lodash.eq = eq;
					lodash.escape = escape;
					lodash.escapeRegExp = escapeRegExp;
					lodash.every = every;
					lodash.find = find;
					lodash.findIndex = findIndex;
					lodash.findKey = findKey;
					lodash.findLast = findLast;
					lodash.findLastIndex = findLastIndex;
					lodash.findLastKey = findLastKey;
					lodash.floor = floor;
					lodash.forEach = forEach;
					lodash.forEachRight = forEachRight;
					lodash.forIn = forIn;
					lodash.forInRight = forInRight;
					lodash.forOwn = forOwn;
					lodash.forOwnRight = forOwnRight;
					lodash.get = get;
					lodash.gt = gt;
					lodash.gte = gte;
					lodash.has = has;
					lodash.hasIn = hasIn;
					lodash.head = head;
					lodash.identity = identity;
					lodash.includes = includes;
					lodash.indexOf = indexOf;
					lodash.inRange = inRange;
					lodash.invoke = invoke;
					lodash.isArguments = isArguments;
					lodash.isArray = isArray;
					lodash.isArrayBuffer = isArrayBuffer;
					lodash.isArrayLike = isArrayLike;
					lodash.isArrayLikeObject = isArrayLikeObject;
					lodash.isBoolean = isBoolean;
					lodash.isBuffer = isBuffer;
					lodash.isDate = isDate;
					lodash.isElement = isElement;
					lodash.isEmpty = isEmpty;
					lodash.isEqual = isEqual;
					lodash.isEqualWith = isEqualWith;
					lodash.isError = isError;
					lodash.isFinite = isFinite;
					lodash.isFunction = isFunction;
					lodash.isInteger = isInteger;
					lodash.isLength = isLength;
					lodash.isMap = isMap;
					lodash.isMatch = isMatch;
					lodash.isMatchWith = isMatchWith;
					lodash.isNaN = isNaN;
					lodash.isNative = isNative;
					lodash.isNil = isNil;
					lodash.isNull = isNull;
					lodash.isNumber = isNumber;
					lodash.isObject = isObject;
					lodash.isObjectLike = isObjectLike;
					lodash.isPlainObject = isPlainObject;
					lodash.isRegExp = isRegExp;
					lodash.isSafeInteger = isSafeInteger;
					lodash.isSet = isSet;
					lodash.isString = isString;
					lodash.isSymbol = isSymbol;
					lodash.isTypedArray = isTypedArray;
					lodash.isUndefined = isUndefined;
					lodash.isWeakMap = isWeakMap;
					lodash.isWeakSet = isWeakSet;
					lodash.join = join;
					lodash.kebabCase = kebabCase;
					lodash.last = last;
					lodash.lastIndexOf = lastIndexOf;
					lodash.lowerCase = lowerCase;
					lodash.lowerFirst = lowerFirst;
					lodash.lt = lt;
					lodash.lte = lte;
					lodash.max = max;
					lodash.maxBy = maxBy;
					lodash.mean = mean;
					lodash.meanBy = meanBy;
					lodash.min = min;
					lodash.minBy = minBy;
					lodash.stubArray = stubArray;
					lodash.stubFalse = stubFalse;
					lodash.stubObject = stubObject;
					lodash.stubString = stubString;
					lodash.stubTrue = stubTrue;
					lodash.multiply = multiply;
					lodash.nth = nth;
					lodash.noConflict = noConflict;
					lodash.noop = noop;
					lodash.now = now;
					lodash.pad = pad;
					lodash.padEnd = padEnd;
					lodash.padStart = padStart;
					lodash.parseInt = parseInt;
					lodash.random = random;
					lodash.reduce = reduce;
					lodash.reduceRight = reduceRight;
					lodash.repeat = repeat;
					lodash.replace = replace;
					lodash.result = result;
					lodash.round = round;
					lodash.runInContext = runInContext;
					lodash.sample = sample;
					lodash.size = size;
					lodash.snakeCase = snakeCase;
					lodash.some = some;
					lodash.sortedIndex = sortedIndex;
					lodash.sortedIndexBy = sortedIndexBy;
					lodash.sortedIndexOf = sortedIndexOf;
					lodash.sortedLastIndex = sortedLastIndex;
					lodash.sortedLastIndexBy = sortedLastIndexBy;
					lodash.sortedLastIndexOf = sortedLastIndexOf;
					lodash.startCase = startCase;
					lodash.startsWith = startsWith;
					lodash.subtract = subtract;
					lodash.sum = sum;
					lodash.sumBy = sumBy;
					lodash.template = template;
					lodash.times = times;
					lodash.toFinite = toFinite;
					lodash.toInteger = toInteger;
					lodash.toLength = toLength;
					lodash.toLower = toLower;
					lodash.toNumber = toNumber;
					lodash.toSafeInteger = toSafeInteger;
					lodash.toString = toString;
					lodash.toUpper = toUpper;
					lodash.trim = trim;
					lodash.trimEnd = trimEnd;
					lodash.trimStart = trimStart;
					lodash.truncate = truncate;
					lodash.unescape = unescape;
					lodash.uniqueId = uniqueId;
					lodash.upperCase = upperCase;
					lodash.upperFirst = upperFirst;
					lodash.each = forEach;
					lodash.eachRight = forEachRight;
					lodash.first = head;
					mixin(lodash, function ()
					{
						var source = {};
						baseForOwn(lodash, function (func, methodName)
						{
							hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func)
						});
						return source
					}(),
					{
						chain: false
					});
					lodash.VERSION = VERSION;
					arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (methodName)
					{
						lodash[methodName].placeholder = lodash
					});
					arrayEach(["drop", "take"], function (methodName, index)
					{
						LazyWrapper.prototype[methodName] = function (n)
						{
							n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
							var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
							result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push(
							{
								size: nativeMin(n, MAX_ARRAY_LENGTH),
								type: methodName + (result.__dir__ < 0 ? "Right" : "")
							});
							return result
						};
						LazyWrapper.prototype[methodName + "Right"] = function (n)
						{
							return this.reverse()[methodName](n).reverse()
						}
					});
					arrayEach(["filter", "map", "takeWhile"], function (methodName, index)
					{
						var type = index + 1,
							isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
						LazyWrapper.prototype[methodName] = function (iteratee)
						{
							var result = this.clone();
							result.__iteratees__.push(
							{
								iteratee: getIteratee(iteratee, 3),
								type: type
							});
							result.__filtered__ = result.__filtered__ || isFilter;
							return result
						}
					});
					arrayEach(["head", "last"], function (methodName, index)
					{
						var takeName = "take" + (index ? "Right" : "");
						LazyWrapper.prototype[methodName] = function ()
						{
							return this[takeName](1).value()[0]
						}
					});
					arrayEach(["initial", "tail"], function (methodName, index)
					{
						var dropName = "drop" + (index ? "" : "Right");
						LazyWrapper.prototype[methodName] = function ()
						{
							return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
						}
					});
					LazyWrapper.prototype.compact = function ()
					{
						return this.filter(identity)
					};
					LazyWrapper.prototype.find = function (predicate)
					{
						return this.filter(predicate).head()
					};
					LazyWrapper.prototype.findLast = function (predicate)
					{
						return this.reverse().find(predicate)
					};
					LazyWrapper.prototype.invokeMap = baseRest(function (path, args)
					{
						if ("function" == typeof path) return new LazyWrapper(this);
						return this.map(function (value)
						{
							return baseInvoke(value, path, args)
						})
					});
					LazyWrapper.prototype.reject = function (predicate)
					{
						return this.filter(negate(getIteratee(predicate)))
					};
					LazyWrapper.prototype.slice = function (start, end)
					{
						start = toInteger(start);
						var result = this;
						if (result.__filtered__ && (start > 0 || end < 0)) return new LazyWrapper(result);
						start < 0 ? result = result.takeRight(-start) : start && (result = result.drop(start));
						if (end !== undefined)
						{
							end = toInteger(end);
							result = end < 0 ? result.dropRight(-end) : result.take(end - start)
						}
						return result
					};
					LazyWrapper.prototype.takeRightWhile = function (predicate)
					{
						return this.reverse().takeWhile(predicate).reverse()
					};
					LazyWrapper.prototype.toArray = function ()
					{
						return this.take(MAX_ARRAY_LENGTH)
					};
					baseForOwn(LazyWrapper.prototype, function (func, methodName)
					{
						var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
							isTaker = /^(?:head|last)$/.test(methodName),
							lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName],
							retUnwrapped = isTaker || /^find/.test(methodName);
						if (!lodashFunc) return;
						lodash.prototype[methodName] = function ()
						{
							var value = this.__wrapped__,
								args = isTaker ? [1] : arguments,
								isLazy = value instanceof LazyWrapper,
								iteratee = args[0],
								useLazy = isLazy || isArray(value);
							var interceptor = function (value)
							{
								var result = lodashFunc.apply(lodash, arrayPush([value], args));
								return isTaker && chainAll ? result[0] : result
							};
							useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = false);
							var chainAll = this.__chain__,
								isHybrid = !!this.__actions__.length,
								isUnwrapped = retUnwrapped && !chainAll,
								onlyLazy = isLazy && !isHybrid;
							if (!retUnwrapped && useLazy)
							{
								value = onlyLazy ? value : new LazyWrapper(this);
								var result = func.apply(value, args);
								result.__actions__.push(
								{
									func: thru,
									args: [interceptor],
									thisArg: undefined
								});
								return new LodashWrapper(result, chainAll)
							}
							if (isUnwrapped && onlyLazy) return func.apply(this, args);
							result = this.thru(interceptor);
							return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result
						}
					});
					arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function (methodName)
					{
						var func = arrayProto[methodName],
							chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru",
							retUnwrapped = /^(?:pop|shift)$/.test(methodName);
						lodash.prototype[methodName] = function ()
						{
							var args = arguments;
							if (retUnwrapped && !this.__chain__)
							{
								var value = this.value();
								return func.apply(isArray(value) ? value : [], args)
							}
							return this[chainName](function (value)
							{
								return func.apply(isArray(value) ? value : [], args)
							})
						}
					});
					baseForOwn(LazyWrapper.prototype, function (func, methodName)
					{
						var lodashFunc = lodash[methodName];
						if (lodashFunc)
						{
							var key = lodashFunc.name + "",
								names = realNames[key] || (realNames[key] = []);
							names.push(
							{
								name: methodName,
								func: lodashFunc
							})
						}
					});
					realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [
					{
						name: "wrapper",
						func: undefined
					}];
					LazyWrapper.prototype.clone = lazyClone;
					LazyWrapper.prototype.reverse = lazyReverse;
					LazyWrapper.prototype.value = lazyValue;
					lodash.prototype.at = wrapperAt;
					lodash.prototype.chain = wrapperChain;
					lodash.prototype.commit = wrapperCommit;
					lodash.prototype.next = wrapperNext;
					lodash.prototype.plant = wrapperPlant;
					lodash.prototype.reverse = wrapperReverse;
					lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
					lodash.prototype.first = lodash.prototype.head;
					symIterator && (lodash.prototype[symIterator] = wrapperToIterator);
					return lodash
				};
				var _ = runInContext();
				true;
				root._ = _;
				!(__WEBPACK_AMD_DEFINE_RESULT__ = function ()
				{
					return _
				}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
			}).call(this)
		}).call(exports, __webpack_require__(24), __webpack_require__(46)(module))
	},
	398: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/src/FileSaver.js */
		var saveAs = exports.saveAs = saveAs || function (view)
		{
			if ("undefined" === typeof view || "undefined" !== typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent)) return;
			var doc = view.document,
				get_URL = function get_URL()
				{
					return view.URL || view.webkitURL || view
				},
				save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
				can_use_save_link = "download" in save_link,
				click = function click(node)
				{
					var event = new MouseEvent("click");
					node.dispatchEvent(event)
				},
				is_safari = /constructor/i.test(view.HTMLElement) || view.safari,
				is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent),
				setImmediate = view.setImmediate || view.setTimeout,
				throw_outside = function throw_outside(ex)
				{
					setImmediate(function ()
					{
						throw ex
					}, 0)
				},
				force_saveable_type = "application/octet-stream",
				arbitrary_revoke_timeout = 4e4,
				revoke = function revoke(file)
				{
					var revoker = function revoker()
					{
						"string" === typeof file ? get_URL().revokeObjectURL(file) : file.remove()
					};
					setTimeout(revoker, arbitrary_revoke_timeout)
				},
				dispatch = function dispatch(filesaver, event_types, event)
				{
					event_types = [].concat(event_types);
					var i = event_types.length;
					while (i--)
					{
						var listener = filesaver["on" + event_types[i]];
						if ("function" === typeof listener) try
						{
							listener.call(filesaver, event || filesaver)
						}
						catch (ex)
						{
							throw_outside(ex)
						}
					}
				},
				auto_bom = function auto_bom(blob)
				{
					if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) return new Blob([String.fromCharCode(65279), blob],
					{
						type: blob.type
					});
					return blob
				},
				FileSaver = function FileSaver(blob, name, no_auto_bom)
				{
					no_auto_bom || (blob = auto_bom(blob));
					var object_url, filesaver = this,
						type = blob.type,
						force = type === force_saveable_type,
						dispatch_all = function dispatch_all()
						{
							dispatch(filesaver, "writestart progress write writeend".split(" "))
						},
						fs_error = function fs_error()
						{
							if ((is_chrome_ios || force && is_safari) && view.FileReader)
							{
								var reader = new FileReader;
								reader.onloadend = function ()
								{
									var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, "data:attachment/file;");
									var popup = view.open(url, "_blank");
									popup || (view.location.href = url);
									url = void 0;
									filesaver.readyState = filesaver.DONE;
									dispatch_all()
								};
								reader.readAsDataURL(blob);
								filesaver.readyState = filesaver.INIT;
								return
							}
							object_url || (object_url = get_URL().createObjectURL(blob));
							if (force) view.location.href = object_url;
							else
							{
								var opened = view.open(object_url, "_blank");
								opened || (view.location.href = object_url)
							}
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
							revoke(object_url)
						};
					filesaver.readyState = filesaver.INIT;
					if (can_use_save_link)
					{
						object_url = get_URL().createObjectURL(blob);
						setImmediate(function ()
						{
							save_link.href = object_url;
							save_link.download = name;
							click(save_link);
							dispatch_all();
							revoke(object_url);
							filesaver.readyState = filesaver.DONE
						}, 0);
						return
					}
					fs_error()
				},
				FS_proto = FileSaver.prototype,
				saveAs = function saveAs(blob, name, no_auto_bom)
				{
					return new FileSaver(blob, name || blob.name || "download", no_auto_bom)
				};
			if ("undefined" !== typeof navigator && navigator.msSaveOrOpenBlob) return function (blob, name, no_auto_bom)
			{
				name = name || blob.name || "download";
				no_auto_bom || (blob = auto_bom(blob));
				return navigator.msSaveOrOpenBlob(blob, name)
			};
			FS_proto.abort = function () {};
			FS_proto.readyState = FS_proto.INIT = 0;
			FS_proto.WRITING = 1;
			FS_proto.DONE = 2;
			FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
			return saveAs
		}("undefined" !== typeof self && self || "undefined" !== typeof window && window || void 0)
	},
	4372: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(170);
		__webpack_require__(172);
		__webpack_require__(174);
		__webpack_require__(175);
		__webpack_require__(176);
		__webpack_require__(177);
		__webpack_require__(178);
		__webpack_require__(179);
		__webpack_require__(180);
		__webpack_require__(181);
		__webpack_require__(182);
		__webpack_require__(183);
		__webpack_require__(184);
		__webpack_require__(185);
		__webpack_require__(186);
		__webpack_require__(187);
		__webpack_require__(188);
		__webpack_require__(189);
		__webpack_require__(190);
		__webpack_require__(191);
		__webpack_require__(192);
		__webpack_require__(193);
		__webpack_require__(194);
		__webpack_require__(195);
		__webpack_require__(196);
		__webpack_require__(197);
		__webpack_require__(198);
		__webpack_require__(199);
		__webpack_require__(200);
		__webpack_require__(201);
		__webpack_require__(202);
		__webpack_require__(203);
		__webpack_require__(204);
		__webpack_require__(205);
		__webpack_require__(206);
		__webpack_require__(207);
		__webpack_require__(208);
		__webpack_require__(209);
		__webpack_require__(210);
		__webpack_require__(211);
		__webpack_require__(212);
		__webpack_require__(213);
		__webpack_require__(214);
		__webpack_require__(215);
		__webpack_require__(216);
		__webpack_require__(217);
		__webpack_require__(218);
		__webpack_require__(219);
		__webpack_require__(220);
		__webpack_require__(221);
		__webpack_require__(222);
		__webpack_require__(140);
		__webpack_require__(223);
		__webpack_require__(224);
		__webpack_require__(225);
		__webpack_require__(226);
		__webpack_require__(227);
		__webpack_require__(228);
		__webpack_require__(229);
		__webpack_require__(230);
		__webpack_require__(231);
		__webpack_require__(232);
		__webpack_require__(233);
		__webpack_require__(234);
		__webpack_require__(235);
		__webpack_require__(236);
		__webpack_require__(237);
		__webpack_require__(238);
		__webpack_require__(239);
		__webpack_require__(240);
		__webpack_require__(241);
		__webpack_require__(242);
		__webpack_require__(243);
		__webpack_require__(244);
		__webpack_require__(245);
		__webpack_require__(246);
		__webpack_require__(247);
		__webpack_require__(248);
		__webpack_require__(249);
		__webpack_require__(250);
		__webpack_require__(251);
		__webpack_require__(252);
		__webpack_require__(253);
		__webpack_require__(254);
		__webpack_require__(255);
		__webpack_require__(256);
		__webpack_require__(257);
		__webpack_require__(258);
		__webpack_require__(259);
		__webpack_require__(260);
		var _i18n = __webpack_require__(12);
		var _kibanaCore__ = __webpack_require__(261);
		var injectedMetadata = JSON.parse(document.querySelector("kbn-injected-metadata").getAttribute("data"));
		_i18n.i18n.init(injectedMetadata.legacyMetadata.translations);
		new _kibanaCore__.CoreSystem(
		{
			injectedMetadata: injectedMetadata,
			rootDomElement: document.body,
			requireLegacyFiles: function requireLegacyFiles()
			{
				__webpack_require__(4373)
			}
		}).start()
	},
	4373: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(443);
		__webpack_require__(813);
		__webpack_require__(865);
		__webpack_require__(867);
		__webpack_require__(870);
		__webpack_require__(615);
		__webpack_require__(4374);
		__webpack_require__(622);
		__webpack_require__(1582);
		__webpack_require__(892);
		__webpack_require__(1584);
		__webpack_require__(1678);
		__webpack_require__(893);
		__webpack_require__(880);
		__webpack_require__(895);
		__webpack_require__(5218);
		var _modules = __webpack_require__(2);
		__webpack_require__(5226);
		__webpack_require__(5227);
		__webpack_require__(5240);
		__webpack_require__(1516);
		__webpack_require__(5241);
		__webpack_require__(5242);
		__webpack_require__(5243);
		__webpack_require__(467);
		__webpack_require__(9);
		__webpack_require__(5244);
		__webpack_require__(5280);
		__webpack_require__(5322);
		__webpack_require__(5359);
		__webpack_require__(5370);
		var app = _modules.uiModules.get("app/wazuh", ["ngCookies", "ngMaterial"]);
		app.config(["$compileProvider", function ($compileProvider)
		{
			$compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|data|blob):/)
		}]);
		app.config(["$httpProvider", function ($httpProvider)
		{
			$httpProvider.useApplyAsync(true)
		}]);
		_modules.uiModules.get("kibana").provider("dashboardConfig", function ()
		{
			var hideWriteControls = false;
			return {
				turnHideWriteControlsOn: function turnHideWriteControlsOn()
				{
					hideWriteControls = true
				},
				$get: function $get()
				{
					return {
						getHideWriteControls: function getHideWriteControls()
						{
							return hideWriteControls
						}
					}
				}
			}
		})
	},
	4374: function (module, exports) {},
	47: function (module, exports, __webpack_require__)
	{
		"use strict";
		var pug_has_own_property = Object.prototype.hasOwnProperty;
		exports.merge = pug_merge;

		function pug_merge(a, b)
		{
			if (1 === arguments.length)
			{
				var attrs = a[0];
				for (var i = 1; i < a.length; i++) attrs = pug_merge(attrs, a[i]);
				return attrs
			}
			for (var key in b)
				if ("class" === key)
				{
					var valA = a[key] || [];
					a[key] = (Array.isArray(valA) ? valA : [valA]).concat(b[key] || [])
				}
			else if ("style" === key)
			{
				valA = pug_style(a[key]);
				valA = valA && ";" !== valA[valA.length - 1] ? valA + ";" : valA;
				var valB = pug_style(b[key]);
				valB = valB && ";" !== valB[valB.length - 1] ? valB + ";" : valB;
				a[key] = valA + valB
			}
			else a[key] = b[key];
			return a
		}
		exports.classes = pug_classes;

		function pug_classes_array(val, escaping)
		{
			var className, classString = "",
				padding = "",
				escapeEnabled = Array.isArray(escaping);
			for (var i = 0; i < val.length; i++)
			{
				className = pug_classes(val[i]);
				if (!className) continue;
				escapeEnabled && escaping[i] && (className = pug_escape(className));
				classString = classString + padding + className;
				padding = " "
			}
			return classString
		}

		function pug_classes_object(val)
		{
			var classString = "",
				padding = "";
			for (var key in val)
				if (key && val[key] && pug_has_own_property.call(val, key))
				{
					classString = classString + padding + key;
					padding = " "
				}
			return classString
		}

		function pug_classes(val, escaping)
		{
			return Array.isArray(val) ? pug_classes_array(val, escaping) : val && "object" === typeof val ? pug_classes_object(val) : val || ""
		}
		exports.style = pug_style;

		function pug_style(val)
		{
			if (!val) return "";
			if ("object" === typeof val)
			{
				var out = "";
				for (var style in val) pug_has_own_property.call(val, style) && (out = out + style + ":" + val[style] + ";");
				return out
			}
			return val + ""
		}
		exports.attr = pug_attr;

		function pug_attr(key, val, escaped, terse)
		{
			if (false === val || null == val || !val && ("class" === key || "style" === key)) return "";
			if (true === val) return " " + (terse ? key : key + '="' + key + '"');
			"function" === typeof val.toJSON && (val = val.toJSON());
			if ("string" !== typeof val)
			{
				val = JSON.stringify(val);
				if (!escaped && -1 !== val.indexOf('"')) return " " + key + "='" + val.replace(/'/g, "&#39;") + "'"
			}
			escaped && (val = pug_escape(val));
			return " " + key + '="' + val + '"'
		}
		exports.attrs = pug_attrs;

		function pug_attrs(obj, terse)
		{
			var attrs = "";
			for (var key in obj)
				if (pug_has_own_property.call(obj, key))
				{
					var val = obj[key];
					if ("class" === key)
					{
						val = pug_classes(val);
						attrs = pug_attr(key, val, false, terse) + attrs;
						continue
					}
					"style" === key && (val = pug_style(val));
					attrs += pug_attr(key, val, false, terse)
				}
			return attrs
		}
		var pug_match_html = /["&<>]/;
		exports.escape = pug_escape;

		function pug_escape(_html)
		{
			var html = "" + _html;
			var regexResult = pug_match_html.exec(html);
			if (!regexResult) return _html;
			var result = "";
			var i, lastIndex, escape;
			for (i = regexResult.index, lastIndex = 0; i < html.length; i++)
			{
				switch (html.charCodeAt(i))
				{
				case 34:
					escape = "&quot;";
					break;
				case 38:
					escape = "&amp;";
					break;
				case 60:
					escape = "&lt;";
					break;
				case 62:
					escape = "&gt;";
					break;
				default:
					continue
				}
				lastIndex !== i && (result += html.substring(lastIndex, i));
				lastIndex = i + 1;
				result += escape
			}
			return lastIndex !== i ? result + html.substring(lastIndex, i) : result
		}
		exports.rethrow = pug_rethrow;

		function pug_rethrow(err, filename, lineno, str)
		{
			if (!(err instanceof Error)) throw err;
			if (("undefined" != typeof window || !filename) && !str)
			{
				err.message += " on line " + lineno;
				throw err
			}
			try
			{
				str = str || __webpack_require__(5297).readFileSync(filename, "utf8")
			}
			catch (ex)
			{
				pug_rethrow(err, null, lineno)
			}
			var context = 3,
				lines = str.split("\n"),
				start = Math.max(lineno - context, 0),
				end = Math.min(lines.length, lineno + context);
			context = lines.slice(start, end).map(function (line, i)
			{
				var curr = i + start + 1;
				return (curr == lineno ? "  > " : "    ") + curr + "| " + line
			}).join("\n");
			err.path = filename;
			err.message = (filename || "Pug") + ":" + lineno + "\n" + context + "\n\n" + err.message;
			throw err
		}
	},
	484: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				function doFold(cm, pos, options, force)
				{
					if (options && options.call)
					{
						var finder = options;
						options = null
					}
					else finder = getOption(cm, options, "rangeFinder");
					"number" == typeof pos && (pos = CodeMirror.Pos(pos, 0));
					var minSize = getOption(cm, options, "minFoldSize");

					function getRange(allowFolded)
					{
						var range = finder(cm, pos);
						if (!range || range.to.line - range.from.line < minSize) return null;
						var marks = cm.findMarksAt(range.from);
						for (var i = 0; i < marks.length; ++i)
							if (marks[i].__isFold && "fold" !== force)
							{
								if (!allowFolded) return null;
								range.cleared = true;
								marks[i].clear()
							}
						return range
					}
					var range = getRange(true);
					if (getOption(cm, options, "scanUp"))
						while (!range && pos.line > cm.firstLine())
						{
							pos = CodeMirror.Pos(pos.line - 1, 0);
							range = getRange(false)
						}
					if (!range || range.cleared || "unfold" === force) return;
					var myWidget = makeWidget(cm, options);
					CodeMirror.on(myWidget, "mousedown", function (e)
					{
						myRange.clear();
						CodeMirror.e_preventDefault(e)
					});
					var myRange = cm.markText(range.from, range.to,
					{
						replacedWith: myWidget,
						clearOnEnter: getOption(cm, options, "clearOnEnter"),
						__isFold: true
					});
					myRange.on("clear", function (from, to)
					{
						CodeMirror.signal(cm, "unfold", cm, from, to)
					});
					CodeMirror.signal(cm, "fold", cm, range.from, range.to)
				}

				function makeWidget(cm, options)
				{
					var widget = getOption(cm, options, "widget");
					if ("string" == typeof widget)
					{
						var text = document.createTextNode(widget);
						widget = document.createElement("span");
						widget.appendChild(text);
						widget.className = "CodeMirror-foldmarker"
					}
					else widget && (widget = widget.cloneNode(true));
					return widget
				}
				CodeMirror.newFoldFunction = function (rangeFinder, widget)
				{
					return function (cm, pos)
					{
						doFold(cm, pos,
						{
							rangeFinder: rangeFinder,
							widget: widget
						})
					}
				};
				CodeMirror.defineExtension("foldCode", function (pos, options, force)
				{
					doFold(this, pos, options, force)
				});
				CodeMirror.defineExtension("isFolded", function (pos)
				{
					var marks = this.findMarksAt(pos);
					for (var i = 0; i < marks.length; ++i)
						if (marks[i].__isFold) return true
				});
				CodeMirror.commands.toggleFold = function (cm)
				{
					cm.foldCode(cm.getCursor())
				};
				CodeMirror.commands.fold = function (cm)
				{
					cm.foldCode(cm.getCursor(), null, "fold")
				};
				CodeMirror.commands.unfold = function (cm)
				{
					cm.foldCode(cm.getCursor(), null, "unfold")
				};
				CodeMirror.commands.foldAll = function (cm)
				{
					cm.operation(function ()
					{
						for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) cm.foldCode(CodeMirror.Pos(i, 0), null, "fold")
					})
				};
				CodeMirror.commands.unfoldAll = function (cm)
				{
					cm.operation(function ()
					{
						for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold")
					})
				};
				CodeMirror.registerHelper("fold", "combine", function ()
				{
					var funcs = Array.prototype.slice.call(arguments, 0);
					return function (cm, start)
					{
						for (var i = 0; i < funcs.length; ++i)
						{
							var found = funcs[i](cm, start);
							if (found) return found
						}
					}
				});
				CodeMirror.registerHelper("fold", "auto", function (cm, start)
				{
					var helpers = cm.getHelpers(start, "fold");
					for (var i = 0; i < helpers.length; i++)
					{
						var cur = helpers[i](cm, start);
						if (cur) return cur
					}
				});
				var defaultOptions = {
					rangeFinder: CodeMirror.fold.auto,
					widget: "",
					minFoldSize: 0,
					scanUp: false,
					clearOnEnter: true
				};
				CodeMirror.defineOption("foldOptions", null);

				function getOption(cm, options, name)
				{
					if (options && void 0 !== options[name]) return options[name];
					var editorOptions = cm.options.foldOptions;
					if (editorOptions && void 0 !== editorOptions[name]) return editorOptions[name];
					return defaultOptions[name]
				}
				CodeMirror.defineExtension("foldOption", function (options, name)
				{
					return getOption(this, options, name)
				})
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	485: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var StringOptions = function ()
		{
			function StringOptions(stringOptions)
			{
				void 0 === stringOptions && (stringOptions = {});
				this.doubleQuotes = false;
				this.indent = "    ";
				this.newline = "\n";
				this.pretty = true;
				if (!utils_1.isObject(stringOptions)) throw new TypeError("options should be an Object or undefined");
				if (utils_1.isBoolean(stringOptions.doubleQuotes)) this.doubleQuotes = stringOptions.doubleQuotes;
				else if (!utils_1.isUndefined(stringOptions.doubleQuotes)) throw new TypeError("options.doubleQuotes should be a boolean or undefined");
				if (utils_1.isString(stringOptions.indent)) this.indent = stringOptions.indent;
				else if (!utils_1.isUndefined(stringOptions.indent)) throw new TypeError("options.indent should be a string or undefined");
				if (utils_1.isString(stringOptions.newline)) this.newline = stringOptions.newline;
				else if (!utils_1.isUndefined(stringOptions.newline)) throw new TypeError("options.newline should be a string or undefined");
				if (utils_1.isBoolean(stringOptions.pretty)) this.pretty = stringOptions.pretty;
				else if (!utils_1.isUndefined(stringOptions.pretty)) throw new TypeError("options.pretty should be a boolean or undefined")
			}
			return StringOptions
		}();
		exports.StringOptions = StringOptions;
		var DeclarationOptions = function ()
		{
			function DeclarationOptions(declarationOptions)
			{
				void 0 === declarationOptions && (declarationOptions = {});
				this.version = "1.0";
				if (!utils_1.isObject(declarationOptions)) throw new TypeError("options should be an Object or undefined");
				if (utils_1.isString(declarationOptions.encoding)) this.encoding = declarationOptions.encoding;
				else if (!utils_1.isUndefined(declarationOptions.encoding)) throw new TypeError("options.encoding should be a string or undefined");
				if (utils_1.isString(declarationOptions.standalone)) this.standalone = declarationOptions.standalone;
				else if (!utils_1.isUndefined(declarationOptions.standalone)) throw new TypeError("options.standalone should be a string or undefined");
				if (utils_1.isString(declarationOptions.version)) this.version = declarationOptions.version;
				else if (!utils_1.isUndefined(declarationOptions.version)) throw new TypeError("options.version should be a string or undefined")
			}
			return DeclarationOptions
		}();
		exports.DeclarationOptions = DeclarationOptions
	},
	5218: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(5219);
		__webpack_require__(5220);
		__webpack_require__(5221);
		__webpack_require__(5222);
		__webpack_require__(5223);
		__webpack_require__(5224);
		__webpack_require__(5225)
	},
	5219: function (module, exports) {},
	5220: function (module, exports) {},
	5221: function (module, exports) {},
	5222: function (module, exports) {},
	5223: function (module, exports) {},
	5224: function (module, exports) {},
	5225: function (module, exports) {},
	5226: function (module, exports) {},
	5227: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(5228);
		__webpack_require__(5229);
		__webpack_require__(5230);
		__webpack_require__(5231);
		__webpack_require__(5232);
		__webpack_require__(5233);
		__webpack_require__(5234);
		__webpack_require__(484);
		__webpack_require__(5235);
		__webpack_require__(5236);
		__webpack_require__(5237);
		__webpack_require__(5238);
		__webpack_require__(5239)
	},
	5228: function (module, exports) {},
	5229: function (module, exports) {},
	5230: function (module, exports) {},
	5231: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				CodeMirror.defineMode("javascript", function (config, parserConfig)
				{
					var indentUnit = config.indentUnit;
					var statementIndent = parserConfig.statementIndent;
					var jsonldMode = parserConfig.jsonld;
					var jsonMode = parserConfig.json || jsonldMode;
					var isTS = parserConfig.typescript;
					var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
					var keywords = function ()
					{
						function kw(type)
						{
							return {
								type: type,
								style: "keyword"
							}
						}
						var A = kw("keyword a"),
							B = kw("keyword b"),
							C = kw("keyword c"),
							D = kw("keyword d");
						var operator = kw("operator"),
							atom = {
								type: "atom",
								style: "atom"
							};
						return {
							if: kw("if"),
							while: A,
							with: A,
							else: B,
							do: B,
							try: B,
							finally: B,
							return: D,
							break: D,
							continue: D,
							new: kw("new"),
							delete: C,
							void: C,
							throw: C,
							debugger: kw("debugger"),
							var: kw("var"),
							const: kw("var"),
							let: kw("var"),
							function: kw("function"),
							catch: kw("catch"),
							for: kw("for"),
							switch: kw("switch"),
							case: kw("case"),
							default: kw("default"),
							in: operator,
							typeof: operator,
							instanceof: operator,
							true: atom,
							false: atom,
							null: atom,
							undefined: atom,
							NaN: atom,
							Infinity: atom,
							this: kw("this"),
							class: kw("class"),
							super: kw("atom"),
							yield: C,
							export: kw("export"),
							import: kw("import"),
							extends: C,
							await: C
						}
					}();
					var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
					var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

					function readRegexp(stream)
					{
						var next, escaped = false,
							inSet = false;
						while (null != (next = stream.next()))
						{
							if (!escaped)
							{
								if ("/" == next && !inSet) return;
								"[" == next ? inSet = true : inSet && "]" == next && (inSet = false)
							}
							escaped = !escaped && "\\" == next
						}
					}
					var type, content;

					function ret(tp, style, cont)
					{
						type = tp;
						content = cont;
						return style
					}

					function tokenBase(stream, state)
					{
						var ch = stream.next();
						if ('"' == ch || "'" == ch)
						{
							state.tokenize = tokenString(ch);
							return state.tokenize(stream, state)
						}
						if ("." == ch && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) return ret("number", "number");
						if ("." == ch && stream.match("..")) return ret("spread", "meta");
						if (/[\[\]{}\(\),;\:\.]/.test(ch)) return ret(ch);
						if ("=" == ch && stream.eat(">")) return ret("=>", "operator");
						if ("0" == ch && stream.eat(/x/i))
						{
							stream.eatWhile(/[\da-f]/i);
							return ret("number", "number")
						}
						if ("0" == ch && stream.eat(/o/i))
						{
							stream.eatWhile(/[0-7]/i);
							return ret("number", "number")
						}
						if ("0" == ch && stream.eat(/b/i))
						{
							stream.eatWhile(/[01]/i);
							return ret("number", "number")
						}
						if (/\d/.test(ch))
						{
							stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
							return ret("number", "number")
						}
						if ("/" == ch)
						{
							if (stream.eat("*"))
							{
								state.tokenize = tokenComment;
								return tokenComment(stream, state)
							}
							if (stream.eat("/"))
							{
								stream.skipToEnd();
								return ret("comment", "comment")
							}
							if (expressionAllowed(stream, state, 1))
							{
								readRegexp(stream);
								stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
								return ret("regexp", "string-2")
							}
							stream.eat("=");
							return ret("operator", "operator", stream.current())
						}
						if ("`" == ch)
						{
							state.tokenize = tokenQuasi;
							return tokenQuasi(stream, state)
						}
						if ("#" == ch)
						{
							stream.skipToEnd();
							return ret("error", "error")
						}
						if (isOperatorChar.test(ch))
						{
							if (">" != ch || !state.lexical || ">" != state.lexical.type)
								if (stream.eat("=")) "!" != ch && "=" != ch || stream.eat("=");
								else if (/[<>*+\-]/.test(ch))
							{
								stream.eat(ch);
								">" == ch && stream.eat(ch)
							}
							return ret("operator", "operator", stream.current())
						}
						if (wordRE.test(ch))
						{
							stream.eatWhile(wordRE);
							var word = stream.current();
							if ("." != state.lastType)
							{
								if (keywords.propertyIsEnumerable(word))
								{
									var kw = keywords[word];
									return ret(kw.type, kw.style, word)
								}
								if ("async" == word && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false)) return ret("async", "keyword", word)
							}
							return ret("variable", "variable", word)
						}
					}

					function tokenString(quote)
					{
						return function (stream, state)
						{
							var next, escaped = false;
							if (jsonldMode && "@" == stream.peek() && stream.match(isJsonldKeyword))
							{
								state.tokenize = tokenBase;
								return ret("jsonld-keyword", "meta")
							}
							while (null != (next = stream.next()))
							{
								if (next == quote && !escaped) break;
								escaped = !escaped && "\\" == next
							}
							escaped || (state.tokenize = tokenBase);
							return ret("string", "string")
						}
					}

					function tokenComment(stream, state)
					{
						var ch, maybeEnd = false;
						while (ch = stream.next())
						{
							if ("/" == ch && maybeEnd)
							{
								state.tokenize = tokenBase;
								break
							}
							maybeEnd = "*" == ch
						}
						return ret("comment", "comment")
					}

					function tokenQuasi(stream, state)
					{
						var next, escaped = false;
						while (null != (next = stream.next()))
						{
							if (!escaped && ("`" == next || "$" == next && stream.eat("{")))
							{
								state.tokenize = tokenBase;
								break
							}
							escaped = !escaped && "\\" == next
						}
						return ret("quasi", "string-2", stream.current())
					}
					var brackets = "([{}])";

					function findFatArrow(stream, state)
					{
						state.fatArrowAt && (state.fatArrowAt = null);
						var arrow = stream.string.indexOf("=>", stream.start);
						if (arrow < 0) return;
						if (isTS)
						{
							var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
							m && (arrow = m.index)
						}
						var depth = 0,
							sawSomething = false;
						for (var pos = arrow - 1; pos >= 0; --pos)
						{
							var ch = stream.string.charAt(pos);
							var bracket = brackets.indexOf(ch);
							if (bracket >= 0 && bracket < 3)
							{
								if (!depth)
								{
									++pos;
									break
								}
								if (0 == --depth)
								{
									"(" == ch && (sawSomething = true);
									break
								}
							}
							else if (bracket >= 3 && bracket < 6) ++depth;
							else if (wordRE.test(ch)) sawSomething = true;
							else
							{
								if (/["'\/]/.test(ch)) return;
								if (sawSomething && !depth)
								{
									++pos;
									break
								}
							}
						}
						sawSomething && !depth && (state.fatArrowAt = pos)
					}
					var atomicTypes = {
						atom: true,
						number: true,
						variable: true,
						string: true,
						regexp: true,
						this: true,
						"jsonld-keyword": true
					};

					function JSLexical(indented, column, type, align, prev, info)
					{
						this.indented = indented;
						this.column = column;
						this.type = type;
						this.prev = prev;
						this.info = info;
						null != align && (this.align = align)
					}

					function inScope(state, varname)
					{
						for (var v = state.localVars; v; v = v.next)
							if (v.name == varname) return true;
						for (var cx = state.context; cx; cx = cx.prev)
							for (v = cx.vars; v; v = v.next)
								if (v.name == varname) return true
					}

					function parseJS(state, style, type, content, stream)
					{
						var cc = state.cc;
						cx.state = state;
						cx.stream = stream;
						cx.marked = null, cx.cc = cc;
						cx.style = style;
						state.lexical.hasOwnProperty("align") || (state.lexical.align = true);
						while (true)
						{
							var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
							if (combinator(type, content))
							{
								while (cc.length && cc[cc.length - 1].lex) cc.pop()();
								if (cx.marked) return cx.marked;
								if ("variable" == type && inScope(state, content)) return "variable-2";
								return style
							}
						}
					}
					var cx = {
						state: null,
						column: null,
						marked: null,
						cc: null
					};

					function pass()
					{
						for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i])
					}

					function cont()
					{
						pass.apply(null, arguments);
						return true
					}

					function register(varname)
					{
						function inList(list)
						{
							for (var v = list; v; v = v.next)
								if (v.name == varname) return true;
							return false
						}
						var state = cx.state;
						cx.marked = "def";
						if (state.context)
						{
							if (inList(state.localVars)) return;
							state.localVars = {
								name: varname,
								next: state.localVars
							}
						}
						else
						{
							if (inList(state.globalVars)) return;
							parserConfig.globalVars && (state.globalVars = {
								name: varname,
								next: state.globalVars
							})
						}
					}

					function isModifier(name)
					{
						return "public" == name || "private" == name || "protected" == name || "abstract" == name || "readonly" == name
					}
					var defaultVars = {
						name: "this",
						next:
						{
							name: "arguments"
						}
					};

					function pushcontext()
					{
						cx.state.context = {
							prev: cx.state.context,
							vars: cx.state.localVars
						};
						cx.state.localVars = defaultVars
					}

					function popcontext()
					{
						cx.state.localVars = cx.state.context.vars;
						cx.state.context = cx.state.context.prev
					}

					function pushlex(type, info)
					{
						var result = function result()
						{
							var state = cx.state,
								indent = state.indented;
							if ("stat" == state.lexical.type) indent = state.lexical.indented;
							else
								for (var outer = state.lexical; outer && ")" == outer.type && outer.align; outer = outer.prev) indent = outer.indented;
							state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info)
						};
						result.lex = true;
						return result
					}

					function poplex()
					{
						var state = cx.state;
						if (state.lexical.prev)
						{
							")" == state.lexical.type && (state.indented = state.lexical.indented);
							state.lexical = state.lexical.prev
						}
					}
					poplex.lex = true;

					function expect(wanted)
					{
						function exp(type)
						{
							return type == wanted ? cont() : ";" == wanted ? pass() : cont(exp)
						}
						return exp
					}

					function statement(type, value)
					{
						if ("var" == type) return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
						if ("keyword a" == type) return cont(pushlex("form"), parenExpr, statement, poplex);
						if ("keyword b" == type) return cont(pushlex("form"), statement, poplex);
						if ("keyword d" == type) return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
						if ("debugger" == type) return cont(expect(";"));
						if ("{" == type) return cont(pushlex("}"), block, poplex);
						if (";" == type) return cont();
						if ("if" == type)
						{
							"else" == cx.state.lexical.info && cx.state.cc[cx.state.cc.length - 1] == poplex && cx.state.cc.pop()();
							return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse)
						}
						if ("function" == type) return cont(functiondef);
						if ("for" == type) return cont(pushlex("form"), forspec, statement, poplex);
						if ("class" == type || isTS && "interface" == value)
						{
							cx.marked = "keyword";
							return cont(pushlex("form"), className, poplex)
						}
						if ("variable" == type)
						{
							if (isTS && "declare" == value)
							{
								cx.marked = "keyword";
								return cont(statement)
							}
							if (isTS && ("module" == value || "enum" == value || "type" == value) && cx.stream.match(/^\s*\w/, false))
							{
								cx.marked = "keyword";
								return "enum" == value ? cont(enumdef) : "type" == value ? cont(typeexpr, expect("operator"), typeexpr, expect(";")) : cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
							}
							if (isTS && "namespace" == value)
							{
								cx.marked = "keyword";
								return cont(pushlex("form"), expression, block, poplex)
							}
							if (isTS && "abstract" == value)
							{
								cx.marked = "keyword";
								return cont(statement)
							}
							return cont(pushlex("stat"), maybelabel)
						}
						if ("switch" == type) return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), block, poplex, poplex);
						if ("case" == type) return cont(expression, expect(":"));
						if ("default" == type) return cont(expect(":"));
						if ("catch" == type) return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext);
						if ("export" == type) return cont(pushlex("stat"), afterExport, poplex);
						if ("import" == type) return cont(pushlex("stat"), afterImport, poplex);
						if ("async" == type) return cont(statement);
						if ("@" == value) return cont(expression, statement);
						return pass(pushlex("stat"), expression, expect(";"), poplex)
					}

					function expression(type, value)
					{
						return expressionInner(type, value, false)
					}

					function expressionNoComma(type, value)
					{
						return expressionInner(type, value, true)
					}

					function parenExpr(type)
					{
						if ("(" != type) return pass();
						return cont(pushlex(")"), expression, expect(")"), poplex)
					}

					function expressionInner(type, value, noComma)
					{
						if (cx.state.fatArrowAt == cx.stream.start)
						{
							var body = noComma ? arrowBodyNoComma : arrowBody;
							if ("(" == type) return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
							if ("variable" == type) return pass(pushcontext, pattern, expect("=>"), body, popcontext)
						}
						var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
						if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
						if ("function" == type) return cont(functiondef, maybeop);
						if ("class" == type || isTS && "interface" == value)
						{
							cx.marked = "keyword";
							return cont(pushlex("form"), classExpression, poplex)
						}
						if ("keyword c" == type || "async" == type) return cont(noComma ? expressionNoComma : expression);
						if ("(" == type) return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
						if ("operator" == type || "spread" == type) return cont(noComma ? expressionNoComma : expression);
						if ("[" == type) return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
						if ("{" == type) return contCommasep(objprop, "}", null, maybeop);
						if ("quasi" == type) return pass(quasi, maybeop);
						if ("new" == type) return cont(maybeTarget(noComma));
						if ("import" == type) return cont(expression);
						return cont()
					}

					function maybeexpression(type)
					{
						if (type.match(/[;\}\)\],]/)) return pass();
						return pass(expression)
					}

					function maybeoperatorComma(type, value)
					{
						if ("," == type) return cont(expression);
						return maybeoperatorNoComma(type, value, false)
					}

					function maybeoperatorNoComma(type, value, noComma)
					{
						var me = false == noComma ? maybeoperatorComma : maybeoperatorNoComma;
						var expr = false == noComma ? expression : expressionNoComma;
						if ("=>" == type) return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
						if ("operator" == type)
						{
							if (/\+\+|--/.test(value) || isTS && "!" == value) return cont(me);
							if (isTS && "<" == value && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false)) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
							if ("?" == value) return cont(expression, expect(":"), expr);
							return cont(expr)
						}
						if ("quasi" == type) return pass(quasi, me);
						if (";" == type) return;
						if ("(" == type) return contCommasep(expressionNoComma, ")", "call", me);
						if ("." == type) return cont(property, me);
						if ("[" == type) return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
						if (isTS && "as" == value)
						{
							cx.marked = "keyword";
							return cont(typeexpr, me)
						}
						if ("regexp" == type)
						{
							cx.state.lastType = cx.marked = "operator";
							cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
							return cont(expr)
						}
					}

					function quasi(type, value)
					{
						if ("quasi" != type) return pass();
						if ("${" != value.slice(value.length - 2)) return cont(quasi);
						return cont(expression, continueQuasi)
					}

					function continueQuasi(type)
					{
						if ("}" == type)
						{
							cx.marked = "string-2";
							cx.state.tokenize = tokenQuasi;
							return cont(quasi)
						}
					}

					function arrowBody(type)
					{
						findFatArrow(cx.stream, cx.state);
						return pass("{" == type ? statement : expression)
					}

					function arrowBodyNoComma(type)
					{
						findFatArrow(cx.stream, cx.state);
						return pass("{" == type ? statement : expressionNoComma)
					}

					function maybeTarget(noComma)
					{
						return function (type)
						{
							return "." == type ? cont(noComma ? targetNoComma : target) : "variable" == type && isTS ? cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma) : pass(noComma ? expressionNoComma : expression)
						}
					}

					function target(_, value)
					{
						if ("target" == value)
						{
							cx.marked = "keyword";
							return cont(maybeoperatorComma)
						}
					}

					function targetNoComma(_, value)
					{
						if ("target" == value)
						{
							cx.marked = "keyword";
							return cont(maybeoperatorNoComma)
						}
					}

					function maybelabel(type)
					{
						if (":" == type) return cont(poplex, statement);
						return pass(maybeoperatorComma, expect(";"), poplex)
					}

					function property(type)
					{
						if ("variable" == type)
						{
							cx.marked = "property";
							return cont()
						}
					}

					function objprop(type, value)
					{
						if ("async" == type)
						{
							cx.marked = "property";
							return cont(objprop)
						}
						if ("variable" == type || "keyword" == cx.style)
						{
							cx.marked = "property";
							if ("get" == value || "set" == value) return cont(getterSetter);
							var m;
							isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)) && (cx.state.fatArrowAt = cx.stream.pos + m[0].length);
							return cont(afterprop)
						}
						if ("number" == type || "string" == type)
						{
							cx.marked = jsonldMode ? "property" : cx.style + " property";
							return cont(afterprop)
						}
						if ("jsonld-keyword" == type) return cont(afterprop);
						if (isTS && isModifier(value))
						{
							cx.marked = "keyword";
							return cont(objprop)
						}
						if ("[" == type) return cont(expression, maybetype, expect("]"), afterprop);
						if ("spread" == type) return cont(expressionNoComma, afterprop);
						if ("*" == value)
						{
							cx.marked = "keyword";
							return cont(objprop)
						}
						if (":" == type) return pass(afterprop)
					}

					function getterSetter(type)
					{
						if ("variable" != type) return pass(afterprop);
						cx.marked = "property";
						return cont(functiondef)
					}

					function afterprop(type)
					{
						if (":" == type) return cont(expressionNoComma);
						if ("(" == type) return pass(functiondef)
					}

					function commasep(what, end, sep)
					{
						function proceed(type, value)
						{
							if (sep ? sep.indexOf(type) > -1 : "," == type)
							{
								var lex = cx.state.lexical;
								"call" == lex.info && (lex.pos = (lex.pos || 0) + 1);
								return cont(function (type, value)
								{
									if (type == end || value == end) return pass();
									return pass(what)
								}, proceed)
							}
							if (type == end || value == end) return cont();
							return cont(expect(end))
						}
						return function (type, value)
						{
							if (type == end || value == end) return cont();
							return pass(what, proceed)
						}
					}

					function contCommasep(what, end, info)
					{
						for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);
						return cont(pushlex(end, info), commasep(what, end), poplex)
					}

					function block(type)
					{
						if ("}" == type) return cont();
						return pass(statement, block)
					}

					function maybetype(type, value)
					{
						if (isTS)
						{
							if (":" == type) return cont(typeexpr);
							if ("?" == value) return cont(maybetype)
						}
					}

					function mayberettype(type)
					{
						if (isTS && ":" == type) return cx.stream.match(/^\s*\w+\s+is\b/, false) ? cont(expression, isKW, typeexpr) : cont(typeexpr)
					}

					function isKW(_, value)
					{
						if ("is" == value)
						{
							cx.marked = "keyword";
							return cont()
						}
					}

					function typeexpr(type, value)
					{
						if ("keyof" == value || "typeof" == value)
						{
							cx.marked = "keyword";
							return cont("keyof" == value ? typeexpr : expressionNoComma)
						}
						if ("variable" == type || "void" == value)
						{
							cx.marked = "type";
							return cont(afterType)
						}
						if ("string" == type || "number" == type || "atom" == type) return cont(afterType);
						if ("[" == type) return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
						if ("{" == type) return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType);
						if ("(" == type) return cont(commasep(typearg, ")"), maybeReturnType);
						if ("<" == type) return cont(commasep(typeexpr, ">"), typeexpr)
					}

					function maybeReturnType(type)
					{
						if ("=>" == type) return cont(typeexpr)
					}

					function typeprop(type, value)
					{
						if ("variable" == type || "keyword" == cx.style)
						{
							cx.marked = "property";
							return cont(typeprop)
						}
						if ("?" == value) return cont(typeprop);
						if (":" == type) return cont(typeexpr);
						if ("[" == type) return cont(expression, maybetype, expect("]"), typeprop)
					}

					function typearg(type, value)
					{
						if ("variable" == type && cx.stream.match(/^\s*[?:]/, false) || "?" == value) return cont(typearg);
						if (":" == type) return cont(typeexpr);
						return pass(typeexpr)
					}

					function afterType(type, value)
					{
						if ("<" == value) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
						if ("|" == value || "." == type || "&" == value) return cont(typeexpr);
						if ("[" == type) return cont(expect("]"), afterType);
						if ("extends" == value || "implements" == value)
						{
							cx.marked = "keyword";
							return cont(typeexpr)
						}
					}

					function maybeTypeArgs(_, value)
					{
						if ("<" == value) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
					}

					function typeparam()
					{
						return pass(typeexpr, maybeTypeDefault)
					}

					function maybeTypeDefault(_, value)
					{
						if ("=" == value) return cont(typeexpr)
					}

					function vardef(_, value)
					{
						if ("enum" == value)
						{
							cx.marked = "keyword";
							return cont(enumdef)
						}
						return pass(pattern, maybetype, maybeAssign, vardefCont)
					}

					function pattern(type, value)
					{
						if (isTS && isModifier(value))
						{
							cx.marked = "keyword";
							return cont(pattern)
						}
						if ("variable" == type)
						{
							register(value);
							return cont()
						}
						if ("spread" == type) return cont(pattern);
						if ("[" == type) return contCommasep(pattern, "]");
						if ("{" == type) return contCommasep(proppattern, "}")
					}

					function proppattern(type, value)
					{
						if ("variable" == type && !cx.stream.match(/^\s*:/, false))
						{
							register(value);
							return cont(maybeAssign)
						}
						"variable" == type && (cx.marked = "property");
						if ("spread" == type) return cont(pattern);
						if ("}" == type) return pass();
						return cont(expect(":"), pattern, maybeAssign)
					}

					function maybeAssign(_type, value)
					{
						if ("=" == value) return cont(expressionNoComma)
					}

					function vardefCont(type)
					{
						if ("," == type) return cont(vardef)
					}

					function maybeelse(type, value)
					{
						if ("keyword b" == type && "else" == value) return cont(pushlex("form", "else"), statement, poplex)
					}

					function forspec(type, value)
					{
						if ("await" == value) return cont(forspec);
						if ("(" == type) return cont(pushlex(")"), forspec1, expect(")"), poplex)
					}

					function forspec1(type)
					{
						if ("var" == type) return cont(vardef, expect(";"), forspec2);
						if (";" == type) return cont(forspec2);
						if ("variable" == type) return cont(formaybeinof);
						return pass(expression, expect(";"), forspec2)
					}

					function formaybeinof(_type, value)
					{
						if ("in" == value || "of" == value)
						{
							cx.marked = "keyword";
							return cont(expression)
						}
						return cont(maybeoperatorComma, forspec2)
					}

					function forspec2(type, value)
					{
						if (";" == type) return cont(forspec3);
						if ("in" == value || "of" == value)
						{
							cx.marked = "keyword";
							return cont(expression)
						}
						return pass(expression, expect(";"), forspec3)
					}

					function forspec3(type)
					{
						")" != type && cont(expression)
					}

					function functiondef(type, value)
					{
						if ("*" == value)
						{
							cx.marked = "keyword";
							return cont(functiondef)
						}
						if ("variable" == type)
						{
							register(value);
							return cont(functiondef)
						}
						if ("(" == type) return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
						if (isTS && "<" == value) return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
					}

					function funarg(type, value)
					{
						"@" == value && cont(expression, funarg);
						if ("spread" == type) return cont(funarg);
						if (isTS && isModifier(value))
						{
							cx.marked = "keyword";
							return cont(funarg)
						}
						return pass(pattern, maybetype, maybeAssign)
					}

					function classExpression(type, value)
					{
						if ("variable" == type) return className(type, value);
						return classNameAfter(type, value)
					}

					function className(type, value)
					{
						if ("variable" == type)
						{
							register(value);
							return cont(classNameAfter)
						}
					}

					function classNameAfter(type, value)
					{
						if ("<" == value) return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
						if ("extends" == value || "implements" == value || isTS && "," == type)
						{
							"implements" == value && (cx.marked = "keyword");
							return cont(isTS ? typeexpr : expression, classNameAfter)
						}
						if ("{" == type) return cont(pushlex("}"), classBody, poplex)
					}

					function classBody(type, value)
					{
						if ("async" == type || "variable" == type && ("static" == value || "get" == value || "set" == value || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))
						{
							cx.marked = "keyword";
							return cont(classBody)
						}
						if ("variable" == type || "keyword" == cx.style)
						{
							cx.marked = "property";
							return cont(isTS ? classfield : functiondef, classBody)
						}
						if ("[" == type) return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody);
						if ("*" == value)
						{
							cx.marked = "keyword";
							return cont(classBody)
						}
						if (";" == type) return cont(classBody);
						if ("}" == type) return cont();
						if ("@" == value) return cont(expression, classBody)
					}

					function classfield(type, value)
					{
						if ("?" == value) return cont(classfield);
						if (":" == type) return cont(typeexpr, maybeAssign);
						if ("=" == value) return cont(expressionNoComma);
						return pass(functiondef)
					}

					function afterExport(type, value)
					{
						if ("*" == value)
						{
							cx.marked = "keyword";
							return cont(maybeFrom, expect(";"))
						}
						if ("default" == value)
						{
							cx.marked = "keyword";
							return cont(expression, expect(";"))
						}
						if ("{" == type) return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
						return pass(statement)
					}

					function exportField(type, value)
					{
						if ("as" == value)
						{
							cx.marked = "keyword";
							return cont(expect("variable"))
						}
						if ("variable" == type) return pass(expressionNoComma, exportField)
					}

					function afterImport(type)
					{
						if ("string" == type) return cont();
						if ("(" == type) return pass(expression);
						return pass(importSpec, maybeMoreImports, maybeFrom)
					}

					function importSpec(type, value)
					{
						if ("{" == type) return contCommasep(importSpec, "}");
						"variable" == type && register(value);
						"*" == value && (cx.marked = "keyword");
						return cont(maybeAs)
					}

					function maybeMoreImports(type)
					{
						if ("," == type) return cont(importSpec, maybeMoreImports)
					}

					function maybeAs(_type, value)
					{
						if ("as" == value)
						{
							cx.marked = "keyword";
							return cont(importSpec)
						}
					}

					function maybeFrom(_type, value)
					{
						if ("from" == value)
						{
							cx.marked = "keyword";
							return cont(expression)
						}
					}

					function arrayLiteral(type)
					{
						if ("]" == type) return cont();
						return pass(commasep(expressionNoComma, "]"))
					}

					function enumdef()
					{
						return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
					}

					function enummember()
					{
						return pass(pattern, maybeAssign)
					}

					function isContinuedStatement(state, textAfter)
					{
						return "operator" == state.lastType || "," == state.lastType || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0))
					}

					function expressionAllowed(stream, state, backUp)
					{
						return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || "quasi" == state.lastType && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)))
					}
					return {
						startState: function startState(basecolumn)
						{
							var state = {
								tokenize: tokenBase,
								lastType: "sof",
								cc: [],
								lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
								localVars: parserConfig.localVars,
								context: parserConfig.localVars &&
								{
									vars: parserConfig.localVars
								},
								indented: basecolumn || 0
							};
							parserConfig.globalVars && "object" == _typeof(parserConfig.globalVars) && (state.globalVars = parserConfig.globalVars);
							return state
						},
						token: function token(stream, state)
						{
							if (stream.sol())
							{
								state.lexical.hasOwnProperty("align") || (state.lexical.align = false);
								state.indented = stream.indentation();
								findFatArrow(stream, state)
							}
							if (state.tokenize != tokenComment && stream.eatSpace()) return null;
							var style = state.tokenize(stream, state);
							if ("comment" == type) return style;
							state.lastType = "operator" != type || "++" != content && "--" != content ? type : "incdec";
							return parseJS(state, style, type, content, stream)
						},
						indent: function indent(state, textAfter)
						{
							if (state.tokenize == tokenComment) return CodeMirror.Pass;
							if (state.tokenize != tokenBase) return 0;
							var top, firstChar = textAfter && textAfter.charAt(0),
								lexical = state.lexical;
							if (!/^\s*else\b/.test(textAfter))
								for (var i = state.cc.length - 1; i >= 0; --i)
								{
									var c = state.cc[i];
									if (c == poplex) lexical = lexical.prev;
									else if (c != maybeelse) break
								}
							while (("stat" == lexical.type || "form" == lexical.type) && ("}" == firstChar || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter))) lexical = lexical.prev;
							statementIndent && ")" == lexical.type && "stat" == lexical.prev.type && (lexical = lexical.prev);
							var type = lexical.type,
								closing = firstChar == type;
							return "vardef" == type ? lexical.indented + ("operator" == state.lastType || "," == state.lastType ? lexical.info + 1 : 0) : "form" == type && "{" == firstChar ? lexical.indented : "form" == type ? lexical.indented + indentUnit : "stat" == type ? lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0) : "switch" != lexical.info || closing || false == parserConfig.doubleIndentSwitch ? lexical.align ? lexical.column + (closing ? 0 : 1) : lexical.indented + (closing ? 0 : indentUnit) : lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit)
						},
						electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
						blockCommentStart: jsonMode ? null : "/*",
						blockCommentEnd: jsonMode ? null : "*/",
						blockCommentContinue: jsonMode ? null : " * ",
						lineComment: jsonMode ? null : "//",
						fold: "brace",
						closeBrackets: "()[]{}''\"\"``",
						helperType: jsonMode ? "json" : "javascript",
						jsonldMode: jsonldMode,
						jsonMode: jsonMode,
						expressionAllowed: expressionAllowed,
						skipExpression: function skipExpression(state)
						{
							var top = state.cc[state.cc.length - 1];
							top != expression && top != expressionNoComma || state.cc.pop()
						}
					}
				});
				CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
				CodeMirror.defineMIME("text/javascript", "javascript");
				CodeMirror.defineMIME("text/ecmascript", "javascript");
				CodeMirror.defineMIME("application/javascript", "javascript");
				CodeMirror.defineMIME("application/x-javascript", "javascript");
				CodeMirror.defineMIME("application/ecmascript", "javascript");
				CodeMirror.defineMIME("application/json",
				{
					name: "javascript",
					json: true
				});
				CodeMirror.defineMIME("application/x-json",
				{
					name: "javascript",
					json: true
				});
				CodeMirror.defineMIME("application/ld+json",
				{
					name: "javascript",
					jsonld: true
				});
				CodeMirror.defineMIME("text/typescript",
				{
					name: "javascript",
					typescript: true
				});
				CodeMirror.defineMIME("application/typescript",
				{
					name: "javascript",
					typescript: true
				})
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	5232: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				var htmlConfig = {
					autoSelfClosers:
					{
						area: true,
						base: true,
						br: true,
						col: true,
						command: true,
						embed: true,
						frame: true,
						hr: true,
						img: true,
						input: true,
						keygen: true,
						link: true,
						meta: true,
						param: true,
						source: true,
						track: true,
						wbr: true,
						menuitem: true
					},
					implicitlyClosed:
					{
						dd: true,
						li: true,
						optgroup: true,
						option: true,
						p: true,
						rp: true,
						rt: true,
						tbody: true,
						td: true,
						tfoot: true,
						th: true,
						tr: true
					},
					contextGrabbers:
					{
						dd:
						{
							dd: true,
							dt: true
						},
						dt:
						{
							dd: true,
							dt: true
						},
						li:
						{
							li: true
						},
						option:
						{
							option: true,
							optgroup: true
						},
						optgroup:
						{
							optgroup: true
						},
						p:
						{
							address: true,
							article: true,
							aside: true,
							blockquote: true,
							dir: true,
							div: true,
							dl: true,
							fieldset: true,
							footer: true,
							form: true,
							h1: true,
							h2: true,
							h3: true,
							h4: true,
							h5: true,
							h6: true,
							header: true,
							hgroup: true,
							hr: true,
							menu: true,
							nav: true,
							ol: true,
							p: true,
							pre: true,
							section: true,
							table: true,
							ul: true
						},
						rp:
						{
							rp: true,
							rt: true
						},
						rt:
						{
							rp: true,
							rt: true
						},
						tbody:
						{
							tbody: true,
							tfoot: true
						},
						td:
						{
							td: true,
							th: true
						},
						tfoot:
						{
							tbody: true
						},
						th:
						{
							td: true,
							th: true
						},
						thead:
						{
							tbody: true,
							tfoot: true
						},
						tr:
						{
							tr: true
						}
					},
					doNotIndent:
					{
						pre: true
					},
					allowUnquoted: true,
					allowMissing: true,
					caseFold: true
				};
				var xmlConfig = {
					autoSelfClosers:
					{},
					implicitlyClosed:
					{},
					contextGrabbers:
					{},
					doNotIndent:
					{},
					allowUnquoted: false,
					allowMissing: false,
					allowMissingTagName: false,
					caseFold: false
				};
				CodeMirror.defineMode("xml", function (editorConf, config_)
				{
					var indentUnit = editorConf.indentUnit;
					var config = {};
					var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
					for (var prop in defaults) config[prop] = defaults[prop];
					for (var prop in config_) config[prop] = config_[prop];
					var type, setStyle;

					function inText(stream, state)
					{
						function chain(parser)
						{
							state.tokenize = parser;
							return parser(stream, state)
						}
						var ch = stream.next();
						if ("<" == ch)
						{
							if (stream.eat("!"))
							{
								if (stream.eat("[")) return stream.match("CDATA[") ? chain(inBlock("atom", "]]>")) : null;
								if (stream.match("--")) return chain(inBlock("comment", "-->"));
								if (stream.match("DOCTYPE", true, true))
								{
									stream.eatWhile(/[\w\._\-]/);
									return chain(doctype(1))
								}
								return null
							}
							if (stream.eat("?"))
							{
								stream.eatWhile(/[\w\._\-]/);
								state.tokenize = inBlock("meta", "?>");
								return "meta"
							}
							type = stream.eat("/") ? "closeTag" : "openTag";
							state.tokenize = inTag;
							return "tag bracket"
						}
						if ("&" == ch)
						{
							var ok;
							ok = stream.eat("#") ? stream.eat("x") ? stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";") : stream.eatWhile(/[\d]/) && stream.eat(";") : stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
							return ok ? "atom" : "error"
						}
						stream.eatWhile(/[^&<]/);
						return null
					}
					inText.isInText = true;

					function inTag(stream, state)
					{
						var ch = stream.next();
						if (">" == ch || "/" == ch && stream.eat(">"))
						{
							state.tokenize = inText;
							type = ">" == ch ? "endTag" : "selfcloseTag";
							return "tag bracket"
						}
						if ("=" == ch)
						{
							type = "equals";
							return null
						}
						if ("<" == ch)
						{
							state.tokenize = inText;
							state.state = baseState;
							state.tagName = state.tagStart = null;
							var next = state.tokenize(stream, state);
							return next ? next + " tag error" : "tag error"
						}
						if (/[\'\"]/.test(ch))
						{
							state.tokenize = inAttribute(ch);
							state.stringStartCol = stream.column();
							return state.tokenize(stream, state)
						}
						stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
						return "word"
					}

					function inAttribute(quote)
					{
						var closure = function closure(stream, state)
						{
							while (!stream.eol())
								if (stream.next() == quote)
								{
									state.tokenize = inTag;
									break
								}
							return "string"
						};
						closure.isInAttribute = true;
						return closure
					}

					function inBlock(style, terminator)
					{
						return function (stream, state)
						{
							while (!stream.eol())
							{
								if (stream.match(terminator))
								{
									state.tokenize = inText;
									break
								}
								stream.next()
							}
							return style
						}
					}

					function doctype(depth)
					{
						return function (stream, state)
						{
							var ch;
							while (null != (ch = stream.next()))
							{
								if ("<" == ch)
								{
									state.tokenize = doctype(depth + 1);
									return state.tokenize(stream, state)
								}
								if (">" == ch)
								{
									if (1 == depth)
									{
										state.tokenize = inText;
										break
									}
									state.tokenize = doctype(depth - 1);
									return state.tokenize(stream, state)
								}
							}
							return "meta"
						}
					}

					function Context(state, tagName, startOfLine)
					{
						this.prev = state.context;
						this.tagName = tagName;
						this.indent = state.indented;
						this.startOfLine = startOfLine;
						(config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) && (this.noIndent = true)
					}

					function popContext(state)
					{
						state.context && (state.context = state.context.prev)
					}

					function maybePopContext(state, nextTagName)
					{
						var parentTagName;
						while (true)
						{
							if (!state.context) return;
							parentTagName = state.context.tagName;
							if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) return;
							popContext(state)
						}
					}

					function baseState(type, stream, state)
					{
						if ("openTag" == type)
						{
							state.tagStart = stream.column();
							return tagNameState
						}
						return "closeTag" == type ? closeTagNameState : baseState
					}

					function tagNameState(type, stream, state)
					{
						if ("word" == type)
						{
							state.tagName = stream.current();
							setStyle = "tag";
							return attrState
						}
						if (config.allowMissingTagName && "endTag" == type)
						{
							setStyle = "tag bracket";
							return attrState(type, stream, state)
						}
						setStyle = "error";
						return tagNameState
					}

					function closeTagNameState(type, stream, state)
					{
						if ("word" == type)
						{
							var tagName = stream.current();
							state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName) && popContext(state);
							if (state.context && state.context.tagName == tagName || false === config.matchClosing)
							{
								setStyle = "tag";
								return closeState
							}
							setStyle = "tag error";
							return closeStateErr
						}
						if (config.allowMissingTagName && "endTag" == type)
						{
							setStyle = "tag bracket";
							return closeState(type, stream, state)
						}
						setStyle = "error";
						return closeStateErr
					}

					function closeState(type, _stream, state)
					{
						if ("endTag" != type)
						{
							setStyle = "error";
							return closeState
						}
						popContext(state);
						return baseState
					}

					function closeStateErr(type, stream, state)
					{
						setStyle = "error";
						return closeState(type, stream, state)
					}

					function attrState(type, _stream, state)
					{
						if ("word" == type)
						{
							setStyle = "attribute";
							return attrEqState
						}
						if ("endTag" == type || "selfcloseTag" == type)
						{
							var tagName = state.tagName,
								tagStart = state.tagStart;
							state.tagName = state.tagStart = null;
							if ("selfcloseTag" == type || config.autoSelfClosers.hasOwnProperty(tagName)) maybePopContext(state, tagName);
							else
							{
								maybePopContext(state, tagName);
								state.context = new Context(state, tagName, tagStart == state.indented)
							}
							return baseState
						}
						setStyle = "error";
						return attrState
					}

					function attrEqState(type, stream, state)
					{
						if ("equals" == type) return attrValueState;
						config.allowMissing || (setStyle = "error");
						return attrState(type, stream, state)
					}

					function attrValueState(type, stream, state)
					{
						if ("string" == type) return attrContinuedState;
						if ("word" == type && config.allowUnquoted)
						{
							setStyle = "string";
							return attrState
						}
						setStyle = "error";
						return attrState(type, stream, state)
					}

					function attrContinuedState(type, stream, state)
					{
						if ("string" == type) return attrContinuedState;
						return attrState(type, stream, state)
					}
					return {
						startState: function startState(baseIndent)
						{
							var state = {
								tokenize: inText,
								state: baseState,
								indented: baseIndent || 0,
								tagName: null,
								tagStart: null,
								context: null
							};
							null != baseIndent && (state.baseIndent = baseIndent);
							return state
						},
						token: function token(stream, state)
						{
							!state.tagName && stream.sol() && (state.indented = stream.indentation());
							if (stream.eatSpace()) return null;
							type = null;
							var style = state.tokenize(stream, state);
							if ((style || type) && "comment" != style)
							{
								setStyle = null;
								state.state = state.state(type || style, stream, state);
								setStyle && (style = "error" == setStyle ? style + " error" : setStyle)
							}
							return style
						},
						indent: function indent(state, textAfter, fullLine)
						{
							var context = state.context;
							if (state.tokenize.isInAttribute) return state.tagStart == state.indented ? state.stringStartCol + 1 : state.indented + indentUnit;
							if (context && context.noIndent) return CodeMirror.Pass;
							if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
							if (state.tagName) return false !== config.multilineTagIndentPastTag ? state.tagStart + state.tagName.length + 2 : state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
							if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
							var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
							if (tagAfter && tagAfter[1])
								while (context)
								{
									if (context.tagName == tagAfter[2])
									{
										context = context.prev;
										break
									}
									if (!config.implicitlyClosed.hasOwnProperty(context.tagName)) break;
									context = context.prev
								}
							else if (tagAfter)
								while (context)
								{
									var grabbers = config.contextGrabbers[context.tagName];
									if (!grabbers || !grabbers.hasOwnProperty(tagAfter[2])) break;
									context = context.prev
								}
							while (context && context.prev && !context.startOfLine) context = context.prev;
							return context ? context.indent + indentUnit : state.baseIndent || 0
						},
						electricInput: /<\/[\s\w:]+>$/,
						blockCommentStart: "<!--",
						blockCommentEnd: "-->",
						configuration: config.htmlMode ? "html" : "xml",
						helperType: config.htmlMode ? "html" : "xml",
						skipAttribute: function skipAttribute(state)
						{
							state.state == attrValueState && (state.state = attrState)
						}
					}
				});
				CodeMirror.defineMIME("text/xml", "xml");
				CodeMirror.defineMIME("application/xml", "xml");
				CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html",
				{
					name: "xml",
					htmlMode: true
				})
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	5233: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58), __webpack_require__(484));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58), __webpack_require__(484)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				CodeMirror.extendMode("css",
				{
					commentStart: "/*",
					commentEnd: "*/",
					newlineAfterToken: function newlineAfterToken(type, content)
					{
						return /^[;{}]$/.test(content)
					}
				});
				CodeMirror.extendMode("javascript",
				{
					commentStart: "/*",
					commentEnd: "*/",
					newlineAfterToken: function newlineAfterToken(type, content, textAfter, state)
					{
						if (this.jsonMode) return /^[\[,{]$/.test(content) || /^}/.test(textAfter);
						if (";" == content && state.lexical && ")" == state.lexical.type) return false;
						return /^[;{}]$/.test(content) && !/^;/.test(textAfter)
					}
				});
				CodeMirror.extendMode("xml",
				{
					commentStart: "<!--",
					commentEnd: "-->",
					newlineAfterToken: function newlineAfterToken(type, content, textAfter)
					{
						return "tag" == type && />$/.test(content) || /^</.test(textAfter)
					}
				});
				CodeMirror.defineExtension("commentRange", function (isComment, from, to)
				{
					var cm = this,
						curMode = CodeMirror.innerMode(cm.getMode(), cm.getTokenAt(from).state).mode;
					cm.operation(function ()
					{
						if (isComment)
						{
							cm.replaceRange(curMode.commentEnd, to);
							cm.replaceRange(curMode.commentStart, from);
							from.line == to.line && from.ch == to.ch && cm.setCursor(from.line, from.ch + curMode.commentStart.length)
						}
						else
						{
							var selText = cm.getRange(from, to);
							var startIndex = selText.indexOf(curMode.commentStart);
							var endIndex = selText.lastIndexOf(curMode.commentEnd);
							startIndex > -1 && endIndex > -1 && endIndex > startIndex && (selText = selText.substr(0, startIndex) + selText.substring(startIndex + curMode.commentStart.length, endIndex) + selText.substr(endIndex + curMode.commentEnd.length));
							cm.replaceRange(selText, from, to)
						}
					})
				});
				CodeMirror.defineExtension("autoIndentRange", function (from, to)
				{
					var cmInstance = this;
					this.operation(function ()
					{
						for (var i = from.line; i <= to.line; i++) cmInstance.indentLine(i, "smart")
					})
				});
				CodeMirror.defineExtension("autoFormatRange", function (from, to)
				{
					var cm = this;
					var outer = cm.getMode(),
						text = cm.getRange(from, to).split("\n");
					var state = CodeMirror.copyState(outer, cm.getTokenAt(from).state);
					var tabSize = cm.getOption("tabSize");
					var out = "",
						lines = 0,
						atSol = 0 == from.ch;

					function newline()
					{
						out += "\n";
						atSol = true;
						++lines
					}
					for (var i = 0; i < text.length; ++i)
					{
						var stream = new CodeMirror.StringStream(text[i], tabSize);
						while (!stream.eol())
						{
							var inner = CodeMirror.innerMode(outer, state);
							var style = outer.token(stream, state),
								cur = stream.current();
							stream.start = stream.pos;
							if (!atSol || /\S/.test(cur))
							{
								out += cur;
								atSol = false
							}
							var noBreak = false;
							var trimed = out.trim();
							">" != trimed[trimed.length - 1] && (noBreak = true);
							!noBreak && !atSol && inner.mode.newlineAfterToken && inner.mode.newlineAfterToken(style, cur, stream.string.slice(stream.pos) || text[i + 1] || "", inner.state) && newline()
						}!stream.pos && outer.blankLine && outer.blankLine(state);
						atSol || newline()
					}
					cm.operation(function ()
					{
						cm.replaceRange(out, from, to);
						for (var cur = from.line + 1, end = from.line + lines; cur <= end; ++cur) cm.indentLine(cur, "smart");
						cm.setSelection(from, cm.getCursor(false))
					})
				})
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	5234: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				CodeMirror.registerHelper("fold", "brace", function (cm, start)
				{
					var line = start.line,
						lineText = cm.getLine(line);
					var tokenType;

					function findOpening(openCh)
					{
						for (var at = start.ch, pass = 0;;)
						{
							var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
							if (-1 == found)
							{
								if (1 == pass) break;
								pass = 1;
								at = lineText.length;
								continue
							}
							if (1 == pass && found < start.ch) break;
							tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));
							if (!/^(comment|string)/.test(tokenType)) return found + 1;
							at = found - 1
						}
					}
					var startToken = "{",
						endToken = "}",
						startCh = findOpening("{");
					if (null == startCh)
					{
						startToken = "[", endToken = "]";
						startCh = findOpening("[")
					}
					if (null == startCh) return;
					var end, endCh, count = 1,
						lastLine = cm.lastLine();
					outer: for (var i = line; i <= lastLine; ++i)
					{
						var text = cm.getLine(i),
							pos = i == line ? startCh : 0;
						for (;;)
						{
							var nextOpen = text.indexOf(startToken, pos),
								nextClose = text.indexOf(endToken, pos);
							nextOpen < 0 && (nextOpen = text.length);
							nextClose < 0 && (nextClose = text.length);
							pos = Math.min(nextOpen, nextClose);
							if (pos == text.length) break;
							if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType)
								if (pos == nextOpen) ++count;
								else if (!--count)
							{
								end = i;
								endCh = pos;
								break outer
							}++pos
						}
					}
					if (null == end || line == end && endCh == startCh) return;
					return {
						from: CodeMirror.Pos(line, startCh),
						to: CodeMirror.Pos(end, endCh)
					}
				});
				CodeMirror.registerHelper("fold", "import", function (cm, start)
				{
					function hasImport(line)
					{
						if (line < cm.firstLine() || line > cm.lastLine()) return null;
						var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
						/\S/.test(start.string) || (start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1)));
						if ("keyword" != start.type || "import" != start.string) return null;
						for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i)
						{
							var text = cm.getLine(i),
								semi = text.indexOf(";");
							if (-1 != semi) return {
								startCh: start.end,
								end: CodeMirror.Pos(i, semi)
							}
						}
					}
					var prev, startLine = start.line,
						has = hasImport(startLine);
					if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1) return null;
					for (var end = has.end;;)
					{
						var next = hasImport(end.line + 1);
						if (null == next) break;
						end = next.end
					}
					return {
						from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)),
						to: end
					}
				});
				CodeMirror.registerHelper("fold", "include", function (cm, start)
				{
					function hasInclude(line)
					{
						if (line < cm.firstLine() || line > cm.lastLine()) return null;
						var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
						/\S/.test(start.string) || (start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1)));
						if ("meta" == start.type && "#include" == start.string.slice(0, 8)) return start.start + 8
					}
					var startLine = start.line,
						has = hasInclude(startLine);
					if (null == has || null != hasInclude(startLine - 1)) return null;
					for (var end = startLine;;)
					{
						var next = hasInclude(end + 1);
						if (null == next) break;
						++end
					}
					return {
						from: CodeMirror.Pos(startLine, has + 1),
						to: cm.clipPos(CodeMirror.Pos(end))
					}
				})
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	5235: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58), __webpack_require__(484));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58), __webpack_require__(484)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				CodeMirror.defineOption("foldGutter", false, function (cm, val, old)
				{
					if (old && old != CodeMirror.Init)
					{
						cm.clearGutter(cm.state.foldGutter.options.gutter);
						cm.state.foldGutter = null;
						cm.off("gutterClick", onGutterClick);
						cm.off("change", onChange);
						cm.off("viewportChange", onViewportChange);
						cm.off("fold", onFold);
						cm.off("unfold", onFold);
						cm.off("swapDoc", onChange)
					}
					if (val)
					{
						cm.state.foldGutter = new State(parseOptions(val));
						updateInViewport(cm);
						cm.on("gutterClick", onGutterClick);
						cm.on("change", onChange);
						cm.on("viewportChange", onViewportChange);
						cm.on("fold", onFold);
						cm.on("unfold", onFold);
						cm.on("swapDoc", onChange)
					}
				});
				var Pos = CodeMirror.Pos;

				function State(options)
				{
					this.options = options;
					this.from = this.to = 0
				}

				function parseOptions(opts)
				{
					true === opts && (opts = {});
					null == opts.gutter && (opts.gutter = "CodeMirror-foldgutter");
					null == opts.indicatorOpen && (opts.indicatorOpen = "CodeMirror-foldgutter-open");
					null == opts.indicatorFolded && (opts.indicatorFolded = "CodeMirror-foldgutter-folded");
					return opts
				}

				function isFolded(cm, line)
				{
					var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
					for (var i = 0; i < marks.length; ++i)
						if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i]
				}

				function marker(spec)
				{
					if ("string" == typeof spec)
					{
						var elt = document.createElement("div");
						elt.className = spec + " CodeMirror-guttermarker-subtle";
						return elt
					}
					return spec.cloneNode(true)
				}

				function updateFoldInfo(cm, from, to)
				{
					var opts = cm.state.foldGutter.options,
						cur = from;
					var minSize = cm.foldOption(opts, "minFoldSize");
					var func = cm.foldOption(opts, "rangeFinder");
					cm.eachLine(from, to, function (line)
					{
						var mark = null;
						if (isFolded(cm, cur)) mark = marker(opts.indicatorFolded);
						else
						{
							var pos = Pos(cur, 0);
							var range = func && func(cm, pos);
							range && range.to.line - range.from.line >= minSize && (mark = marker(opts.indicatorOpen))
						}
						cm.setGutterMarker(line, opts.gutter, mark);
						++cur
					})
				}

				function updateInViewport(cm)
				{
					var vp = cm.getViewport(),
						state = cm.state.foldGutter;
					if (!state) return;
					cm.operation(function ()
					{
						updateFoldInfo(cm, vp.from, vp.to)
					});
					state.from = vp.from;
					state.to = vp.to
				}

				function onGutterClick(cm, line, gutter)
				{
					var state = cm.state.foldGutter;
					if (!state) return;
					var opts = state.options;
					if (gutter != opts.gutter) return;
					var folded = isFolded(cm, line);
					folded ? folded.clear() : cm.foldCode(Pos(line, 0), opts.rangeFinder)
				}

				function onChange(cm)
				{
					var state = cm.state.foldGutter;
					if (!state) return;
					var opts = state.options;
					state.from = state.to = 0;
					clearTimeout(state.changeUpdate);
					state.changeUpdate = setTimeout(function ()
					{
						updateInViewport(cm)
					}, opts.foldOnChangeTimeSpan || 600)
				}

				function onViewportChange(cm)
				{
					var state = cm.state.foldGutter;
					if (!state) return;
					var opts = state.options;
					clearTimeout(state.changeUpdate);
					state.changeUpdate = setTimeout(function ()
					{
						var vp = cm.getViewport();
						state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20 ? updateInViewport(cm) : cm.operation(function ()
						{
							if (vp.from < state.from)
							{
								updateFoldInfo(cm, vp.from, state.from);
								state.from = vp.from
							}
							if (vp.to > state.to)
							{
								updateFoldInfo(cm, state.to, vp.to);
								state.to = vp.to
							}
						})
					}, opts.updateViewportTimeSpan || 400)
				}

				function onFold(cm, from)
				{
					var state = cm.state.foldGutter;
					if (!state) return;
					var line = from.line;
					line >= state.from && line < state.to && updateFoldInfo(cm, line, line + 1)
				}
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	5236: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				var Pos = CodeMirror.Pos;

				function regexpFlags(regexp)
				{
					var flags = regexp.flags;
					return null != flags ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "")
				}

				function ensureFlags(regexp, flags)
				{
					var current = regexpFlags(regexp),
						target = current;
					for (var i = 0; i < flags.length; i++) - 1 == target.indexOf(flags.charAt(i)) && (target += flags.charAt(i));
					return current == target ? regexp : new RegExp(regexp.source, target)
				}

				function maybeMultiline(regexp)
				{
					return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source)
				}

				function searchRegexpForward(doc, regexp, start)
				{
					regexp = ensureFlags(regexp, "g");
					for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0)
					{
						regexp.lastIndex = ch;
						var string = doc.getLine(line),
							match = regexp.exec(string);
						if (match) return {
							from: Pos(line, match.index),
							to: Pos(line, match.index + match[0].length),
							match: match
						}
					}
				}

				function searchRegexpForwardMultiline(doc, regexp, start)
				{
					if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start);
					regexp = ensureFlags(regexp, "gm");
					var string, chunk = 1;
					for (var line = start.line, last = doc.lastLine(); line <= last;)
					{
						for (var i = 0; i < chunk; i++)
						{
							if (line > last) break;
							var curLine = doc.getLine(line++);
							string = null == string ? curLine : string + "\n" + curLine
						}
						chunk *= 2;
						regexp.lastIndex = start.ch;
						var match = regexp.exec(string);
						if (match)
						{
							var before = string.slice(0, match.index).split("\n"),
								inside = match[0].split("\n");
							var startLine = start.line + before.length - 1,
								startCh = before[before.length - 1].length;
							return {
								from: Pos(startLine, startCh),
								to: Pos(startLine + inside.length - 1, 1 == inside.length ? startCh + inside[0].length : inside[inside.length - 1].length),
								match: match
							}
						}
					}
				}

				function lastMatchIn(string, regexp)
				{
					var match, cutOff = 0;
					for (;;)
					{
						regexp.lastIndex = cutOff;
						var newMatch = regexp.exec(string);
						if (!newMatch) return match;
						match = newMatch;
						cutOff = match.index + (match[0].length || 1);
						if (cutOff == string.length) return match
					}
				}

				function searchRegexpBackward(doc, regexp, start)
				{
					regexp = ensureFlags(regexp, "g");
					for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1)
					{
						var string = doc.getLine(line);
						ch > -1 && (string = string.slice(0, ch));
						var match = lastMatchIn(string, regexp);
						if (match) return {
							from: Pos(line, match.index),
							to: Pos(line, match.index + match[0].length),
							match: match
						}
					}
				}

				function searchRegexpBackwardMultiline(doc, regexp, start)
				{
					regexp = ensureFlags(regexp, "gm");
					var string, chunk = 1;
					for (var line = start.line, first = doc.firstLine(); line >= first;)
					{
						for (var i = 0; i < chunk; i++)
						{
							var curLine = doc.getLine(line--);
							string = null == string ? curLine.slice(0, start.ch) : curLine + "\n" + string
						}
						chunk *= 2;
						var match = lastMatchIn(string, regexp);
						if (match)
						{
							var before = string.slice(0, match.index).split("\n"),
								inside = match[0].split("\n");
							var startLine = line + before.length,
								startCh = before[before.length - 1].length;
							return {
								from: Pos(startLine, startCh),
								to: Pos(startLine + inside.length - 1, 1 == inside.length ? startCh + inside[0].length : inside[inside.length - 1].length),
								match: match
							}
						}
					}
				}
				var doFold, noFold;
				if (String.prototype.normalize)
				{
					doFold = function doFold(str)
					{
						return str.normalize("NFD").toLowerCase()
					};
					noFold = function noFold(str)
					{
						return str.normalize("NFD")
					}
				}
				else
				{
					doFold = function doFold(str)
					{
						return str.toLowerCase()
					};
					noFold = function noFold(str)
					{
						return str
					}
				}

				function adjustPos(orig, folded, pos, foldFunc)
				{
					if (orig.length == folded.length) return pos;
					for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;)
					{
						if (min == max) return min;
						var mid = min + max >> 1;
						var len = foldFunc(orig.slice(0, mid)).length;
						if (len == pos) return mid;
						len > pos ? max = mid : min = mid + 1
					}
				}

				function searchStringForward(doc, query, start, caseFold)
				{
					if (!query.length) return null;
					var fold = caseFold ? doFold : noFold;
					var lines = fold(query).split(/\r|\n\r?/);
					search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0)
					{
						var orig = doc.getLine(line).slice(ch),
							string = fold(orig);
						if (1 == lines.length)
						{
							var found = string.indexOf(lines[0]);
							if (-1 == found) continue search;
							start = adjustPos(orig, string, found, fold) + ch;
							return {
								from: Pos(line, adjustPos(orig, string, found, fold) + ch),
								to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)
							}
						}
						var cutFrom = string.length - lines[0].length;
						if (string.slice(cutFrom) != lines[0]) continue search;
						for (var i = 1; i < lines.length - 1; i++)
							if (fold(doc.getLine(line + i)) != lines[i]) continue search;
						var end = doc.getLine(line + lines.length - 1),
							endString = fold(end),
							lastLine = lines[lines.length - 1];
						if (endString.slice(0, lastLine.length) != lastLine) continue search;
						return {
							from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
							to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))
						}
					}
				}

				function searchStringBackward(doc, query, start, caseFold)
				{
					if (!query.length) return null;
					var fold = caseFold ? doFold : noFold;
					var lines = fold(query).split(/\r|\n\r?/);
					search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1)
					{
						var orig = doc.getLine(line);
						ch > -1 && (orig = orig.slice(0, ch));
						var string = fold(orig);
						if (1 == lines.length)
						{
							var found = string.lastIndexOf(lines[0]);
							if (-1 == found) continue search;
							return {
								from: Pos(line, adjustPos(orig, string, found, fold)),
								to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))
							}
						}
						var lastLine = lines[lines.length - 1];
						if (string.slice(0, lastLine.length) != lastLine) continue search;
						var i = 1;
						for (start = line - lines.length + 1; i < lines.length - 1; i++)
							if (fold(doc.getLine(start + i)) != lines[i]) continue search;
						var top = doc.getLine(line + 1 - lines.length),
							topString = fold(top);
						if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;
						return {
							from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
							to: Pos(line, adjustPos(orig, string, lastLine.length, fold))
						}
					}
				}

				function SearchCursor(doc, query, pos, options)
				{
					this.atOccurrence = false;
					this.doc = doc;
					pos = pos ? doc.clipPos(pos) : Pos(0, 0);
					this.pos = {
						from: pos,
						to: pos
					};
					var caseFold;
					if ("object" == ("undefined" === typeof options ? "undefined" : _typeof(options))) caseFold = options.caseFold;
					else
					{
						caseFold = options;
						options = null
					}
					if ("string" == typeof query)
					{
						null == caseFold && (caseFold = false);
						this.matches = function (reverse, pos)
						{
							return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)
						}
					}
					else
					{
						query = ensureFlags(query, "gm");
						options && false === options.multiline ? this.matches = function (reverse, pos)
						{
							return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)
						} : this.matches = function (reverse, pos)
						{
							return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)
						}
					}
				}
				SearchCursor.prototype = {
					findNext: function findNext()
					{
						return this.find(false)
					},
					findPrevious: function findPrevious()
					{
						return this.find(true)
					},
					find: function find(reverse)
					{
						var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to));
						while (result && 0 == CodeMirror.cmpPos(result.from, result.to)) reverse ? result.from.ch ? result.from = Pos(result.from.line, result.from.ch - 1) : result = result.from.line == this.doc.firstLine() ? null : this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1))) : result.to.ch < this.doc.getLine(result.to.line).length ? result.to = Pos(result.to.line, result.to.ch + 1) : result = result.to.line == this.doc.lastLine() ? null : this.matches(reverse, Pos(result.to.line + 1, 0));
						if (result)
						{
							this.pos = result;
							this.atOccurrence = true;
							return this.pos.match || true
						}
						var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
						this.pos = {
							from: end,
							to: end
						};
						return this.atOccurrence = false
					},
					from: function from()
					{
						if (this.atOccurrence) return this.pos.from
					},
					to: function to()
					{
						if (this.atOccurrence) return this.pos.to
					},
					replace: function replace(newText, origin)
					{
						if (!this.atOccurrence) return;
						var lines = CodeMirror.splitLines(newText);
						this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
						this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (1 == lines.length ? this.pos.from.ch : 0))
					}
				};
				CodeMirror.defineExtension("getSearchCursor", function (query, pos, caseFold)
				{
					return new SearchCursor(this.doc, query, pos, caseFold)
				});
				CodeMirror.defineDocExtension("getSearchCursor", function (query, pos, caseFold)
				{
					return new SearchCursor(this, query, pos, caseFold)
				});
				CodeMirror.defineExtension("selectMatches", function (query, caseFold)
				{
					var ranges = [];
					var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
					while (cur.findNext())
					{
						if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
						ranges.push(
						{
							anchor: cur.from(),
							head: cur.to()
						})
					}
					ranges.length && this.setSelections(ranges, 0)
				})
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	5237: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				CodeMirror.defineOption("styleSelectedText", false, function (cm, val, old)
				{
					var prev = old && old != CodeMirror.Init;
					if (val && !prev)
					{
						cm.state.markedSelection = [];
						cm.state.markedSelectionStyle = "string" == typeof val ? val : "CodeMirror-selectedtext";
						reset(cm);
						cm.on("cursorActivity", onCursorActivity);
						cm.on("change", onChange)
					}
					else if (!val && prev)
					{
						cm.off("cursorActivity", onCursorActivity);
						cm.off("change", onChange);
						clear(cm);
						cm.state.markedSelection = cm.state.markedSelectionStyle = null
					}
				});

				function onCursorActivity(cm)
				{
					cm.state.markedSelection && cm.operation(function ()
					{
						update(cm)
					})
				}

				function onChange(cm)
				{
					cm.state.markedSelection && cm.state.markedSelection.length && cm.operation(function ()
					{
						clear(cm)
					})
				}
				var CHUNK_SIZE = 8;
				var Pos = CodeMirror.Pos;
				var cmp = CodeMirror.cmpPos;

				function coverRange(cm, from, to, addAt)
				{
					if (0 == cmp(from, to)) return;
					var array = cm.state.markedSelection;
					var cls = cm.state.markedSelectionStyle;
					for (var line = from.line;;)
					{
						var start = line == from.line ? from : Pos(line, 0);
						var endLine = line + CHUNK_SIZE,
							atEnd = endLine >= to.line;
						var end = atEnd ? to : Pos(endLine, 0);
						var mark = cm.markText(start, end,
						{
							className: cls
						});
						null == addAt ? array.push(mark) : array.splice(addAt++, 0, mark);
						if (atEnd) break;
						line = endLine
					}
				}

				function clear(cm)
				{
					var array = cm.state.markedSelection;
					for (var i = 0; i < array.length; ++i) array[i].clear();
					array.length = 0
				}

				function reset(cm)
				{
					clear(cm);
					var ranges = cm.listSelections();
					for (var i = 0; i < ranges.length; i++) coverRange(cm, ranges[i].from(), ranges[i].to())
				}

				function update(cm)
				{
					if (!cm.somethingSelected()) return clear(cm);
					if (cm.listSelections().length > 1) return reset(cm);
					var from = cm.getCursor("start"),
						to = cm.getCursor("end");
					var array = cm.state.markedSelection;
					if (!array.length) return coverRange(cm, from, to);
					var coverStart = array[0].find(),
						coverEnd = array[array.length - 1].find();
					if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE || cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0) return reset(cm);
					while (cmp(from, coverStart.from) > 0)
					{
						array.shift().clear();
						coverStart = array[0].find()
					}
					if (cmp(from, coverStart.from) < 0)
						if (coverStart.to.line - from.line < CHUNK_SIZE)
						{
							array.shift().clear();
							coverRange(cm, from, coverStart.to, 0)
						}
					else coverRange(cm, from, coverStart.from, 0);
					while (cmp(to, coverEnd.to) < 0)
					{
						array.pop().clear();
						coverEnd = array[array.length - 1].find()
					}
					if (cmp(to, coverEnd.to) > 0)
						if (to.line - coverEnd.from.line < CHUNK_SIZE)
						{
							array.pop().clear();
							coverRange(cm, coverEnd.from, to)
						}
					else coverRange(cm, coverEnd.to, to)
				}
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	5238: function (module, exports, __webpack_require__)
	{
		"use strict";
		(function (module)
		{
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
			{
				return typeof obj
			} : function (obj)
			{
				return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
			};
			(function (mod)
			{
				if ("object" == _typeof(exports) && "object" == _typeof(module)) mod(__webpack_require__(58));
				else
				{
					true;
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(58)], __WEBPACK_AMD_DEFINE_FACTORY__ = mod, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
				}
			})(function (CodeMirror)
			{
				CodeMirror.showHint = function (cm, getHints, options)
				{
					if (cm.somethingSelected()) return;
					null == getHints && (getHints = cm.getHelper(cm.getCursor(), "hint"));
					if (null == getHints) return;
					cm.state.completionActive && cm.state.completionActive.close();
					var completion = cm.state.completionActive = new Completion(cm, getHints, options ||
					{});
					CodeMirror.signal(cm, "startCompletion", cm);
					if (!completion.options.async) return completion.showHints(getHints(cm, completion.options));
					getHints(cm, function (hints)
					{
						completion.showHints(hints)
					}, completion.options)
				};

				function Completion(cm, getHints, options)
				{
					this.cm = cm;
					this.getHints = getHints;
					this.options = options;
					this.widget = this.onClose = null
				}
				Completion.prototype = {
					close: function close()
					{
						if (!this.active()) return;
						this.cm.state.completionActive = null;
						this.widget && this.widget.close();
						this.onClose && this.onClose();
						CodeMirror.signal(this.cm, "endCompletion", this.cm)
					},
					active: function active()
					{
						return this.cm.state.completionActive == this
					},
					pick: function pick(data, i)
					{
						var completion = data.list[i];
						completion.hint ? completion.hint(this.cm, data, completion) : this.cm.replaceRange(getText(completion), data.from, data.to);
						this.close()
					},
					showHints: function showHints(data)
					{
						if (!data || !data.list.length || !this.active()) return this.close();
						false != this.options.completeSingle && 1 == data.list.length ? this.pick(data, 0) : this.showWidget(data)
					},
					showWidget: function showWidget(data)
					{
						this.widget = new Widget(this, data);
						CodeMirror.signal(data, "shown");
						var finished, debounce = null,
							completion = this;
						var closeOn = this.options.closeCharacters || /[\s()\[\]{};:>,]/;
						var startPos = this.cm.getCursor(),
							startLen = this.cm.getLine(startPos.line).length;

						function done()
						{
							if (finished) return;
							finished = true;
							completion.close();
							completion.cm.off("cursorActivity", activity);
							CodeMirror.signal(data, "close")
						}

						function isDone()
						{
							if (finished) return true;
							if (!completion.widget)
							{
								done();
								return true
							}
						}

						function update()
						{
							if (isDone()) return;
							CodeMirror.signal(data, "update");
							completion.options.async ? completion.getHints(completion.cm, finishUpdate, completion.options) : finishUpdate(completion.getHints(completion.cm, completion.options))
						}

						function finishUpdate(data_)
						{
							data = data_;
							if (isDone()) return;
							if (!data || !data.list.length) return done();
							completion.widget.close();
							completion.widget = new Widget(completion, data)
						}

						function activity()
						{
							clearTimeout(debounce);
							var pos = completion.cm.getCursor(),
								line = completion.cm.getLine(pos.line);
							pos.line != startPos.line || line.length - pos.ch != startLen - startPos.ch || pos.ch < startPos.ch || completion.cm.somethingSelected() || pos.ch && closeOn.test(line.charAt(pos.ch - 1)) ? completion.close() : debounce = setTimeout(update, 170)
						}
						this.cm.on("cursorActivity", activity);
						this.onClose = done
					}
				};

				function getText(completion)
				{
					return "string" == typeof completion ? completion : completion.text
				}

				function buildKeyMap(options, handle)
				{
					var baseMap = {
						Up: function Up()
						{
							handle.moveFocus(-1)
						},
						Down: function Down()
						{
							handle.moveFocus(1)
						},
						PageUp: function PageUp()
						{
							handle.moveFocus(-handle.menuSize())
						},
						PageDown: function PageDown()
						{
							handle.moveFocus(handle.menuSize())
						},
						Home: function Home()
						{
							handle.setFocus(0)
						},
						End: function End()
						{
							handle.setFocus(handle.length)
						},
						Enter: handle.pick,
						Tab: handle.pick,
						Esc: handle.close
					};
					var ourMap = options.customKeys ?
					{} : baseMap;

					function addBinding(key, val)
					{
						var bound;
						bound = "string" != typeof val ? function bound(cm)
						{
							return val(cm, handle)
						} : baseMap.hasOwnProperty(val) ? baseMap[val] : val;
						ourMap[key] = bound
					}
					if (options.customKeys)
						for (var key in options.customKeys) options.customKeys.hasOwnProperty(key) && addBinding(key, options.customKeys[key]);
					if (options.extraKeys)
						for (var key in options.extraKeys) options.extraKeys.hasOwnProperty(key) && addBinding(key, options.extraKeys[key]);
					return ourMap
				}

				function Widget(completion, data)
				{
					this.completion = completion;
					this.data = data;
					var widget = this,
						cm = completion.cm,
						options = completion.options;
					var hints = this.hints = document.createElement("ul");
					hints.className = "CodeMirror-hints";
					this.selectedHint = 0;
					var completions = data.list;
					for (var i = 0; i < completions.length; ++i)
					{
						var elt = hints.appendChild(document.createElement("li")),
							cur = completions[i];
						var className = "CodeMirror-hint" + (i ? "" : " CodeMirror-hint-active");
						null != cur.className && (className = cur.className + " " + className);
						elt.className = className;
						cur.render ? cur.render(elt, data, cur) : elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
						elt.hintId = i
					}
					var pos = cm.cursorCoords(false !== options.alignWithWord ? data.from : null);
					var left = pos.left,
						top = pos.bottom,
						below = true;
					hints.style.left = left + "px";
					hints.style.top = top + "px";
					var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
					var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
					var box = hints.getBoundingClientRect();
					var overlapX = box.right - winW,
						overlapY = box.bottom - winH;
					if (overlapX > 0)
					{
						if (box.right - box.left > winW)
						{
							hints.style.width = winW - 5 + "px";
							overlapX -= box.right - box.left - winW
						}
						hints.style.left = (left = pos.left - overlapX) + "px"
					}
					if (overlapY > 0)
					{
						var height = box.bottom - box.top;
						if (box.top - (pos.bottom - pos.top) - height > 0)
						{
							overlapY = height + (pos.bottom - pos.top);
							below = false
						}
						else if (height > winH)
						{
							hints.style.height = winH - 5 + "px";
							overlapY -= height - winH
						}
						hints.style.top = (top = pos.bottom - overlapY) + "px"
					}(options.container || document.body).appendChild(hints);
					cm.addKeyMap(this.keyMap = buildKeyMap(options,
					{
						moveFocus: function moveFocus(n)
						{
							widget.changeActive(widget.selectedHint + n)
						},
						setFocus: function setFocus(n)
						{
							widget.changeActive(n)
						},
						menuSize: function menuSize()
						{
							return widget.screenAmount()
						},
						length: completions.length,
						close: function close()
						{
							completion.close()
						},
						pick: function pick()
						{
							widget.pick()
						}
					}));
					if (false !== options.closeOnUnfocus)
					{
						var closingOnBlur;
						cm.on("blur", this.onBlur = function ()
						{
							closingOnBlur = setTimeout(function ()
							{
								completion.close()
							}, 100)
						});
						cm.on("focus", this.onFocus = function ()
						{
							clearTimeout(closingOnBlur)
						})
					}
					var startScroll = cm.getScrollInfo();
					cm.on("scroll", this.onScroll = function ()
					{
						var curScroll = cm.getScrollInfo(),
							editor = cm.getWrapperElement().getBoundingClientRect();
						var newTop = top + startScroll.top - curScroll.top;
						var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
						below || (point += hints.offsetHeight);
						if (point <= editor.top || point >= editor.bottom) return completion.close();
						hints.style.top = newTop + "px";
						hints.style.left = left + startScroll.left - curScroll.left + "px"
					});
					CodeMirror.on(hints, "dblclick", function (e)
					{
						var t = e.target || e.srcElement;
						if (null != t.hintId)
						{
							widget.changeActive(t.hintId);
							widget.pick()
						}
					});
					CodeMirror.on(hints, "click", function (e)
					{
						var t = e.target || e.srcElement;
						null != t.hintId && widget.changeActive(t.hintId)
					});
					CodeMirror.on(hints, "mousedown", function ()
					{
						setTimeout(function ()
						{
							cm.focus()
						}, 20)
					});
					CodeMirror.signal(data, "select", completions[0], hints.firstChild);
					return true
				}
				Widget.prototype = {
					close: function close()
					{
						if (this.completion.widget != this) return;
						this.completion.widget = null;
						this.hints.parentNode.removeChild(this.hints);
						this.completion.cm.removeKeyMap(this.keyMap);
						var cm = this.completion.cm;
						if (false !== this.completion.options.closeOnUnfocus)
						{
							cm.off("blur", this.onBlur);
							cm.off("focus", this.onFocus)
						}
						cm.off("scroll", this.onScroll)
					},
					pick: function pick()
					{
						this.completion.pick(this.data, this.selectedHint)
					},
					changeActive: function changeActive(i)
					{
						i = Math.max(0, Math.min(i, this.data.list.length - 1));
						if (this.selectedHint == i) return;
						var node = this.hints.childNodes[this.selectedHint];
						node.className = node.className.replace(" CodeMirror-hint-active", "");
						node = this.hints.childNodes[this.selectedHint = i];
						node.className += " CodeMirror-hint-active";
						node.offsetTop < this.hints.scrollTop ? this.hints.scrollTop = node.offsetTop - 3 : node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight && (this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3);
						CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node)
					},
					screenAmount: function screenAmount()
					{
						return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1
					}
				}
			})
		}).call(exports, __webpack_require__(46)(module))
	},
	5239: function (module, exports) {},
	5240: function (module, exports) {},
	5241: function (module, exports)
	{
		/**
		 * @license AngularJS v1.6.5
		 * (c) 2010-2017 Google, Inc. http://angularjs.org
		 * License: MIT
		 */
		(function (window, angular)
		{
			"use strict";
			var ELEMENT_NODE = 1;
			var ADD_CLASS_SUFFIX = "-add";
			var REMOVE_CLASS_SUFFIX = "-remove";
			var EVENT_CLASS_PREFIX = "ng-";
			var ACTIVE_CLASS_SUFFIX = "-active";
			var PREPARE_CLASS_SUFFIX = "-prepare";
			var NG_ANIMATE_CLASSNAME = "ng-animate";
			var NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";
			var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
			if (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend)
			{
				"-webkit-";
				TRANSITION_PROP = "WebkitTransition";
				TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend"
			}
			else
			{
				TRANSITION_PROP = "transition";
				TRANSITIONEND_EVENT = "transitionend"
			}
			if (void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend)
			{
				"-webkit-";
				ANIMATION_PROP = "WebkitAnimation";
				ANIMATIONEND_EVENT = "webkitAnimationEnd animationend"
			}
			else
			{
				ANIMATION_PROP = "animation";
				ANIMATIONEND_EVENT = "animationend"
			}
			var DURATION_KEY = "Duration";
			var PROPERTY_KEY = "Property";
			var DELAY_KEY = "Delay";
			var TIMING_KEY = "TimingFunction";
			var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
			var ANIMATION_PLAYSTATE_KEY = "PlayState";
			var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
			var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
			var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
			var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
			var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
			var ngMinErr = angular.$$minErr("ng");

			function assertArg(arg, name, reason)
			{
				if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
				return arg
			}

			function mergeClasses(a, b)
			{
				if (!a && !b) return "";
				if (!a) return b;
				if (!b) return a;
				isArray(a) && (a = a.join(" "));
				isArray(b) && (b = b.join(" "));
				return a + " " + b
			}

			function packageStyles(options)
			{
				var styles = {};
				if (options && (options.to || options.from))
				{
					styles.to = options.to;
					styles.from = options.from
				}
				return styles
			}

			function pendClasses(classes, fix, isPrefix)
			{
				var className = "";
				classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
				forEach(classes, function (klass, i)
				{
					if (klass && klass.length > 0)
					{
						className += i > 0 ? " " : "";
						className += isPrefix ? fix + klass : klass + fix
					}
				});
				return className
			}

			function removeFromArray(arr, val)
			{
				var index = arr.indexOf(val);
				val >= 0 && arr.splice(index, 1)
			}

			function stripCommentsFromElement(element)
			{
				if (element instanceof jqLite) switch (element.length)
				{
				case 0:
					return element;
				case 1:
					if (element[0].nodeType === ELEMENT_NODE) return element;
					break;
				default:
					return jqLite(extractElementNode(element))
				}
				if (element.nodeType === ELEMENT_NODE) return jqLite(element)
			}

			function extractElementNode(element)
			{
				if (!element[0]) return element;
				for (var i = 0; i < element.length; i++)
				{
					var elm = element[i];
					if (elm.nodeType === ELEMENT_NODE) return elm
				}
			}

			function $$addClass($$jqLite, element, className)
			{
				forEach(element, function (elm)
				{
					$$jqLite.addClass(elm, className)
				})
			}

			function $$removeClass($$jqLite, element, className)
			{
				forEach(element, function (elm)
				{
					$$jqLite.removeClass(elm, className)
				})
			}

			function applyAnimationClassesFactory($$jqLite)
			{
				return function (element, options)
				{
					if (options.addClass)
					{
						$$addClass($$jqLite, element, options.addClass);
						options.addClass = null
					}
					if (options.removeClass)
					{
						$$removeClass($$jqLite, element, options.removeClass);
						options.removeClass = null
					}
				}
			}

			function prepareAnimationOptions(options)
			{
				options = options ||
				{};
				if (!options.$$prepared)
				{
					var domOperation = options.domOperation || noop;
					options.domOperation = function ()
					{
						options.$$domOperationFired = true;
						domOperation();
						domOperation = noop
					};
					options.$$prepared = true
				}
				return options
			}

			function applyAnimationStyles(element, options)
			{
				applyAnimationFromStyles(element, options);
				applyAnimationToStyles(element, options)
			}

			function applyAnimationFromStyles(element, options)
			{
				if (options.from)
				{
					element.css(options.from);
					options.from = null
				}
			}

			function applyAnimationToStyles(element, options)
			{
				if (options.to)
				{
					element.css(options.to);
					options.to = null
				}
			}

			function mergeAnimationDetails(element, oldAnimation, newAnimation)
			{
				var target = oldAnimation.options ||
				{};
				var newOptions = newAnimation.options ||
				{};
				var toAdd = (target.addClass || "") + " " + (newOptions.addClass || "");
				var toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || "");
				var classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
				if (newOptions.preparationClasses)
				{
					target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
					delete newOptions.preparationClasses
				}
				var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
				extend(target, newOptions);
				realDomOperation && (target.domOperation = realDomOperation);
				classes.addClass ? target.addClass = classes.addClass : target.addClass = null;
				classes.removeClass ? target.removeClass = classes.removeClass : target.removeClass = null;
				oldAnimation.addClass = target.addClass;
				oldAnimation.removeClass = target.removeClass;
				return target
			}

			function resolveElementClasses(existing, toAdd, toRemove)
			{
				var ADD_CLASS = 1;
				var REMOVE_CLASS = -1;
				var flags = {};
				existing = splitClassesToLookup(existing);
				toAdd = splitClassesToLookup(toAdd);
				forEach(toAdd, function (value, key)
				{
					flags[key] = ADD_CLASS
				});
				toRemove = splitClassesToLookup(toRemove);
				forEach(toRemove, function (value, key)
				{
					flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS
				});
				var classes = {
					addClass: "",
					removeClass: ""
				};
				forEach(flags, function (val, klass)
				{
					var prop, allow;
					if (val === ADD_CLASS)
					{
						prop = "addClass";
						allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX]
					}
					else if (val === REMOVE_CLASS)
					{
						prop = "removeClass";
						allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX]
					}
					if (allow)
					{
						classes[prop].length && (classes[prop] += " ");
						classes[prop] += klass
					}
				});

				function splitClassesToLookup(classes)
				{
					isString(classes) && (classes = classes.split(" "));
					var obj = {};
					forEach(classes, function (klass)
					{
						klass.length && (obj[klass] = true)
					});
					return obj
				}
				return classes
			}

			function getDomNode(element)
			{
				return element instanceof jqLite ? element[0] : element
			}

			function applyGeneratedPreparationClasses(element, event, options)
			{
				var classes = "";
				event && (classes = pendClasses(event, EVENT_CLASS_PREFIX, true));
				options.addClass && (classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX)));
				options.removeClass && (classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)));
				if (classes.length)
				{
					options.preparationClasses = classes;
					element.addClass(classes)
				}
			}

			function clearGeneratedClasses(element, options)
			{
				if (options.preparationClasses)
				{
					element.removeClass(options.preparationClasses);
					options.preparationClasses = null
				}
				if (options.activeClasses)
				{
					element.removeClass(options.activeClasses);
					options.activeClasses = null
				}
			}

			function blockTransitions(node, duration)
			{
				var value = duration ? "-" + duration + "s" : "";
				applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
				return [TRANSITION_DELAY_PROP, value]
			}

			function blockKeyframeAnimations(node, applyBlock)
			{
				var value = applyBlock ? "paused" : "";
				var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
				applyInlineStyle(node, [key, value]);
				return [key, value]
			}

			function applyInlineStyle(node, styleTuple)
			{
				var prop = styleTuple[0];
				var value = styleTuple[1];
				node.style[prop] = value
			}

			function concatWithSpace(a, b)
			{
				if (!a) return b;
				if (!b) return a;
				return a + " " + b
			}
			var $$rAFSchedulerFactory = ["$$rAF", function ($$rAF)
			{
				var queue, cancelFn;

				function scheduler(tasks)
				{
					queue = queue.concat(tasks);
					nextTick()
				}
				queue = scheduler.queue = [];
				scheduler.waitUntilQuiet = function (fn)
				{
					cancelFn && cancelFn();
					cancelFn = $$rAF(function ()
					{
						cancelFn = null;
						fn();
						nextTick()
					})
				};
				return scheduler;

				function nextTick()
				{
					if (!queue.length) return;
					var items = queue.shift();
					for (var i = 0; i < items.length; i++) items[i]();
					cancelFn || $$rAF(function ()
					{
						cancelFn || nextTick()
					})
				}
			}];
			var $$AnimateChildrenDirective = ["$interpolate", function ($interpolate)
			{
				return {
					link: function (scope, element, attrs)
					{
						var val = attrs.ngAnimateChildren;
						if (isString(val) && 0 === val.length) element.data(NG_ANIMATE_CHILDREN_DATA, true);
						else
						{
							setData($interpolate(val)(scope));
							attrs.$observe("ngAnimateChildren", setData)
						}

						function setData(value)
						{
							value = "on" === value || "true" === value;
							element.data(NG_ANIMATE_CHILDREN_DATA, value)
						}
					}
				}
			}];
			var ANIMATE_TIMER_KEY = "$$animateCss";
			var ONE_SECOND = 1e3;
			var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
			var CLOSING_TIME_BUFFER = 1.5;
			var DETECT_CSS_PROPERTIES = {
				transitionDuration: TRANSITION_DURATION_PROP,
				transitionDelay: TRANSITION_DELAY_PROP,
				transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
				animationDuration: ANIMATION_DURATION_PROP,
				animationDelay: ANIMATION_DELAY_PROP,
				animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
			};
			var DETECT_STAGGER_CSS_PROPERTIES = {
				transitionDuration: TRANSITION_DURATION_PROP,
				transitionDelay: TRANSITION_DELAY_PROP,
				animationDuration: ANIMATION_DURATION_PROP,
				animationDelay: ANIMATION_DELAY_PROP
			};

			function getCssKeyframeDurationStyle(duration)
			{
				return [ANIMATION_DURATION_PROP, duration + "s"]
			}

			function getCssDelayStyle(delay, isKeyframeAnimation)
			{
				var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
				return [prop, delay + "s"]
			}

			function computeCssStyles($window, element, properties)
			{
				var styles = Object.create(null);
				var detectedStyles = $window.getComputedStyle(element) ||
				{};
				forEach(properties, function (formalStyleName, actualStyleName)
				{
					var val = detectedStyles[formalStyleName];
					if (val)
					{
						var c = val.charAt(0);
						("-" === c || "+" === c || c >= 0) && (val = parseMaxTime(val));
						0 === val && (val = null);
						styles[actualStyleName] = val
					}
				});
				return styles
			}

			function parseMaxTime(str)
			{
				var maxValue = 0;
				var values = str.split(/\s*,\s*/);
				forEach(values, function (value)
				{
					"s" === value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1));
					value = parseFloat(value) || 0;
					maxValue = maxValue ? Math.max(value, maxValue) : value
				});
				return maxValue
			}

			function truthyTimingValue(val)
			{
				return 0 === val || null != val
			}

			function getCssTransitionDurationStyle(duration, applyOnlyDuration)
			{
				var style = TRANSITION_PROP;
				var value = duration + "s";
				applyOnlyDuration ? style += DURATION_KEY : value += " linear all";
				return [style, value]
			}

			function createLocalCacheLookup()
			{
				var cache = Object.create(null);
				return {
					flush: function ()
					{
						cache = Object.create(null)
					},
					count: function (key)
					{
						var entry = cache[key];
						return entry ? entry.total : 0
					},
					get: function (key)
					{
						var entry = cache[key];
						return entry && entry.value
					},
					put: function (key, value)
					{
						cache[key] ? cache[key].total++ : cache[key] = {
							total: 1,
							value: value
						}
					}
				}
			}

			function registerRestorableStyles(backup, node, properties)
			{
				forEach(properties, function (prop)
				{
					backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop)
				})
			}
			var $AnimateCssProvider = ["$animateProvider", function ($animateProvider)
			{
				var gcsLookup = createLocalCacheLookup();
				var gcsStaggerLookup = createLocalCacheLookup();
				this.$get = ["$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function ($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue)
				{
					var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
					var parentCounter = 0;

					function gcsHashFn(node, extraClasses)
					{
						var KEY = "$$ngAnimateParentKey";
						var parentNode = node.parentNode;
						var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
						return parentID + "-" + node.getAttribute("class") + "-" + extraClasses
					}

					function computeCachedCssStyles(node, className, cacheKey, properties)
					{
						var timings = gcsLookup.get(cacheKey);
						if (!timings)
						{
							timings = computeCssStyles($window, node, properties);
							"infinite" === timings.animationIterationCount && (timings.animationIterationCount = 1)
						}
						gcsLookup.put(cacheKey, timings);
						return timings
					}

					function computeCachedCssStaggerStyles(node, className, cacheKey, properties)
					{
						var stagger;
						if (gcsLookup.count(cacheKey) > 0)
						{
							stagger = gcsStaggerLookup.get(cacheKey);
							if (!stagger)
							{
								var staggerClassName = pendClasses(className, "-stagger");
								$$jqLite.addClass(node, staggerClassName);
								stagger = computeCssStyles($window, node, properties);
								stagger.animationDuration = Math.max(stagger.animationDuration, 0);
								stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
								$$jqLite.removeClass(node, staggerClassName);
								gcsStaggerLookup.put(cacheKey, stagger)
							}
						}
						return stagger ||
						{}
					}
					var rafWaitQueue = [];

					function waitUntilQuiet(callback)
					{
						rafWaitQueue.push(callback);
						$$rAFScheduler.waitUntilQuiet(function ()
						{
							gcsLookup.flush();
							gcsStaggerLookup.flush();
							var pageWidth = $$forceReflow();
							for (var i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
							rafWaitQueue.length = 0
						})
					}

					function computeTimings(node, className, cacheKey)
					{
						var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
						var aD = timings.animationDelay;
						var tD = timings.transitionDelay;
						timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
						timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
						return timings
					}
					return function init(element, initialOptions)
					{
						var options = initialOptions ||
						{};
						options.$$prepared || (options = prepareAnimationOptions(copy(options)));
						var restoreStyles = {};
						var node = getDomNode(element);
						if (!node || !node.parentNode || !$$animateQueue.enabled()) return closeAndReturnNoopAnimator();
						var temporaryStyles = [];
						var classes = element.attr("class");
						var styles = packageStyles(options);
						var animationClosed;
						var animationPaused;
						var animationCompleted;
						var runner;
						var runnerHost;
						var maxDelay;
						var maxDelayTime;
						var maxDuration;
						var maxDurationTime;
						var startTime;
						var events = [];
						if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions) return closeAndReturnNoopAnimator();
						var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event;
						var isStructural = method && options.structural;
						var structuralClassName = "";
						var addRemoveClassName = "";
						isStructural ? structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true) : method && (structuralClassName = method);
						options.addClass && (addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX));
						if (options.removeClass)
						{
							addRemoveClassName.length && (addRemoveClassName += " ");
							addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)
						}
						options.applyClassesEarly && addRemoveClassName.length && applyAnimationClasses(element, options);
						var preparationClasses = [structuralClassName, addRemoveClassName].join(" ").trim();
						var fullClassName = classes + " " + preparationClasses;
						var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
						var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
						var containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
						if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) return closeAndReturnNoopAnimator();
						var cacheKey, stagger;
						if (options.stagger > 0)
						{
							var staggerVal = parseFloat(options.stagger);
							stagger = {
								transitionDelay: staggerVal,
								animationDelay: staggerVal,
								transitionDuration: 0,
								animationDuration: 0
							}
						}
						else
						{
							cacheKey = gcsHashFn(node, fullClassName);
							stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES)
						}
						options.$$skipPreparationClasses || $$jqLite.addClass(element, preparationClasses);
						var applyOnlyDuration;
						if (options.transitionStyle)
						{
							var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
							applyInlineStyle(node, transitionStyle);
							temporaryStyles.push(transitionStyle)
						}
						if (options.duration >= 0)
						{
							applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
							var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
							applyInlineStyle(node, durationStyle);
							temporaryStyles.push(durationStyle)
						}
						if (options.keyframeStyle)
						{
							var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
							applyInlineStyle(node, keyframeStyle);
							temporaryStyles.push(keyframeStyle)
						}
						var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
						var isFirst = 0 === itemIndex;
						isFirst && !options.skipBlocking && blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
						var timings = computeTimings(node, fullClassName, cacheKey);
						var relativeDelay = timings.maxDelay;
						maxDelay = Math.max(relativeDelay, 0);
						maxDuration = timings.maxDuration;
						var flags = {};
						flags.hasTransitions = timings.transitionDuration > 0;
						flags.hasAnimations = timings.animationDuration > 0;
						flags.hasTransitionAll = flags.hasTransitions && "all" === timings.transitionProperty;
						flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions);
						flags.applyAnimationDuration = options.duration && flags.hasAnimations;
						flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
						flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
						flags.recalculateTimingStyles = addRemoveClassName.length > 0;
						if (flags.applyTransitionDuration || flags.applyAnimationDuration)
						{
							maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
							if (flags.applyTransitionDuration)
							{
								flags.hasTransitions = true;
								timings.transitionDuration = maxDuration;
								applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
								temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))
							}
							if (flags.applyAnimationDuration)
							{
								flags.hasAnimations = true;
								timings.animationDuration = maxDuration;
								temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration))
							}
						}
						if (0 === maxDuration && !flags.recalculateTimingStyles) return closeAndReturnNoopAnimator();
						if (null != options.delay)
						{
							var delayStyle;
							if ("boolean" !== typeof options.delay)
							{
								delayStyle = parseFloat(options.delay);
								maxDelay = Math.max(delayStyle, 0)
							}
							flags.applyTransitionDelay && temporaryStyles.push(getCssDelayStyle(delayStyle));
							flags.applyAnimationDelay && temporaryStyles.push(getCssDelayStyle(delayStyle, true))
						}
						null == options.duration && timings.transitionDuration > 0 && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst);
						maxDelayTime = maxDelay * ONE_SECOND;
						maxDurationTime = maxDuration * ONE_SECOND;
						if (!options.skipBlocking)
						{
							flags.blockTransition = timings.transitionDuration > 0;
							flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration
						}
						if (options.from)
						{
							options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
							applyAnimationFromStyles(element, options)
						}
						flags.blockTransition || flags.blockKeyframeAnimation ? applyBlocking(maxDuration) : options.skipBlocking || blockTransitions(node, false);
						return {
							$$willAnimate: true,
							end: endFn,
							start: function ()
							{
								if (animationClosed) return;
								runnerHost = {
									end: endFn,
									cancel: cancelFn,
									resume: null,
									pause: null
								};
								runner = new $$AnimateRunner(runnerHost);
								waitUntilQuiet(start);
								return runner
							}
						};

						function endFn()
						{
							close()
						}

						function cancelFn()
						{
							close(true)
						}

						function close(rejected)
						{
							if (animationClosed || animationCompleted && animationPaused) return;
							animationClosed = true;
							animationPaused = false;
							options.$$skipPreparationClasses || $$jqLite.removeClass(element, preparationClasses);
							$$jqLite.removeClass(element, activeClasses);
							blockKeyframeAnimations(node, false);
							blockTransitions(node, false);
							forEach(temporaryStyles, function (entry)
							{
								node.style[entry[0]] = ""
							});
							applyAnimationClasses(element, options);
							applyAnimationStyles(element, options);
							Object.keys(restoreStyles).length && forEach(restoreStyles, function (value, prop)
							{
								value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop)
							});
							options.onDone && options.onDone();
							events && events.length && element.off(events.join(" "), onAnimationProgress);
							var animationTimerData = element.data(ANIMATE_TIMER_KEY);
							if (animationTimerData)
							{
								$timeout.cancel(animationTimerData[0].timer);
								element.removeData(ANIMATE_TIMER_KEY)
							}
							runner && runner.complete(!rejected)
						}

						function applyBlocking(duration)
						{
							flags.blockTransition && blockTransitions(node, duration);
							flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration)
						}

						function closeAndReturnNoopAnimator()
						{
							runner = new $$AnimateRunner(
							{
								end: endFn,
								cancel: cancelFn
							});
							waitUntilQuiet(noop);
							close();
							return {
								$$willAnimate: false,
								start: function ()
								{
									return runner
								},
								end: endFn
							}
						}

						function onAnimationProgress(event)
						{
							event.stopPropagation();
							var ev = event.originalEvent || event;
							var timeStamp = ev.$manualTimeStamp || Date.now();
							var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
							if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration)
							{
								animationCompleted = true;
								close()
							}
						}

						function start()
						{
							if (animationClosed) return;
							if (!node.parentNode)
							{
								close();
								return
							}
							var playPause = function (playAnimation)
							{
								if (animationCompleted)
								{
									if (animationPaused && playAnimation)
									{
										animationPaused = false;
										close()
									}
								}
								else
								{
									animationPaused = !playAnimation;
									if (timings.animationDuration)
									{
										var value = blockKeyframeAnimations(node, animationPaused);
										animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value)
									}
								}
							};
							var maxStagger = itemIndex > 0 && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay);
							maxStagger ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false) : triggerAnimationStart();
							runnerHost.resume = function ()
							{
								playPause(true)
							};
							runnerHost.pause = function ()
							{
								playPause(false)
							};

							function triggerAnimationStart()
							{
								if (animationClosed) return;
								applyBlocking(false);
								forEach(temporaryStyles, function (entry)
								{
									var key = entry[0];
									var value = entry[1];
									node.style[key] = value
								});
								applyAnimationClasses(element, options);
								$$jqLite.addClass(element, activeClasses);
								if (flags.recalculateTimingStyles)
								{
									fullClassName = node.getAttribute("class") + " " + preparationClasses;
									cacheKey = gcsHashFn(node, fullClassName);
									timings = computeTimings(node, fullClassName, cacheKey);
									relativeDelay = timings.maxDelay;
									maxDelay = Math.max(relativeDelay, 0);
									maxDuration = timings.maxDuration;
									if (0 === maxDuration)
									{
										close();
										return
									}
									flags.hasTransitions = timings.transitionDuration > 0;
									flags.hasAnimations = timings.animationDuration > 0
								}
								if (flags.applyAnimationDelay)
								{
									relativeDelay = "boolean" !== typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
									maxDelay = Math.max(relativeDelay, 0);
									timings.animationDelay = relativeDelay;
									delayStyle = getCssDelayStyle(relativeDelay, true);
									temporaryStyles.push(delayStyle);
									node.style[delayStyle[0]] = delayStyle[1]
								}
								maxDelayTime = maxDelay * ONE_SECOND;
								maxDurationTime = maxDuration * ONE_SECOND;
								if (options.easing)
								{
									var easeProp, easeVal = options.easing;
									if (flags.hasTransitions)
									{
										easeProp = TRANSITION_PROP + TIMING_KEY;
										temporaryStyles.push([easeProp, easeVal]);
										node.style[easeProp] = easeVal
									}
									if (flags.hasAnimations)
									{
										easeProp = ANIMATION_PROP + TIMING_KEY;
										temporaryStyles.push([easeProp, easeVal]);
										node.style[easeProp] = easeVal
									}
								}
								timings.transitionDuration && events.push(TRANSITIONEND_EVENT);
								timings.animationDuration && events.push(ANIMATIONEND_EVENT);
								startTime = Date.now();
								var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
								var endTime = startTime + timerTime;
								var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
								var setupFallbackTimer = true;
								if (animationsData.length)
								{
									var currentTimerData = animationsData[0];
									setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
									setupFallbackTimer ? $timeout.cancel(currentTimerData.timer) : animationsData.push(close)
								}
								if (setupFallbackTimer)
								{
									var timer = $timeout(onAnimationExpired, timerTime, false);
									animationsData[0] = {
										timer: timer,
										expectedEndTime: endTime
									};
									animationsData.push(close);
									element.data(ANIMATE_TIMER_KEY, animationsData)
								}
								events.length && element.on(events.join(" "), onAnimationProgress);
								if (options.to)
								{
									options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
									applyAnimationToStyles(element, options)
								}
							}

							function onAnimationExpired()
							{
								var animationsData = element.data(ANIMATE_TIMER_KEY);
								if (animationsData)
								{
									for (var i = 1; i < animationsData.length; i++) animationsData[i]();
									element.removeData(ANIMATE_TIMER_KEY)
								}
							}
						}
					}
				}]
			}];
			var $$AnimateCssDriverProvider = ["$$animationProvider", function ($$animationProvider)
			{
				$$animationProvider.drivers.push("$$animateCssDriver");
				var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim";
				var NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor";
				var NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";
				var NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";

				function isDocumentFragment(node)
				{
					return node.parentNode && 11 === node.parentNode.nodeType
				}
				this.$get = ["$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function ($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document)
				{
					if (!$sniffer.animations && !$sniffer.transitions) return noop;
					var bodyNode = $document[0].body;
					var rootNode = getDomNode($rootElement);
					var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
					return function initDriverFn(animationDetails)
					{
						return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails)
					};

					function filterCssClasses(classes)
					{
						return classes.replace(/\bng-\S+\b/g, "")
					}

					function getUniqueValues(a, b)
					{
						isString(a) && (a = a.split(" "));
						isString(b) && (b = b.split(" "));
						return a.filter(function (val)
						{
							return -1 === b.indexOf(val)
						}).join(" ")
					}

					function prepareAnchoredAnimation(classes, outAnchor, inAnchor)
					{
						var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
						var startingClasses = filterCssClasses(getClassVal(clone));
						outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
						inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
						clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
						rootBodyElement.append(clone);
						var animatorIn, animatorOut = prepareOutAnimation();
						if (!animatorOut)
						{
							animatorIn = prepareInAnimation();
							if (!animatorIn) return end()
						}
						var startingAnimator = animatorOut || animatorIn;
						return {
							start: function ()
							{
								var runner;
								var currentAnimation = startingAnimator.start();
								currentAnimation.done(function ()
								{
									currentAnimation = null;
									if (!animatorIn)
									{
										animatorIn = prepareInAnimation();
										if (animatorIn)
										{
											currentAnimation = animatorIn.start();
											currentAnimation.done(function ()
											{
												currentAnimation = null;
												end();
												runner.complete()
											});
											return currentAnimation
										}
									}
									end();
									runner.complete()
								});
								runner = new $$AnimateRunner(
								{
									end: endFn,
									cancel: endFn
								});
								return runner;

								function endFn()
								{
									currentAnimation && currentAnimation.end()
								}
							}
						};

						function calculateAnchorStyles(anchor)
						{
							var styles = {};
							var coords = getDomNode(anchor).getBoundingClientRect();
							forEach(["width", "height", "top", "left"], function (key)
							{
								var value = coords[key];
								switch (key)
								{
								case "top":
									value += bodyNode.scrollTop;
									break;
								case "left":
									value += bodyNode.scrollLeft
								}
								styles[key] = Math.floor(value) + "px"
							});
							return styles
						}

						function prepareOutAnimation()
						{
							var animator = $animateCss(clone,
							{
								addClass: NG_OUT_ANCHOR_CLASS_NAME,
								delay: true,
								from: calculateAnchorStyles(outAnchor)
							});
							return animator.$$willAnimate ? animator : null
						}

						function getClassVal(element)
						{
							return element.attr("class") || ""
						}

						function prepareInAnimation()
						{
							var endingClasses = filterCssClasses(getClassVal(inAnchor));
							var toAdd = getUniqueValues(endingClasses, startingClasses);
							var toRemove = getUniqueValues(startingClasses, endingClasses);
							var animator = $animateCss(clone,
							{
								to: calculateAnchorStyles(inAnchor),
								addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
								removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
								delay: true
							});
							return animator.$$willAnimate ? animator : null
						}

						function end()
						{
							clone.remove();
							outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
							inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME)
						}
					}

					function prepareFromToAnchorAnimation(from, to, classes, anchors)
					{
						var fromAnimation = prepareRegularAnimation(from, noop);
						var toAnimation = prepareRegularAnimation(to, noop);
						var anchorAnimations = [];
						forEach(anchors, function (anchor)
						{
							var outElement = anchor["out"];
							var inElement = anchor["in"];
							var animator = prepareAnchoredAnimation(classes, outElement, inElement);
							animator && anchorAnimations.push(animator)
						});
						if (!fromAnimation && !toAnimation && 0 === anchorAnimations.length) return;
						return {
							start: function ()
							{
								var animationRunners = [];
								fromAnimation && animationRunners.push(fromAnimation.start());
								toAnimation && animationRunners.push(toAnimation.start());
								forEach(anchorAnimations, function (animation)
								{
									animationRunners.push(animation.start())
								});
								var runner = new $$AnimateRunner(
								{
									end: endFn,
									cancel: endFn
								});
								$$AnimateRunner.all(animationRunners, function (status)
								{
									runner.complete(status)
								});
								return runner;

								function endFn()
								{
									forEach(animationRunners, function (runner)
									{
										runner.end()
									})
								}
							}
						}
					}

					function prepareRegularAnimation(animationDetails)
					{
						var element = animationDetails.element;
						var options = animationDetails.options ||
						{};
						if (animationDetails.structural)
						{
							options.event = animationDetails.event;
							options.structural = true;
							options.applyClassesEarly = true;
							"leave" === animationDetails.event && (options.onDone = options.domOperation)
						}
						options.preparationClasses && (options.event = concatWithSpace(options.event, options.preparationClasses));
						var animator = $animateCss(element, options);
						return animator.$$willAnimate ? animator : null
					}
				}]
			}];
			var $$AnimateJsProvider = ["$animateProvider", function ($animateProvider)
			{
				this.$get = ["$injector", "$$AnimateRunner", "$$jqLite", function ($injector, $$AnimateRunner, $$jqLite)
				{
					var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
					return function (element, event, classes, options)
					{
						var animationClosed = false;
						if (3 === arguments.length && isObject(classes))
						{
							options = classes;
							classes = null
						}
						options = prepareAnimationOptions(options);
						if (!classes)
						{
							classes = element.attr("class") || "";
							options.addClass && (classes += " " + options.addClass);
							options.removeClass && (classes += " " + options.removeClass)
						}
						var classesToAdd = options.addClass;
						var classesToRemove = options.removeClass;
						var animations = lookupAnimations(classes);
						var before, after;
						if (animations.length)
						{
							var afterFn, beforeFn;
							if ("leave" === event)
							{
								beforeFn = "leave";
								afterFn = "afterLeave"
							}
							else
							{
								beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1);
								afterFn = event
							}
							"enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn));
							after = packageAnimations(element, event, options, animations, afterFn)
						}
						if (!before && !after) return;

						function applyOptions()
						{
							options.domOperation();
							applyAnimationClasses(element, options)
						}

						function close()
						{
							animationClosed = true;
							applyOptions();
							applyAnimationStyles(element, options)
						}
						var runner;
						return {
							$$willAnimate: true,
							end: function ()
							{
								if (runner) runner.end();
								else
								{
									close();
									runner = new $$AnimateRunner;
									runner.complete(true)
								}
								return runner
							},
							start: function ()
							{
								if (runner) return runner;
								runner = new $$AnimateRunner;
								var closeActiveAnimations;
								var chain = [];
								before && chain.push(function (fn)
								{
									closeActiveAnimations = before(fn)
								});
								chain.length ? chain.push(function (fn)
								{
									applyOptions();
									fn(true)
								}) : applyOptions();
								after && chain.push(function (fn)
								{
									closeActiveAnimations = after(fn)
								});
								runner.setHost(
								{
									end: function ()
									{
										endAnimations()
									},
									cancel: function ()
									{
										endAnimations(true)
									}
								});
								$$AnimateRunner.chain(chain, onComplete);
								return runner;

								function onComplete(success)
								{
									close(success);
									runner.complete(success)
								}

								function endAnimations(cancelled)
								{
									if (!animationClosed)
									{
										(closeActiveAnimations || noop)(cancelled);
										onComplete(cancelled)
									}
								}
							}
						};

						function executeAnimationFn(fn, element, event, options, onDone)
						{
							var args;
							switch (event)
							{
							case "animate":
								args = [element, options.from, options.to, onDone];
								break;
							case "setClass":
								args = [element, classesToAdd, classesToRemove, onDone];
								break;
							case "addClass":
								args = [element, classesToAdd, onDone];
								break;
							case "removeClass":
								args = [element, classesToRemove, onDone];
								break;
							default:
								args = [element, onDone]
							}
							args.push(options);
							var value = fn.apply(fn, args);
							if (value)
							{
								isFunction(value.start) && (value = value.start());
								if (value instanceof $$AnimateRunner) value.done(onDone);
								else if (isFunction(value)) return value
							}
							return noop
						}

						function groupEventedAnimations(element, event, options, animations, fnName)
						{
							var operations = [];
							forEach(animations, function (ani)
							{
								var animation = ani[fnName];
								if (!animation) return;
								operations.push(function ()
								{
									var runner;
									var endProgressCb;
									var resolved = false;
									var onAnimationComplete = function (rejected)
									{
										if (!resolved)
										{
											resolved = true;
											(endProgressCb || noop)(rejected);
											runner.complete(!rejected)
										}
									};
									runner = new $$AnimateRunner(
									{
										end: function ()
										{
											onAnimationComplete()
										},
										cancel: function ()
										{
											onAnimationComplete(true)
										}
									});
									endProgressCb = executeAnimationFn(animation, element, event, options, function (result)
									{
										var cancelled = false === result;
										onAnimationComplete(cancelled)
									});
									return runner
								})
							});
							return operations
						}

						function packageAnimations(element, event, options, animations, fnName)
						{
							var operations = groupEventedAnimations(element, event, options, animations, fnName);
							if (0 === operations.length)
							{
								var a, b;
								if ("beforeSetClass" === fnName)
								{
									a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass");
									b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")
								}
								else if ("setClass" === fnName)
								{
									a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass");
									b = groupEventedAnimations(element, "addClass", options, animations, "addClass")
								}
								a && (operations = operations.concat(a));
								b && (operations = operations.concat(b))
							}
							if (0 === operations.length) return;
							return function startAnimation(callback)
							{
								var runners = [];
								operations.length && forEach(operations, function (animateFn)
								{
									runners.push(animateFn())
								});
								runners.length ? $$AnimateRunner.all(runners, callback) : callback();
								return function endFn(reject)
								{
									forEach(runners, function (runner)
									{
										reject ? runner.cancel() : runner.end()
									})
								}
							}
						}
					};

					function lookupAnimations(classes)
					{
						classes = isArray(classes) ? classes : classes.split(" ");
						var matches = [],
							flagMap = {};
						for (var i = 0; i < classes.length; i++)
						{
							var klass = classes[i],
								animationFactory = $animateProvider.$$registeredAnimations[klass];
							if (animationFactory && !flagMap[klass])
							{
								matches.push($injector.get(animationFactory));
								flagMap[klass] = true
							}
						}
						return matches
					}
				}]
			}];
			var $$AnimateJsDriverProvider = ["$$animationProvider", function ($$animationProvider)
			{
				$$animationProvider.drivers.push("$$animateJsDriver");
				this.$get = ["$$animateJs", "$$AnimateRunner", function ($$animateJs, $$AnimateRunner)
				{
					return function initDriverFn(animationDetails)
					{
						if (animationDetails.from && animationDetails.to)
						{
							var fromAnimation = prepareAnimation(animationDetails.from);
							var toAnimation = prepareAnimation(animationDetails.to);
							if (!fromAnimation && !toAnimation) return;
							return {
								start: function ()
								{
									var animationRunners = [];
									fromAnimation && animationRunners.push(fromAnimation.start());
									toAnimation && animationRunners.push(toAnimation.start());
									$$AnimateRunner.all(animationRunners, done);
									var runner = new $$AnimateRunner(
									{
										end: endFnFactory(),
										cancel: endFnFactory()
									});
									return runner;

									function endFnFactory()
									{
										return function ()
										{
											forEach(animationRunners, function (runner)
											{
												runner.end()
											})
										}
									}

									function done(status)
									{
										runner.complete(status)
									}
								}
							}
						}
						return prepareAnimation(animationDetails)
					};

					function prepareAnimation(animationDetails)
					{
						var element = animationDetails.element;
						var event = animationDetails.event;
						var options = animationDetails.options;
						var classes = animationDetails.classes;
						return $$animateJs(element, event, classes, options)
					}
				}]
			}];
			var NG_ANIMATE_ATTR_NAME = "data-ng-animate";
			var NG_ANIMATE_PIN_DATA = "$ngAnimatePin";
			var $$AnimateQueueProvider = ["$animateProvider", function ($animateProvider)
			{
				var PRE_DIGEST_STATE = 1;
				var RUNNING_STATE = 2;
				var ONE_SPACE = " ";
				var rules = this.rules = {
					skip: [],
					cancel: [],
					join: []
				};

				function makeTruthyCssClassMap(classString)
				{
					if (!classString) return null;
					var keys = classString.split(ONE_SPACE);
					var map = Object.create(null);
					forEach(keys, function (key)
					{
						map[key] = true
					});
					return map
				}

				function hasMatchingClasses(newClassString, currentClassString)
				{
					if (newClassString && currentClassString)
					{
						var currentClassMap = makeTruthyCssClassMap(currentClassString);
						return newClassString.split(ONE_SPACE).some(function (className)
						{
							return currentClassMap[className]
						})
					}
				}

				function isAllowed(ruleType, currentAnimation, previousAnimation)
				{
					return rules[ruleType].some(function (fn)
					{
						return fn(currentAnimation, previousAnimation)
					})
				}

				function hasAnimationClasses(animation, and)
				{
					var a = (animation.addClass || "").length > 0;
					var b = (animation.removeClass || "").length > 0;
					return and ? a && b : a || b
				}
				rules.join.push(function (newAnimation, currentAnimation)
				{
					return !newAnimation.structural && hasAnimationClasses(newAnimation)
				});
				rules.skip.push(function (newAnimation, currentAnimation)
				{
					return !newAnimation.structural && !hasAnimationClasses(newAnimation)
				});
				rules.skip.push(function (newAnimation, currentAnimation)
				{
					return "leave" === currentAnimation.event && newAnimation.structural
				});
				rules.skip.push(function (newAnimation, currentAnimation)
				{
					return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural
				});
				rules.cancel.push(function (newAnimation, currentAnimation)
				{
					return currentAnimation.structural && newAnimation.structural
				});
				rules.cancel.push(function (newAnimation, currentAnimation)
				{
					return currentAnimation.state === RUNNING_STATE && newAnimation.structural
				});
				rules.cancel.push(function (newAnimation, currentAnimation)
				{
					if (currentAnimation.structural) return false;
					var nA = newAnimation.addClass;
					var nR = newAnimation.removeClass;
					var cA = currentAnimation.addClass;
					var cR = currentAnimation.removeClass;
					if (isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR)) return false;
					return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA)
				});
				this.$get = ["$$rAF", "$rootScope", "$rootElement", "$document", "$$Map", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function ($$rAF, $rootScope, $rootElement, $document, $$Map, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden)
				{
					var activeAnimationsLookup = new $$Map;
					var disabledElementsLookup = new $$Map;
					var animationsEnabled = null;

					function postDigestTaskFactory()
					{
						var postDigestCalled = false;
						return function (fn)
						{
							postDigestCalled ? fn() : $rootScope.$$postDigest(function ()
							{
								postDigestCalled = true;
								fn()
							})
						}
					}
					var deregisterWatch = $rootScope.$watch(function ()
					{
						return 0 === $templateRequest.totalPendingRequests
					}, function (isEmpty)
					{
						if (!isEmpty) return;
						deregisterWatch();
						$rootScope.$$postDigest(function ()
						{
							$rootScope.$$postDigest(function ()
							{
								null === animationsEnabled && (animationsEnabled = true)
							})
						})
					});
					var callbackRegistry = Object.create(null);
					var customFilter = $animateProvider.customFilter();
					var classNameFilter = $animateProvider.classNameFilter();
					var returnTrue = function ()
					{
						return true
					};
					var isAnimatableByFilter = customFilter || returnTrue;
					var isAnimatableClassName = classNameFilter ? function (node, options)
					{
						var className = [node.getAttribute("class"), options.addClass, options.removeClass].join(" ");
						return classNameFilter.test(className)
					} : returnTrue;
					var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

					function normalizeAnimationDetails(element, animation)
					{
						return mergeAnimationDetails(element, animation,
						{})
					}
					var contains = window.Node.prototype.contains || function (arg)
					{
						return this === arg || !!(16 & this.compareDocumentPosition(arg))
					};

					function findCallbacks(targetParentNode, targetNode, event)
					{
						var matches = [];
						var entries = callbackRegistry[event];
						entries && forEach(entries, function (entry)
						{
							contains.call(entry.node, targetNode) ? matches.push(entry.callback) : "leave" === event && contains.call(entry.node, targetParentNode) && matches.push(entry.callback)
						});
						return matches
					}

					function filterFromRegistry(list, matchContainer, matchCallback)
					{
						var containerNode = extractElementNode(matchContainer);
						return list.filter(function (entry)
						{
							var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
							return !isMatch
						})
					}

					function cleanupEventListeners(phase, node)
					{
						"close" !== phase || node.parentNode || $animate.off(node)
					}
					var $animate = {
						on: function (event, container, callback)
						{
							var node = extractElementNode(container);
							callbackRegistry[event] = callbackRegistry[event] || [];
							callbackRegistry[event].push(
							{
								node: node,
								callback: callback
							});
							jqLite(container).on("$destroy", function ()
							{
								var animationDetails = activeAnimationsLookup.get(node);
								animationDetails || $animate.off(event, container, callback)
							})
						},
						off: function (event, container, callback)
						{
							if (1 === arguments.length && !isString(arguments[0]))
							{
								container = arguments[0];
								for (var eventType in callbackRegistry) callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
								return
							}
							var entries = callbackRegistry[event];
							if (!entries) return;
							callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback)
						},
						pin: function (element, parentElement)
						{
							assertArg(isElement(element), "element", "not an element");
							assertArg(isElement(parentElement), "parentElement", "not an element");
							element.data(NG_ANIMATE_PIN_DATA, parentElement)
						},
						push: function (element, event, options, domOperation)
						{
							options = options ||
							{};
							options.domOperation = domOperation;
							return queueAnimation(element, event, options)
						},
						enabled: function (element, bool)
						{
							var argCount = arguments.length;
							if (0 === argCount) bool = !!animationsEnabled;
							else
							{
								var hasElement = isElement(element);
								if (hasElement)
								{
									var node = getDomNode(element);
									1 === argCount ? bool = !disabledElementsLookup.get(node) : disabledElementsLookup.set(node, !bool)
								}
								else bool = animationsEnabled = !!element
							}
							return bool
						}
					};
					return $animate;

					function queueAnimation(originalElement, event, initialOptions)
					{
						var options = copy(initialOptions);
						var element = stripCommentsFromElement(originalElement);
						var node = getDomNode(element);
						var parentNode = node && node.parentNode;
						options = prepareAnimationOptions(options);
						var runner = new $$AnimateRunner;
						var runInNextPostDigestOrNow = postDigestTaskFactory();
						isArray(options.addClass) && (options.addClass = options.addClass.join(" "));
						options.addClass && !isString(options.addClass) && (options.addClass = null);
						isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" "));
						options.removeClass && !isString(options.removeClass) && (options.removeClass = null);
						options.from && !isObject(options.from) && (options.from = null);
						options.to && !isObject(options.to) && (options.to = null);
						if (!animationsEnabled || !node || !isAnimatableByFilter(node, event, initialOptions) || !isAnimatableClassName(node, options))
						{
							close();
							return runner
						}
						var isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;
						var documentHidden = $$isDocumentHidden();
						var skipAnimations = documentHidden || disabledElementsLookup.get(node);
						var existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) ||
						{};
						var hasExistingAnimation = !!existingAnimation.state;
						skipAnimations || hasExistingAnimation && existingAnimation.state === PRE_DIGEST_STATE || (skipAnimations = !areAnimationsAllowed(node, parentNode, event));
						if (skipAnimations)
						{
							documentHidden && notifyProgress(runner, event, "start");
							close();
							documentHidden && notifyProgress(runner, event, "close");
							return runner
						}
						isStructural && closeChildAnimations(node);
						var newAnimation = {
							structural: isStructural,
							element: element,
							event: event,
							addClass: options.addClass,
							removeClass: options.removeClass,
							close: close,
							options: options,
							runner: runner
						};
						if (hasExistingAnimation)
						{
							var skipAnimationFlag = isAllowed("skip", newAnimation, existingAnimation);
							if (skipAnimationFlag)
							{
								if (existingAnimation.state === RUNNING_STATE)
								{
									close();
									return runner
								}
								mergeAnimationDetails(element, existingAnimation, newAnimation);
								return existingAnimation.runner
							}
							var cancelAnimationFlag = isAllowed("cancel", newAnimation, existingAnimation);
							if (cancelAnimationFlag)
								if (existingAnimation.state === RUNNING_STATE) existingAnimation.runner.end();
								else
								{
									if (!existingAnimation.structural)
									{
										mergeAnimationDetails(element, existingAnimation, newAnimation);
										return existingAnimation.runner
									}
									existingAnimation.close()
								}
							else
							{
								var joinAnimationFlag = isAllowed("join", newAnimation, existingAnimation);
								if (joinAnimationFlag)
								{
									if (existingAnimation.state !== RUNNING_STATE)
									{
										applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
										event = newAnimation.event = existingAnimation.event;
										options = mergeAnimationDetails(element, existingAnimation, newAnimation);
										return existingAnimation.runner
									}
									normalizeAnimationDetails(element, newAnimation)
								}
							}
						}
						else normalizeAnimationDetails(element, newAnimation);
						var isValidAnimation = newAnimation.structural;
						isValidAnimation || (isValidAnimation = "animate" === newAnimation.event && Object.keys(newAnimation.options.to ||
						{}).length > 0 || hasAnimationClasses(newAnimation));
						if (!isValidAnimation)
						{
							close();
							clearElementAnimationState(node);
							return runner
						}
						var counter = (existingAnimation.counter || 0) + 1;
						newAnimation.counter = counter;
						markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);
						$rootScope.$$postDigest(function ()
						{
							element = stripCommentsFromElement(originalElement);
							var animationDetails = activeAnimationsLookup.get(node);
							var animationCancelled = !animationDetails;
							animationDetails = animationDetails ||
							{};
							var parentElement = element.parent() || [];
							var isValidAnimation = parentElement.length > 0 && ("animate" === animationDetails.event || animationDetails.structural || hasAnimationClasses(animationDetails));
							if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation)
							{
								if (animationCancelled)
								{
									applyAnimationClasses(element, options);
									applyAnimationStyles(element, options)
								}
								if (animationCancelled || isStructural && animationDetails.event !== event)
								{
									options.domOperation();
									runner.end()
								}
								isValidAnimation || clearElementAnimationState(node);
								return
							}
							event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? "setClass" : animationDetails.event;
							markElementAnimationState(node, RUNNING_STATE);
							var realRunner = $$animation(element, event, animationDetails.options);
							runner.setHost(realRunner);
							notifyProgress(runner, event, "start",
							{});
							realRunner.done(function (status)
							{
								close(!status);
								var animationDetails = activeAnimationsLookup.get(node);
								animationDetails && animationDetails.counter === counter && clearElementAnimationState(node);
								notifyProgress(runner, event, "close",
								{})
							})
						});
						return runner;

						function notifyProgress(runner, event, phase, data)
						{
							runInNextPostDigestOrNow(function ()
							{
								var callbacks = findCallbacks(parentNode, node, event);
								callbacks.length ? $$rAF(function ()
								{
									forEach(callbacks, function (callback)
									{
										callback(element, phase, data)
									});
									cleanupEventListeners(phase, node)
								}) : cleanupEventListeners(phase, node)
							});
							runner.progress(event, phase, data)
						}

						function close(reject)
						{
							clearGeneratedClasses(element, options);
							applyAnimationClasses(element, options);
							applyAnimationStyles(element, options);
							options.domOperation();
							runner.complete(!reject)
						}
					}

					function closeChildAnimations(node)
					{
						var children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
						forEach(children, function (child)
						{
							var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);
							var animationDetails = activeAnimationsLookup.get(child);
							if (animationDetails) switch (state)
							{
							case RUNNING_STATE:
								animationDetails.runner.end();
							case PRE_DIGEST_STATE:
								activeAnimationsLookup.delete(child)
							}
						})
					}

					function clearElementAnimationState(node)
					{
						node.removeAttribute(NG_ANIMATE_ATTR_NAME);
						activeAnimationsLookup.delete(node)
					}

					function areAnimationsAllowed(node, parentNode, event)
					{
						var bodyNode = $document[0].body;
						var rootNode = getDomNode($rootElement);
						var bodyNodeDetected = node === bodyNode || "HTML" === node.nodeName;
						var rootNodeDetected = node === rootNode;
						var parentAnimationDetected = false;
						var elementDisabled = disabledElementsLookup.get(node);
						var animateChildren;
						var parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);
						parentHost && (parentNode = getDomNode(parentHost));
						while (parentNode)
						{
							rootNodeDetected || (rootNodeDetected = parentNode === rootNode);
							if (parentNode.nodeType !== ELEMENT_NODE) break;
							var details = activeAnimationsLookup.get(parentNode) ||
							{};
							if (!parentAnimationDetected)
							{
								var parentNodeDisabled = disabledElementsLookup.get(parentNode);
								if (true === parentNodeDisabled && false !== elementDisabled)
								{
									elementDisabled = true;
									break
								}
								false === parentNodeDisabled && (elementDisabled = false);
								parentAnimationDetected = details.structural
							}
							if (isUndefined(animateChildren) || true === animateChildren)
							{
								var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);
								isDefined(value) && (animateChildren = value)
							}
							if (parentAnimationDetected && false === animateChildren) break;
							bodyNodeDetected || (bodyNodeDetected = parentNode === bodyNode);
							if (bodyNodeDetected && rootNodeDetected) break;
							if (!rootNodeDetected)
							{
								parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA);
								if (parentHost)
								{
									parentNode = getDomNode(parentHost);
									continue
								}
							}
							parentNode = parentNode.parentNode
						}
						var allowAnimation = (!parentAnimationDetected || animateChildren) && true !== elementDisabled;
						return allowAnimation && rootNodeDetected && bodyNodeDetected
					}

					function markElementAnimationState(node, state, details)
					{
						details = details ||
						{};
						details.state = state;
						node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
						var oldValue = activeAnimationsLookup.get(node);
						var newValue = oldValue ? extend(oldValue, details) : details;
						activeAnimationsLookup.set(node, newValue)
					}
				}]
			}];
			var $$AnimationProvider = ["$animateProvider", function ($animateProvider)
			{
				var NG_ANIMATE_REF_ATTR = "ng-animate-ref";
				var drivers = this.drivers = [];
				var RUNNER_STORAGE_KEY = "$$animationRunner";

				function setRunner(element, runner)
				{
					element.data(RUNNER_STORAGE_KEY, runner)
				}

				function removeRunner(element)
				{
					element.removeData(RUNNER_STORAGE_KEY)
				}

				function getRunner(element)
				{
					return element.data(RUNNER_STORAGE_KEY)
				}
				this.$get = ["$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$Map", "$$rAFScheduler", function ($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler)
				{
					var animationQueue = [];
					var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

					function sortAnimations(animations)
					{
						var tree = {
							children: []
						};
						var i, lookup = new $$Map;
						for (i = 0; i < animations.length; i++)
						{
							var animation = animations[i];
							lookup.set(animation.domNode, animations[i] = {
								domNode: animation.domNode,
								fn: animation.fn,
								children: []
							})
						}
						for (i = 0; i < animations.length; i++) processNode(animations[i]);
						return flatten(tree);

						function processNode(entry)
						{
							if (entry.processed) return entry;
							entry.processed = true;
							var elementNode = entry.domNode;
							var parentNode = elementNode.parentNode;
							lookup.set(elementNode, entry);
							var parentEntry;
							while (parentNode)
							{
								parentEntry = lookup.get(parentNode);
								if (parentEntry)
								{
									parentEntry.processed || (parentEntry = processNode(parentEntry));
									break
								}
								parentNode = parentNode.parentNode
							}(parentEntry || tree).children.push(entry);
							return entry
						}

						function flatten(tree)
						{
							var result = [];
							var queue = [];
							var i;
							for (i = 0; i < tree.children.length; i++) queue.push(tree.children[i]);
							var remainingLevelEntries = queue.length;
							var nextLevelEntries = 0;
							var row = [];
							for (i = 0; i < queue.length; i++)
							{
								var entry = queue[i];
								if (remainingLevelEntries <= 0)
								{
									remainingLevelEntries = nextLevelEntries;
									nextLevelEntries = 0;
									result.push(row);
									row = []
								}
								row.push(entry.fn);
								entry.children.forEach(function (childEntry)
								{
									nextLevelEntries++;
									queue.push(childEntry)
								});
								remainingLevelEntries--
							}
							row.length && result.push(row);
							return result
						}
					}
					return function (element, event, options)
					{
						options = prepareAnimationOptions(options);
						var isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;
						var runner = new $$AnimateRunner(
						{
							end: function ()
							{
								close()
							},
							cancel: function ()
							{
								close(true)
							}
						});
						if (!drivers.length)
						{
							close();
							return runner
						}
						setRunner(element, runner);
						var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass));
						var tempClasses = options.tempClasses;
						if (tempClasses)
						{
							classes += " " + tempClasses;
							options.tempClasses = null
						}
						var prepareClassName;
						if (isStructural)
						{
							prepareClassName = "ng-" + event + PREPARE_CLASS_SUFFIX;
							$$jqLite.addClass(element, prepareClassName)
						}
						animationQueue.push(
						{
							element: element,
							classes: classes,
							event: event,
							structural: isStructural,
							options: options,
							beforeStart: beforeStart,
							close: close
						});
						element.on("$destroy", handleDestroyedElement);
						if (animationQueue.length > 1) return runner;
						$rootScope.$$postDigest(function ()
						{
							var animations = [];
							forEach(animationQueue, function (entry)
							{
								getRunner(entry.element) ? animations.push(entry) : entry.close()
							});
							animationQueue.length = 0;
							var groupedAnimations = groupAnimations(animations);
							var toBeSortedAnimations = [];
							forEach(groupedAnimations, function (animationEntry)
							{
								toBeSortedAnimations.push(
								{
									domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
									fn: function triggerAnimationStart()
									{
										animationEntry.beforeStart();
										var startAnimationFn, closeFn = animationEntry.close;
										var targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
										if (getRunner(targetElement))
										{
											var operation = invokeFirstDriver(animationEntry);
											operation && (startAnimationFn = operation.start)
										}
										if (startAnimationFn)
										{
											var animationRunner = startAnimationFn();
											animationRunner.done(function (status)
											{
												closeFn(!status)
											});
											updateAnimationRunners(animationEntry, animationRunner)
										}
										else closeFn()
									}
								})
							});
							$$rAFScheduler(sortAnimations(toBeSortedAnimations))
						});
						return runner;

						function getAnchorNodes(node)
						{
							var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]";
							var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
							var anchors = [];
							forEach(items, function (node)
							{
								var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
								attr && attr.length && anchors.push(node)
							});
							return anchors
						}

						function groupAnimations(animations)
						{
							var preparedAnimations = [];
							var refLookup = {};
							forEach(animations, function (animation, index)
							{
								var element = animation.element;
								var node = getDomNode(element);
								var event = animation.event;
								var enterOrMove = ["enter", "move"].indexOf(event) >= 0;
								var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
								if (anchorNodes.length)
								{
									var direction = enterOrMove ? "to" : "from";
									forEach(anchorNodes, function (anchor)
									{
										var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
										refLookup[key] = refLookup[key] ||
										{};
										refLookup[key][direction] = {
											animationID: index,
											element: jqLite(anchor)
										}
									})
								}
								else preparedAnimations.push(animation)
							});
							var usedIndicesLookup = {};
							var anchorGroups = {};
							forEach(refLookup, function (operations, key)
							{
								var from = operations.from;
								var to = operations.to;
								if (!from || !to)
								{
									var index = from ? from.animationID : to.animationID;
									var indexKey = index.toString();
									if (!usedIndicesLookup[indexKey])
									{
										usedIndicesLookup[indexKey] = true;
										preparedAnimations.push(animations[index])
									}
									return
								}
								var fromAnimation = animations[from.animationID];
								var toAnimation = animations[to.animationID];
								var lookupKey = from.animationID.toString();
								if (!anchorGroups[lookupKey])
								{
									var group = anchorGroups[lookupKey] = {
										structural: true,
										beforeStart: function ()
										{
											fromAnimation.beforeStart();
											toAnimation.beforeStart()
										},
										close: function ()
										{
											fromAnimation.close();
											toAnimation.close()
										},
										classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
										from: fromAnimation,
										to: toAnimation,
										anchors: []
									};
									if (group.classes.length) preparedAnimations.push(group);
									else
									{
										preparedAnimations.push(fromAnimation);
										preparedAnimations.push(toAnimation)
									}
								}
								anchorGroups[lookupKey].anchors.push(
								{
									out: from.element,
									in: to.element
								})
							});
							return preparedAnimations
						}

						function cssClassesIntersection(a, b)
						{
							a = a.split(" ");
							b = b.split(" ");
							var matches = [];
							for (var i = 0; i < a.length; i++)
							{
								var aa = a[i];
								if ("ng-" === aa.substring(0, 3)) continue;
								for (var j = 0; j < b.length; j++)
									if (aa === b[j])
									{
										matches.push(aa);
										break
									}
							}
							return matches.join(" ")
						}

						function invokeFirstDriver(animationDetails)
						{
							for (var i = drivers.length - 1; i >= 0; i--)
							{
								var driverName = drivers[i];
								var factory = $injector.get(driverName);
								var driver = factory(animationDetails);
								if (driver) return driver
							}
						}

						function beforeStart()
						{
							element.addClass(NG_ANIMATE_CLASSNAME);
							tempClasses && $$jqLite.addClass(element, tempClasses);
							if (prepareClassName)
							{
								$$jqLite.removeClass(element, prepareClassName);
								prepareClassName = null
							}
						}

						function updateAnimationRunners(animation, newRunner)
						{
							if (animation.from && animation.to)
							{
								update(animation.from.element);
								update(animation.to.element)
							}
							else update(animation.element);

							function update(element)
							{
								var runner = getRunner(element);
								runner && runner.setHost(newRunner)
							}
						}

						function handleDestroyedElement()
						{
							var runner = getRunner(element);
							!runner || "leave" === event && options.$$domOperationFired || runner.end()
						}

						function close(rejected)
						{
							element.off("$destroy", handleDestroyedElement);
							removeRunner(element);
							applyAnimationClasses(element, options);
							applyAnimationStyles(element, options);
							options.domOperation();
							tempClasses && $$jqLite.removeClass(element, tempClasses);
							element.removeClass(NG_ANIMATE_CLASSNAME);
							runner.complete(!rejected)
						}
					}
				}]
			}];
			var ngAnimateSwapDirective = ["$animate", "$rootScope", function ($animate, $rootScope)
			{
				return {
					restrict: "A",
					transclude: "element",
					terminal: true,
					priority: 600,
					link: function (scope, $element, attrs, ctrl, $transclude)
					{
						var previousElement, previousScope;
						scope.$watchCollection(attrs.ngAnimateSwap || attrs["for"], function (value)
						{
							previousElement && $animate.leave(previousElement);
							if (previousScope)
							{
								previousScope.$destroy();
								previousScope = null
							}
							if (value || 0 === value)
							{
								previousScope = scope.$new();
								$transclude(previousScope, function (element)
								{
									previousElement = element;
									$animate.enter(element, null, $element)
								})
							}
						})
					}
				}
			}];
			var copy;
			var extend;
			var forEach;
			var isArray;
			var isDefined;
			var isElement;
			var isFunction;
			var isObject;
			var isString;
			var isUndefined;
			var jqLite;
			var noop;
			angular.module("ngAnimate", [], function initAngularHelpers()
			{
				noop = angular.noop;
				copy = angular.copy;
				extend = angular.extend;
				jqLite = angular.element;
				forEach = angular.forEach;
				isArray = angular.isArray;
				isString = angular.isString;
				isObject = angular.isObject;
				isUndefined = angular.isUndefined;
				isDefined = angular.isDefined;
				isFunction = angular.isFunction;
				isElement = angular.isElement
			}).info(
			{
				angularVersion: "1.6.5"
			}).directive("ngAnimateSwap", ngAnimateSwapDirective).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", $$rAFSchedulerFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider)
		})(window, window.angular)
	},
	5242: function (module, exports)
	{
		/*!
		 * AngularJS Material Design
		 * https://github.com/angular/material
		 * @license MIT
		 * v1.1.10
		 */
		(function (window, angular, undefined)
		{
			"use strict";
			void angular.module("ngMaterial", ["ng", "ngAnimate", "ngAria", "material.core", "material.core.gestures", "material.core.interaction", "material.core.layout", "material.core.meta", "material.core.theming.palette", "material.core.theming", "material.core.animate", "material.components.autocomplete", "material.components.backdrop", "material.components.bottomSheet", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.chips", "material.components.colors", "material.components.content", "material.components.datepicker", "material.components.dialog", "material.components.divider", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.gridList", "material.components.icon", "material.components.input", "material.components.list", "material.components.menu", "material.components.menuBar", "material.components.navBar", "material.components.panel", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.toast", "material.components.toolbar", "material.components.tooltip", "material.components.truncate", "material.components.virtualRepeat", "material.components.whiteframe"]);
			(function ()
			{
				DetectNgTouch.$inject = ["$log", "$injector"];
				MdCoreConfigure.$inject = ["$provide", "$mdThemingProvider"];
				rAFDecorator.$inject = ["$delegate"];
				qDecorator.$inject = ["$delegate"];
				angular.module("material.core", ["ngAnimate", "material.core.animate", "material.core.layout", "material.core.interaction", "material.core.gestures", "material.core.theming"]).config(MdCoreConfigure).run(DetectNgTouch);

				function DetectNgTouch($log, $injector)
				{
					if ($injector.has("$swipe"))
					{
						var msg = "You are using the ngTouch module. \nAngularJS Material already has mobile click, tap, and swipe support... \nngTouch is not supported with AngularJS Material!";
						$log.warn(msg)
					}
				}

				function MdCoreConfigure($provide, $mdThemingProvider)
				{
					$provide.decorator("$$rAF", ["$delegate", rAFDecorator]);
					$provide.decorator("$q", ["$delegate", qDecorator]);
					$mdThemingProvider.theme("default").primaryPalette("indigo").accentPalette("pink").warnPalette("deep-orange").backgroundPalette("grey")
				}

				function rAFDecorator($delegate)
				{
					$delegate.throttle = function (cb)
					{
						var queuedArgs, alreadyQueued, queueCb, context;
						return function debounced()
						{
							queuedArgs = arguments;
							context = this;
							queueCb = cb;
							if (!alreadyQueued)
							{
								alreadyQueued = true;
								$delegate(function ()
								{
									queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
									alreadyQueued = false
								})
							}
						}
					};
					return $delegate
				}

				function qDecorator($delegate)
				{
					$delegate.resolve || ($delegate.resolve = $delegate.when);
					return $delegate
				}
			})();
			(function ()
			{
				MdAutofocusDirective.$inject = ["$parse"];
				angular.module("material.core").directive("mdAutofocus", MdAutofocusDirective).directive("mdAutoFocus", MdAutofocusDirective).directive("mdSidenavFocus", MdAutofocusDirective);

				function MdAutofocusDirective($parse)
				{
					return {
						restrict: "A",
						link:
						{
							pre: preLink
						}
					};

					function preLink(scope, element, attr)
					{
						var attrExp = attr.mdAutoFocus || attr.mdAutofocus || attr.mdSidenavFocus;
						updateExpression($parse(attrExp)(scope));
						attrExp && scope.$watch(attrExp, updateExpression);

						function updateExpression(value)
						{
							angular.isUndefined(value) && (value = true);
							element.toggleClass("md-autofocus", !!value)
						}
					}
				}
			})();
			(function ()
			{
				angular.module("material.core").factory("$mdColorUtil", ColorUtilFactory);

				function ColorUtilFactory()
				{
					function hexToRgba(color)
					{
						var hex = "#" === color[0] ? color.substr(1) : color,
							dig = hex.length / 3,
							red = hex.substr(0, dig),
							green = hex.substr(dig, dig),
							blue = hex.substr(2 * dig);
						if (1 === dig)
						{
							red += red;
							green += green;
							blue += blue
						}
						return "rgba(" + parseInt(red, 16) + "," + parseInt(green, 16) + "," + parseInt(blue, 16) + ",0.1)"
					}

					function rgbaToHex(color)
					{
						color = color.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
						var hex = color && 4 === color.length ? "#" + ("0" + parseInt(color[1], 10).toString(16)).slice(-2) + ("0" + parseInt(color[2], 10).toString(16)).slice(-2) + ("0" + parseInt(color[3], 10).toString(16)).slice(-2) : "";
						return hex.toUpperCase()
					}

					function rgbToRgba(color)
					{
						return color.replace(")", ", 0.1)").replace("(", "a(")
					}

					function rgbaToRgb(color)
					{
						return color ? color.replace("rgba", "rgb").replace(/,[^),]+\)/, ")") : "rgb(0,0,0)"
					}
					return {
						rgbaToHex: rgbaToHex,
						hexToRgba: hexToRgba,
						rgbToRgba: rgbToRgba,
						rgbaToRgb: rgbaToRgb
					}
				}
			})();
			(function ()
			{
				angular.module("material.core").factory("$mdConstant", MdConstantFactory);

				function MdConstantFactory()
				{
					var prefixTestEl = document.createElement("div");
					var vendorPrefix = getVendorPrefix(prefixTestEl);
					var isWebkit = /webkit/i.test(vendorPrefix);
					var SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;

					function vendorProperty(name)
					{
						var prefixedName = vendorPrefix + "-" + name;
						var ucPrefix = camelCase(prefixedName);
						var lcPrefix = ucPrefix.charAt(0).toLowerCase() + ucPrefix.substring(1);
						return hasStyleProperty(prefixTestEl, name) ? name : hasStyleProperty(prefixTestEl, ucPrefix) ? ucPrefix : hasStyleProperty(prefixTestEl, lcPrefix) ? lcPrefix : name
					}

					function hasStyleProperty(testElement, property)
					{
						return angular.isDefined(testElement.style[property])
					}

					function camelCase(input)
					{
						return input.replace(SPECIAL_CHARS_REGEXP, function (matches, separator, letter, offset)
						{
							return offset ? letter.toUpperCase() : letter
						})
					}

					function getVendorPrefix(testElement)
					{
						var prop, match;
						var vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/;
						for (prop in testElement.style)
							if (match = vendorRegex.exec(prop)) return match[0]
					}
					var self = {
						isInputKey: function (e)
						{
							return e.keyCode >= 31 && e.keyCode <= 90
						},
						isNumPadKey: function (e)
						{
							return 3 === e.location && e.keyCode >= 97 && e.keyCode <= 105
						},
						isMetaKey: function (e)
						{
							return e.keyCode >= 91 && e.keyCode <= 93
						},
						isFnLockKey: function (e)
						{
							return e.keyCode >= 112 && e.keyCode <= 145
						},
						isNavigationKey: function (e)
						{
							var kc = self.KEY_CODE,
								NAVIGATION_KEYS = [kc.SPACE, kc.ENTER, kc.UP_ARROW, kc.DOWN_ARROW];
							return -1 != NAVIGATION_KEYS.indexOf(e.keyCode)
						},
						hasModifierKey: function (e)
						{
							return e.ctrlKey || e.metaKey || e.altKey
						},
						ELEMENT_MAX_PIXELS: 1533917,
						BEFORE_NG_ARIA: 210,
						KEY_CODE:
						{
							COMMA: 188,
							SEMICOLON: 186,
							ENTER: 13,
							ESCAPE: 27,
							SPACE: 32,
							PAGE_UP: 33,
							PAGE_DOWN: 34,
							END: 35,
							HOME: 36,
							LEFT_ARROW: 37,
							UP_ARROW: 38,
							RIGHT_ARROW: 39,
							DOWN_ARROW: 40,
							TAB: 9,
							BACKSPACE: 8,
							DELETE: 46
						},
						CSS:
						{
							TRANSITIONEND: "transitionend" + (isWebkit ? " webkitTransitionEnd" : ""),
							ANIMATIONEND: "animationend" + (isWebkit ? " webkitAnimationEnd" : ""),
							TRANSFORM: vendorProperty("transform"),
							TRANSFORM_ORIGIN: vendorProperty("transformOrigin"),
							TRANSITION: vendorProperty("transition"),
							TRANSITION_DURATION: vendorProperty("transitionDuration"),
							ANIMATION_PLAY_STATE: vendorProperty("animationPlayState"),
							ANIMATION_DURATION: vendorProperty("animationDuration"),
							ANIMATION_NAME: vendorProperty("animationName"),
							ANIMATION_TIMING: vendorProperty("animationTimingFunction"),
							ANIMATION_DIRECTION: vendorProperty("animationDirection")
						},
						MEDIA:
						{
							xs: "(max-width: 599px)",
							"gt-xs": "(min-width: 600px)",
							sm: "(min-width: 600px) and (max-width: 959px)",
							"gt-sm": "(min-width: 960px)",
							md: "(min-width: 960px) and (max-width: 1279px)",
							"gt-md": "(min-width: 1280px)",
							lg: "(min-width: 1280px) and (max-width: 1919px)",
							"gt-lg": "(min-width: 1920px)",
							xl: "(min-width: 1920px)",
							landscape: "(orientation: landscape)",
							portrait: "(orientation: portrait)",
							print: "print"
						},
						MEDIA_PRIORITY: ["xl", "gt-lg", "lg", "gt-md", "md", "gt-sm", "sm", "gt-xs", "xs", "landscape", "portrait", "print"]
					};
					return self
				}
			})();
			(function ()
			{
				angular.module("material.core").config(["$provide", function ($provide)
				{
					$provide.decorator("$mdUtil", ["$delegate", function ($delegate)
					{
						$delegate.iterator = MdIterator;
						return $delegate
					}])
				}]);

				function MdIterator(items, reloop)
				{
					var trueFn = function ()
					{
						return true
					};
					items && !angular.isArray(items) && (items = Array.prototype.slice.call(items));
					reloop = !!reloop;
					var _items = items || [];
					return {
						items: getItems,
						count: count,
						inRange: inRange,
						contains: contains,
						indexOf: indexOf,
						itemAt: itemAt,
						findBy: findBy,
						add: add,
						remove: remove,
						first: first,
						last: last,
						next: angular.bind(null, findSubsequentItem, false),
						previous: angular.bind(null, findSubsequentItem, true),
						hasPrevious: hasPrevious,
						hasNext: hasNext
					};

					function getItems()
					{
						return [].concat(_items)
					}

					function count()
					{
						return _items.length
					}

					function inRange(index)
					{
						return _items.length && index > -1 && index < _items.length
					}

					function hasNext(item)
					{
						return !!item && inRange(indexOf(item) + 1)
					}

					function hasPrevious(item)
					{
						return !!item && inRange(indexOf(item) - 1)
					}

					function itemAt(index)
					{
						return inRange(index) ? _items[index] : null
					}

					function findBy(key, val)
					{
						return _items.filter(function (item)
						{
							return item[key] === val
						})
					}

					function add(item, index)
					{
						if (!item) return -1;
						angular.isNumber(index) || (index = _items.length);
						_items.splice(index, 0, item);
						return indexOf(item)
					}

					function remove(item)
					{
						contains(item) && _items.splice(indexOf(item), 1)
					}

					function indexOf(item)
					{
						return _items.indexOf(item)
					}

					function contains(item)
					{
						return item && indexOf(item) > -1
					}

					function first()
					{
						return _items.length ? _items[0] : null
					}

					function last()
					{
						return _items.length ? _items[_items.length - 1] : null
					}

					function findSubsequentItem(backwards, item, validate, limit)
					{
						validate = validate || trueFn;
						var curIndex = indexOf(item);
						while (true)
						{
							if (!inRange(curIndex)) return null;
							var nextIndex = curIndex + (backwards ? -1 : 1);
							var foundItem = null;
							if (inRange(nextIndex)) foundItem = _items[nextIndex];
							else if (reloop)
							{
								foundItem = backwards ? last() : first();
								nextIndex = indexOf(foundItem)
							}
							if (null === foundItem || nextIndex === limit) return null;
							if (validate(foundItem)) return foundItem;
							angular.isUndefined(limit) && (limit = nextIndex);
							curIndex = nextIndex
						}
					}
				}
			})();
			(function ()
			{
				mdMediaFactory.$inject = ["$mdConstant", "$rootScope", "$window"];
				angular.module("material.core").factory("$mdMedia", mdMediaFactory);

				function mdMediaFactory($mdConstant, $rootScope, $window)
				{
					var queries = {};
					var mqls = {};
					var results = {};
					var normalizeCache = {};
					$mdMedia.getResponsiveAttribute = getResponsiveAttribute;
					$mdMedia.getQuery = getQuery;
					$mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;
					return $mdMedia;

					function $mdMedia(query)
					{
						var validated = queries[query];
						angular.isUndefined(validated) && (validated = queries[query] = validate(query));
						var result = results[validated];
						angular.isUndefined(result) && (result = add(validated));
						return result
					}

					function validate(query)
					{
						return $mdConstant.MEDIA[query] || ("(" !== query.charAt(0) ? "(" + query + ")" : query)
					}

					function add(query)
					{
						var result = mqls[query];
						result || (result = mqls[query] = $window.matchMedia(query));
						result.addListener(onQueryChange);
						return results[result.media] = !!result.matches
					}

					function onQueryChange(query)
					{
						$rootScope.$evalAsync(function ()
						{
							results[query.media] = !!query.matches
						})
					}

					function getQuery(name)
					{
						return mqls[name]
					}

					function getResponsiveAttribute(attrs, attrName)
					{
						for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++)
						{
							var mediaName = $mdConstant.MEDIA_PRIORITY[i];
							if (!mqls[queries[mediaName]].matches) continue;
							var normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
							if (attrs[normalizedName]) return attrs[normalizedName]
						}
						return attrs[getNormalizedName(attrs, attrName)]
					}

					function watchResponsiveAttributes(attrNames, attrs, watchFn)
					{
						var unwatchFns = [];
						attrNames.forEach(function (attrName)
						{
							var normalizedName = getNormalizedName(attrs, attrName);
							angular.isDefined(attrs[normalizedName]) && unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
							for (var mediaName in $mdConstant.MEDIA)
							{
								normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
								angular.isDefined(attrs[normalizedName]) && unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)))
							}
						});
						return function unwatch()
						{
							unwatchFns.forEach(function (fn)
							{
								fn()
							})
						}
					}

					function getNormalizedName(attrs, attrName)
					{
						return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName))
					}
				}
			})();
			(function ()
			{
				angular.module("material.core").config(["$provide", function ($provide)
				{
					$provide.decorator("$mdUtil", ["$delegate", function ($delegate)
					{
						$delegate.prefixer = MdPrefixer;
						return $delegate
					}])
				}]);

				function MdPrefixer(initialAttributes, buildSelector)
				{
					var PREFIXES = ["data", "x"];
					if (initialAttributes) return buildSelector ? _buildSelector(initialAttributes) : _buildList(initialAttributes);
					return {
						buildList: _buildList,
						buildSelector: _buildSelector,
						hasAttribute: _hasAttribute,
						removeAttribute: _removeAttribute
					};

					function _buildList(attributes)
					{
						attributes = angular.isArray(attributes) ? attributes : [attributes];
						attributes.forEach(function (item)
						{
							PREFIXES.forEach(function (prefix)
							{
								attributes.push(prefix + "-" + item)
							})
						});
						return attributes
					}

					function _buildSelector(attributes)
					{
						attributes = angular.isArray(attributes) ? attributes : [attributes];
						return _buildList(attributes).map(function (item)
						{
							return "[" + item + "]"
						}).join(",")
					}

					function _hasAttribute(element, attribute)
					{
						element = _getNativeElement(element);
						if (!element) return false;
						var prefixedAttrs = _buildList(attribute);
						for (var i = 0; i < prefixedAttrs.length; i++)
							if (element.hasAttribute(prefixedAttrs[i])) return true;
						return false
					}

					function _removeAttribute(element, attribute)
					{
						element = _getNativeElement(element);
						if (!element) return;
						_buildList(attribute).forEach(function (prefixedAttribute)
						{
							element.removeAttribute(prefixedAttribute)
						})
					}

					function _getNativeElement(element)
					{
						element = element[0] || element;
						if (element.nodeType) return element
					}
				}
			})();
			(function ()
			{
				UtilFactory.$inject = ["$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window", "$$rAF"];
				var nextUniqueId = 0;
				angular.module("material.core").factory("$mdUtil", UtilFactory);

				function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window, $$rAF)
				{
					var startSymbol = $interpolate.startSymbol(),
						endSymbol = $interpolate.endSymbol(),
						usesStandardSymbols = "{{" === startSymbol && "}}" === endSymbol;
					var hasComputedStyle = function (target, key, expectedVal)
					{
						var hasValue = false;
						if (target && target.length)
						{
							var computedStyles = $window.getComputedStyle(target[0]);
							hasValue = angular.isDefined(computedStyles[key]) && (!expectedVal || computedStyles[key] == expectedVal)
						}
						return hasValue
					};

					function validateCssValue(value)
					{
						return value ? hasPx(value) || hasPercent(value) ? value : value + "px" : "0"
					}

					function hasPx(value)
					{
						return String(value).indexOf("px") > -1
					}

					function hasPercent(value)
					{
						return String(value).indexOf("%") > -1
					}
					var $mdUtil = {
						dom:
						{},
						now: window.performance && window.performance.now ? angular.bind(window.performance, window.performance.now) : Date.now || function ()
						{
							return (new Date).getTime()
						},
						getModelOption: function (ngModelCtrl, optionName)
						{
							if (!ngModelCtrl.$options) return;
							var $options = ngModelCtrl.$options;
							return $options.getOption ? $options.getOption(optionName) : $options[optionName]
						},
						bidi: function (element, property, lValue, rValue)
						{
							var ltr = !("rtl" == $document[0].dir || "rtl" == $document[0].body.dir);
							if (0 == arguments.length) return ltr ? "ltr" : "rtl";
							var elem = angular.element(element);
							ltr && angular.isDefined(lValue) ? elem.css(property, validateCssValue(lValue)) : !ltr && angular.isDefined(rValue) && elem.css(property, validateCssValue(rValue))
						},
						bidiProperty: function (element, lProperty, rProperty, value)
						{
							var ltr = !("rtl" == $document[0].dir || "rtl" == $document[0].body.dir);
							var elem = angular.element(element);
							if (ltr && angular.isDefined(lProperty))
							{
								elem.css(lProperty, validateCssValue(value));
								elem.css(rProperty, "")
							}
							else if (!ltr && angular.isDefined(rProperty))
							{
								elem.css(rProperty, validateCssValue(value));
								elem.css(lProperty, "")
							}
						},
						clientRect: function (element, offsetParent, isOffsetRect)
						{
							var node = getNode(element);
							offsetParent = getNode(offsetParent || node.offsetParent || document.body);
							var nodeRect = node.getBoundingClientRect();
							var offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() :
							{
								left: 0,
								top: 0,
								width: 0,
								height: 0
							};
							return {
								left: nodeRect.left - offsetRect.left,
								top: nodeRect.top - offsetRect.top,
								width: nodeRect.width,
								height: nodeRect.height
							}
						},
						offsetRect: function (element, offsetParent)
						{
							return $mdUtil.clientRect(element, offsetParent, true)
						},
						nodesToArray: function (nodes)
						{
							nodes = nodes || [];
							var results = [];
							for (var i = 0; i < nodes.length; ++i) results.push(nodes.item(i));
							return results
						},
						getViewportTop: function ()
						{
							return window.scrollY || window.pageYOffset || 0
						},
						findFocusTarget: function (containerEl, attributeVal)
						{
							var AUTO_FOCUS = this.prefixer("md-autofocus", true);
							var elToFocus;
							elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);
							if (!elToFocus && attributeVal != AUTO_FOCUS)
							{
								elToFocus = scanForFocusable(containerEl, this.prefixer("md-auto-focus", true));
								elToFocus || (elToFocus = scanForFocusable(containerEl, AUTO_FOCUS))
							}
							return elToFocus;

							function scanForFocusable(target, selector)
							{
								var elFound, items = target[0].querySelectorAll(selector);
								items && items.length && items.length && angular.forEach(items, function (it)
								{
									it = angular.element(it);
									var isFocusable = it.hasClass("md-autofocus");
									isFocusable && (elFound = it)
								});
								return elFound
							}
						},
						disableScrollAround: function (element, parent, options)
						{
							options = options ||
							{};
							$mdUtil.disableScrollAround._count = Math.max(0, $mdUtil.disableScrollAround._count || 0);
							$mdUtil.disableScrollAround._count++;
							if ($mdUtil.disableScrollAround._restoreScroll) return $mdUtil.disableScrollAround._restoreScroll;
							var body = $document[0].body;
							var restoreBody = disableBodyScroll();
							var restoreElement = disableElementScroll(parent);
							return $mdUtil.disableScrollAround._restoreScroll = function ()
							{
								if (--$mdUtil.disableScrollAround._count <= 0)
								{
									restoreBody();
									restoreElement();
									delete $mdUtil.disableScrollAround._restoreScroll
								}
							};

							function disableElementScroll(element)
							{
								element = angular.element(element || body);
								var scrollMask;
								if (options.disableScrollMask) scrollMask = element;
								else
								{
									scrollMask = angular.element('<div class="md-scroll-mask">  <div class="md-scroll-mask-bar"></div></div>');
									element.append(scrollMask)
								}
								scrollMask.on("wheel", preventDefault);
								scrollMask.on("touchmove", preventDefault);
								return function restoreElementScroll()
								{
									scrollMask.off("wheel");
									scrollMask.off("touchmove");
									!options.disableScrollMask && scrollMask[0].parentNode && scrollMask[0].parentNode.removeChild(scrollMask[0])
								};

								function preventDefault(e)
								{
									e.preventDefault()
								}
							}

							function disableBodyScroll()
							{
								var documentElement = $document[0].documentElement;
								var prevDocumentStyle = documentElement.style.cssText || "";
								var prevBodyStyle = body.style.cssText || "";
								var viewportTop = $mdUtil.getViewportTop();
								var clientWidth = body.clientWidth;
								var hasVerticalScrollbar = body.scrollHeight > body.clientHeight + 1;
								var scrollElement = documentElement.scrollTop > 0 ? documentElement : body;
								hasVerticalScrollbar && angular.element(body).css(
								{
									position: "fixed",
									width: "100%",
									top: -viewportTop + "px"
								});
								body.clientWidth < clientWidth && (body.style.overflow = "hidden");
								hasVerticalScrollbar && (documentElement.style.overflowY = "scroll");
								return function restoreScroll()
								{
									body.style.cssText = prevBodyStyle;
									documentElement.style.cssText = prevDocumentStyle;
									scrollElement.scrollTop = viewportTop
								}
							}
						},
						enableScrolling: function ()
						{
							var restoreFn = this.disableScrollAround._restoreScroll;
							restoreFn && restoreFn()
						},
						floatingScrollbars: function ()
						{
							if (this.floatingScrollbars.cached === undefined)
							{
								var tempNode = angular.element("<div><div></div></div>").css(
								{
									width: "100%",
									"z-index": -1,
									position: "absolute",
									height: "35px",
									"overflow-y": "scroll"
								});
								tempNode.children().css("height", "60px");
								$document[0].body.appendChild(tempNode[0]);
								this.floatingScrollbars.cached = tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth;
								tempNode.remove()
							}
							return this.floatingScrollbars.cached
						},
						forceFocus: function (element)
						{
							var node = element[0] || element;
							document.addEventListener("click", function focusOnClick(ev)
							{
								if (ev.target === node && ev.$focus)
								{
									node.focus();
									ev.stopImmediatePropagation();
									ev.preventDefault();
									node.removeEventListener("click", focusOnClick)
								}
							}, true);
							var newEvent = document.createEvent("MouseEvents");
							newEvent.initMouseEvent("click", false, true, window,
							{}, 0, 0, 0, 0, false, false, false, false, 0, null);
							newEvent.$material = true;
							newEvent.$focus = true;
							node.dispatchEvent(newEvent)
						},
						createBackdrop: function (scope, addClass)
						{
							return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [addClass]))(scope)
						},
						supplant: function (template, values, pattern)
						{
							pattern = pattern || /\{([^{}]*)\}/g;
							return template.replace(pattern, function (a, b)
							{
								var p = b.split("."),
									r = values;
								try
								{
									for (var s in p) p.hasOwnProperty(s) && (r = r[p[s]])
								}
								catch (e)
								{
									r = a
								}
								return "string" === typeof r || "number" === typeof r ? r : a
							})
						},
						fakeNgModel: function ()
						{
							return {
								$fake: true,
								$setTouched: angular.noop,
								$setViewValue: function (value)
								{
									this.$viewValue = value;
									this.$render(value);
									this.$viewChangeListeners.forEach(function (cb)
									{
										cb()
									})
								},
								$isEmpty: function (value)
								{
									return 0 === ("" + value).length
								},
								$parsers: [],
								$formatters: [],
								$viewChangeListeners: [],
								$render: angular.noop
							}
						},
						debounce: function (func, wait, scope, invokeApply)
						{
							var timer;
							return function debounced()
							{
								var context = scope,
									args = Array.prototype.slice.call(arguments);
								$timeout.cancel(timer);
								timer = $timeout(function ()
								{
									timer = undefined;
									func.apply(context, args)
								}, wait || 10, invokeApply)
							}
						},
						throttle: function throttle(func, delay)
						{
							var recent;
							return function throttled()
							{
								var context = this;
								var args = arguments;
								var now = $mdUtil.now();
								if (!recent || now - recent > delay)
								{
									func.apply(context, args);
									recent = now
								}
							}
						},
						time: function time(cb)
						{
							var start = $mdUtil.now();
							cb();
							return $mdUtil.now() - start
						},
						valueOnUse: function (scope, key, getter)
						{
							var value = null,
								args = Array.prototype.slice.call(arguments);
							var params = args.length > 3 ? args.slice(3) : [];
							Object.defineProperty(scope, key,
							{
								get: function ()
								{
									null === value && (value = getter.apply(scope, params));
									return value
								}
							})
						},
						nextUid: function ()
						{
							return "" + nextUniqueId++
						},
						disconnectScope: function disconnectScope(scope)
						{
							if (!scope) return;
							if (scope.$root === scope) return;
							if (scope.$$destroyed) return;
							var parent = scope.$parent;
							scope.$$disconnected = true;
							parent.$$childHead === scope && (parent.$$childHead = scope.$$nextSibling);
							parent.$$childTail === scope && (parent.$$childTail = scope.$$prevSibling);
							scope.$$prevSibling && (scope.$$prevSibling.$$nextSibling = scope.$$nextSibling);
							scope.$$nextSibling && (scope.$$nextSibling.$$prevSibling = scope.$$prevSibling);
							scope.$$nextSibling = scope.$$prevSibling = null
						},
						reconnectScope: function reconnectScope(scope)
						{
							if (!scope) return;
							if (scope.$root === scope) return;
							if (!scope.$$disconnected) return;
							var child = scope;
							var parent = child.$parent;
							child.$$disconnected = false;
							child.$$prevSibling = parent.$$childTail;
							if (parent.$$childHead)
							{
								parent.$$childTail.$$nextSibling = child;
								parent.$$childTail = child
							}
							else parent.$$childHead = parent.$$childTail = child
						},
						getClosest: function getClosest(el, validateWith, onlyParent)
						{
							if (angular.isString(validateWith))
							{
								var tagName = validateWith.toUpperCase();
								validateWith = function (el)
								{
									return el.nodeName.toUpperCase() === tagName
								}
							}
							el instanceof angular.element && (el = el[0]);
							onlyParent && (el = el.parentNode);
							if (!el) return null;
							do {
								if (validateWith(el)) return el
							} while (el = el.parentNode);
							return null
						},
						elementContains: function (node, child)
						{
							var hasContains = window.Node && window.Node.prototype && Node.prototype.contains;
							var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function (arg)
							{
								return node === child || !!(16 & this.compareDocumentPosition(arg))
							});
							return findFn(child)
						},
						extractElementByName: function (element, nodeName, scanDeep, warnNotFound)
						{
							var found = scanTree(element);
							found || !warnNotFound || $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [nodeName, element[0].outerHTML]));
							return angular.element(found || element);

							function scanTree(element)
							{
								return scanLevel(element) || (scanDeep ? scanChildren(element) : null)
							}

							function scanLevel(element)
							{
								if (element)
									for (var i = 0, len = element.length; i < len; i++)
										if (element[i].nodeName.toLowerCase() === nodeName) return element[i];
								return null
							}

							function scanChildren(element)
							{
								var found;
								if (element)
									for (var i = 0, len = element.length; i < len; i++)
									{
										var target = element[i];
										if (!found)
											for (var j = 0, numChild = target.childNodes.length; j < numChild; j++) found = found || scanTree([target.childNodes[j]])
									}
								return found
							}
						},
						initOptionalProperties: function (scope, attr, defaults)
						{
							defaults = defaults ||
							{};
							angular.forEach(scope.$$isolateBindings, function (binding, key)
							{
								if (binding.optional && angular.isUndefined(scope[key]))
								{
									var attrIsDefined = angular.isDefined(attr[binding.attrName]);
									scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined
								}
							})
						},
						nextTick: function (callback, digest, scope)
						{
							var nextTick = $mdUtil.nextTick;
							var timeout = nextTick.timeout;
							var queue = nextTick.queue || [];
							queue.push(
							{
								scope: scope,
								callback: callback
							});
							null == digest && (digest = true);
							nextTick.digest = nextTick.digest || digest;
							nextTick.queue = queue;
							return timeout || (nextTick.timeout = $timeout(processQueue, 0, false));

							function processQueue()
							{
								var queue = nextTick.queue;
								var digest = nextTick.digest;
								nextTick.queue = [];
								nextTick.timeout = null;
								nextTick.digest = false;
								queue.forEach(function (queueItem)
								{
									var skip = queueItem.scope && queueItem.scope.$$destroyed;
									skip || queueItem.callback()
								});
								digest && $rootScope.$digest()
							}
						},
						processTemplate: function (template)
						{
							if (usesStandardSymbols) return template;
							if (!template || !angular.isString(template)) return template;
							return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
						},
						getParentWithPointerEvents: function (element)
						{
							var parent = element.parent();
							while (hasComputedStyle(parent, "pointer-events", "none")) parent = parent.parent();
							return parent
						},
						getNearestContentElement: function (element)
						{
							var current = element.parent()[0];
							while (current && current !== $rootElement[0] && current !== document.body && "MD-CONTENT" !== current.nodeName.toUpperCase()) current = current.parentNode;
							return current
						},
						checkStickySupport: function ()
						{
							var stickyProp;
							var testEl = angular.element("<div>");
							$document[0].body.appendChild(testEl[0]);
							var stickyProps = ["sticky", "-webkit-sticky"];
							for (var i = 0; i < stickyProps.length; ++i)
							{
								testEl.css(
								{
									position: stickyProps[i],
									top: 0,
									"z-index": 2
								});
								if (testEl.css("position") == stickyProps[i])
								{
									stickyProp = stickyProps[i];
									break
								}
							}
							testEl.remove();
							return stickyProp
						},
						parseAttributeBoolean: function (value, negatedCheck)
						{
							return "" === value || !!value && (false === negatedCheck || "false" !== value && "0" !== value)
						},
						hasComputedStyle: hasComputedStyle,
						isParentFormSubmitted: function (element)
						{
							var parent = $mdUtil.getClosest(element, "form");
							var form = parent ? angular.element(parent).controller("form") : null;
							return !!form && form.$submitted
						},
						animateScrollTo: function (element, scrollEnd, duration)
						{
							var scrollStart = element.scrollTop;
							var scrollChange = scrollEnd - scrollStart;
							var scrollingDown = scrollStart < scrollEnd;
							var startTime = $mdUtil.now();
							$$rAF(scrollChunk);

							function scrollChunk()
							{
								var newPosition = calculateNewPosition();
								element.scrollTop = newPosition;
								(scrollingDown ? newPosition < scrollEnd : newPosition > scrollEnd) && $$rAF(scrollChunk)
							}

							function calculateNewPosition()
							{
								var easeDuration = duration || 1e3;
								var currentTime = $mdUtil.now() - startTime;
								return ease(currentTime, scrollStart, scrollChange, easeDuration)
							}

							function ease(currentTime, start, change, duration)
							{
								if (currentTime > duration) return start + change;
								var ts = (currentTime /= duration) * currentTime;
								var tc = ts * currentTime;
								return start + change * (-2 * tc + 3 * ts)
							}
						},
						uniq: function (array)
						{
							if (!array) return;
							return array.filter(function (value, index, self)
							{
								return self.indexOf(value) === index
							})
						}
					};
					$mdUtil.dom.animator = $$mdAnimate($mdUtil);
					return $mdUtil;

					function getNode(el)
					{
						return el[0] || el
					}
				}
				angular.element.prototype.focus = angular.element.prototype.focus || function ()
				{
					this.length && this[0].focus();
					return this
				};
				angular.element.prototype.blur = angular.element.prototype.blur || function ()
				{
					this.length && this[0].blur();
					return this
				}
			})();
			(function ()
			{
				MdAriaService.$inject = ["$$rAF", "$log", "$window", "$interpolate"];
				angular.module("material.core").provider("$mdAria", MdAriaProvider);

				function MdAriaProvider()
				{
					var config = {
						showWarnings: true
					};
					return {
						disableWarnings: disableWarnings,
						$get: ["$$rAF", "$log", "$window", "$interpolate", function ($$rAF, $log, $window, $interpolate)
						{
							return MdAriaService.apply(config, arguments)
						}]
					};

					function disableWarnings()
					{
						config.showWarnings = false
					}
				}

				function MdAriaService($$rAF, $log, $window, $interpolate)
				{
					var showWarnings = this.showWarnings;
					return {
						expect: expect,
						expectAsync: expectAsync,
						expectWithText: expectWithText,
						expectWithoutText: expectWithoutText,
						getText: getText,
						hasAriaLabel: hasAriaLabel,
						parentHasAriaLabel: parentHasAriaLabel
					};

					function expect(element, attrName, defaultValue)
					{
						var node = angular.element(element)[0] || element;
						if (node && (!node.hasAttribute(attrName) || 0 === node.getAttribute(attrName).length) && !childHasAttribute(node, attrName))
						{
							defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : "";
							defaultValue.length ? element.attr(attrName, defaultValue) : showWarnings && $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node)
						}
					}

					function expectAsync(element, attrName, defaultValueGetter)
					{
						$$rAF(function ()
						{
							expect(element, attrName, defaultValueGetter())
						})
					}

					function expectWithText(element, attrName)
					{
						var content = getText(element) || "";
						var hasBinding = content.indexOf($interpolate.startSymbol()) > -1;
						hasBinding ? expectAsync(element, attrName, function ()
						{
							return getText(element)
						}) : expect(element, attrName, content)
					}

					function expectWithoutText(element, attrName)
					{
						var content = getText(element);
						var hasBinding = content.indexOf($interpolate.startSymbol()) > -1;
						hasBinding || content || expect(element, attrName, content)
					}

					function getText(element)
					{
						element = element[0] || element;
						var walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
						var text = "";
						var node;
						while (node = walker.nextNode()) isAriaHiddenNode(node) || (text += node.textContent);
						return text.trim() || "";

						function isAriaHiddenNode(node)
						{
							while (node.parentNode && (node = node.parentNode) !== element)
								if (node.getAttribute && "true" === node.getAttribute("aria-hidden")) return true
						}
					}

					function childHasAttribute(node, attrName)
					{
						var hasChildren = node.hasChildNodes(),
							hasAttr = false;

						function isHidden(el)
						{
							var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
							return "none" === style.display
						}
						if (hasChildren)
						{
							var children = node.childNodes;
							for (var i = 0; i < children.length; i++)
							{
								var child = children[i];
								1 === child.nodeType && child.hasAttribute(attrName) && (isHidden(child) || (hasAttr = true))
							}
						}
						return hasAttr
					}

					function hasAriaLabel(element)
					{
						var node = angular.element(element)[0] || element;
						if (!node.hasAttribute) return false;
						return node.hasAttribute("aria-label") || node.hasAttribute("aria-labelledby") || node.hasAttribute("aria-describedby")
					}

					function parentHasAriaLabel(element, level)
					{
						level = level || 1;
						var node = angular.element(element)[0] || element;
						if (!node.parentNode) return false;
						if (performCheck(node.parentNode)) return true;
						level--;
						if (level) return parentHasAriaLabel(node.parentNode, level);
						return false;

						function performCheck(parentNode)
						{
							if (!hasAriaLabel(parentNode)) return false;
							if (parentNode.hasAttribute("role")) switch (parentNode.getAttribute("role").toLowerCase())
							{
							case "command":
							case "definition":
							case "directory":
							case "grid":
							case "list":
							case "listitem":
							case "log":
							case "marquee":
							case "menu":
							case "menubar":
							case "note":
							case "presentation":
							case "separator":
							case "scrollbar":
							case "status":
							case "tablist":
								return false
							}
							switch (parentNode.tagName.toLowerCase())
							{
							case "abbr":
							case "acronym":
							case "address":
							case "applet":
							case "audio":
							case "b":
							case "bdi":
							case "bdo":
							case "big":
							case "blockquote":
							case "br":
							case "canvas":
							case "caption":
							case "center":
							case "cite":
							case "code":
							case "col":
							case "data":
							case "dd":
							case "del":
							case "dfn":
							case "dir":
							case "div":
							case "dl":
							case "em":
							case "embed":
							case "fieldset":
							case "figcaption":
							case "font":
							case "h1":
							case "h2":
							case "h3":
							case "h4":
							case "h5":
							case "h6":
							case "hgroup":
							case "html":
							case "i":
							case "ins":
							case "isindex":
							case "kbd":
							case "keygen":
							case "label":
							case "legend":
							case "li":
							case "map":
							case "mark":
							case "menu":
							case "object":
							case "ol":
							case "output":
							case "pre":
							case "presentation":
							case "q":
							case "rt":
							case "ruby":
							case "samp":
							case "small":
							case "source":
							case "span":
							case "status":
							case "strike":
							case "strong":
							case "sub":
							case "sup":
							case "svg":
							case "tbody":
							case "td":
							case "th":
							case "thead":
							case "time":
							case "tr":
							case "track":
							case "tt":
							case "ul":
							case "var":
								return false
							}
							return true
						}
					}
				}
			})();
			(function ()
			{
				angular.module("material.core").provider("$mdCompiler", MdCompilerProvider);
				MdCompilerProvider.$inject = ["$compileProvider"];

				function MdCompilerProvider($compileProvider)
				{
					var respectPreAssignBindingsEnabled = false;
					this.respectPreAssignBindingsEnabled = function (respected)
					{
						if (angular.isDefined(respected))
						{
							respectPreAssignBindingsEnabled = respected;
							return this
						}
						return respectPreAssignBindingsEnabled
					};

					function getPreAssignBindingsEnabled()
					{
						if (!respectPreAssignBindingsEnabled) return true;
						if ("function" === typeof $compileProvider.preAssignBindingsEnabled) return $compileProvider.preAssignBindingsEnabled();
						if (1 === angular.version.major && angular.version.minor < 6) return true;
						return false
					}
					this.$get = ["$q", "$templateRequest", "$injector", "$compile", "$controller", function ($q, $templateRequest, $injector, $compile, $controller)
					{
						return new MdCompilerService($q, $templateRequest, $injector, $compile, $controller)
					}];

					function MdCompilerService($q, $templateRequest, $injector, $compile, $controller)
					{
						this.$q = $q;
						this.$templateRequest = $templateRequest;
						this.$injector = $injector;
						this.$compile = $compile;
						this.$controller = $controller
					}
					MdCompilerService.prototype.compile = function (options)
					{
						return options.contentElement ? this._prepareContentElement(options) : this._compileTemplate(options)
					};
					MdCompilerService.prototype._prepareContentElement = function (options)
					{
						var contentElement = this._fetchContentElement(options);
						return this.$q.resolve(
						{
							element: contentElement.element,
							cleanup: contentElement.restore,
							locals:
							{},
							link: function ()
							{
								return contentElement.element
							}
						})
					};
					MdCompilerService.prototype._compileTemplate = function (options)
					{
						var self = this;
						var templateUrl = options.templateUrl;
						var template = options.template || "";
						var resolve = angular.extend(
						{}, options.resolve);
						var locals = angular.extend(
						{}, options.locals);
						var transformTemplate = options.transformTemplate || angular.identity;
						angular.forEach(resolve, function (value, key)
						{
							angular.isString(value) ? resolve[key] = self.$injector.get(value) : resolve[key] = self.$injector.invoke(value)
						});
						angular.extend(resolve, locals);
						resolve.$$ngTemplate = templateUrl ? this.$templateRequest(templateUrl) : this.$q.when(template);
						return this.$q.all(resolve).then(function (locals)
						{
							var template = transformTemplate(locals.$$ngTemplate, options);
							var element = options.element || angular.element("<div>").html(template.trim()).contents();
							return self._compileElement(locals, element, options)
						})
					};
					MdCompilerService.prototype._compileElement = function (locals, element, options)
					{
						var self = this;
						var ngLinkFn = this.$compile(element);
						var compileData = {
							element: element,
							cleanup: element.remove.bind(element),
							locals: locals,
							link: linkFn
						};

						function linkFn(scope)
						{
							locals.$scope = scope;
							if (options.controller)
							{
								var injectLocals = angular.extend(
								{}, locals,
								{
									$element: element
								});
								var ctrl = self._createController(options, injectLocals, locals);
								element.data("$ngControllerController", ctrl);
								element.children().data("$ngControllerController", ctrl);
								compileData.controller = ctrl
							}
							return ngLinkFn(scope)
						}
						return compileData
					};
					MdCompilerService.prototype._createController = function (options, injectLocals, locals)
					{
						var ctrl;
						var preAssignBindingsEnabled = getPreAssignBindingsEnabled();
						if (preAssignBindingsEnabled)
						{
							var invokeCtrl = this.$controller(options.controller, injectLocals, true);
							options.bindToController && angular.extend(invokeCtrl.instance, locals);
							ctrl = invokeCtrl()
						}
						else
						{
							ctrl = this.$controller(options.controller, injectLocals);
							options.bindToController && angular.extend(ctrl, locals)
						}
						options.controllerAs && (injectLocals.$scope[options.controllerAs] = ctrl);
						angular.isFunction(ctrl.$onInit) && ctrl.$onInit();
						return ctrl
					};
					MdCompilerService.prototype._fetchContentElement = function (options)
					{
						var contentEl = options.contentElement;
						var restoreFn = null;
						if (angular.isString(contentEl))
						{
							contentEl = document.querySelector(contentEl);
							restoreFn = createRestoreFn(contentEl)
						}
						else
						{
							contentEl = contentEl[0] || contentEl;
							restoreFn = document.contains(contentEl) ? createRestoreFn(contentEl) : function ()
							{
								contentEl.parentNode && contentEl.parentNode.removeChild(contentEl)
							}
						}
						return {
							element: angular.element(contentEl),
							restore: restoreFn
						};

						function createRestoreFn(element)
						{
							var parent = element.parentNode;
							var nextSibling = element.nextElementSibling;
							return function ()
							{
								nextSibling ? parent.insertBefore(element, nextSibling) : parent.appendChild(element)
							}
						}
					}
				}
			})();
			(function ()
			{
				MdGesture.$inject = ["$$MdGestureHandler", "$$rAF", "$timeout"];
				attachToDocument.$inject = ["$mdGesture", "$$MdGestureHandler"];
				var HANDLERS = {};
				var pointer, lastPointer, maxClickDistance = 6;
				var forceSkipClickHijack = false,
					disableAllGestures = false;
				var lastLabelClickPos = null;
				var isInitialized = false;
				angular.module("material.core.gestures", []).provider("$mdGesture", MdGestureProvider).factory("$$MdGestureHandler", MdGestureHandler).run(attachToDocument);

				function MdGestureProvider()
				{}
				MdGestureProvider.prototype = {
					disableAll: function ()
					{
						disableAllGestures = true
					},
					skipClickHijack: function ()
					{
						return forceSkipClickHijack = true
					},
					setMaxClickDistance: function (clickDistance)
					{
						maxClickDistance = parseInt(clickDistance)
					},
					$get: ["$$MdGestureHandler", "$$rAF", "$timeout", function ($$MdGestureHandler, $$rAF, $timeout)
					{
						return new MdGesture($$MdGestureHandler, $$rAF, $timeout)
					}]
				};

				function MdGesture($$MdGestureHandler, $$rAF, $timeout)
				{
					var userAgent = navigator.userAgent || navigator.vendor || window.opera;
					var isIos = userAgent.match(/ipad|iphone|ipod/i);
					var isAndroid = userAgent.match(/android/i);
					var touchActionProperty = getTouchAction();
					var hasJQuery = "undefined" !== typeof window.jQuery && angular.element === window.jQuery;
					var self = {
						handler: addHandler,
						register: register,
						isAndroid: isAndroid,
						isIos: isIos,
						isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack
					};
					if (self.isHijackingClicks)
					{
						self.handler("click",
						{
							options:
							{
								maxDistance: maxClickDistance
							},
							onEnd: checkDistanceAndEmit("click")
						});
						self.handler("focus",
						{
							options:
							{
								maxDistance: maxClickDistance
							},
							onEnd: function (ev, pointer)
							{
								if (pointer.distance < this.state.options.maxDistance && canFocus(ev.target))
								{
									this.dispatchEvent(ev, "focus", pointer);
									ev.target.focus()
								}
							}
						});
						self.handler("mouseup",
						{
							options:
							{
								maxDistance: maxClickDistance
							},
							onEnd: checkDistanceAndEmit("mouseup")
						});
						self.handler("mousedown",
						{
							onStart: function (ev)
							{
								this.dispatchEvent(ev, "mousedown")
							}
						})
					}

					function checkDistanceAndEmit(eventName)
					{
						return function (ev, pointer)
						{
							pointer.distance < this.state.options.maxDistance && this.dispatchEvent(ev, eventName, pointer)
						}
					}

					function register(element, handlerName, options)
					{
						var handler = HANDLERS[handlerName.replace(/^\$md./, "")];
						if (!handler) throw new Error("Failed to register element with handler " + handlerName + ". Available handlers: " + Object.keys(HANDLERS).join(", "));
						return handler.registerElement(element, options)
					}

					function addHandler(name, definition)
					{
						var handler = new $$MdGestureHandler(name);
						angular.extend(handler, definition);
						HANDLERS[name] = handler;
						return self
					}
					return self.handler("press",
					{
						onStart: function (ev, pointer)
						{
							this.dispatchEvent(ev, "$md.pressdown")
						},
						onEnd: function (ev, pointer)
						{
							this.dispatchEvent(ev, "$md.pressup")
						}
					}).handler("hold",
					{
						options:
						{
							maxDistance: 6,
							delay: 500
						},
						onCancel: function ()
						{
							$timeout.cancel(this.state.timeout)
						},
						onStart: function (ev, pointer)
						{
							if (!this.state.registeredParent) return this.cancel();
							this.state.pos = {
								x: pointer.x,
								y: pointer.y
							};
							this.state.timeout = $timeout(angular.bind(this, function holdDelayFn()
							{
								this.dispatchEvent(ev, "$md.hold");
								this.cancel()
							}), this.state.options.delay, false)
						},
						onMove: function (ev, pointer)
						{
							touchActionProperty || "touchmove" !== ev.type || ev.preventDefault();
							var dx = this.state.pos.x - pointer.x;
							var dy = this.state.pos.y - pointer.y;
							Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance && this.cancel()
						},
						onEnd: function ()
						{
							this.onCancel()
						}
					}).handler("drag",
					{
						options:
						{
							minDistance: 6,
							horizontal: true,
							cancelMultiplier: 1.5
						},
						onSetup: function (element, options)
						{
							if (touchActionProperty)
							{
								this.oldTouchAction = element[0].style[touchActionProperty];
								element[0].style[touchActionProperty] = options.horizontal ? "pan-y" : "pan-x"
							}
						},
						onCleanup: function (element)
						{
							this.oldTouchAction && (element[0].style[touchActionProperty] = this.oldTouchAction)
						},
						onStart: function (ev)
						{
							this.state.registeredParent || this.cancel()
						},
						onMove: function (ev, pointer)
						{
							var shouldStartDrag, shouldCancel;
							touchActionProperty || "touchmove" !== ev.type || ev.preventDefault();
							if (this.state.dragPointer) this.dispatchDragMove(ev);
							else
							{
								if (this.state.options.horizontal)
								{
									shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
									shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier
								}
								else
								{
									shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
									shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier
								}
								if (shouldStartDrag)
								{
									this.state.dragPointer = makeStartPointer(ev);
									updatePointerState(ev, this.state.dragPointer);
									this.dispatchEvent(ev, "$md.dragstart", this.state.dragPointer)
								}
								else shouldCancel && this.cancel()
							}
						},
						dispatchDragMove: $$rAF.throttle(function (ev)
						{
							if (this.state.isRunning)
							{
								updatePointerState(ev, this.state.dragPointer);
								this.dispatchEvent(ev, "$md.drag", this.state.dragPointer)
							}
						}),
						onEnd: function (ev, pointer)
						{
							if (this.state.dragPointer)
							{
								updatePointerState(ev, this.state.dragPointer);
								this.dispatchEvent(ev, "$md.dragend", this.state.dragPointer)
							}
						}
					}).handler("swipe",
					{
						options:
						{
							minVelocity: .65,
							minDistance: 10
						},
						onEnd: function (ev, pointer)
						{
							var eventType;
							if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance)
							{
								eventType = "left" == pointer.directionX ? "$md.swipeleft" : "$md.swiperight";
								this.dispatchEvent(ev, eventType)
							}
							else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance)
							{
								eventType = "up" == pointer.directionY ? "$md.swipeup" : "$md.swipedown";
								this.dispatchEvent(ev, eventType)
							}
						}
					});

					function getTouchAction()
					{
						var testEl = document.createElement("div");
						var vendorPrefixes = ["", "webkit", "Moz", "MS", "ms", "o"];
						for (var i = 0; i < vendorPrefixes.length; i++)
						{
							var prefix = vendorPrefixes[i];
							var property = prefix ? prefix + "TouchAction" : "touchAction";
							if (angular.isDefined(testEl.style[property])) return property
						}
					}
				}

				function GestureHandler(name)
				{
					this.name = name;
					this.state = {}
				}

				function MdGestureHandler()
				{
					var hasJQuery = "undefined" !== typeof window.jQuery && angular.element === window.jQuery;
					GestureHandler.prototype = {
						options:
						{},
						dispatchEvent: hasJQuery ? jQueryDispatchEvent : nativeDispatchEvent,
						onSetup: angular.noop,
						onCleanup: angular.noop,
						onStart: angular.noop,
						onMove: angular.noop,
						onEnd: angular.noop,
						onCancel: angular.noop,
						start: function (ev, pointer)
						{
							if (this.state.isRunning) return;
							var parentTarget = this.getNearestParent(ev.target);
							var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] ||
							{};
							this.state = {
								isRunning: true,
								options: angular.extend(
								{}, this.options, parentTargetOptions),
								registeredParent: parentTarget
							};
							this.onStart(ev, pointer)
						},
						move: function (ev, pointer)
						{
							if (!this.state.isRunning) return;
							this.onMove(ev, pointer)
						},
						end: function (ev, pointer)
						{
							if (!this.state.isRunning) return;
							this.onEnd(ev, pointer);
							this.state.isRunning = false
						},
						cancel: function (ev, pointer)
						{
							this.onCancel(ev, pointer);
							this.state = {}
						},
						getNearestParent: function (node)
						{
							var current = node;
							while (current)
							{
								if ((current.$mdGesture ||
									{})[this.name]) return current;
								current = current.parentNode
							}
							return null
						},
						registerElement: function (element, options)
						{
							var self = this;
							element[0].$mdGesture = element[0].$mdGesture ||
							{};
							element[0].$mdGesture[this.name] = options ||
							{};
							element.on("$destroy", onDestroy);
							self.onSetup(element, options ||
							{});
							return onDestroy;

							function onDestroy()
							{
								delete element[0].$mdGesture[self.name];
								element.off("$destroy", onDestroy);
								self.onCleanup(element, options ||
								{})
							}
						}
					};
					return GestureHandler;

					function jQueryDispatchEvent(srcEvent, eventType, eventPointer)
					{
						eventPointer = eventPointer || pointer;
						var eventObj = new angular.element.Event(eventType);
						eventObj.$material = true;
						eventObj.pointer = eventPointer;
						eventObj.srcEvent = srcEvent;
						angular.extend(eventObj,
						{
							clientX: eventPointer.x,
							clientY: eventPointer.y,
							screenX: eventPointer.x,
							screenY: eventPointer.y,
							pageX: eventPointer.x,
							pageY: eventPointer.y,
							ctrlKey: srcEvent.ctrlKey,
							altKey: srcEvent.altKey,
							shiftKey: srcEvent.shiftKey,
							metaKey: srcEvent.metaKey
						});
						angular.element(eventPointer.target).trigger(eventObj)
					}

					function nativeDispatchEvent(srcEvent, eventType, eventPointer)
					{
						eventPointer = eventPointer || pointer;
						var eventObj;
						if ("click" === eventType || "mouseup" === eventType || "mousedown" === eventType)
						{
							eventObj = document.createEvent("MouseEvents");
							eventObj.initMouseEvent(eventType, true, true, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null)
						}
						else
						{
							eventObj = document.createEvent("CustomEvent");
							eventObj.initCustomEvent(eventType, true, true,
							{})
						}
						eventObj.$material = true;
						eventObj.pointer = eventPointer;
						eventObj.srcEvent = srcEvent;
						eventPointer.target.dispatchEvent(eventObj)
					}
				}

				function attachToDocument($mdGesture, $$MdGestureHandler)
				{
					if (disableAllGestures) return;
					document.contains || (document.contains = function (node)
					{
						return document.body.contains(node)
					});
					if (!isInitialized && $mdGesture.isHijackingClicks)
					{
						document.addEventListener("click", clickHijacker, true);
						document.addEventListener("mouseup", mouseInputHijacker, true);
						document.addEventListener("mousedown", mouseInputHijacker, true);
						document.addEventListener("focus", mouseInputHijacker, true);
						isInitialized = true
					}

					function mouseInputHijacker(ev)
					{
						var isKeyClick = !ev.clientX && !ev.clientY;
						if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev) && ("mousedown" !== ev.type || !canFocus(ev.target) && !canFocus(document.activeElement)))
						{
							ev.preventDefault();
							ev.stopPropagation()
						}
					}

					function clickHijacker(ev)
					{
						var isKeyClick = 0 === ev.clientX && 0 === ev.clientY;
						var isSubmitEvent = ev.target && "submit" === ev.target.type;
						if (isKeyClick || ev.$material || ev.isIonicTap || isInputEventFromLabelClick(ev) || isSubmitEvent)
						{
							lastLabelClickPos = null;
							"label" == ev.target.tagName.toLowerCase() && (lastLabelClickPos = {
								x: ev.x,
								y: ev.y
							})
						}
						else
						{
							ev.preventDefault();
							ev.stopPropagation();
							lastLabelClickPos = null
						}
					}
					var START_EVENTS = "mousedown touchstart pointerdown";
					var MOVE_EVENTS = "mousemove touchmove pointermove";
					var END_EVENTS = "mouseup mouseleave touchend touchcancel pointerup pointercancel";
					angular.element(document).on(START_EVENTS, gestureStart).on(MOVE_EVENTS, gestureMove).on(END_EVENTS, gestureEnd).on("$$mdGestureReset", function gestureClearCache()
					{
						lastPointer = pointer = null
					});

					function runHandlers(handlerEvent, event)
					{
						var handler;
						for (var name in HANDLERS)
						{
							handler = HANDLERS[name];
							if (handler instanceof $$MdGestureHandler)
							{
								"start" === handlerEvent && handler.cancel();
								handler[handlerEvent](event, pointer)
							}
						}
					}

					function gestureStart(ev)
					{
						if (pointer) return;
						var now = +Date.now();
						if (lastPointer && !typesMatch(ev, lastPointer) && now - lastPointer.endTime < 1500) return;
						pointer = makeStartPointer(ev);
						runHandlers("start", ev)
					}

					function gestureMove(ev)
					{
						if (!pointer || !typesMatch(ev, pointer)) return;
						updatePointerState(ev, pointer);
						runHandlers("move", ev)
					}

					function gestureEnd(ev)
					{
						if (!pointer || !typesMatch(ev, pointer)) return;
						updatePointerState(ev, pointer);
						pointer.endTime = +Date.now();
						"pointercancel" !== ev.type && runHandlers("end", ev);
						lastPointer = pointer;
						pointer = null
					}
				}

				function makeStartPointer(ev)
				{
					var point = getEventPoint(ev);
					var startPointer = {
						startTime: +Date.now(),
						target: ev.target,
						type: ev.type.charAt(0)
					};
					startPointer.startX = startPointer.x = point.pageX;
					startPointer.startY = startPointer.y = point.pageY;
					return startPointer
				}

				function typesMatch(ev, pointer)
				{
					return ev && pointer && ev.type.charAt(0) === pointer.type
				}

				function isInputEventFromLabelClick(event)
				{
					return lastLabelClickPos && lastLabelClickPos.x == event.x && lastLabelClickPos.y == event.y
				}

				function updatePointerState(ev, pointer)
				{
					var point = getEventPoint(ev);
					var x = pointer.x = point.pageX;
					var y = pointer.y = point.pageY;
					pointer.distanceX = x - pointer.startX;
					pointer.distanceY = y - pointer.startY;
					pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY);
					pointer.directionX = pointer.distanceX > 0 ? "right" : pointer.distanceX < 0 ? "left" : "";
					pointer.directionY = pointer.distanceY > 0 ? "down" : pointer.distanceY < 0 ? "up" : "";
					pointer.duration = +Date.now() - pointer.startTime;
					pointer.velocityX = pointer.distanceX / pointer.duration;
					pointer.velocityY = pointer.distanceY / pointer.duration
				}

				function getEventPoint(ev)
				{
					ev = ev.originalEvent || ev;
					return ev.touches && ev.touches[0] || ev.changedTouches && ev.changedTouches[0] || ev
				}

				function canFocus(element)
				{
					return !!element && "-1" !== element.getAttribute("tabindex") && !element.hasAttribute("disabled") && (element.hasAttribute("tabindex") || element.hasAttribute("href") || element.isContentEditable || -1 !== ["INPUT", "SELECT", "BUTTON", "TEXTAREA", "VIDEO", "AUDIO"].indexOf(element.nodeName))
				}
			})();
			(function ()
			{
				MdInteractionService.$inject = ["$timeout", "$mdUtil"];
				angular.module("material.core.interaction", []).service("$mdInteraction", MdInteractionService);

				function MdInteractionService($timeout, $mdUtil)
				{
					this.$timeout = $timeout;
					this.$mdUtil = $mdUtil;
					this.bodyElement = angular.element(document.body);
					this.isBuffering = false;
					this.bufferTimeout = null;
					this.lastInteractionType = null;
					this.lastInteractionTime = null;
					this.inputEventMap = {
						keydown: "keyboard",
						mousedown: "mouse",
						mouseenter: "mouse",
						touchstart: "touch",
						pointerdown: "pointer",
						MSPointerDown: "pointer"
					};
					this.iePointerMap = {
						2: "touch",
						3: "touch",
						4: "mouse"
					};
					this.initializeEvents()
				}
				MdInteractionService.prototype.initializeEvents = function ()
				{
					var pointerEvent = "MSPointerEvent" in window ? "MSPointerDown" : "PointerEvent" in window ? "pointerdown" : null;
					this.bodyElement.on("keydown mousedown", this.onInputEvent.bind(this));
					"ontouchstart" in document.documentElement && this.bodyElement.on("touchstart", this.onBufferInputEvent.bind(this));
					pointerEvent && this.bodyElement.on(pointerEvent, this.onInputEvent.bind(this))
				};
				MdInteractionService.prototype.onInputEvent = function (event)
				{
					if (this.isBuffering) return;
					var type = this.inputEventMap[event.type];
					"pointer" === type && (type = this.iePointerMap[event.pointerType] || event.pointerType);
					this.lastInteractionType = type;
					this.lastInteractionTime = this.$mdUtil.now()
				};
				MdInteractionService.prototype.onBufferInputEvent = function (event)
				{
					this.$timeout.cancel(this.bufferTimeout);
					this.onInputEvent(event);
					this.isBuffering = true;
					this.bufferTimeout = this.$timeout(function ()
					{
						this.isBuffering = false
					}.bind(this), 650, false)
				};
				MdInteractionService.prototype.getLastInteractionType = function ()
				{
					return this.lastInteractionType
				};
				MdInteractionService.prototype.isUserInvoked = function (checkDelay)
				{
					var delay = angular.isNumber(checkDelay) ? checkDelay : 15;
					return this.lastInteractionTime >= this.$mdUtil.now() - delay
				}
			})();
			(function ()
			{
				angular.module("material.core").provider("$$interimElement", InterimElementProvider);

				function InterimElementProvider()
				{
					InterimElementFactory.$inject = ["$document", "$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector", "$exceptionHandler"];
					createInterimElementProvider.$get = InterimElementFactory;
					return createInterimElementProvider;

					function createInterimElementProvider(interimFactoryName)
					{
						factory.$inject = ["$$interimElement", "$injector"];
						var EXPOSED_METHODS = ["onHide", "onShow", "onRemove"];
						var customMethods = {};
						var providerConfig = {
							presets:
							{}
						};
						var provider = {
							setDefaults: setDefaults,
							addPreset: addPreset,
							addMethod: addMethod,
							$get: factory
						};
						provider.addPreset("build",
						{
							methods: ["controller", "controllerAs", "resolve", "multiple", "template", "templateUrl", "themable", "transformTemplate", "parent", "contentElement"]
						});
						return provider;

						function setDefaults(definition)
						{
							providerConfig.optionsFactory = definition.options;
							providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
							return provider
						}

						function addMethod(name, fn)
						{
							customMethods[name] = fn;
							return provider
						}

						function addPreset(name, definition)
						{
							definition = definition ||
							{};
							definition.methods = definition.methods || [];
							definition.options = definition.options || function ()
							{
								return {}
							};
							if (/^cancel|hide|show$/.test(name)) throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
							if (definition.methods.indexOf("_options") > -1) throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
							providerConfig.presets[name] = {
								methods: definition.methods.concat(EXPOSED_METHODS),
								optionsFactory: definition.options,
								argOption: definition.argOption
							};
							return provider
						}

						function factory($$interimElement, $injector)
						{
							var defaultMethods;
							var defaultOptions;
							var interimElementService = $$interimElement();
							var publicService = {
								hide: interimElementService.hide,
								cancel: interimElementService.cancel,
								show: showInterimElement,
								destroy: destroyInterimElement
							};
							defaultMethods = providerConfig.methods || [];
							defaultOptions = invokeFactory(providerConfig.optionsFactory,
							{});
							angular.forEach(customMethods, function (fn, name)
							{
								publicService[name] = fn
							});
							angular.forEach(providerConfig.presets, function (definition, name)
							{
								var presetDefaults = invokeFactory(definition.optionsFactory,
								{});
								var presetMethods = (definition.methods || []).concat(defaultMethods);
								angular.extend(presetDefaults,
								{
									$type: name
								});

								function Preset(opts)
								{
									this._options = angular.extend(
									{}, presetDefaults, opts)
								}
								angular.forEach(presetMethods, function (name)
								{
									Preset.prototype[name] = function (value)
									{
										this._options[name] = value;
										return this
									}
								});
								if (definition.argOption)
								{
									var methodName = "show" + name.charAt(0).toUpperCase() + name.slice(1);
									publicService[methodName] = function (arg)
									{
										var config = publicService[name](arg);
										return publicService.show(config)
									}
								}
								publicService[name] = function (arg)
								{
									return arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg) ? (new Preset)[definition.argOption](arg) : new Preset(arg)
								}
							});
							return publicService;

							function showInterimElement(opts)
							{
								opts = opts ||
								{};
								opts._options && (opts = opts._options);
								return interimElementService.show(angular.extend(
								{}, defaultOptions, opts))
							}

							function destroyInterimElement(opts)
							{
								return interimElementService.destroy(opts)
							}

							function invokeFactory(factory, defaultVal)
							{
								var locals = {};
								locals[interimFactoryName] = publicService;
								return $injector.invoke(factory || function ()
								{
									return defaultVal
								},
								{}, locals)
							}
						}
					}

					function InterimElementFactory($document, $q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector, $exceptionHandler)
					{
						return function createInterimElementService()
						{
							var SHOW_CANCELLED = false;
							var service;
							var showPromises = [];
							var hidePromises = [];
							var showingInterims = [];
							return service = {
								show: show,
								hide: waitForInterim(hide),
								cancel: waitForInterim(cancel),
								destroy: destroy,
								$injector_: $injector
							};

							function show(options)
							{
								options = options ||
								{};
								var interimElement = new InterimElement(options ||
								{});
								var hideAction = options.multiple ? $q.resolve() : $q.all(showPromises);
								options.multiple || (hideAction = hideAction.then(function ()
								{
									var promiseArray = hidePromises.concat(showingInterims.map(service.cancel));
									return $q.all(promiseArray)
								}));
								var showAction = hideAction.then(function ()
								{
									return interimElement.show().catch(function (reason)
									{
										return reason
									}).finally(function ()
									{
										showPromises.splice(showPromises.indexOf(showAction), 1);
										showingInterims.push(interimElement)
									})
								});
								showPromises.push(showAction);
								interimElement.deferred.promise.catch(function (fault)
								{
									fault instanceof Error && $exceptionHandler(fault);
									return fault
								});
								return interimElement.deferred.promise
							}

							function hide(reason, options)
							{
								options = options ||
								{};
								if (options.closeAll) return $q.all(showingInterims.slice().reverse().map(closeElement));
								if (options.closeTo !== undefined) return $q.all(showingInterims.slice(options.closeTo).map(closeElement));
								return closeElement(showingInterims[showingInterims.length - 1]);

								function closeElement(interim)
								{
									var hideAction = interim.remove(reason, false, options ||
									{}).catch(function (reason)
									{
										return reason
									}).finally(function ()
									{
										hidePromises.splice(hidePromises.indexOf(hideAction), 1)
									});
									showingInterims.splice(showingInterims.indexOf(interim), 1);
									hidePromises.push(hideAction);
									return interim.deferred.promise
								}
							}

							function cancel(reason, options)
							{
								var interim = showingInterims.pop();
								if (!interim) return $q.when(reason);
								var cancelAction = interim.remove(reason, true, options ||
								{}).catch(function (reason)
								{
									return reason
								}).finally(function ()
								{
									hidePromises.splice(hidePromises.indexOf(cancelAction), 1)
								});
								hidePromises.push(cancelAction);
								return interim.deferred.promise.catch(angular.noop)
							}

							function waitForInterim(callbackFn)
							{
								return function ()
								{
									var fnArguments = arguments;
									if (!showingInterims.length)
									{
										if (showPromises.length) return showPromises[0].finally(function ()
										{
											return callbackFn.apply(service, fnArguments)
										});
										return $q.when("No interim elements currently showing up.")
									}
									return callbackFn.apply(service, fnArguments)
								}
							}

							function destroy(targetEl)
							{
								var interim = targetEl ? null : showingInterims.shift();
								var parentEl = angular.element(targetEl).length && angular.element(targetEl)[0].parentNode;
								if (parentEl)
								{
									var filtered = showingInterims.filter(function (entry)
									{
										return entry.options.element[0] === parentEl
									});
									if (filtered.length)
									{
										interim = filtered[0];
										showingInterims.splice(showingInterims.indexOf(interim), 1)
									}
								}
								return interim ? interim.remove(SHOW_CANCELLED, false,
								{
									$destroy: true
								}) : $q.when(SHOW_CANCELLED)
							}

							function InterimElement(options)
							{
								var self, element, showAction = $q.when(true);
								options = configureScopeAndTransitions(options);
								return self = {
									options: options,
									deferred: $q.defer(),
									show: createAndTransitionIn,
									remove: transitionOutAndRemove
								};

								function createAndTransitionIn()
								{
									return $q(function (resolve, reject)
									{
										options.onCompiling && options.onCompiling(options);
										compileElement(options).then(function (compiledData)
										{
											element = linkElement(compiledData, options);
											options.cleanupElement = compiledData.cleanup;
											showAction = showElement(element, options, compiledData.controller).then(resolve, rejectAll)
										}).catch(rejectAll);

										function rejectAll(fault)
										{
											self.deferred.reject(fault);
											reject(fault)
										}
									})
								}

								function transitionOutAndRemove(response, isCancelled, opts)
								{
									if (!element) return $q.when(false);
									options = angular.extend(options ||
									{}, opts ||
									{});
									options.cancelAutoHide && options.cancelAutoHide();
									options.element.triggerHandler("$mdInterimElementRemove");
									if (true === options.$destroy) return hideElement(options.element, options).then(function ()
									{
										isCancelled && rejectAll(response) || resolveAll(response)
									});
									$q.when(showAction).finally(function ()
									{
										hideElement(options.element, options).then(function ()
										{
											isCancelled ? rejectAll(response) : resolveAll(response)
										}, rejectAll)
									});
									return self.deferred.promise;

									function resolveAll(response)
									{
										self.deferred.resolve(response)
									}

									function rejectAll(fault)
									{
										self.deferred.reject(fault)
									}
								}

								function configureScopeAndTransitions(options)
								{
									options = options ||
									{};
									options.template && (options.template = $mdUtil.processTemplate(options.template));
									return angular.extend(
									{
										preserveScope: false,
										cancelAutoHide: angular.noop,
										scope: options.scope || $rootScope.$new(options.isolateScope),
										onShow: function transitionIn(scope, element, options)
										{
											return $animate.enter(element, options.parent)
										},
										onRemove: function transitionOut(scope, element)
										{
											return element && $animate.leave(element) || $q.when()
										}
									}, options)
								}

								function compileElement(options)
								{
									var compiled = options.skipCompile ? null : $mdCompiler.compile(options);
									return compiled || $q(function (resolve)
									{
										resolve(
										{
											locals:
											{},
											link: function ()
											{
												return options.element
											}
										})
									})
								}

								function linkElement(compileData, options)
								{
									angular.extend(compileData.locals, options);
									var element = compileData.link(options.scope);
									options.element = element;
									options.parent = findParent(element, options);
									options.themable && $mdTheming(element);
									return element
								}

								function findParent(element, options)
								{
									var parent = options.parent;
									parent = angular.isFunction(parent) ? parent(options.scope, element, options) : angular.isString(parent) ? angular.element($document[0].querySelector(parent)) : angular.element(parent);
									if (!(parent ||
										{}).length)
									{
										var el;
										$rootElement[0] && $rootElement[0].querySelector && (el = $rootElement[0].querySelector(":not(svg) > body"));
										el || (el = $rootElement[0]);
										"#comment" == el.nodeName && (el = $document[0].body);
										return angular.element(el)
									}
									return parent
								}

								function startAutoHide()
								{
									var autoHideTimer, cancelAutoHide = angular.noop;
									if (options.hideDelay)
									{
										autoHideTimer = $timeout(service.hide, options.hideDelay);
										cancelAutoHide = function ()
										{
											$timeout.cancel(autoHideTimer)
										}
									}
									options.cancelAutoHide = function ()
									{
										cancelAutoHide();
										options.cancelAutoHide = undefined
									}
								}

								function showElement(element, options, controller)
								{
									var notifyShowing = options.onShowing || angular.noop;
									var notifyComplete = options.onComplete || angular.noop;
									try
									{
										notifyShowing(options.scope, element, options, controller)
									}
									catch (e)
									{
										return $q.reject(e)
									}
									return $q(function (resolve, reject)
									{
										try
										{
											$q.when(options.onShow(options.scope, element, options, controller)).then(function ()
											{
												notifyComplete(options.scope, element, options);
												startAutoHide();
												resolve(element)
											}, reject)
										}
										catch (e)
										{
											reject(e.message)
										}
									})
								}

								function hideElement(element, options)
								{
									var announceRemoving = options.onRemoving || angular.noop;
									return $q(function (resolve, reject)
									{
										try
										{
											var action = $q.when(options.onRemove(options.scope, element, options) || true);
											announceRemoving(element, action);
											if (options.$destroy)
											{
												resolve(element);
												!options.preserveScope && options.scope && action.then(function ()
												{
													options.scope.$destroy()
												})
											}
											else action.then(function ()
											{
												!options.preserveScope && options.scope && options.scope.$destroy();
												resolve(element)
											}, reject)
										}
										catch (e)
										{
											reject(e.message)
										}
									})
								}
							}
						}
					}
				}
			})();
			void
			function ()
			{
				var $mdUtil, $interpolate, $log;
				var SUFFIXES = /(-gt)?-(sm|md|lg|print)/g;
				var WHITESPACE = /\s+/g;
				var FLEX_OPTIONS = ["grow", "initial", "auto", "none", "noshrink", "nogrow"];
				var LAYOUT_OPTIONS = ["row", "column"];
				var ALIGNMENT_MAIN_AXIS = ["", "start", "center", "end", "stretch", "space-around", "space-between"];
				var ALIGNMENT_CROSS_AXIS = ["", "start", "center", "end", "stretch"];
				var config = {
					enabled: true,
					breakpoints: []
				};
				registerLayoutAPI(angular.module("material.core.layout", ["ng"]));

				function registerLayoutAPI(module)
				{
					var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
					var SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;
					var BREAKPOINTS = ["", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print"];
					var API_WITH_VALUES = ["layout", "flex", "flex-order", "flex-offset", "layout-align"];
					var API_NO_VALUES = ["show", "hide", "layout-padding", "layout-margin"];
					angular.forEach(BREAKPOINTS, function (mqb)
					{
						angular.forEach(API_WITH_VALUES, function (name)
						{
							var fullName = mqb ? name + "-" + mqb : name;
							module.directive(directiveNormalize(fullName), attributeWithObserve(fullName))
						});
						angular.forEach(API_NO_VALUES, function (name)
						{
							var fullName = mqb ? name + "-" + mqb : name;
							module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName))
						})
					});
					module.provider("$$mdLayout", function ()
					{
						return {
							$get: angular.noop,
							validateAttributeValue: validateAttributeValue,
							validateAttributeUsage: validateAttributeUsage,
							disableLayouts: function (isDisabled)
							{
								config.enabled = true !== isDisabled
							}
						}
					}).directive("mdLayoutCss", disableLayoutDirective).directive("ngCloak", buildCloakInterceptor("ng-cloak")).directive("layoutWrap", attributeWithoutValue("layout-wrap")).directive("layoutNowrap", attributeWithoutValue("layout-nowrap")).directive("layoutNoWrap", attributeWithoutValue("layout-no-wrap")).directive("layoutFill", attributeWithoutValue("layout-fill")).directive("layoutLtMd", warnAttrNotSupported("layout-lt-md", true)).directive("layoutLtLg", warnAttrNotSupported("layout-lt-lg", true)).directive("flexLtMd", warnAttrNotSupported("flex-lt-md", true)).directive("flexLtLg", warnAttrNotSupported("flex-lt-lg", true)).directive("layoutAlignLtMd", warnAttrNotSupported("layout-align-lt-md")).directive("layoutAlignLtLg", warnAttrNotSupported("layout-align-lt-lg")).directive("flexOrderLtMd", warnAttrNotSupported("flex-order-lt-md")).directive("flexOrderLtLg", warnAttrNotSupported("flex-order-lt-lg")).directive("offsetLtMd", warnAttrNotSupported("flex-offset-lt-md")).directive("offsetLtLg", warnAttrNotSupported("flex-offset-lt-lg")).directive("hideLtMd", warnAttrNotSupported("hide-lt-md")).directive("hideLtLg", warnAttrNotSupported("hide-lt-lg")).directive("showLtMd", warnAttrNotSupported("show-lt-md")).directive("showLtLg", warnAttrNotSupported("show-lt-lg")).config(detectDisabledLayouts);

					function directiveNormalize(name)
					{
						return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset)
						{
							return offset ? letter.toUpperCase() : letter
						})
					}
				}

				function detectDisabledLayouts()
				{
					var isDisabled = !!document.querySelector("[md-layouts-disabled]");
					config.enabled = !isDisabled
				}

				function disableLayoutDirective()
				{
					config.enabled = false;
					return {
						restrict: "A",
						priority: "900"
					}
				}

				function buildCloakInterceptor(className)
				{
					return ["$timeout", function ($timeout)
					{
						return {
							restrict: "A",
							priority: -10,
							compile: function (element)
							{
								if (!config.enabled) return angular.noop;
								element.addClass(className);
								return function (scope, element)
								{
									$timeout(function ()
									{
										element.removeClass(className)
									}, 10, false)
								}
							}
						}
					}]
				}

				function attributeWithObserve(className)
				{
					return ["$mdUtil", "$interpolate", "$log", function (_$mdUtil_, _$interpolate_, _$log_)
					{
						$mdUtil = _$mdUtil_;
						$interpolate = _$interpolate_;
						$log = _$log_;
						return {
							restrict: "A",
							compile: function (element, attr)
							{
								var linkFn;
								if (config.enabled)
								{
									validateAttributeUsage(className, attr, element, $log);
									validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
									linkFn = translateWithValueToCssClass
								}
								return linkFn || angular.noop
							}
						}
					}];

					function translateWithValueToCssClass(scope, element, attrs)
					{
						var updateFn = updateClassWithValue(element, className, attrs);
						var unwatch = attrs.$observe(attrs.$normalize(className), updateFn);
						updateFn(getNormalizedAttrValue(className, attrs, ""));
						scope.$on("$destroy", function ()
						{
							unwatch()
						})
					}
				}

				function attributeWithoutValue(className)
				{
					return ["$mdUtil", "$interpolate", "$log", function (_$mdUtil_, _$interpolate_, _$log_)
					{
						$mdUtil = _$mdUtil_;
						$interpolate = _$interpolate_;
						$log = _$log_;
						return {
							restrict: "A",
							compile: function (element, attr)
							{
								var linkFn;
								if (config.enabled)
								{
									validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
									translateToCssClass(null, element);
									linkFn = translateToCssClass
								}
								return linkFn || angular.noop
							}
						}
					}];

					function translateToCssClass(scope, element)
					{
						element.addClass(className)
					}
				}

				function updateClassWithValue(element, className)
				{
					var lastClass;
					return function updateClassFn(newValue)
					{
						var value = validateAttributeValue(className, newValue || "");
						if (angular.isDefined(value))
						{
							lastClass && element.removeClass(lastClass);
							lastClass = value ? className + "-" + value.trim().replace(WHITESPACE, "-") : className;
							element.addClass(lastClass)
						}
					}
				}

				function warnAttrNotSupported(className)
				{
					var parts = className.split("-");
					return ["$log", function ($log)
					{
						$log.warn(className + "has been deprecated. Please use a `" + parts[0] + "-gt-<xxx>` variant.");
						return angular.noop
					}]
				}

				function validateAttributeUsage(className, attr, element, $log)
				{
					var message, usage, url;
					var nodeName = element[0].nodeName.toLowerCase();
					switch (className.replace(SUFFIXES, ""))
					{
					case "flex":
						if ("md-button" == nodeName || "fieldset" == nodeName)
						{
							usage = "<" + nodeName + " " + className + "></" + nodeName + ">";
							url = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers";
							message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.";
							$log.warn($mdUtil.supplant(message, [usage, url]))
						}
					}
				}

				function validateAttributeValue(className, value, updateFn)
				{
					var origValue;
					if (!needsInterpolation(value))
					{
						switch (className.replace(SUFFIXES, ""))
						{
						case "layout":
							findIn(value, LAYOUT_OPTIONS) || (value = LAYOUT_OPTIONS[0]);
							break;
						case "flex":
							findIn(value, FLEX_OPTIONS) || isNaN(value) && (value = "");
							break;
						case "flex-offset":
						case "flex-order":
							value && !isNaN(+value) || (value = "0");
							break;
						case "layout-align":
							var axis = extractAlignAxis(value);
							value = $mdUtil.supplant("{main}-{cross}", axis);
							break;
						case "layout-padding":
						case "layout-margin":
						case "layout-fill":
						case "layout-wrap":
						case "layout-nowrap":
							value = ""
						}
						value != origValue && (updateFn || angular.noop)(value)
					}
					return value ? value.trim() : ""
				}

				function buildUpdateFn(element, className, attrs)
				{
					return function updateAttrValue(fallback)
					{
						needsInterpolation(fallback) || (attrs[attrs.$normalize(className)] = fallback)
					}
				}

				function needsInterpolation(value)
				{
					return (value || "").indexOf($interpolate.startSymbol()) > -1
				}

				function getNormalizedAttrValue(className, attrs, defaultVal)
				{
					var normalizedAttr = attrs.$normalize(className);
					return attrs[normalizedAttr] ? attrs[normalizedAttr].trim().replace(WHITESPACE, "-") : defaultVal || null
				}

				function findIn(item, list, replaceWith)
				{
					item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;
					var found = false;
					item && list.forEach(function (it)
					{
						it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
						found = found || it === item
					});
					return found
				}

				function extractAlignAxis(attrValue)
				{
					var values, axis = {
						main: "start",
						cross: "stretch"
					};
					attrValue = attrValue || "";
					0 !== attrValue.indexOf("-") && 0 !== attrValue.indexOf(" ") || (attrValue = "none" + attrValue);
					values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-");
					values.length && "space" === values[0] && (values = [values[0] + "-" + values[1], values[2]]);
					values.length > 0 && (axis.main = values[0] || axis.main);
					values.length > 1 && (axis.cross = values[1] || axis.cross);
					ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0 && (axis.main = "start");
					ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0 && (axis.cross = "stretch");
					return axis
				}
			}();
			(function ()
			{
				MdLiveAnnouncer.$inject = ["$timeout"];
				angular.module("material.core").service("$mdLiveAnnouncer", MdLiveAnnouncer);

				function MdLiveAnnouncer($timeout)
				{
					this._$timeout = $timeout;
					this._liveElement = this._createLiveElement();
					this._announceTimeout = 100
				}
				MdLiveAnnouncer.prototype.announce = function (message, politeness)
				{
					politeness || (politeness = "polite");
					var self = this;
					self._liveElement.textContent = "";
					self._liveElement.setAttribute("aria-live", politeness);
					self._$timeout(function ()
					{
						self._liveElement.textContent = message
					}, self._announceTimeout, false)
				};
				MdLiveAnnouncer.prototype._createLiveElement = function ()
				{
					var liveEl = document.createElement("div");
					liveEl.classList.add("md-visually-hidden");
					liveEl.setAttribute("role", "status");
					liveEl.setAttribute("aria-atomic", "true");
					liveEl.setAttribute("aria-live", "polite");
					document.body.appendChild(liveEl);
					return liveEl
				}
			})();
			void angular.module("material.core.meta", []).provider("$$mdMeta", function ()
			{
				var head = angular.element(document.head);
				var metaElements = {};

				function mapExistingElement(name)
				{
					if (metaElements[name]) return true;
					var element = document.getElementsByName(name)[0];
					if (!element) return false;
					metaElements[name] = angular.element(element);
					return true
				}

				function setMeta(name, content)
				{
					mapExistingElement(name);
					if (metaElements[name]) metaElements[name].attr("content", content);
					else
					{
						var newMeta = angular.element('<meta name="' + name + '" content="' + content + '"/>');
						head.append(newMeta);
						metaElements[name] = newMeta
					}
					return function ()
					{
						metaElements[name].attr("content", "");
						metaElements[name].remove();
						delete metaElements[name]
					}
				}

				function getMeta(name)
				{
					if (!mapExistingElement(name)) throw Error("$$mdMeta: could not find a meta tag with the name '" + name + "'");
					return metaElements[name].attr("content")
				}
				var module = {
					setMeta: setMeta,
					getMeta: getMeta
				};
				return angular.extend(
				{}, module,
				{
					$get: function ()
					{
						return module
					}
				})
			});
			(function ()
			{
				ComponentRegistry.$inject = ["$log", "$q"];
				angular.module("material.core").factory("$mdComponentRegistry", ComponentRegistry);

				function ComponentRegistry($log, $q)
				{
					var self;
					var instances = [];
					var pendings = {};
					return self = {
						notFoundError: function (handle, msgContext)
						{
							$log.error((msgContext || "") + "No instance found for handle", handle)
						},
						getInstances: function ()
						{
							return instances
						},
						get: function (handle)
						{
							if (!isValidID(handle)) return null;
							var i, j, instance;
							for (i = 0, j = instances.length; i < j; i++)
							{
								instance = instances[i];
								if (instance.$$mdHandle === handle) return instance
							}
							return null
						},
						register: function (instance, handle)
						{
							if (!handle) return angular.noop;
							instance.$$mdHandle = handle;
							instances.push(instance);
							resolveWhen();
							return deregister;

							function deregister()
							{
								var index = instances.indexOf(instance); - 1 !== index && instances.splice(index, 1)
							}

							function resolveWhen()
							{
								var dfd = pendings[handle];
								if (dfd)
								{
									dfd.forEach(function (promise)
									{
										promise.resolve(instance)
									});
									delete pendings[handle]
								}
							}
						},
						when: function (handle)
						{
							if (isValidID(handle))
							{
								var deferred = $q.defer();
								var instance = self.get(handle);
								if (instance) deferred.resolve(instance);
								else
								{
									pendings[handle] === undefined && (pendings[handle] = []);
									pendings[handle].push(deferred)
								}
								return deferred.promise
							}
							return $q.reject("Invalid `md-component-id` value.")
						}
					};

					function isValidID(handle)
					{
						return handle && "" !== handle
					}
				}
			})();
			void
			function ()
			{
				MdButtonInkRipple.$inject = ["$mdInkRipple"];
				angular.module("material.core").factory("$mdButtonInkRipple", MdButtonInkRipple);

				function MdButtonInkRipple($mdInkRipple)
				{
					return {
						attach: function attachRipple(scope, element, options)
						{
							options = angular.extend(optionsForElement(element), options);
							return $mdInkRipple.attach(scope, element, options)
						}
					};

					function optionsForElement(element)
					{
						return element.hasClass("md-icon-button") ?
						{
							isMenuItem: element.hasClass("md-menu-item"),
							fitRipple: true,
							center: true
						} :
						{
							isMenuItem: element.hasClass("md-menu-item"),
							dimBackground: true
						}
					}
				}
			}();
			void
			function ()
			{
				MdCheckboxInkRipple.$inject = ["$mdInkRipple"];
				angular.module("material.core").factory("$mdCheckboxInkRipple", MdCheckboxInkRipple);

				function MdCheckboxInkRipple($mdInkRipple)
				{
					return {
						attach: attach
					};

					function attach(scope, element, options)
					{
						return $mdInkRipple.attach(scope, element, angular.extend(
						{
							center: true,
							dimBackground: false,
							fitRipple: true
						}, options))
					}
				}
			}();
			void
			function ()
			{
				MdListInkRipple.$inject = ["$mdInkRipple"];
				angular.module("material.core").factory("$mdListInkRipple", MdListInkRipple);

				function MdListInkRipple($mdInkRipple)
				{
					return {
						attach: attach
					};

					function attach(scope, element, options)
					{
						return $mdInkRipple.attach(scope, element, angular.extend(
						{
							center: false,
							dimBackground: true,
							outline: false,
							rippleSize: "full"
						}, options))
					}
				}
			}();
			(function ()
			{
				InkRippleCtrl.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil", "$mdColorUtil"];
				InkRippleDirective.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"];
				angular.module("material.core").provider("$mdInkRipple", InkRippleProvider).directive("mdInkRipple", InkRippleDirective).directive("mdNoInk", attrNoDirective).directive("mdNoBar", attrNoDirective).directive("mdNoStretch", attrNoDirective);
				var DURATION = 450;

				function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple)
				{
					return {
						controller: angular.noop,
						link: function (scope, element, attr)
						{
							attr.hasOwnProperty("mdInkRippleCheckbox") ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element)
						}
					}
				}

				function InkRippleProvider()
				{
					var isDisabledGlobally = false;
					return {
						disableInkRipple: disableInkRipple,
						$get: ["$injector", function ($injector)
						{
							return {
								attach: attach
							};

							function attach(scope, element, options)
							{
								if (isDisabledGlobally || element.controller("mdNoInk")) return angular.noop;
								return $injector.instantiate(InkRippleCtrl,
								{
									$scope: scope,
									$element: element,
									rippleOptions: options
								})
							}
						}]
					};

					function disableInkRipple()
					{
						isDisabledGlobally = true
					}
				}

				function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil, $mdColorUtil)
				{
					this.$window = $window;
					this.$timeout = $timeout;
					this.$mdUtil = $mdUtil;
					this.$mdColorUtil = $mdColorUtil;
					this.$scope = $scope;
					this.$element = $element;
					this.options = rippleOptions;
					this.mousedown = false;
					this.ripples = [];
					this.timeout = null;
					this.lastRipple = null;
					$mdUtil.valueOnUse(this, "container", this.createContainer);
					this.$element.addClass("md-ink-ripple");
					($element.controller("mdInkRipple") ||
					{}).createRipple = angular.bind(this, this.createRipple);
					($element.controller("mdInkRipple") ||
					{}).setColor = angular.bind(this, this.color);
					this.bindEvents()
				}

				function autoCleanup(self, cleanupFn)
				{
					if (self.mousedown || self.lastRipple)
					{
						self.mousedown = false;
						self.$mdUtil.nextTick(angular.bind(self, cleanupFn), false)
					}
				}
				InkRippleCtrl.prototype.color = function (value)
				{
					var self = this;
					angular.isDefined(value) && (self._color = self._parseColor(value));
					return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor());

					function getElementColor()
					{
						var items = self.options && self.options.colorElement ? self.options.colorElement : [];
						var elem = items.length ? items[0] : self.$element[0];
						return elem ? self.$window.getComputedStyle(elem).color : "rgb(0,0,0)"
					}
				};
				InkRippleCtrl.prototype.calculateColor = function ()
				{
					return this.color()
				};
				InkRippleCtrl.prototype._parseColor = function parseColor(color, multiplier)
				{
					multiplier = multiplier || 1;
					var colorUtil = this.$mdColorUtil;
					if (!color) return;
					if (0 === color.indexOf("rgba")) return color.replace(/\d?\.?\d*\s*\)\s*$/, (.1 * multiplier).toString() + ")");
					if (0 === color.indexOf("rgb")) return colorUtil.rgbToRgba(color);
					if (0 === color.indexOf("#")) return colorUtil.hexToRgba(color)
				};
				InkRippleCtrl.prototype.bindEvents = function ()
				{
					this.$element.on("mousedown", angular.bind(this, this.handleMousedown));
					this.$element.on("mouseup touchend", angular.bind(this, this.handleMouseup));
					this.$element.on("mouseleave", angular.bind(this, this.handleMouseup));
					this.$element.on("touchmove", angular.bind(this, this.handleTouchmove))
				};
				InkRippleCtrl.prototype.handleMousedown = function (event)
				{
					if (this.mousedown) return;
					event.hasOwnProperty("originalEvent") && (event = event.originalEvent);
					this.mousedown = true;
					if (this.options.center) this.createRipple(this.container.prop("clientWidth") / 2, this.container.prop("clientWidth") / 2);
					else if (event.srcElement !== this.$element[0])
					{
						var layerRect = this.$element[0].getBoundingClientRect();
						var layerX = event.clientX - layerRect.left;
						var layerY = event.clientY - layerRect.top;
						this.createRipple(layerX, layerY)
					}
					else this.createRipple(event.offsetX, event.offsetY)
				};
				InkRippleCtrl.prototype.handleMouseup = function ()
				{
					this.$timeout(function ()
					{
						autoCleanup(this, this.clearRipples)
					}.bind(this))
				};
				InkRippleCtrl.prototype.handleTouchmove = function ()
				{
					autoCleanup(this, this.deleteRipples)
				};
				InkRippleCtrl.prototype.deleteRipples = function ()
				{
					for (var i = 0; i < this.ripples.length; i++) this.ripples[i].remove()
				};
				InkRippleCtrl.prototype.clearRipples = function ()
				{
					for (var i = 0; i < this.ripples.length; i++) this.fadeInComplete(this.ripples[i])
				};
				InkRippleCtrl.prototype.createContainer = function ()
				{
					var container = angular.element('<div class="md-ripple-container"></div>');
					this.$element.append(container);
					return container
				};
				InkRippleCtrl.prototype.clearTimeout = function ()
				{
					if (this.timeout)
					{
						this.$timeout.cancel(this.timeout);
						this.timeout = null
					}
				};
				InkRippleCtrl.prototype.isRippleAllowed = function ()
				{
					var element = this.$element[0];
					do {
						if (!element.tagName || "BODY" === element.tagName) break;
						if (element && angular.isFunction(element.hasAttribute))
						{
							if (element.hasAttribute("disabled")) return false;
							if ("false" === this.inkRipple() || "0" === this.inkRipple()) return false
						}
					} while (element = element.parentNode);
					return true
				};
				InkRippleCtrl.prototype.inkRipple = function ()
				{
					return this.$element.attr("md-ink-ripple")
				};
				InkRippleCtrl.prototype.createRipple = function (left, top)
				{
					if (!this.isRippleAllowed()) return;
					var ctrl = this;
					var colorUtil = ctrl.$mdColorUtil;
					var ripple = angular.element('<div class="md-ripple"></div>');
					var width = this.$element.prop("clientWidth");
					var height = this.$element.prop("clientHeight");
					var x = 2 * Math.max(Math.abs(width - left), left);
					var y = 2 * Math.max(Math.abs(height - top), top);
					var size = getSize(this.options.fitRipple, x, y);
					var color = this.calculateColor();
					ripple.css(
					{
						left: left + "px",
						top: top + "px",
						background: "black",
						width: size + "px",
						height: size + "px",
						backgroundColor: colorUtil.rgbaToRgb(color),
						borderColor: colorUtil.rgbaToRgb(color)
					});
					this.lastRipple = ripple;
					this.clearTimeout();
					this.timeout = this.$timeout(function ()
					{
						ctrl.clearTimeout();
						ctrl.mousedown || ctrl.fadeInComplete(ripple)
					}, .35 * DURATION, false);
					this.options.dimBackground && this.container.css(
					{
						backgroundColor: color
					});
					this.container.append(ripple);
					this.ripples.push(ripple);
					ripple.addClass("md-ripple-placed");
					this.$mdUtil.nextTick(function ()
					{
						ripple.addClass("md-ripple-scaled md-ripple-active");
						ctrl.$timeout(function ()
						{
							ctrl.clearRipples()
						}, DURATION, false)
					}, false);

					function getSize(fit, x, y)
					{
						return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))
					}
				};
				InkRippleCtrl.prototype.fadeInComplete = function (ripple)
				{
					this.lastRipple === ripple && (this.timeout || this.mousedown) || this.removeRipple(ripple)
				};
				InkRippleCtrl.prototype.removeRipple = function (ripple)
				{
					var ctrl = this;
					var index = this.ripples.indexOf(ripple);
					if (index < 0) return;
					this.ripples.splice(this.ripples.indexOf(ripple), 1);
					ripple.removeClass("md-ripple-active");
					ripple.addClass("md-ripple-remove");
					0 === this.ripples.length && this.container.css(
					{
						backgroundColor: ""
					});
					this.$timeout(function ()
					{
						ctrl.fadeOutComplete(ripple)
					}, DURATION, false)
				};
				InkRippleCtrl.prototype.fadeOutComplete = function (ripple)
				{
					ripple.remove();
					this.lastRipple = null
				};

				function attrNoDirective()
				{
					return {
						controller: angular.noop
					}
				}
			})();
			void
			function ()
			{
				MdTabInkRipple.$inject = ["$mdInkRipple"];
				angular.module("material.core").factory("$mdTabInkRipple", MdTabInkRipple);

				function MdTabInkRipple($mdInkRipple)
				{
					return {
						attach: attach
					};

					function attach(scope, element, options)
					{
						return $mdInkRipple.attach(scope, element, angular.extend(
						{
							center: false,
							dimBackground: true,
							outline: false,
							rippleSize: "full"
						}, options))
					}
				}
			}();
			void angular.module("material.core.theming.palette", []).constant("$mdColorPalette",
			{
				red:
				{
					50: "#ffebee",
					100: "#ffcdd2",
					200: "#ef9a9a",
					300: "#e57373",
					400: "#ef5350",
					500: "#f44336",
					600: "#e53935",
					700: "#d32f2f",
					800: "#c62828",
					900: "#b71c1c",
					A100: "#ff8a80",
					A200: "#ff5252",
					A400: "#ff1744",
					A700: "#d50000",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 300 A100",
					contrastStrongLightColors: "400 500 600 700 A200 A400 A700"
				},
				pink:
				{
					50: "#fce4ec",
					100: "#f8bbd0",
					200: "#f48fb1",
					300: "#f06292",
					400: "#ec407a",
					500: "#e91e63",
					600: "#d81b60",
					700: "#c2185b",
					800: "#ad1457",
					900: "#880e4f",
					A100: "#ff80ab",
					A200: "#ff4081",
					A400: "#f50057",
					A700: "#c51162",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 A100",
					contrastStrongLightColors: "500 600 A200 A400 A700"
				},
				purple:
				{
					50: "#f3e5f5",
					100: "#e1bee7",
					200: "#ce93d8",
					300: "#ba68c8",
					400: "#ab47bc",
					500: "#9c27b0",
					600: "#8e24aa",
					700: "#7b1fa2",
					800: "#6a1b9a",
					900: "#4a148c",
					A100: "#ea80fc",
					A200: "#e040fb",
					A400: "#d500f9",
					A700: "#aa00ff",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 A100",
					contrastStrongLightColors: "300 400 A200 A400 A700"
				},
				"deep-purple":
				{
					50: "#ede7f6",
					100: "#d1c4e9",
					200: "#b39ddb",
					300: "#9575cd",
					400: "#7e57c2",
					500: "#673ab7",
					600: "#5e35b1",
					700: "#512da8",
					800: "#4527a0",
					900: "#311b92",
					A100: "#b388ff",
					A200: "#7c4dff",
					A400: "#651fff",
					A700: "#6200ea",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 A100",
					contrastStrongLightColors: "300 400 A200"
				},
				indigo:
				{
					50: "#e8eaf6",
					100: "#c5cae9",
					200: "#9fa8da",
					300: "#7986cb",
					400: "#5c6bc0",
					500: "#3f51b5",
					600: "#3949ab",
					700: "#303f9f",
					800: "#283593",
					900: "#1a237e",
					A100: "#8c9eff",
					A200: "#536dfe",
					A400: "#3d5afe",
					A700: "#304ffe",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 A100",
					contrastStrongLightColors: "300 400 A200 A400"
				},
				blue:
				{
					50: "#e3f2fd",
					100: "#bbdefb",
					200: "#90caf9",
					300: "#64b5f6",
					400: "#42a5f5",
					500: "#2196f3",
					600: "#1e88e5",
					700: "#1976d2",
					800: "#1565c0",
					900: "#0d47a1",
					A100: "#82b1ff",
					A200: "#448aff",
					A400: "#2979ff",
					A700: "#2962ff",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 300 400 A100",
					contrastStrongLightColors: "500 600 700 A200 A400 A700"
				},
				"light-blue":
				{
					50: "#e1f5fe",
					100: "#b3e5fc",
					200: "#81d4fa",
					300: "#4fc3f7",
					400: "#29b6f6",
					500: "#03a9f4",
					600: "#039be5",
					700: "#0288d1",
					800: "#0277bd",
					900: "#01579b",
					A100: "#80d8ff",
					A200: "#40c4ff",
					A400: "#00b0ff",
					A700: "#0091ea",
					contrastDefaultColor: "dark",
					contrastLightColors: "600 700 800 900 A700",
					contrastStrongLightColors: "600 700 800 A700"
				},
				cyan:
				{
					50: "#e0f7fa",
					100: "#b2ebf2",
					200: "#80deea",
					300: "#4dd0e1",
					400: "#26c6da",
					500: "#00bcd4",
					600: "#00acc1",
					700: "#0097a7",
					800: "#00838f",
					900: "#006064",
					A100: "#84ffff",
					A200: "#18ffff",
					A400: "#00e5ff",
					A700: "#00b8d4",
					contrastDefaultColor: "dark",
					contrastLightColors: "700 800 900",
					contrastStrongLightColors: "700 800 900"
				},
				teal:
				{
					50: "#e0f2f1",
					100: "#b2dfdb",
					200: "#80cbc4",
					300: "#4db6ac",
					400: "#26a69a",
					500: "#009688",
					600: "#00897b",
					700: "#00796b",
					800: "#00695c",
					900: "#004d40",
					A100: "#a7ffeb",
					A200: "#64ffda",
					A400: "#1de9b6",
					A700: "#00bfa5",
					contrastDefaultColor: "dark",
					contrastLightColors: "500 600 700 800 900",
					contrastStrongLightColors: "500 600 700"
				},
				green:
				{
					50: "#e8f5e9",
					100: "#c8e6c9",
					200: "#a5d6a7",
					300: "#81c784",
					400: "#66bb6a",
					500: "#4caf50",
					600: "#43a047",
					700: "#388e3c",
					800: "#2e7d32",
					900: "#1b5e20",
					A100: "#b9f6ca",
					A200: "#69f0ae",
					A400: "#00e676",
					A700: "#00c853",
					contrastDefaultColor: "dark",
					contrastLightColors: "500 600 700 800 900",
					contrastStrongLightColors: "500 600 700"
				},
				"light-green":
				{
					50: "#f1f8e9",
					100: "#dcedc8",
					200: "#c5e1a5",
					300: "#aed581",
					400: "#9ccc65",
					500: "#8bc34a",
					600: "#7cb342",
					700: "#689f38",
					800: "#558b2f",
					900: "#33691e",
					A100: "#ccff90",
					A200: "#b2ff59",
					A400: "#76ff03",
					A700: "#64dd17",
					contrastDefaultColor: "dark",
					contrastLightColors: "700 800 900",
					contrastStrongLightColors: "700 800 900"
				},
				lime:
				{
					50: "#f9fbe7",
					100: "#f0f4c3",
					200: "#e6ee9c",
					300: "#dce775",
					400: "#d4e157",
					500: "#cddc39",
					600: "#c0ca33",
					700: "#afb42b",
					800: "#9e9d24",
					900: "#827717",
					A100: "#f4ff81",
					A200: "#eeff41",
					A400: "#c6ff00",
					A700: "#aeea00",
					contrastDefaultColor: "dark",
					contrastLightColors: "900",
					contrastStrongLightColors: "900"
				},
				yellow:
				{
					50: "#fffde7",
					100: "#fff9c4",
					200: "#fff59d",
					300: "#fff176",
					400: "#ffee58",
					500: "#ffeb3b",
					600: "#fdd835",
					700: "#fbc02d",
					800: "#f9a825",
					900: "#f57f17",
					A100: "#ffff8d",
					A200: "#ffff00",
					A400: "#ffea00",
					A700: "#ffd600",
					contrastDefaultColor: "dark"
				},
				amber:
				{
					50: "#fff8e1",
					100: "#ffecb3",
					200: "#ffe082",
					300: "#ffd54f",
					400: "#ffca28",
					500: "#ffc107",
					600: "#ffb300",
					700: "#ffa000",
					800: "#ff8f00",
					900: "#ff6f00",
					A100: "#ffe57f",
					A200: "#ffd740",
					A400: "#ffc400",
					A700: "#ffab00",
					contrastDefaultColor: "dark"
				},
				orange:
				{
					50: "#fff3e0",
					100: "#ffe0b2",
					200: "#ffcc80",
					300: "#ffb74d",
					400: "#ffa726",
					500: "#ff9800",
					600: "#fb8c00",
					700: "#f57c00",
					800: "#ef6c00",
					900: "#e65100",
					A100: "#ffd180",
					A200: "#ffab40",
					A400: "#ff9100",
					A700: "#ff6d00",
					contrastDefaultColor: "dark",
					contrastLightColors: "800 900",
					contrastStrongLightColors: "800 900"
				},
				"deep-orange":
				{
					50: "#fbe9e7",
					100: "#ffccbc",
					200: "#ffab91",
					300: "#ff8a65",
					400: "#ff7043",
					500: "#ff5722",
					600: "#f4511e",
					700: "#e64a19",
					800: "#d84315",
					900: "#bf360c",
					A100: "#ff9e80",
					A200: "#ff6e40",
					A400: "#ff3d00",
					A700: "#dd2c00",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 300 400 A100 A200",
					contrastStrongLightColors: "500 600 700 800 900 A400 A700"
				},
				brown:
				{
					50: "#efebe9",
					100: "#d7ccc8",
					200: "#bcaaa4",
					300: "#a1887f",
					400: "#8d6e63",
					500: "#795548",
					600: "#6d4c41",
					700: "#5d4037",
					800: "#4e342e",
					900: "#3e2723",
					A100: "#d7ccc8",
					A200: "#bcaaa4",
					A400: "#8d6e63",
					A700: "#5d4037",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 A100 A200",
					contrastStrongLightColors: "300 400"
				},
				grey:
				{
					50: "#fafafa",
					100: "#f5f5f5",
					200: "#eeeeee",
					300: "#e0e0e0",
					400: "#bdbdbd",
					500: "#9e9e9e",
					600: "#757575",
					700: "#616161",
					800: "#424242",
					900: "#212121",
					A100: "#ffffff",
					A200: "#000000",
					A400: "#303030",
					A700: "#616161",
					contrastDefaultColor: "dark",
					contrastLightColors: "600 700 800 900 A200 A400 A700"
				},
				"blue-grey":
				{
					50: "#eceff1",
					100: "#cfd8dc",
					200: "#b0bec5",
					300: "#90a4ae",
					400: "#78909c",
					500: "#607d8b",
					600: "#546e7a",
					700: "#455a64",
					800: "#37474f",
					900: "#263238",
					A100: "#cfd8dc",
					A200: "#b0bec5",
					A400: "#78909c",
					A700: "#455a64",
					contrastDefaultColor: "light",
					contrastDarkColors: "50 100 200 300 A100 A200",
					contrastStrongLightColors: "400 500 700"
				}
			});
			void
			function (angular)
			{
				detectDisabledThemes.$inject = ["$mdThemingProvider"];
				ThemingDirective.$inject = ["$mdTheming", "$interpolate", "$parse", "$mdUtil", "$q", "$log"];
				ThemableDirective.$inject = ["$mdTheming"];
				ThemingProvider.$inject = ["$mdColorPalette", "$$mdMetaProvider"];
				generateAllThemes.$inject = ["$injector", "$mdTheming"];
				angular.module("material.core.theming", ["material.core.theming.palette", "material.core.meta"]).directive("mdTheme", ThemingDirective).directive("mdThemable", ThemableDirective).directive("mdThemesDisabled", disableThemesDirective).provider("$mdTheming", ThemingProvider).config(detectDisabledThemes).run(generateAllThemes);

				function detectDisabledThemes($mdThemingProvider)
				{
					var isDisabled = !!document.querySelector("[md-themes-disabled]");
					$mdThemingProvider.disableTheming(isDisabled)
				}
				var GENERATED = {};
				var PALETTES;
				var DARK_FOREGROUND = {
					name: "dark",
					1: "rgba(0,0,0,0.87)",
					2: "rgba(0,0,0,0.54)",
					3: "rgba(0,0,0,0.38)",
					4: "rgba(0,0,0,0.12)"
				};
				var LIGHT_FOREGROUND = {
					name: "light",
					1: "rgba(255,255,255,1.0)",
					2: "rgba(255,255,255,0.7)",
					3: "rgba(255,255,255,0.5)",
					4: "rgba(255,255,255,0.12)"
				};
				var DARK_SHADOW = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)";
				var LIGHT_SHADOW = "";
				var DARK_CONTRAST_COLOR = colorToRgbaArray("rgba(0,0,0,0.87)");
				var LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgba(255,255,255,0.87)");
				var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgb(255,255,255)");
				var THEME_COLOR_TYPES = ["primary", "accent", "warn", "background"];
				var DEFAULT_COLOR_TYPE = "primary";
				var LIGHT_DEFAULT_HUES = {
					accent:
					{
						default: "A200",
						"hue-1": "A100",
						"hue-2": "A400",
						"hue-3": "A700"
					},
					background:
					{
						default: "50",
						"hue-1": "A100",
						"hue-2": "100",
						"hue-3": "300"
					}
				};
				var DARK_DEFAULT_HUES = {
					background:
					{
						default: "A400",
						"hue-1": "800",
						"hue-2": "900",
						"hue-3": "A200"
					}
				};
				THEME_COLOR_TYPES.forEach(function (colorType)
				{
					var defaultDefaultHues = {
						default: "500",
						"hue-1": "300",
						"hue-2": "800",
						"hue-3": "A100"
					};
					LIGHT_DEFAULT_HUES[colorType] || (LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues);
					DARK_DEFAULT_HUES[colorType] || (DARK_DEFAULT_HUES[colorType] = defaultDefaultHues)
				});
				var VALID_HUE_VALUES = ["50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700"];
				var themeConfig = {
					disableTheming: false,
					generateOnDemand: false,
					registeredStyles: [],
					nonce: null
				};

				function ThemingProvider($mdColorPalette, $$mdMetaProvider)
				{
					ThemingService.$inject = ["$rootScope", "$mdUtil", "$q", "$log"];
					PALETTES = {};
					var THEMES = {};
					var themingProvider;
					var alwaysWatchTheme = false;
					var defaultTheme = "default";
					angular.extend(PALETTES, $mdColorPalette);
					var setBrowserColor = function (color)
					{
						var removeChrome = $$mdMetaProvider.setMeta("theme-color", color);
						var removeWindows = $$mdMetaProvider.setMeta("msapplication-navbutton-color", color);
						return function ()
						{
							removeChrome();
							removeWindows()
						}
					};
					var enableBrowserColor = function (options)
					{
						options = angular.isObject(options) ? options :
						{};
						var theme = options.theme || "default";
						var hue = options.hue || "800";
						var palette = PALETTES[options.palette] || PALETTES[THEMES[theme].colors[options.palette || "primary"].name];
						var color = angular.isObject(palette[hue]) ? palette[hue].hex : palette[hue];
						return setBrowserColor(color)
					};
					return themingProvider = {
						definePalette: definePalette,
						extendPalette: extendPalette,
						theme: registerTheme,
						configuration: function ()
						{
							return angular.extend(
							{}, themeConfig,
							{
								defaultTheme: defaultTheme,
								alwaysWatchTheme: alwaysWatchTheme,
								registeredStyles: [].concat(themeConfig.registeredStyles)
							})
						},
						disableTheming: function (isDisabled)
						{
							themeConfig.disableTheming = angular.isUndefined(isDisabled) || !!isDisabled
						},
						registerStyles: function (styles)
						{
							themeConfig.registeredStyles.push(styles)
						},
						setNonce: function (nonceValue)
						{
							themeConfig.nonce = nonceValue
						},
						generateThemesOnDemand: function (onDemand)
						{
							themeConfig.generateOnDemand = onDemand
						},
						setDefaultTheme: function (theme)
						{
							defaultTheme = theme
						},
						alwaysWatchTheme: function (alwaysWatch)
						{
							alwaysWatchTheme = alwaysWatch
						},
						enableBrowserColor: enableBrowserColor,
						$get: ThemingService,
						_LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
						_DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
						_PALETTES: PALETTES,
						_THEMES: THEMES,
						_parseRules: parseRules,
						_rgba: rgba
					};

					function definePalette(name, map)
					{
						map = map ||
						{};
						PALETTES[name] = checkPaletteValid(name, map);
						return themingProvider
					}

					function extendPalette(name, map)
					{
						return checkPaletteValid(name, angular.extend(
						{}, PALETTES[name] ||
						{}, map))
					}

					function checkPaletteValid(name, map)
					{
						var missingColors = VALID_HUE_VALUES.filter(function (field)
						{
							return !map[field]
						});
						if (missingColors.length) throw new Error("Missing colors %1 in palette %2!".replace("%1", missingColors.join(", ")).replace("%2", name));
						return map
					}

					function registerTheme(name, inheritFrom)
					{
						if (THEMES[name]) return THEMES[name];
						inheritFrom = inheritFrom || "default";
						var parentTheme = "string" === typeof inheritFrom ? THEMES[inheritFrom] : inheritFrom;
						var theme = new Theme(name);
						parentTheme && angular.forEach(parentTheme.colors, function (color, colorType)
						{
							theme.colors[colorType] = {
								name: color.name,
								hues: angular.extend(
								{}, color.hues)
							}
						});
						THEMES[name] = theme;
						return theme
					}

					function Theme(name)
					{
						var self = this;
						self.name = name;
						self.colors = {};
						self.dark = setDark;
						setDark(false);

						function setDark(isDark)
						{
							isDark = 0 === arguments.length || !!isDark;
							if (isDark === self.isDark) return;
							self.isDark = isDark;
							self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
							self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
							var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
							var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
							angular.forEach(newDefaultHues, function (newDefaults, colorType)
							{
								var color = self.colors[colorType];
								var oldDefaults = oldDefaultHues[colorType];
								if (color)
									for (var hueName in color.hues) color.hues[hueName] === oldDefaults[hueName] && (color.hues[hueName] = newDefaults[hueName])
							});
							return self
						}
						THEME_COLOR_TYPES.forEach(function (colorType)
						{
							var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
							self[colorType + "Palette"] = function setPaletteType(paletteName, hues)
							{
								var color = self.colors[colorType] = {
									name: paletteName,
									hues: angular.extend(
									{}, defaultHues, hues)
								};
								Object.keys(color.hues).forEach(function (name)
								{
									if (!defaultHues[name]) throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", name).replace("%2", self.name).replace("%3", paletteName).replace("%4", Object.keys(defaultHues).join(", ")))
								});
								Object.keys(color.hues).map(function (key)
								{
									return color.hues[key]
								}).forEach(function (hueValue)
								{
									if (-1 == VALID_HUE_VALUES.indexOf(hueValue)) throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", hueValue).replace("%2", self.name).replace("%3", colorType).replace("%4", paletteName).replace("%5", VALID_HUE_VALUES.join(", ")))
								});
								return self
							};
							self[colorType + "Color"] = function ()
							{
								var args = Array.prototype.slice.call(arguments);
								console.warn("$mdThemingProviderTheme." + colorType + "Color() has been deprecated. Use $mdThemingProviderTheme." + colorType + "Palette() instead.");
								return self[colorType + "Palette"].apply(self, args)
							}
						})
					}

					function ThemingService($rootScope, $mdUtil, $q, $log)
					{
						var applyTheme = function (scope, el)
						{
							if (el === undefined)
							{
								el = scope;
								scope = undefined
							}
							scope === undefined && (scope = $rootScope);
							applyTheme.inherit(el, el)
						};
						Object.defineProperty(applyTheme, "THEMES",
						{
							get: function ()
							{
								return angular.extend(
								{}, THEMES)
							}
						});
						Object.defineProperty(applyTheme, "PALETTES",
						{
							get: function ()
							{
								return angular.extend(
								{}, PALETTES)
							}
						});
						Object.defineProperty(applyTheme, "ALWAYS_WATCH",
						{
							get: function ()
							{
								return alwaysWatchTheme
							}
						});
						applyTheme.inherit = inheritTheme;
						applyTheme.registered = registered;
						applyTheme.defaultTheme = function ()
						{
							return defaultTheme
						};
						applyTheme.generateTheme = function (name)
						{
							generateTheme(THEMES[name], name, themeConfig.nonce)
						};
						applyTheme.defineTheme = function (name, options)
						{
							options = options ||
							{};
							var theme = registerTheme(name);
							options.primary && theme.primaryPalette(options.primary);
							options.accent && theme.accentPalette(options.accent);
							options.warn && theme.warnPalette(options.warn);
							options.background && theme.backgroundPalette(options.background);
							options.dark && theme.dark();
							this.generateTheme(name);
							return $q.resolve(name)
						};
						applyTheme.setBrowserColor = enableBrowserColor;
						return applyTheme;

						function registered(themeName)
						{
							if (themeName === undefined || "" === themeName) return true;
							return applyTheme.THEMES[themeName] !== undefined
						}

						function inheritTheme(el, parent)
						{
							var ctrl = parent.controller("mdTheme") || el.data("$mdThemeController");
							var scope = el.scope();
							updateThemeClass(lookupThemeName());
							if (ctrl)
							{
								var watchTheme = alwaysWatchTheme || ctrl.$shouldWatch || $mdUtil.parseAttributeBoolean(el.attr("md-theme-watch"));
								if (watchTheme || ctrl.isAsyncTheme)
								{
									var clearNameWatcher = function ()
									{
										if (unwatch)
										{
											unwatch();
											unwatch = undefined
										}
									};
									var unwatch = ctrl.registerChanges(function (name)
									{
										updateThemeClass(name);
										watchTheme || clearNameWatcher()
									});
									scope ? scope.$on("$destroy", clearNameWatcher) : el.on("$destroy", clearNameWatcher)
								}
							}

							function lookupThemeName()
							{
								return ctrl && ctrl.$mdTheme || ("default" === defaultTheme ? "" : defaultTheme)
							}

							function updateThemeClass(theme)
							{
								if (!theme) return;
								registered(theme) || $log.warn("Attempted to use unregistered theme '" + theme + "'. Register it with $mdThemingProvider.theme().");
								var oldTheme = el.data("$mdThemeName");
								oldTheme && el.removeClass("md-" + oldTheme + "-theme");
								el.addClass("md-" + theme + "-theme");
								el.data("$mdThemeName", theme);
								ctrl && el.data("$mdThemeController", ctrl)
							}
						}
					}
				}

				function ThemingDirective($mdTheming, $interpolate, $parse, $mdUtil, $q, $log)
				{
					return {
						priority: 101,
						link:
						{
							pre: function (scope, el, attrs)
							{
								var registeredCallbacks = [];
								var startSymbol = $interpolate.startSymbol();
								var endSymbol = $interpolate.endSymbol();
								var theme = attrs.mdTheme.trim();
								var hasInterpolation = theme.substr(0, startSymbol.length) === startSymbol && theme.lastIndexOf(endSymbol) === theme.length - endSymbol.length;
								var oneTimeOperator = "::";
								var oneTimeBind = attrs.mdTheme.split(startSymbol).join("").split(endSymbol).join("").trim().substr(0, oneTimeOperator.length) === oneTimeOperator;
								var getTheme = function ()
								{
									var interpolation = $interpolate(attrs.mdTheme)(scope);
									return $parse(interpolation)(scope) || interpolation
								};
								var ctrl = {
									isAsyncTheme: angular.isFunction(getTheme()) || angular.isFunction(getTheme().then),
									registerChanges: function (cb, context)
									{
										context && (cb = angular.bind(context, cb));
										registeredCallbacks.push(cb);
										return function ()
										{
											var index = registeredCallbacks.indexOf(cb);
											index > -1 && registeredCallbacks.splice(index, 1)
										}
									},
									$setTheme: function (theme)
									{
										$mdTheming.registered(theme) || $log.warn("attempted to use unregistered theme '" + theme + "'");
										ctrl.$mdTheme = theme;
										for (var i = registeredCallbacks.length; i--;) registeredCallbacks[i](theme)
									},
									$shouldWatch: $mdUtil.parseAttributeBoolean(el.attr("md-theme-watch")) || $mdTheming.ALWAYS_WATCH || hasInterpolation && !oneTimeBind
								};
								el.data("$mdThemeController", ctrl);
								var setParsedTheme = function (theme)
								{
									if ("string" === typeof theme) return ctrl.$setTheme(theme);
									$q.when(angular.isFunction(theme) ? theme() : theme).then(function (name)
									{
										ctrl.$setTheme(name)
									})
								};
								setParsedTheme(getTheme());
								var unwatch = scope.$watch(getTheme, function (theme)
								{
									if (theme)
									{
										setParsedTheme(theme);
										ctrl.$shouldWatch || unwatch()
									}
								})
							}
						}
					}
				}

				function disableThemesDirective()
				{
					themeConfig.disableTheming = true;
					return {
						restrict: "A",
						priority: "900"
					}
				}

				function ThemableDirective($mdTheming)
				{
					return $mdTheming
				}

				function parseRules(theme, colorType, rules)
				{
					checkValidPalette(theme, colorType);
					rules = rules.replace(/THEME_NAME/g, theme.name);
					var themeNameRegex = new RegExp("\\.md-" + theme.name + "-theme", "g");
					var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue-[0-3]|shadow|default)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g;
					rules = rules.replace(simpleVariableRegex, function (match, colorType, hue, opacity, contrast)
					{
						if ("foreground" === colorType) return "shadow" == hue ? theme.foregroundShadow : theme.foregroundPalette[hue] || theme.foregroundPalette["1"];
						0 !== hue.indexOf("hue") && "default" !== hue || (hue = theme.colors[colorType].hues[hue]);
						return rgba((PALETTES[theme.colors[colorType].name][hue] || "")[contrast ? "contrast" : "value"], opacity)
					});
					var hueRegex = new RegExp("('|\")?{{\\s*([a-zA-Z]+)-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g");
					var generatedRules = [];
					angular.forEach(["default", "hue-1", "hue-2", "hue-3"], function (hueName)
					{
						var newRule = rules.replace(hueRegex, function (match, _, matchedColorType, hueType, opacity)
						{
							var color = theme.colors[matchedColorType];
							var palette = PALETTES[color.name];
							var hueValue = color.hues[hueName];
							return rgba(palette[hueValue]["color" === hueType ? "value" : "contrast"], opacity)
						});
						"default" !== hueName && (newRule = newRule.replace(themeNameRegex, ".md-" + theme.name + "-theme.md-" + hueName));
						if ("default" == theme.name)
						{
							var themeRuleRegex = /((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)\.md-default-theme((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;
							newRule = newRule.replace(themeRuleRegex, function (match, start, end)
							{
								return match + ", " + start + end
							})
						}
						generatedRules.push(newRule)
					});
					return generatedRules
				}
				var rulesByType = {};

				function generateAllThemes($injector, $mdTheming)
				{
					var head = document.head;
					var firstChild = head ? head.firstElementChild : null;
					var themeCss = !themeConfig.disableTheming && $injector.has("$MD_THEME_CSS") ? $injector.get("$MD_THEME_CSS") : "";
					themeCss += themeConfig.registeredStyles.join("");
					if (!firstChild) return;
					if (0 === themeCss.length) return;
					angular.forEach(PALETTES, sanitizePalette);
					var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function (rule)
					{
						return rule && rule.trim().length
					}).map(function (rule)
					{
						return rule.trim() + "}"
					});
					THEME_COLOR_TYPES.forEach(function (type)
					{
						rulesByType[type] = ""
					});
					rules.forEach(function (rule)
					{
						for (var type, i = 0; type = THEME_COLOR_TYPES[i]; i++)
							if (rule.indexOf(".md-" + type) > -1) return rulesByType[type] += rule;
						for (i = 0; type = THEME_COLOR_TYPES[i]; i++)
							if (rule.indexOf(type) > -1) return rulesByType[type] += rule;
						return rulesByType[DEFAULT_COLOR_TYPE] += rule
					});
					if (themeConfig.generateOnDemand) return;
					angular.forEach($mdTheming.THEMES, function (theme)
					{
						GENERATED[theme.name] || "default" !== $mdTheming.defaultTheme() && "default" === theme.name || generateTheme(theme, theme.name, themeConfig.nonce)
					});

					function sanitizePalette(palette, name)
					{
						var defaultContrast = palette.contrastDefaultColor;
						var lightColors = palette.contrastLightColors || [];
						var strongLightColors = palette.contrastStrongLightColors || [];
						var darkColors = palette.contrastDarkColors || [];
						"string" === typeof lightColors && (lightColors = lightColors.split(" "));
						"string" === typeof strongLightColors && (strongLightColors = strongLightColors.split(" "));
						"string" === typeof darkColors && (darkColors = darkColors.split(" "));
						delete palette.contrastDefaultColor;
						delete palette.contrastLightColors;
						delete palette.contrastStrongLightColors;
						delete palette.contrastDarkColors;
						angular.forEach(palette, function (hueValue, hueName)
						{
							if (angular.isObject(hueValue)) return;
							var rgbValue = colorToRgbaArray(hueValue);
							if (!rgbValue) throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", hueValue).replace("%2", palette.name).replace("%3", hueName));
							palette[hueName] = {
								hex: palette[hueName],
								value: rgbValue,
								contrast: getContrastColor()
							};

							function getContrastColor()
							{
								return "light" === defaultContrast ? darkColors.indexOf(hueName) > -1 ? DARK_CONTRAST_COLOR : strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR : lightColors.indexOf(hueName) > -1 ? strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR : DARK_CONTRAST_COLOR
							}
						})
					}
				}

				function generateTheme(theme, name, nonce)
				{
					var head = document.head;
					var firstChild = head ? head.firstElementChild : null;
					if (!GENERATED[name])
					{
						THEME_COLOR_TYPES.forEach(function (colorType)
						{
							var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);
							while (styleStrings.length)
							{
								var styleContent = styleStrings.shift();
								if (styleContent)
								{
									var style = document.createElement("style");
									style.setAttribute("md-theme-style", "");
									nonce && style.setAttribute("nonce", nonce);
									style.appendChild(document.createTextNode(styleContent));
									head.insertBefore(style, firstChild)
								}
							}
						});
						GENERATED[theme.name] = true
					}
				}

				function checkValidPalette(theme, colorType)
				{
					if (!PALETTES[(theme.colors[colorType] ||
						{}).name]) throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", theme.name).replace("%2", colorType).replace("%3", Object.keys(PALETTES).join(", ")))
				}

				function colorToRgbaArray(clr)
				{
					if (angular.isArray(clr) && 3 == clr.length) return clr;
					if (/^rgb/.test(clr)) return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map(function (value, i)
					{
						return 3 == i ? parseFloat(value, 10) : parseInt(value, 10)
					});
					"#" == clr.charAt(0) && (clr = clr.substring(1));
					if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return;
					var dig = clr.length / 3;
					var red = clr.substr(0, dig);
					var grn = clr.substr(dig, dig);
					var blu = clr.substr(2 * dig);
					if (1 === dig)
					{
						red += red;
						grn += grn;
						blu += blu
					}
					return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)]
				}

				function rgba(rgbArray, opacity)
				{
					if (!rgbArray) return "rgb('0,0,0')";
					if (4 == rgbArray.length)
					{
						rgbArray = angular.copy(rgbArray);
						opacity ? rgbArray.pop() : opacity = rgbArray.pop()
					}
					return opacity && ("number" == typeof opacity || "string" == typeof opacity && opacity.length) ? "rgba(" + rgbArray.join(",") + "," + opacity + ")" : "rgb(" + rgbArray.join(",") + ")"
				}
			}(window.angular);
			(function ()
			{
				angular.module("material.core").factory("$$mdAnimate", ["$q", "$timeout", "$mdConstant", "$animateCss", function ($q, $timeout, $mdConstant, $animateCss)
				{
					return function ($mdUtil)
					{
						return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss)
					}
				}]);

				function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss)
				{
					var self;
					return self = {
						translate3d: function (target, from, to, options)
						{
							return $animateCss(target,
							{
								from: from,
								to: to,
								addClass: options.transitionInClass,
								removeClass: options.transitionOutClass,
								duration: options.duration
							}).start().then(function ()
							{
								return reverseTranslate
							});

							function reverseTranslate(newFrom)
							{
								return $animateCss(target,
								{
									to: newFrom || from,
									addClass: options.transitionOutClass,
									removeClass: options.transitionInClass,
									duration: options.duration
								}).start()
							}
						},
						waitTransitionEnd: function (element, opts)
						{
							var TIMEOUT = 3e3;
							return $q(function (resolve, reject)
							{
								opts = opts ||
								{};
								noTransitionFound(opts.cachedTransitionStyles) && (TIMEOUT = 0);
								var timer = $timeout(finished, opts.timeout || TIMEOUT);
								element.on($mdConstant.CSS.TRANSITIONEND, finished);

								function finished(ev)
								{
									if (ev && ev.target !== element[0]) return;
									ev && $timeout.cancel(timer);
									element.off($mdConstant.CSS.TRANSITIONEND, finished);
									resolve()
								}

								function noTransitionFound(styles)
								{
									styles = styles || window.getComputedStyle(element[0]);
									return "0s" == styles.transitionDuration || !styles.transition && !styles.transitionProperty
								}
							})
						},
						calculateTransformValues: function (element, originator)
						{
							var origin = originator.element;
							var bounds = originator.bounds;
							if (origin || bounds)
							{
								var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds);
								var dialogRect = self.copyRect(element[0].getBoundingClientRect());
								var dialogCenterPt = self.centerPointFor(dialogRect);
								var originCenterPt = self.centerPointFor(originBnds);
								return {
									centerX: originCenterPt.x - dialogCenterPt.x,
									centerY: originCenterPt.y - dialogCenterPt.y,
									scaleX: Math.round(100 * Math.min(.5, originBnds.width / dialogRect.width)) / 100,
									scaleY: Math.round(100 * Math.min(.5, originBnds.height / dialogRect.height)) / 100
								}
							}
							return {
								centerX: 0,
								centerY: 0,
								scaleX: .5,
								scaleY: .5
							};

							function currentBounds()
							{
								var cntr = element ? element.parent() : null;
								var parent = cntr ? cntr.parent() : null;
								return parent ? self.clientRect(parent) : null
							}
						},
						calculateZoomToOrigin: function (element, originator)
						{
							var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )";
							var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);
							return buildZoom(self.calculateTransformValues(element, originator))
						},
						calculateSlideToOrigin: function (element, originator)
						{
							var slideTemplate = "translate3d( {centerX}px, {centerY}px, 0 )";
							var buildSlide = angular.bind(null, $mdUtil.supplant, slideTemplate);
							return buildSlide(self.calculateTransformValues(element, originator))
						},
						toCss: function (raw)
						{
							var css = {};
							var lookups = "left top right bottom width height x y min-width min-height max-width max-height";
							angular.forEach(raw, function (value, key)
							{
								if (angular.isUndefined(value)) return;
								if (lookups.indexOf(key) >= 0) css[key] = value + "px";
								else switch (key)
								{
								case "transition":
									convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
									break;
								case "transform":
									convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
									break;
								case "transformOrigin":
									convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
									break;
								case "font-size":
									css["font-size"] = value
								}
							});
							return css;

							function convertToVendor(key, vendor, value)
							{
								angular.forEach(vendor.split(" "), function (key)
								{
									css[key] = value
								})
							}
						},
						toTransformCss: function (transform, addTransition, transition)
						{
							var css = {};
							angular.forEach($mdConstant.CSS.TRANSFORM.split(" "), function (key)
							{
								css[key] = transform
							});
							if (addTransition)
							{
								transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
								css.transition = transition
							}
							return css
						},
						copyRect: function (source, destination)
						{
							if (!source) return null;
							destination = destination ||
							{};
							angular.forEach("left top right bottom width height".split(" "), function (key)
							{
								destination[key] = Math.round(source[key])
							});
							destination.width = destination.width || destination.right - destination.left;
							destination.height = destination.height || destination.bottom - destination.top;
							return destination
						},
						clientRect: function (element)
						{
							var bounds = angular.element(element)[0].getBoundingClientRect();
							var isPositiveSizeClientRect = function (rect)
							{
								return rect && rect.width > 0 && rect.height > 0
							};
							return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null
						},
						centerPointFor: function (targetRect)
						{
							return targetRect ?
							{
								x: Math.round(targetRect.left + targetRect.width / 2),
								y: Math.round(targetRect.top + targetRect.height / 2)
							} :
							{
								x: 0,
								y: 0
							}
						}
					}
				}
			})();
			void(angular.version.minor >= 4 ? angular.module("material.core.animate", []) : function ()
			{
				var forEach = angular.forEach;
				var WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance);
				var PREFIX = WEBKIT ? "-webkit-" : "";
				var TRANSITION_EVENTS = (WEBKIT ? "webkitTransitionEnd " : "") + "transitionend";
				var ANIMATION_EVENTS = (WEBKIT ? "webkitAnimationEnd " : "") + "animationend";
				var $$ForceReflowFactory = ["$document", function ($document)
				{
					return function ()
					{
						return $document[0].body.clientWidth + 1
					}
				}];
				var $$rAFMutexFactory = ["$$rAF", function ($$rAF)
				{
					return function ()
					{
						var passed = false;
						$$rAF(function ()
						{
							passed = true
						});
						return function (fn)
						{
							passed ? fn() : $$rAF(fn)
						}
					}
				}];
				var $$AnimateRunnerFactory = ["$q", "$$rAFMutex", function ($q, $$rAFMutex)
				{
					var INITIAL_STATE = 0;
					var DONE_PENDING_STATE = 1;
					var DONE_COMPLETE_STATE = 2;

					function AnimateRunner(host)
					{
						this.setHost(host);
						this._doneCallbacks = [];
						this._runInAnimationFrame = $$rAFMutex();
						this._state = 0
					}
					AnimateRunner.prototype = {
						setHost: function (host)
						{
							this.host = host ||
							{}
						},
						done: function (fn)
						{
							this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn)
						},
						progress: angular.noop,
						getPromise: function ()
						{
							if (!this.promise)
							{
								var self = this;
								this.promise = $q(function (resolve, reject)
								{
									self.done(function (status)
									{
										false === status ? reject() : resolve()
									})
								})
							}
							return this.promise
						},
						then: function (resolveHandler, rejectHandler)
						{
							return this.getPromise().then(resolveHandler, rejectHandler)
						},
						catch: function (handler)
						{
							return this.getPromise()["catch"](handler)
						},
						finally: function (handler)
						{
							return this.getPromise()["finally"](handler)
						},
						pause: function ()
						{
							this.host.pause && this.host.pause()
						},
						resume: function ()
						{
							this.host.resume && this.host.resume()
						},
						end: function ()
						{
							this.host.end && this.host.end();
							this._resolve(true)
						},
						cancel: function ()
						{
							this.host.cancel && this.host.cancel();
							this._resolve(false)
						},
						complete: function (response)
						{
							var self = this;
							if (self._state === INITIAL_STATE)
							{
								self._state = DONE_PENDING_STATE;
								self._runInAnimationFrame(function ()
								{
									self._resolve(response)
								})
							}
						},
						_resolve: function (response)
						{
							if (this._state !== DONE_COMPLETE_STATE)
							{
								forEach(this._doneCallbacks, function (fn)
								{
									fn(response)
								});
								this._doneCallbacks.length = 0;
								this._state = DONE_COMPLETE_STATE
							}
						}
					};
					AnimateRunner.all = function (runners, callback)
					{
						var count = 0;
						var status = true;
						forEach(runners, function (runner)
						{
							runner.done(onProgress)
						});

						function onProgress(response)
						{
							status = status && response;
							++count === runners.length && callback(status)
						}
					};
					return AnimateRunner
				}];
				angular.module("material.core.animate", []).factory("$$forceReflow", $$ForceReflowFactory).factory("$$AnimateRunner", $$AnimateRunnerFactory).factory("$$rAFMutex", $$rAFMutexFactory).factory("$animateCss", ["$window", "$$rAF", "$$AnimateRunner", "$$forceReflow", "$$jqLite", "$timeout", "$animate", function ($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout, $animate)
				{
					function init(element, options)
					{
						var temporaryStyles = [];
						var node = getDomNode(element);
						var areAnimationsAllowed = node && $animate.enabled();
						var hasCompleteStyles = false;
						var hasCompleteClasses = false;
						if (areAnimationsAllowed)
						{
							options.transitionStyle && temporaryStyles.push([PREFIX + "transition", options.transitionStyle]);
							options.keyframeStyle && temporaryStyles.push([PREFIX + "animation", options.keyframeStyle]);
							options.delay && temporaryStyles.push([PREFIX + "transition-delay", options.delay + "s"]);
							options.duration && temporaryStyles.push([PREFIX + "transition-duration", options.duration + "s"]);
							hasCompleteStyles = options.keyframeStyle || options.to && (options.duration > 0 || options.transitionStyle);
							hasCompleteClasses = !!options.addClass || !!options.removeClass;
							blockTransition(element, true)
						}
						var hasCompleteAnimation = areAnimationsAllowed && (hasCompleteStyles || hasCompleteClasses);
						applyAnimationFromStyles(element, options);
						var animationClosed = false;
						var events, eventFn;
						return {
							close: $window.close,
							start: function ()
							{
								var runner = new $$AnimateRunner;
								waitUntilQuiet(function ()
								{
									blockTransition(element, false);
									if (!hasCompleteAnimation) return close();
									forEach(temporaryStyles, function (entry)
									{
										var key = entry[0];
										var value = entry[1];
										node.style[camelCase(key)] = value
									});
									applyClasses(element, options);
									var timings = computeTimings(element);
									if (0 === timings.duration) return close();
									var moreStyles = [];
									if (options.easing)
									{
										timings.transitionDuration && moreStyles.push([PREFIX + "transition-timing-function", options.easing]);
										timings.animationDuration && moreStyles.push([PREFIX + "animation-timing-function", options.easing])
									}
									options.delay && timings.animationDelay && moreStyles.push([PREFIX + "animation-delay", options.delay + "s"]);
									options.duration && timings.animationDuration && moreStyles.push([PREFIX + "animation-duration", options.duration + "s"]);
									forEach(moreStyles, function (entry)
									{
										var key = entry[0];
										var value = entry[1];
										node.style[camelCase(key)] = value;
										temporaryStyles.push(entry)
									});
									var maxDelay = timings.delay;
									var maxDelayTime = 1e3 * maxDelay;
									var maxDuration = timings.duration;
									var maxDurationTime = 1e3 * maxDuration;
									var startTime = Date.now();
									events = [];
									timings.transitionDuration && events.push(TRANSITION_EVENTS);
									timings.animationDuration && events.push(ANIMATION_EVENTS);
									events = events.join(" ");
									eventFn = function (event)
									{
										event.stopPropagation();
										var ev = event.originalEvent || event;
										var timeStamp = ev.timeStamp || Date.now();
										var elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
										Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && close()
									};
									element.on(events, eventFn);
									applyAnimationToStyles(element, options);
									$timeout(close, maxDelayTime + 1.5 * maxDurationTime, false)
								});
								return runner;

								function close()
								{
									if (animationClosed) return;
									animationClosed = true;
									events && eventFn && element.off(events, eventFn);
									applyClasses(element, options);
									applyAnimationStyles(element, options);
									forEach(temporaryStyles, function (entry)
									{
										node.style[camelCase(entry[0])] = ""
									});
									runner.complete(true);
									return runner
								}
							}
						}
					}

					function applyClasses(element, options)
					{
						if (options.addClass)
						{
							$$jqLite.addClass(element, options.addClass);
							options.addClass = null
						}
						if (options.removeClass)
						{
							$$jqLite.removeClass(element, options.removeClass);
							options.removeClass = null
						}
					}

					function computeTimings(element)
					{
						var node = getDomNode(element);
						var cs = $window.getComputedStyle(node);
						var tdr = parseMaxTime(cs[prop("transitionDuration")]);
						var adr = parseMaxTime(cs[prop("animationDuration")]);
						var tdy = parseMaxTime(cs[prop("transitionDelay")]);
						var ady = parseMaxTime(cs[prop("animationDelay")]);
						adr *= parseInt(cs[prop("animationIterationCount")], 10) || 1;
						var duration = Math.max(adr, tdr);
						var delay = Math.max(ady, tdy);
						return {
							duration: duration,
							delay: delay,
							animationDuration: adr,
							transitionDuration: tdr,
							animationDelay: ady,
							transitionDelay: tdy
						};

						function prop(key)
						{
							return WEBKIT ? "Webkit" + key.charAt(0).toUpperCase() + key.substr(1) : key
						}
					}

					function parseMaxTime(str)
					{
						var maxValue = 0;
						var values = (str || "").split(/\s*,\s*/);
						forEach(values, function (value)
						{
							"s" == value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1));
							value = parseFloat(value) || 0;
							maxValue = maxValue ? Math.max(value, maxValue) : value
						});
						return maxValue
					}
					var cancelLastRAFRequest;
					var rafWaitQueue = [];

					function waitUntilQuiet(callback)
					{
						cancelLastRAFRequest && cancelLastRAFRequest();
						rafWaitQueue.push(callback);
						cancelLastRAFRequest = $$rAF(function ()
						{
							cancelLastRAFRequest = null;
							var pageWidth = $$forceReflow();
							for (var i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
							rafWaitQueue.length = 0
						})
					}

					function applyAnimationStyles(element, options)
					{
						applyAnimationFromStyles(element, options);
						applyAnimationToStyles(element, options)
					}

					function applyAnimationFromStyles(element, options)
					{
						if (options.from)
						{
							element.css(options.from);
							options.from = null
						}
					}

					function applyAnimationToStyles(element, options)
					{
						if (options.to)
						{
							element.css(options.to);
							options.to = null
						}
					}

					function getDomNode(element)
					{
						for (var i = 0; i < element.length; i++)
							if (1 === element[i].nodeType) return element[i]
					}

					function blockTransition(element, bool)
					{
						var node = getDomNode(element);
						var key = camelCase(PREFIX + "transition-delay");
						node.style[key] = bool ? "-9999s" : ""
					}
					return init
				}]);

				function camelCase(str)
				{
					return str.replace(/-[a-z]/g, function (str)
					{
						return str.charAt(1).toUpperCase()
					})
				}
			}());
			void angular.module("material.components.autocomplete", ["material.core", "material.components.icon", "material.components.virtualRepeat"]);
			void angular.module("material.components.backdrop", ["material.core"]).directive("mdBackdrop", ["$mdTheming", "$mdUtil", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function BackdropDirective($mdTheming, $mdUtil, $animate, $rootElement, $window, $log, $$rAF, $document)
			{
				var ERROR_CSS_POSITION = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container.";
				return {
					restrict: "E",
					link: postLink
				};

				function postLink(scope, element, attrs)
				{
					$animate.pin && $animate.pin(element, $rootElement);
					var bodyStyles;
					$$rAF(function ()
					{
						bodyStyles = $window.getComputedStyle($document[0].body);
						if ("fixed" === bodyStyles.position)
						{
							var resizeHandler = $mdUtil.debounce(function ()
							{
								bodyStyles = $window.getComputedStyle($document[0].body);
								resize()
							}, 60, null, false);
							resize();
							angular.element($window).on("resize", resizeHandler);
							scope.$on("$destroy", function ()
							{
								angular.element($window).off("resize", resizeHandler)
							})
						}
						var parent = element.parent();
						if (parent.length)
						{
							"BODY" === parent[0].nodeName && element.css("position", "fixed");
							var styles = $window.getComputedStyle(parent[0]);
							"static" === styles.position && $log.warn(ERROR_CSS_POSITION);
							$mdTheming.inherit(element, parent)
						}
					});

					function resize()
					{
						var viewportHeight = parseInt(bodyStyles.height, 10) + Math.abs(parseInt(bodyStyles.top, 10));
						element.css("height", viewportHeight + "px")
					}
				}
			}]);
			(function ()
			{
				MdBottomSheetDirective.$inject = ["$mdBottomSheet"];
				MdBottomSheetProvider.$inject = ["$$interimElementProvider"];
				angular.module("material.components.bottomSheet", ["material.core", "material.components.backdrop"]).directive("mdBottomSheet", MdBottomSheetDirective).provider("$mdBottomSheet", MdBottomSheetProvider);

				function MdBottomSheetDirective($mdBottomSheet)
				{
					return {
						restrict: "E",
						link: function postLink(scope, element)
						{
							element.addClass("_md");
							scope.$on("$destroy", function ()
							{
								$mdBottomSheet.destroy()
							})
						}
					}
				}

				function MdBottomSheetProvider($$interimElementProvider)
				{
					bottomSheetDefaults.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture", "$log"];
					var CLOSING_VELOCITY = .5;
					var PADDING = 80;
					return $$interimElementProvider("$mdBottomSheet").setDefaults(
					{
						methods: ["disableParentScroll", "escapeToClose", "clickOutsideToClose"],
						options: bottomSheetDefaults
					});

					function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture, $log)
					{
						var backdrop;
						return {
							themable: true,
							onShow: onShow,
							onRemove: onRemove,
							disableBackdrop: false,
							escapeToClose: true,
							clickOutsideToClose: true,
							disableParentScroll: true,
							isLockedOpen: false
						};

						function onShow(scope, element, options, controller)
						{
							element = $mdUtil.extractElementByName(element, "md-bottom-sheet");
							element.attr("tabindex", "-1");
							if (element.hasClass("ng-cloak"))
							{
								var message = "$mdBottomSheet: using `<md-bottom-sheet ng-cloak>` will affect the bottom-sheet opening animations.";
								$log.warn(message, element[0])
							}
							if (options.isLockedOpen)
							{
								options.clickOutsideToClose = false;
								options.escapeToClose = false
							}
							else options.cleanupGestures = registerGestures(element, options.parent);
							if (!options.disableBackdrop)
							{
								backdrop = $mdUtil.createBackdrop(scope, "md-bottom-sheet-backdrop md-opaque");
								backdrop[0].tabIndex = -1;
								options.clickOutsideToClose && backdrop.on("click", function ()
								{
									$mdUtil.nextTick($mdBottomSheet.cancel, true)
								});
								$mdTheming.inherit(backdrop, options.parent);
								$animate.enter(backdrop, options.parent, null)
							}
							$mdTheming.inherit(element, options.parent);
							options.disableParentScroll && (options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent));
							return $animate.enter(element, options.parent, backdrop).then(function ()
							{
								var focusable = $mdUtil.findFocusTarget(element) || angular.element(element[0].querySelector("button") || element[0].querySelector("a") || element[0].querySelector($mdUtil.prefixer("ng-click", true))) || backdrop;
								if (options.escapeToClose)
								{
									options.rootElementKeyupCallback = function (e)
									{
										e.keyCode === $mdConstant.KEY_CODE.ESCAPE && $mdUtil.nextTick($mdBottomSheet.cancel, true)
									};
									$rootElement.on("keyup", options.rootElementKeyupCallback);
									focusable && focusable.focus()
								}
							})
						}

						function onRemove(scope, element, options)
						{
							options.disableBackdrop || $animate.leave(backdrop);
							return $animate.leave(element).then(function ()
							{
								if (options.disableParentScroll)
								{
									options.restoreScroll();
									delete options.restoreScroll
								}
								options.cleanupGestures && options.cleanupGestures()
							})
						}

						function registerGestures(element, parent)
						{
							var deregister = $mdGesture.register(parent, "drag",
							{
								horizontal: false
							});
							parent.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
							return function cleanupGestures()
							{
								deregister();
								parent.off("$md.dragstart", onDragStart);
								parent.off("$md.drag", onDrag);
								parent.off("$md.dragend", onDragEnd)
							};

							function onDragStart()
							{
								element.css($mdConstant.CSS.TRANSITION_DURATION, "0ms")
							}

							function onDrag(ev)
							{
								var transform = ev.pointer.distanceY;
								transform < 5 && (transform = Math.max(-PADDING, transform / 2));
								element.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + (PADDING + transform) + "px,0)")
							}

							function onDragEnd(ev)
							{
								if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY))
								{
									var distanceRemaining = element.prop("offsetHeight") - ev.pointer.distanceY;
									var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * .75, 500);
									element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + "ms");
									$mdUtil.nextTick($mdBottomSheet.cancel, true)
								}
								else
								{
									element.css($mdConstant.CSS.TRANSITION_DURATION, "");
									element.css($mdConstant.CSS.TRANSFORM, "")
								}
							}
						}
					}
				}
			})();
			(function ()
			{
				MdButtonDirective.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$mdInteraction"];
				MdAnchorDirective.$inject = ["$mdTheming"];
				angular.module("material.components.button", ["material.core"]).directive("mdButton", MdButtonDirective).directive("a", MdAnchorDirective);

				function MdAnchorDirective($mdTheming)
				{
					return {
						restrict: "E",
						link: function postLink(scope, element)
						{
							$mdTheming(element)
						}
					}
				}

				function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $mdInteraction)
				{
					return {
						restrict: "EA",
						replace: true,
						transclude: true,
						template: getTemplate,
						link: postLink
					};

					function isAnchor(attr)
					{
						return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref)
					}

					function getTemplate(element, attr)
					{
						if (isAnchor(attr)) return '<a class="md-button" ng-transclude></a>';
						var btnType = "undefined" === typeof attr.type ? "button" : attr.type;
						return '<button class="md-button" type="' + btnType + '" ng-transclude></button>'
					}

					function postLink(scope, element, attr)
					{
						$mdTheming(element);
						$mdButtonInkRipple.attach(scope, element);
						$mdAria.expectWithoutText(element, "aria-label");
						isAnchor(attr) && angular.isDefined(attr.ngDisabled) && scope.$watch(attr.ngDisabled, function (isDisabled)
						{
							element.attr("tabindex", isDisabled ? -1 : 0)
						});
						element.on("click", function (e)
						{
							if (true === attr.disabled)
							{
								e.preventDefault();
								e.stopImmediatePropagation()
							}
						});
						if (!element.hasClass("md-no-focus"))
						{
							element.on("focus", function ()
							{
								$mdInteraction.isUserInvoked() && "keyboard" !== $mdInteraction.getLastInteractionType() || element.addClass("md-focused")
							});
							element.on("blur", function ()
							{
								element.removeClass("md-focused")
							})
						}
					}
				}
			})();
			(function ()
			{
				mdCardDirective.$inject = ["$mdTheming"];
				angular.module("material.components.card", ["material.core"]).directive("mdCard", mdCardDirective);

				function mdCardDirective($mdTheming)
				{
					return {
						restrict: "E",
						link: function ($scope, $element, attr)
						{
							$element.addClass("_md");
							$mdTheming($element)
						}
					}
				}
			})();
			(function ()
			{
				MdCheckboxDirective.$inject = ["inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$mdInteraction"];
				angular.module("material.components.checkbox", ["material.core"]).directive("mdCheckbox", MdCheckboxDirective);

				function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $mdInteraction)
				{
					inputDirective = inputDirective[0];
					return {
						restrict: "E",
						transclude: true,
						require: ["^?mdInputContainer", "?ngModel", "?^form"],
						priority: $mdConstant.BEFORE_NG_ARIA,
						template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-icon"></div></div><div ng-transclude class="md-label"></div>',
						compile: compile
					};

					function compile(tElement, tAttrs)
					{
						tAttrs.$set("tabindex", tAttrs.tabindex || "0");
						tAttrs.$set("type", "checkbox");
						tAttrs.$set("role", tAttrs.type);
						return {
							pre: function (scope, element)
							{
								element.on("click", function (e)
								{
									this.hasAttribute("disabled") && e.stopImmediatePropagation()
								})
							},
							post: postLink
						};

						function postLink(scope, element, attr, ctrls)
						{
							var isIndeterminate;
							var containerCtrl = ctrls[0];
							var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
							var formCtrl = ctrls[2];
							if (containerCtrl)
							{
								var isErrorGetter = containerCtrl.isErrorGetter || function ()
								{
									return ngModelCtrl.$invalid && (ngModelCtrl.$touched || formCtrl && formCtrl.$submitted)
								};
								containerCtrl.input = element;
								scope.$watch(isErrorGetter, containerCtrl.setInvalid)
							}
							$mdTheming(element);
							element.children().on("focus", function ()
							{
								element.focus()
							});
							if ($mdUtil.parseAttributeBoolean(attr.mdIndeterminate))
							{
								setIndeterminateState();
								scope.$watch(attr.mdIndeterminate, setIndeterminateState)
							}
							attr.ngChecked && scope.$watch(scope.$eval.bind(scope, attr.ngChecked), function (value)
							{
								ngModelCtrl.$setViewValue(value);
								ngModelCtrl.$render()
							});
							$$watchExpr("ngDisabled", "tabindex",
							{
								true: "-1",
								false: attr.tabindex
							});
							$mdAria.expectWithText(element, "aria-label");
							inputDirective.link.pre(scope,
							{
								on: angular.noop,
								0:
								{}
							}, attr, [ngModelCtrl]);
							element.on("click", listener).on("keypress", keypressHandler).on("focus", function ()
							{
								"keyboard" === $mdInteraction.getLastInteractionType() && element.addClass("md-focused")
							}).on("blur", function ()
							{
								element.removeClass("md-focused")
							});
							ngModelCtrl.$render = render;

							function $$watchExpr(expr, htmlAttr, valueOpts)
							{
								attr[expr] && scope.$watch(attr[expr], function (val)
								{
									valueOpts[val] && element.attr(htmlAttr, valueOpts[val])
								})
							}

							function keypressHandler(ev)
							{
								var keyCode = ev.which || ev.keyCode;
								if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER)
								{
									ev.preventDefault();
									element.addClass("md-focused");
									listener(ev)
								}
							}

							function listener(ev)
							{
								if (element[0].hasAttribute("disabled") || scope.skipToggle) return;
								scope.$apply(function ()
								{
									var viewValue = attr.ngChecked && attr.ngClick ? attr.checked : !ngModelCtrl.$viewValue;
									ngModelCtrl.$setViewValue(viewValue, ev && ev.type);
									ngModelCtrl.$render()
								})
							}

							function render()
							{
								element.toggleClass("md-checked", !!ngModelCtrl.$viewValue && !isIndeterminate)
							}

							function setIndeterminateState(newValue)
							{
								isIndeterminate = false !== newValue;
								isIndeterminate && element.attr("aria-checked", "mixed");
								element.toggleClass("md-indeterminate", isIndeterminate)
							}
						}
					}
				}
			})();
			void angular.module("material.components.chips", ["material.core", "material.components.autocomplete"]);
			void
			function ()
			{
				MdColorsDirective.$inject = ["$mdColors", "$mdUtil", "$log", "$parse"];
				MdColorsService.$inject = ["$mdTheming", "$mdUtil", "$log"];
				var STATIC_COLOR_EXPRESSION = /^{((\s|,)*?["'a-zA-Z-]+?\s*?:\s*?('|")[a-zA-Z0-9-.]*('|"))+\s*}$/;
				var colorPalettes = null;
				angular.module("material.components.colors", ["material.core"]).directive("mdColors", MdColorsDirective).service("$mdColors", MdColorsService);

				function MdColorsService($mdTheming, $mdUtil, $log)
				{
					colorPalettes = colorPalettes || Object.keys($mdTheming.PALETTES);
					return {
						applyThemeColors: applyThemeColors,
						getThemeColor: getThemeColor,
						hasTheme: hasTheme
					};

					function applyThemeColors(element, colorExpression)
					{
						try
						{
							colorExpression && element.css(interpolateColors(colorExpression))
						}
						catch (e)
						{
							$log.error(e.message)
						}
					}

					function getThemeColor(expression)
					{
						var color = extractColorOptions(expression);
						return parseColor(color)
					}

					function parseColor(color, contrast)
					{
						contrast = contrast || false;
						var rgbValues = $mdTheming.PALETTES[color.palette][color.hue];
						rgbValues = contrast ? rgbValues.contrast : rgbValues.value;
						return $mdUtil.supplant("rgba({0}, {1}, {2}, {3})", [rgbValues[0], rgbValues[1], rgbValues[2], rgbValues[3] || color.opacity])
					}

					function interpolateColors(themeColors)
					{
						var rgbColors = {};
						var hasColorProperty = themeColors.hasOwnProperty("color");
						angular.forEach(themeColors, function (value, key)
						{
							var color = extractColorOptions(value);
							var hasBackground = key.indexOf("background") > -1;
							rgbColors[key] = parseColor(color);
							hasBackground && !hasColorProperty && (rgbColors.color = parseColor(color, true))
						});
						return rgbColors
					}

					function hasTheme(expression)
					{
						return angular.isDefined($mdTheming.THEMES[expression.split("-")[0]])
					}

					function extractColorOptions(expression)
					{
						var parts = expression.split("-");
						var hasTheme = angular.isDefined($mdTheming.THEMES[parts[0]]);
						var theme = hasTheme ? parts.splice(0, 1)[0] : $mdTheming.defaultTheme();
						return {
							theme: theme,
							palette: extractPalette(parts, theme),
							hue: extractHue(parts, theme),
							opacity: parts[2] || 1
						}
					}

					function extractPalette(parts, theme)
					{
						var isTwoWord = parts.length > 1 && -1 !== colorPalettes.indexOf(parts[1]);
						var palette = parts[0].replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
						isTwoWord && (palette = parts[0] + "-" + parts.splice(1, 1));
						if (-1 === colorPalettes.indexOf(palette))
						{
							var scheme = $mdTheming.THEMES[theme].colors[palette];
							if (!scheme) throw new Error($mdUtil.supplant("mdColors: couldn't find '{palette}' in the palettes.",
							{
								palette: palette
							}));
							palette = scheme.name
						}
						return palette
					}

					function extractHue(parts, theme)
					{
						var themeColors = $mdTheming.THEMES[theme].colors;
						if ("hue" === parts[1])
						{
							var hueNumber = parseInt(parts.splice(2, 1)[0], 10);
							if (hueNumber < 1 || hueNumber > 3) throw new Error($mdUtil.supplant("mdColors: 'hue-{hueNumber}' is not a valid hue, can be only 'hue-1', 'hue-2' and 'hue-3'",
							{
								hueNumber: hueNumber
							}));
							parts[1] = "hue-" + hueNumber;
							if (!(parts[0] in themeColors)) throw new Error($mdUtil.supplant("mdColors: 'hue-x' can only be used with [{availableThemes}], but was used with '{usedTheme}'",
							{
								availableThemes: Object.keys(themeColors).join(", "),
								usedTheme: parts[0]
							}));
							return themeColors[parts[0]].hues[parts[1]]
						}
						return parts[1] || themeColors[parts[0] in themeColors ? parts[0] : "primary"].hues["default"]
					}
				}

				function MdColorsDirective($mdColors, $mdUtil, $log, $parse)
				{
					return {
						restrict: "A",
						require: ["^?mdTheme"],
						compile: function (tElem, tAttrs)
						{
							var shouldWatch = shouldColorsWatch();
							return function (scope, element, attrs, ctrl)
							{
								var mdThemeController = ctrl[0];
								var lastColors = {};
								var parseColors = function (theme)
								{
									"string" !== typeof theme && (theme = "");
									attrs.mdColors || (attrs.mdColors = "{}");
									var colors = $parse(attrs.mdColors)(scope);
									mdThemeController && Object.keys(colors).forEach(function (prop)
									{
										var color = colors[prop];
										$mdColors.hasTheme(color) || (colors[prop] = (theme || mdThemeController.$mdTheme) + "-" + color)
									});
									cleanElement(colors);
									return colors
								};
								var cleanElement = function (colors)
								{
									if (!angular.equals(colors, lastColors))
									{
										var keys = Object.keys(lastColors);
										lastColors.background && !keys.color && keys.push("color");
										keys.forEach(function (key)
										{
											element.css(key, "")
										})
									}
									lastColors = colors
								};
								var unregisterChanges = angular.noop;
								mdThemeController && (unregisterChanges = mdThemeController.registerChanges(function (theme)
								{
									$mdColors.applyThemeColors(element, parseColors(theme))
								}));
								scope.$on("$destroy", function ()
								{
									unregisterChanges()
								});
								try
								{
									shouldWatch ? scope.$watch(parseColors, angular.bind(this, $mdColors.applyThemeColors, element), true) : $mdColors.applyThemeColors(element, parseColors())
								}
								catch (e)
								{
									$log.error(e.message)
								}
							};

							function shouldColorsWatch()
							{
								var rawColorExpression = tAttrs.mdColors;
								var bindOnce = rawColorExpression.indexOf("::") > -1;
								var isStatic = !!bindOnce || STATIC_COLOR_EXPRESSION.test(tAttrs.mdColors);
								tAttrs.mdColors = rawColorExpression.replace("::", "");
								var hasWatchAttr = angular.isDefined(tAttrs.mdColorsWatch);
								return !bindOnce && !isStatic && (!hasWatchAttr || $mdUtil.parseAttributeBoolean(tAttrs.mdColorsWatch))
							}
						}
					}
				}
			}();
			(function ()
			{
				mdContentDirective.$inject = ["$mdTheming"];
				angular.module("material.components.content", ["material.core"]).directive("mdContent", mdContentDirective);

				function mdContentDirective($mdTheming)
				{
					return {
						restrict: "E",
						controller: ["$scope", "$element", ContentController],
						link: function (scope, element)
						{
							element.addClass("_md");
							$mdTheming(element);
							scope.$broadcast("$mdContentLoaded", element);
							iosScrollFix(element[0])
						}
					};

					function ContentController($scope, $element)
					{
						this.$scope = $scope;
						this.$element = $element
					}
				}

				function iosScrollFix(node)
				{
					angular.element(node).on("$md.pressdown", function (ev)
					{
						if ("t" !== ev.pointer.type) return;
						if (ev.$materialScrollFixed) return;
						ev.$materialScrollFixed = true;
						0 === node.scrollTop ? node.scrollTop = 1 : node.scrollHeight === node.scrollTop + node.offsetHeight && (node.scrollTop -= 1)
					})
				}
			})();
			void angular.module("material.components.datepicker", ["material.core", "material.components.icon", "material.components.virtualRepeat"]);
			(function ()
			{
				MdDialogDirective.$inject = ["$$rAF", "$mdTheming", "$mdDialog"];
				MdDialogProvider.$inject = ["$$interimElementProvider"];
				angular.module("material.components.dialog", ["material.core", "material.components.backdrop"]).directive("mdDialog", MdDialogDirective).provider("$mdDialog", MdDialogProvider);

				function MdDialogDirective($$rAF, $mdTheming, $mdDialog)
				{
					return {
						restrict: "E",
						link: function (scope, element)
						{
							element.addClass("_md");
							$mdTheming(element);
							$$rAF(function ()
							{
								var images;
								var content = element[0].querySelector("md-dialog-content");
								if (content)
								{
									images = content.getElementsByTagName("img");
									addOverflowClass();
									angular.element(images).on("load", addOverflowClass)
								}
								scope.$on("$destroy", function ()
								{
									$mdDialog.destroy(element)
								});

								function addOverflowClass()
								{
									element.toggleClass("md-content-overflow", content.scrollHeight > content.clientHeight)
								}
							})
						}
					}
				}

				function MdDialogProvider($$interimElementProvider)
				{
					MdDialogController.$inject = ["$mdDialog", "$mdConstant"];
					dialogDefaultOptions.$inject = ["$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector", "$mdTheming", "$interpolate", "$mdInteraction"];
					var topFocusTrap, bottomFocusTrap;
					return $$interimElementProvider("$mdDialog").setDefaults(
					{
						methods: ["disableParentScroll", "hasBackdrop", "clickOutsideToClose", "escapeToClose", "targetEvent", "closeTo", "openFrom", "parent", "fullscreen", "multiple"],
						options: dialogDefaultOptions
					}).addPreset("alert",
					{
						methods: ["title", "htmlContent", "textContent", "content", "ariaLabel", "ok", "theme", "css"],
						options: advancedDialogOptions
					}).addPreset("confirm",
					{
						methods: ["title", "htmlContent", "textContent", "content", "ariaLabel", "ok", "cancel", "theme", "css"],
						options: advancedDialogOptions
					}).addPreset("prompt",
					{
						methods: ["title", "htmlContent", "textContent", "initialValue", "content", "placeholder", "ariaLabel", "ok", "cancel", "theme", "css", "required"],
						options: advancedDialogOptions
					});

					function advancedDialogOptions()
					{
						return {
							template: ['<md-dialog md-theme="{{ dialog.theme || dialog.defaultTheme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', '        ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', "      <p>{{::dialog.mdTextContent}}</p>", "    </div>", '    <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">', '      <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result"              placeholder="{{::dialog.placeholder}}" ng-required="dialog.required">', "    </md-input-container>", "  </md-dialog-content>", "  <md-dialog-actions>", '    <md-button ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"               ng-click="dialog.abort()" class="md-primary md-cancel-button">', "      {{ dialog.cancel }}", "    </md-button>", '    <md-button ng-click="dialog.hide()" class="md-primary md-confirm-button" md-autofocus="dialog.$type===\'alert\'"               ng-disabled="dialog.required && !dialog.result">', "      {{ dialog.ok }}", "    </md-button>", "  </md-dialog-actions>", "</md-dialog>"].join("").replace(/\s\s+/g, ""),
							controller: MdDialogController,
							controllerAs: "dialog",
							bindToController: true
						}
					}

					function MdDialogController($mdDialog, $mdConstant)
					{
						this.$onInit = function ()
						{
							var isPrompt = "prompt" == this.$type;
							isPrompt && this.initialValue && (this.result = this.initialValue);
							this.hide = function ()
							{
								$mdDialog.hide(!isPrompt || this.result)
							};
							this.abort = function ()
							{
								$mdDialog.cancel()
							};
							this.keypress = function ($event)
							{
								var invalidPrompt = isPrompt && this.required && !angular.isDefined(this.result);
								$event.keyCode !== $mdConstant.KEY_CODE.ENTER || invalidPrompt || $mdDialog.hide(this.result)
							}
						}
					}

					function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector, $mdTheming, $interpolate, $mdInteraction)
					{
						return {
							hasBackdrop: true,
							isolateScope: true,
							onCompiling: beforeCompile,
							onShow: onShow,
							onShowing: beforeShow,
							onRemove: onRemove,
							clickOutsideToClose: false,
							escapeToClose: true,
							targetEvent: null,
							closeTo: null,
							openFrom: null,
							focusOnOpen: true,
							disableParentScroll: true,
							autoWrap: true,
							fullscreen: false,
							transformTemplate: function (template, options)
							{
								var startSymbol = $interpolate.startSymbol();
								var endSymbol = $interpolate.endSymbol();
								var theme = startSymbol + (options.themeWatch ? "" : "::") + "theme" + endSymbol;
								var themeAttr = options.hasTheme ? 'md-theme="' + theme + '"' : "";
								return '<div class="md-dialog-container" tabindex="-1" ' + themeAttr + ">" + validatedTemplate(template) + "</div>";

								function validatedTemplate(template)
								{
									return options.autoWrap && !/<\/md-dialog>/g.test(template) ? "<md-dialog>" + (template || "") + "</md-dialog>" : template || ""
								}
							}
						};

						function beforeCompile(options)
						{
							options.defaultTheme = $mdTheming.defaultTheme();
							detectTheming(options)
						}

						function beforeShow(scope, element, options, controller)
						{
							if (controller)
							{
								var mdHtmlContent = controller.htmlContent || options.htmlContent || "";
								var mdTextContent = controller.textContent || options.textContent || controller.content || options.content || "";
								if (mdHtmlContent && !$injector.has("$sanitize")) throw Error("The ngSanitize module must be loaded in order to use htmlContent.");
								if (mdHtmlContent && mdTextContent) throw Error("md-dialog cannot have both `htmlContent` and `textContent`");
								controller.mdHtmlContent = mdHtmlContent;
								controller.mdTextContent = mdTextContent
							}
						}

						function onShow(scope, element, options, controller)
						{
							angular.element($document[0].body).addClass("md-dialog-is-showing");
							var dialogElement = element.find("md-dialog");
							if (dialogElement.hasClass("ng-cloak"))
							{
								var message = "$mdDialog: using `<md-dialog ng-cloak>` will affect the dialog opening animations.";
								$log.warn(message, element[0])
							}
							captureParentAndFromToElements(options);
							configureAria(dialogElement, options);
							showBackdrop(scope, element, options);
							activateListeners(element, options);
							return dialogPopIn(element, options).then(function ()
							{
								lockScreenReader(element, options);
								warnDeprecatedActions();
								focusOnOpen()
							});

							function warnDeprecatedActions()
							{
								element[0].querySelector(".md-actions") && $log.warn("Using a class of md-actions is deprecated, please use <md-dialog-actions>.")
							}

							function focusOnOpen()
							{
								if (options.focusOnOpen)
								{
									var target = $mdUtil.findFocusTarget(element) || findCloseButton() || dialogElement;
									target.focus()
								}

								function findCloseButton()
								{
									return element[0].querySelector(".dialog-close, md-dialog-actions button:last-child")
								}
							}
						}

						function onRemove(scope, element, options)
						{
							options.deactivateListeners();
							options.unlockScreenReader();
							options.hideBackdrop(options.$destroy);
							topFocusTrap && topFocusTrap.parentNode && topFocusTrap.parentNode.removeChild(topFocusTrap);
							bottomFocusTrap && bottomFocusTrap.parentNode && bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
							return options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);

							function animateRemoval()
							{
								return dialogPopOut(element, options)
							}

							function detachAndClean()
							{
								angular.element($document[0].body).removeClass("md-dialog-is-showing");
								options.contentElement && options.reverseContainerStretch();
								options.cleanupElement();
								options.$destroy || "keyboard" !== options.originInteraction || options.origin.focus()
							}
						}

						function detectTheming(options)
						{
							var targetEl;
							options.targetEvent && options.targetEvent.target && (targetEl = angular.element(options.targetEvent.target));
							var themeCtrl = targetEl && targetEl.controller("mdTheme");
							options.hasTheme = !!themeCtrl;
							if (!options.hasTheme) return;
							options.themeWatch = themeCtrl.$shouldWatch;
							var theme = options.theme || themeCtrl.$mdTheme;
							theme && (options.scope.theme = theme);
							var unwatch = themeCtrl.registerChanges(function (newTheme)
							{
								options.scope.theme = newTheme;
								options.themeWatch || unwatch()
							})
						}

						function captureParentAndFromToElements(options)
						{
							options.origin = angular.extend(
							{
								element: null,
								bounds: null,
								focus: angular.noop
							}, options.origin ||
							{});
							options.parent = getDomElement(options.parent, $rootElement);
							options.closeTo = getBoundingClientRect(getDomElement(options.closeTo));
							options.openFrom = getBoundingClientRect(getDomElement(options.openFrom));
							if (options.targetEvent)
							{
								options.origin = getBoundingClientRect(options.targetEvent.target, options.origin);
								options.originInteraction = $mdInteraction.getLastInteractionType()
							}

							function getBoundingClientRect(element, orig)
							{
								var source = angular.element(element ||
								{});
								if (source && source.length)
								{
									var bounds = {
										top: 0,
										left: 0,
										height: 0,
										width: 0
									};
									var hasFn = angular.isFunction(source[0].getBoundingClientRect);
									return angular.extend(orig ||
									{},
									{
										element: hasFn ? source : undefined,
										bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend(
										{}, bounds, source[0]),
										focus: angular.bind(source, source.focus)
									})
								}
							}

							function getDomElement(element, defaultElement)
							{
								angular.isString(element) && (element = $document[0].querySelector(element));
								return angular.element(element || defaultElement)
							}
						}

						function activateListeners(element, options)
						{
							var window = angular.element($window);
							var onWindowResize = $mdUtil.debounce(function ()
							{
								stretchDialogContainerToViewport(element, options)
							}, 60);
							var removeListeners = [];
							var smartClose = function ()
							{
								var closeFn = "alert" == options.$type ? $mdDialog.hide : $mdDialog.cancel;
								$mdUtil.nextTick(closeFn, true)
							};
							if (options.escapeToClose)
							{
								var parentTarget = options.parent;
								var keyHandlerFn = function (ev)
								{
									if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE)
									{
										ev.stopPropagation();
										ev.preventDefault();
										smartClose()
									}
								};
								element.on("keydown", keyHandlerFn);
								parentTarget.on("keydown", keyHandlerFn);
								removeListeners.push(function ()
								{
									element.off("keydown", keyHandlerFn);
									parentTarget.off("keydown", keyHandlerFn)
								})
							}
							window.on("resize", onWindowResize);
							removeListeners.push(function ()
							{
								window.off("resize", onWindowResize)
							});
							if (options.clickOutsideToClose)
							{
								var target = element;
								var sourceElem;
								var mousedownHandler = function (ev)
								{
									sourceElem = ev.target
								};
								var mouseupHandler = function (ev)
								{
									if (sourceElem === target[0] && ev.target === target[0])
									{
										ev.stopPropagation();
										ev.preventDefault();
										smartClose()
									}
								};
								target.on("mousedown", mousedownHandler);
								target.on("mouseup", mouseupHandler);
								removeListeners.push(function ()
								{
									target.off("mousedown", mousedownHandler);
									target.off("mouseup", mouseupHandler)
								})
							}
							options.deactivateListeners = function ()
							{
								removeListeners.forEach(function (removeFn)
								{
									removeFn()
								});
								options.deactivateListeners = null
							}
						}

						function showBackdrop(scope, element, options)
						{
							options.disableParentScroll && (options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent));
							if (options.hasBackdrop)
							{
								options.backdrop = $mdUtil.createBackdrop(scope, "md-dialog-backdrop md-opaque");
								$animate.enter(options.backdrop, options.parent)
							}
							options.hideBackdrop = function hideBackdrop($destroy)
							{
								options.backdrop && ($destroy ? options.backdrop.remove() : $animate.leave(options.backdrop));
								if (options.disableParentScroll)
								{
									options.restoreScroll && options.restoreScroll();
									delete options.restoreScroll
								}
								options.hideBackdrop = null
							}
						}

						function configureAria(element, options)
						{
							var role = "alert" === options.$type ? "alertdialog" : "dialog";
							var dialogContent = element.find("md-dialog-content");
							var existingDialogId = element.attr("id");
							var dialogContentId = "dialogContent_" + (existingDialogId || $mdUtil.nextUid());
							element.attr(
							{
								role: role,
								tabIndex: "-1"
							});
							if (0 === dialogContent.length)
							{
								dialogContent = element;
								existingDialogId && (dialogContentId = existingDialogId)
							}
							dialogContent.attr("id", dialogContentId);
							element.attr("aria-describedby", dialogContentId);
							options.ariaLabel ? $mdAria.expect(element, "aria-label", options.ariaLabel) : $mdAria.expectAsync(element, "aria-label", function ()
							{
								if (options.title) return options.title;
								var words = dialogContent.text().split(/\s+/);
								words.length > 3 && (words = words.slice(0, 3).concat("..."));
								return words.join(" ")
							});
							topFocusTrap = document.createElement("div");
							topFocusTrap.classList.add("md-dialog-focus-trap");
							topFocusTrap.tabIndex = 0;
							bottomFocusTrap = topFocusTrap.cloneNode(false);
							var focusHandler = function ()
							{
								element.focus()
							};
							topFocusTrap.addEventListener("focus", focusHandler);
							bottomFocusTrap.addEventListener("focus", focusHandler);
							element[0].parentNode.insertBefore(topFocusTrap, element[0]);
							element.after(bottomFocusTrap)
						}

						function lockScreenReader(element, options)
						{
							var isHidden = true;
							walkDOM(element[0]);
							options.unlockScreenReader = function ()
							{
								isHidden = false;
								walkDOM(element[0]);
								options.unlockScreenReader = null
							};

							function getParents(element)
							{
								var parents = [];
								while (element.parentNode)
								{
									if (element === document.body) return parents;
									var children = element.parentNode.children;
									for (var i = 0; i < children.length; i++) element === children[i] || isNodeOneOf(children[i], ["SCRIPT", "STYLE"]) || children[i].hasAttribute("aria-live") || parents.push(children[i]);
									element = element.parentNode
								}
								return parents
							}

							function walkDOM(element)
							{
								var elements = getParents(element);
								for (var i = 0; i < elements.length; i++) elements[i].setAttribute("aria-hidden", isHidden)
							}
						}

						function stretchDialogContainerToViewport(container, options)
						{
							var isFixed = "fixed" == $window.getComputedStyle($document[0].body).position;
							var backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null;
							var height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0;
							var previousStyles = {
								top: container.css("top"),
								height: container.css("height")
							};
							var parentTop = Math.abs(options.parent[0].getBoundingClientRect().top);
							container.css(
							{
								top: (isFixed ? parentTop : 0) + "px",
								height: height ? height + "px" : "100%"
							});
							return function ()
							{
								container.css(previousStyles)
							}
						}

						function dialogPopIn(container, options)
						{
							options.parent.append(container);
							options.reverseContainerStretch = stretchDialogContainerToViewport(container, options);
							var dialogEl = container.find("md-dialog");
							var animator = $mdUtil.dom.animator;
							var buildTranslateToOrigin = animator.calculateZoomToOrigin;
							var translateOptions = {
								transitionInClass: "md-transition-in",
								transitionOutClass: "md-transition-out"
							};
							var from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin));
							var to = animator.toTransformCss("");
							dialogEl.toggleClass("md-dialog-fullscreen", !!options.fullscreen);
							return animator.translate3d(dialogEl, from, to, translateOptions).then(function (animateReversal)
							{
								options.reverseAnimate = function ()
								{
									delete options.reverseAnimate;
									if (options.closeTo)
									{
										translateOptions = {
											transitionInClass: "md-transition-out",
											transitionOutClass: "md-transition-in"
										};
										from = to;
										to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo));
										return animator.translate3d(dialogEl, from, to, translateOptions)
									}
									return animateReversal(to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.origin)))
								};
								options.clearAnimate = function ()
								{
									delete options.clearAnimate;
									dialogEl.removeClass([translateOptions.transitionOutClass, translateOptions.transitionInClass].join(" "));
									return animator.translate3d(dialogEl, to, animator.toTransformCss(""),
									{})
								};
								return true
							})
						}

						function dialogPopOut(container, options)
						{
							return options.reverseAnimate().then(function ()
							{
								options.contentElement && options.clearAnimate()
							})
						}

						function isNodeOneOf(elem, nodeTypeArray)
						{
							if (-1 !== nodeTypeArray.indexOf(elem.nodeName)) return true
						}
					}
				}
			})();
			(function ()
			{
				MdDividerDirective.$inject = ["$mdTheming"];
				angular.module("material.components.divider", ["material.core"]).directive("mdDivider", MdDividerDirective);

				function MdDividerDirective($mdTheming)
				{
					return {
						restrict: "E",
						link: $mdTheming
					}
				}
			})();
			void
			function ()
			{
				MdFabActionsDirective.$inject = ["$mdUtil"];
				angular.module("material.components.fabActions", ["material.core"]).directive("mdFabActions", MdFabActionsDirective);

				function MdFabActionsDirective($mdUtil)
				{
					return {
						restrict: "E",
						require: ["^?mdFabSpeedDial", "^?mdFabToolbar"],
						compile: function (element, attributes)
						{
							var children = element.children();
							var hasNgRepeat = $mdUtil.prefixer().hasAttribute(children, "ng-repeat");
							hasNgRepeat ? children.addClass("md-fab-action-item") : children.wrap('<div class="md-fab-action-item">')
						}
					}
				}
			}();
			void
			function ()
			{
				MdFabController.$inject = ["$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout"];
				angular.module("material.components.fabShared", ["material.core"]).controller("MdFabController", MdFabController);

				function MdFabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout)
				{
					var vm = this;
					var initialAnimationAttempts = 0;
					vm.open = function ()
					{
						$scope.$evalAsync("vm.isOpen = true")
					};
					vm.close = function ()
					{
						$scope.$evalAsync("vm.isOpen = false");
						$element.find("md-fab-trigger")[0].focus()
					};
					vm.toggle = function ()
					{
						$scope.$evalAsync("vm.isOpen = !vm.isOpen")
					};
					vm.$onInit = function ()
					{
						setupDefaults();
						setupListeners();
						setupWatchers();
						fireInitialAnimations()
					};
					1 === angular.version.major && angular.version.minor <= 4 && this.$onInit();

					function setupDefaults()
					{
						vm.direction = vm.direction || "down";
						vm.isOpen = vm.isOpen || false;
						resetActionIndex();
						$element.addClass("md-animations-waiting")
					}

					function setupListeners()
					{
						var eventTypes = ["click", "focusin", "focusout"];
						angular.forEach(eventTypes, function (eventType)
						{
							$element.on(eventType, parseEvents)
						});
						$scope.$on("$destroy", function ()
						{
							angular.forEach(eventTypes, function (eventType)
							{
								$element.off(eventType, parseEvents)
							});
							disableKeyboard()
						})
					}
					var closeTimeout;

					function parseEvents(event)
					{
						"click" == event.type && handleItemClick(event);
						"focusout" != event.type || closeTimeout || (closeTimeout = $timeout(function ()
						{
							vm.close()
						}, 100, false));
						if ("focusin" == event.type && closeTimeout)
						{
							$timeout.cancel(closeTimeout);
							closeTimeout = null
						}
					}

					function resetActionIndex()
					{
						vm.currentActionIndex = -1
					}

					function setupWatchers()
					{
						$scope.$watch("vm.direction", function (newDir, oldDir)
						{
							$animate.removeClass($element, "md-" + oldDir);
							$animate.addClass($element, "md-" + newDir);
							resetActionIndex()
						});
						var trigger, actions;
						$scope.$watch("vm.isOpen", function (isOpen)
						{
							resetActionIndex();
							if (!trigger || !actions)
							{
								trigger = getTriggerElement();
								actions = getActionsElement()
							}
							isOpen ? enableKeyboard() : disableKeyboard();
							var toAdd = isOpen ? "md-is-open" : "";
							var toRemove = isOpen ? "" : "md-is-open";
							trigger.attr("aria-haspopup", true);
							trigger.attr("aria-expanded", isOpen);
							actions.attr("aria-hidden", !isOpen);
							$animate.setClass($element, toAdd, toRemove)
						})
					}

					function fireInitialAnimations()
					{
						if ($element[0].scrollHeight > 0) $animate.addClass($element, "_md-animations-ready").then(function ()
						{
							$element.removeClass("md-animations-waiting")
						});
						else if (initialAnimationAttempts < 10)
						{
							$timeout(fireInitialAnimations, 100);
							initialAnimationAttempts += 1
						}
					}

					function enableKeyboard()
					{
						$element.on("keydown", keyPressed);
						$mdUtil.nextTick(function ()
						{
							angular.element(document).on("click touchend", checkForOutsideClick)
						})
					}

					function disableKeyboard()
					{
						$element.off("keydown", keyPressed);
						angular.element(document).off("click touchend", checkForOutsideClick)
					}

					function checkForOutsideClick(event)
					{
						if (event.target)
						{
							var closestTrigger = $mdUtil.getClosest(event.target, "md-fab-trigger");
							var closestActions = $mdUtil.getClosest(event.target, "md-fab-actions");
							closestTrigger || closestActions || vm.close()
						}
					}

					function keyPressed(event)
					{
						switch (event.which)
						{
						case $mdConstant.KEY_CODE.ESCAPE:
							vm.close();
							event.preventDefault();
							return false;
						case $mdConstant.KEY_CODE.LEFT_ARROW:
							doKeyLeft(event);
							return false;
						case $mdConstant.KEY_CODE.UP_ARROW:
							doKeyUp(event);
							return false;
						case $mdConstant.KEY_CODE.RIGHT_ARROW:
							doKeyRight(event);
							return false;
						case $mdConstant.KEY_CODE.DOWN_ARROW:
							doKeyDown(event);
							return false
						}
					}

					function doActionPrev(event)
					{
						focusAction(event, -1)
					}

					function doActionNext(event)
					{
						focusAction(event, 1)
					}

					function focusAction(event, direction)
					{
						var actions = resetActionTabIndexes();
						vm.currentActionIndex = vm.currentActionIndex + direction;
						vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex);
						vm.currentActionIndex = Math.max(0, vm.currentActionIndex);
						var focusElement = angular.element(actions[vm.currentActionIndex]).children()[0];
						angular.element(focusElement).attr("tabindex", 0);
						focusElement.focus();
						event.preventDefault();
						event.stopImmediatePropagation()
					}

					function resetActionTabIndexes()
					{
						var actions = getActionsElement()[0].querySelectorAll(".md-fab-action-item");
						angular.forEach(actions, function (action)
						{
							angular.element(angular.element(action).children()[0]).attr("tabindex", -1)
						});
						return actions
					}

					function doKeyLeft(event)
					{
						"left" === vm.direction ? doActionNext(event) : doActionPrev(event)
					}

					function doKeyUp(event)
					{
						"down" === vm.direction ? doActionPrev(event) : doActionNext(event)
					}

					function doKeyRight(event)
					{
						"left" === vm.direction ? doActionPrev(event) : doActionNext(event)
					}

					function doKeyDown(event)
					{
						"up" === vm.direction ? doActionPrev(event) : doActionNext(event)
					}

					function isTrigger(element)
					{
						return $mdUtil.getClosest(element, "md-fab-trigger")
					}

					function isAction(element)
					{
						return $mdUtil.getClosest(element, "md-fab-actions")
					}

					function handleItemClick(event)
					{
						isTrigger(event.target) && vm.toggle();
						isAction(event.target) && vm.close()
					}

					function getTriggerElement()
					{
						return $element.find("md-fab-trigger")
					}

					function getActionsElement()
					{
						return $element.find("md-fab-actions")
					}
				}
			}();
			void
			function ()
			{
				MdFabSpeedDialFlingAnimation.$inject = ["$timeout"];
				MdFabSpeedDialScaleAnimation.$inject = ["$timeout"];
				var cssAnimationDuration = 300;
				angular.module("material.components.fabSpeedDial", ["material.core", "material.components.fabShared", "material.components.fabActions"]).directive("mdFabSpeedDial", MdFabSpeedDialDirective).animation(".md-fling", MdFabSpeedDialFlingAnimation).animation(".md-scale", MdFabSpeedDialScaleAnimation).service("mdFabSpeedDialFlingAnimation", MdFabSpeedDialFlingAnimation).service("mdFabSpeedDialScaleAnimation", MdFabSpeedDialScaleAnimation);

				function MdFabSpeedDialDirective()
				{
					return {
						restrict: "E",
						scope:
						{
							direction: "@?mdDirection",
							isOpen: "=?mdOpen"
						},
						bindToController: true,
						controller: "MdFabController",
						controllerAs: "vm",
						link: FabSpeedDialLink
					};

					function FabSpeedDialLink(scope, element)
					{
						element.prepend('<div class="_md-css-variables"></div>')
					}
				}

				function MdFabSpeedDialFlingAnimation($timeout)
				{
					function delayDone(done)
					{
						$timeout(done, cssAnimationDuration, false)
					}

					function runAnimation(element)
					{
						if (element.hasClass("md-animations-waiting") && !element.hasClass("_md-animations-ready")) return;
						var el = element[0];
						var ctrl = element.controller("mdFabSpeedDial");
						var items = el.querySelectorAll(".md-fab-action-item");
						var triggerElement = el.querySelector("md-fab-trigger");
						var variablesElement = el.querySelector("._md-css-variables");
						var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
						angular.forEach(items, function (item, index)
						{
							var styles = item.style;
							styles.transform = styles.webkitTransform = "";
							styles.transitionDelay = "";
							styles.opacity = 1;
							styles.zIndex = items.length - index + startZIndex
						});
						triggerElement.style.zIndex = startZIndex + items.length + 1;
						ctrl.isOpen || angular.forEach(items, function (item, index)
						{
							var newPosition, axis;
							var styles = item.style;
							var triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2;
							var triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;
							switch (ctrl.direction)
							{
							case "up":
								newPosition = item.scrollHeight * (index + 1) + triggerItemHeightOffset;
								axis = "Y";
								break;
							case "down":
								newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset);
								axis = "Y";
								break;
							case "left":
								newPosition = item.scrollWidth * (index + 1) + triggerItemWidthOffset;
								axis = "X";
								break;
							case "right":
								newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset);
								axis = "X"
							}
							var newTranslate = "translate" + axis + "(" + newPosition + "px)";
							styles.transform = styles.webkitTransform = newTranslate
						})
					}
					return {
						addClass: function (element, className, done)
						{
							if (element.hasClass("md-fling"))
							{
								runAnimation(element);
								delayDone(done)
							}
							else done()
						},
						removeClass: function (element, className, done)
						{
							runAnimation(element);
							delayDone(done)
						}
					}
				}

				function MdFabSpeedDialScaleAnimation($timeout)
				{
					function delayDone(done)
					{
						$timeout(done, cssAnimationDuration, false)
					}
					var delay = 65;

					function runAnimation(element)
					{
						var el = element[0];
						var ctrl = element.controller("mdFabSpeedDial");
						var items = el.querySelectorAll(".md-fab-action-item");
						var variablesElement = el.querySelector("._md-css-variables");
						var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
						angular.forEach(items, function (item, index)
						{
							var styles = item.style,
								offsetDelay = index * delay;
							styles.opacity = ctrl.isOpen ? 1 : 0;
							styles.transform = styles.webkitTransform = ctrl.isOpen ? "scale(1)" : "scale(0)";
							styles.transitionDelay = (ctrl.isOpen ? offsetDelay : items.length - offsetDelay) + "ms";
							styles.zIndex = items.length - index + startZIndex
						})
					}
					return {
						addClass: function (element, className, done)
						{
							runAnimation(element);
							delayDone(done)
						},
						removeClass: function (element, className, done)
						{
							runAnimation(element);
							delayDone(done)
						}
					}
				}
			}();
			void
			function ()
			{
				angular.module("material.components.fabToolbar", ["material.core", "material.components.fabShared", "material.components.fabActions"]).directive("mdFabToolbar", MdFabToolbarDirective).animation(".md-fab-toolbar", MdFabToolbarAnimation).service("mdFabToolbarAnimation", MdFabToolbarAnimation);

				function MdFabToolbarDirective()
				{
					return {
						restrict: "E",
						transclude: true,
						template: '<div class="md-fab-toolbar-wrapper">  <div class="md-fab-toolbar-content" ng-transclude></div></div>',
						scope:
						{
							direction: "@?mdDirection",
							isOpen: "=?mdOpen"
						},
						bindToController: true,
						controller: "MdFabController",
						controllerAs: "vm",
						link: link
					};

					function link(scope, element, attributes)
					{
						element.addClass("md-fab-toolbar");
						element.find("md-fab-trigger").find("button").prepend('<div class="md-fab-toolbar-background"></div>')
					}
				}

				function MdFabToolbarAnimation()
				{
					function runAnimation(element, className, done)
					{
						if (!className) return;
						var el = element[0];
						var ctrl = element.controller("mdFabToolbar");
						var backgroundElement = el.querySelector(".md-fab-toolbar-background");
						var triggerElement = el.querySelector("md-fab-trigger button");
						var toolbarElement = el.querySelector("md-toolbar");
						var iconElement = el.querySelector("md-fab-trigger button md-icon");
						var actions = element.find("md-fab-actions").children();
						if (triggerElement && backgroundElement)
						{
							var color = window.getComputedStyle(triggerElement).getPropertyValue("background-color");
							var width = el.offsetWidth;
							el.offsetHeight;
							var scale = width / triggerElement.offsetWidth * 2;
							backgroundElement.style.backgroundColor = color;
							backgroundElement.style.borderRadius = width + "px";
							if (ctrl.isOpen)
							{
								toolbarElement.style.pointerEvents = "inherit";
								backgroundElement.style.width = triggerElement.offsetWidth + "px";
								backgroundElement.style.height = triggerElement.offsetHeight + "px";
								backgroundElement.style.transform = "scale(" + scale + ")";
								backgroundElement.style.transitionDelay = "0ms";
								iconElement && (iconElement.style.transitionDelay = ".3s");
								angular.forEach(actions, function (action, index)
								{
									action.style.transitionDelay = 25 * (actions.length - index) + "ms"
								})
							}
							else
							{
								toolbarElement.style.pointerEvents = "none";
								backgroundElement.style.transform = "scale(1)";
								backgroundElement.style.top = "0";
								if (element.hasClass("md-right"))
								{
									backgroundElement.style.left = "0";
									backgroundElement.style.right = null
								}
								if (element.hasClass("md-left"))
								{
									backgroundElement.style.right = "0";
									backgroundElement.style.left = null
								}
								backgroundElement.style.transitionDelay = "200ms";
								iconElement && (iconElement.style.transitionDelay = "0ms");
								angular.forEach(actions, function (action, index)
								{
									action.style.transitionDelay = 200 + 25 * index + "ms"
								})
							}
						}
					}
					return {
						addClass: function (element, className, done)
						{
							runAnimation(element, className, done);
							done()
						},
						removeClass: function (element, className, done)
						{
							runAnimation(element, className, done);
							done()
						}
					}
				}
			}();
			(function ()
			{
				GridListController.$inject = ["$mdUtil"];
				GridLayoutFactory.$inject = ["$mdUtil"];
				GridListDirective.$inject = ["$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia"];
				GridTileDirective.$inject = ["$mdMedia"];
				angular.module("material.components.gridList", ["material.core"]).directive("mdGridList", GridListDirective).directive("mdGridTile", GridTileDirective).directive("mdGridTileFooter", GridTileCaptionDirective).directive("mdGridTileHeader", GridTileCaptionDirective).factory("$mdGridLayout", GridLayoutFactory);

				function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia)
				{
					return {
						restrict: "E",
						controller: GridListController,
						scope:
						{
							mdOnLayout: "&"
						},
						link: postLink
					};

					function postLink(scope, element, attrs, ctrl)
					{
						element.addClass("_md");
						element.attr("role", "list");
						ctrl.layoutDelegate = layoutDelegate;
						var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),
							unwatchAttrs = watchMedia();
						scope.$on("$destroy", unwatchMedia);

						function watchMedia()
						{
							for (var mediaName in $mdConstant.MEDIA)
							{
								$mdMedia(mediaName);
								$mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout)
							}
							return $mdMedia.watchResponsiveAttributes(["md-cols", "md-row-height", "md-gutter"], attrs, layoutIfMediaMatch)
						}

						function unwatchMedia()
						{
							ctrl.layoutDelegate = angular.noop;
							unwatchAttrs();
							for (var mediaName in $mdConstant.MEDIA) $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout)
						}

						function layoutIfMediaMatch(mediaName)
						{
							null == mediaName ? ctrl.invalidateLayout() : $mdMedia(mediaName) && ctrl.invalidateLayout()
						}
						var lastLayoutProps;

						function layoutDelegate(tilesInvalidated)
						{
							var tiles = getTileElements();
							var props = {
								tileSpans: getTileSpans(tiles),
								colCount: getColumnCount(),
								rowMode: getRowMode(),
								rowHeight: getRowHeight(),
								gutter: getGutter()
							};
							if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) return;
							var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles).map(function (tilePositions, rowCount)
							{
								return {
									grid:
									{
										element: element,
										style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
									},
									tiles: tilePositions.map(function (ps, i)
									{
										return {
											element: angular.element(tiles[i]),
											style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
										}
									})
								}
							}).reflow().performance();
							scope.mdOnLayout(
							{
								$event:
								{
									performance: performance
								}
							});
							lastLayoutProps = props
						}
						var startSymbol = $interpolate.startSymbol();
						var endSymbol = $interpolate.endSymbol();

						function expr(exprStr)
						{
							return startSymbol + exprStr + endSymbol
						}
						var UNIT = $interpolate(expr("share") + "% - (" + expr("gutter") + " * " + expr("gutterShare") + ")");
						var POSITION = $interpolate("calc((" + expr("unit") + " + " + expr("gutter") + ") * " + expr("offset") + ")");
						var DIMENSION = $interpolate("calc((" + expr("unit") + ") * " + expr("span") + " + (" + expr("span") + " - 1) * " + expr("gutter") + ")");

						function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight)
						{
							var hShare = 1 / colCount * 100;
							var hGutterShare = (colCount - 1) / colCount;
							var hUnit = UNIT(
							{
								share: hShare,
								gutterShare: hGutterShare,
								gutter: gutter
							});
							var ltr = "rtl" != document.dir && "rtl" != document.body.dir;
							var style = ltr ?
							{
								left: POSITION(
								{
									unit: hUnit,
									offset: position.col,
									gutter: gutter
								}),
								width: DIMENSION(
								{
									unit: hUnit,
									span: spans.col,
									gutter: gutter
								}),
								paddingTop: "",
								marginTop: "",
								top: "",
								height: ""
							} :
							{
								right: POSITION(
								{
									unit: hUnit,
									offset: position.col,
									gutter: gutter
								}),
								width: DIMENSION(
								{
									unit: hUnit,
									span: spans.col,
									gutter: gutter
								}),
								paddingTop: "",
								marginTop: "",
								top: "",
								height: ""
							};
							switch (rowMode)
							{
							case "fixed":
								style.top = POSITION(
								{
									unit: rowHeight,
									offset: position.row,
									gutter: gutter
								});
								style.height = DIMENSION(
								{
									unit: rowHeight,
									span: spans.row,
									gutter: gutter
								});
								break;
							case "ratio":
								var vShare = hShare / rowHeight;
								var vUnit = UNIT(
								{
									share: vShare,
									gutterShare: hGutterShare,
									gutter: gutter
								});
								style.paddingTop = DIMENSION(
								{
									unit: vUnit,
									span: spans.row,
									gutter: gutter
								});
								style.marginTop = POSITION(
								{
									unit: vUnit,
									offset: position.row,
									gutter: gutter
								});
								break;
							case "fit":
								var vGutterShare = (rowCount - 1) / rowCount;
								vShare = 1 / rowCount * 100;
								vUnit = UNIT(
								{
									share: vShare,
									gutterShare: vGutterShare,
									gutter: gutter
								});
								style.top = POSITION(
								{
									unit: vUnit,
									offset: position.row,
									gutter: gutter
								});
								style.height = DIMENSION(
								{
									unit: vUnit,
									span: spans.row,
									gutter: gutter
								})
							}
							return style
						}

						function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight)
						{
							var style = {};
							switch (rowMode)
							{
							case "fixed":
								style.height = DIMENSION(
								{
									unit: rowHeight,
									span: rowCount,
									gutter: gutter
								});
								style.paddingBottom = "";
								break;
							case "ratio":
								var hGutterShare = 1 === colCount ? 0 : (colCount - 1) / colCount,
									hShare = 1 / colCount * 100,
									vShare = hShare * (1 / rowHeight),
									vUnit = UNIT(
									{
										share: vShare,
										gutterShare: hGutterShare,
										gutter: gutter
									});
								style.height = "";
								style.paddingBottom = DIMENSION(
								{
									unit: vUnit,
									span: rowCount,
									gutter: gutter
								})
							}
							return style
						}

						function getTileElements()
						{
							return [].filter.call(element.children(), function (ele)
							{
								return "MD-GRID-TILE" == ele.tagName && !ele.$$mdDestroyed
							})
						}

						function getTileSpans(tileElements)
						{
							return [].map.call(tileElements, function (ele)
							{
								var ctrl = angular.element(ele).controller("mdGridTile");
								return {
									row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, "md-rowspan"), 10) || 1,
									col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, "md-colspan"), 10) || 1
								}
							})
						}

						function getColumnCount()
						{
							var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, "md-cols"), 10);
							if (isNaN(colCount)) throw "md-grid-list: md-cols attribute was not found, or contained a non-numeric value";
							return colCount
						}

						function getGutter()
						{
							return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, "md-gutter") || 1)
						}

						function getRowHeight()
						{
							var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
							if (!rowHeight) throw "md-grid-list: md-row-height attribute was not found";
							switch (getRowMode())
							{
							case "fixed":
								return applyDefaultUnit(rowHeight);
							case "ratio":
								var whRatio = rowHeight.split(":");
								return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);
							case "fit":
								return 0
							}
						}

						function getRowMode()
						{
							var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
							if (!rowHeight) throw "md-grid-list: md-row-height attribute was not found";
							return "fit" == rowHeight ? "fit" : -1 !== rowHeight.indexOf(":") ? "ratio" : "fixed"
						}

						function applyDefaultUnit(val)
						{
							return /\D$/.test(val) ? val : val + "px"
						}
					}
				}

				function GridListController($mdUtil)
				{
					this.layoutInvalidated = false;
					this.tilesInvalidated = false;
					this.$timeout_ = $mdUtil.nextTick;
					this.layoutDelegate = angular.noop
				}
				GridListController.prototype = {
					invalidateTiles: function ()
					{
						this.tilesInvalidated = true;
						this.invalidateLayout()
					},
					invalidateLayout: function ()
					{
						if (this.layoutInvalidated) return;
						this.layoutInvalidated = true;
						this.$timeout_(angular.bind(this, this.layout))
					},
					layout: function ()
					{
						try
						{
							this.layoutDelegate(this.tilesInvalidated)
						}
						finally
						{
							this.layoutInvalidated = false;
							this.tilesInvalidated = false
						}
					}
				};

				function GridLayoutFactory($mdUtil)
				{
					var defaultAnimator = GridTileAnimator;
					GridLayout.animateWith = function (customAnimator)
					{
						defaultAnimator = angular.isFunction(customAnimator) ? customAnimator : GridTileAnimator
					};
					return GridLayout;

					function GridLayout(colCount, tileSpans)
					{
						var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;
						layoutTime = $mdUtil.time(function ()
						{
							layoutInfo = calculateGridFor(colCount, tileSpans)
						});
						return self = {
							layoutInfo: function ()
							{
								return layoutInfo
							},
							map: function (updateFn)
							{
								mapTime = $mdUtil.time(function ()
								{
									var info = self.layoutInfo();
									gridStyles = updateFn(info.positioning, info.rowCount)
								});
								return self
							},
							reflow: function (animatorFn)
							{
								reflowTime = $mdUtil.time(function ()
								{
									var animator = animatorFn || defaultAnimator;
									animator(gridStyles.grid, gridStyles.tiles)
								});
								return self
							},
							performance: function ()
							{
								return {
									tileCount: tileSpans.length,
									layoutTime: layoutTime,
									mapTime: mapTime,
									reflowTime: reflowTime,
									totalTime: layoutTime + mapTime + reflowTime
								}
							}
						}
					}

					function GridTileAnimator(grid, tiles)
					{
						grid.element.css(grid.style);
						tiles.forEach(function (t)
						{
							t.element.css(t.style)
						})
					}

					function calculateGridFor(colCount, tileSpans)
					{
						var curCol = 0,
							curRow = 0,
							spaceTracker = newSpaceTracker();
						return {
							positioning: tileSpans.map(function (spans, i)
							{
								return {
									spans: spans,
									position: reserveSpace(spans, i)
								}
							}),
							rowCount: curRow + Math.max.apply(Math, spaceTracker)
						};

						function reserveSpace(spans, i)
						{
							if (spans.col > colCount) throw "md-grid-list: Tile at position " + i + " has a colspan (" + spans.col + ") that exceeds the column count (" + colCount + ")";
							var start = 0,
								end = 0;
							while (end - start < spans.col)
							{
								if (curCol >= colCount)
								{
									nextRow();
									continue
								}
								start = spaceTracker.indexOf(0, curCol);
								if (-1 === start || -1 === (end = findEnd(start + 1)))
								{
									start = end = 0;
									nextRow();
									continue
								}
								curCol = end + 1
							}
							adjustRow(start, spans.col, spans.row);
							curCol = start + spans.col;
							return {
								col: start,
								row: curRow
							}
						}

						function nextRow()
						{
							curCol = 0;
							curRow++;
							adjustRow(0, colCount, -1)
						}

						function adjustRow(from, cols, by)
						{
							for (var i = from; i < from + cols; i++) spaceTracker[i] = Math.max(spaceTracker[i] + by, 0)
						}

						function findEnd(start)
						{
							var i;
							for (i = start; i < spaceTracker.length; i++)
								if (0 !== spaceTracker[i]) return i;
							if (i === spaceTracker.length) return i
						}

						function newSpaceTracker()
						{
							var tracker = [];
							for (var i = 0; i < colCount; i++) tracker.push(0);
							return tracker
						}
					}
				}

				function GridTileDirective($mdMedia)
				{
					return {
						restrict: "E",
						require: "^mdGridList",
						template: "<figure ng-transclude></figure>",
						transclude: true,
						scope:
						{},
						controller: ["$attrs", function ($attrs)
						{
							this.$attrs = $attrs
						}],
						link: postLink
					};

					function postLink(scope, element, attrs, gridCtrl)
					{
						element.attr("role", "listitem");
						var unwatchAttrs = $mdMedia.watchResponsiveAttributes(["md-colspan", "md-rowspan"], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
						gridCtrl.invalidateTiles();
						scope.$on("$destroy", function ()
						{
							element[0].$$mdDestroyed = true;
							unwatchAttrs();
							gridCtrl.invalidateLayout()
						});
						angular.isDefined(scope.$parent.$index) && scope.$watch(function ()
						{
							return scope.$parent.$index
						}, function indexChanged(newIdx, oldIdx)
						{
							if (newIdx === oldIdx) return;
							gridCtrl.invalidateTiles()
						})
					}
				}

				function GridTileCaptionDirective()
				{
					return {
						template: "<figcaption ng-transclude></figcaption>",
						transclude: true
					}
				}
			})();
			void angular.module("material.components.icon", ["material.core"]);
			(function ()
			{
				mdInputContainerDirective.$inject = ["$mdTheming", "$parse"];
				inputTextareaDirective.$inject = ["$mdUtil", "$window", "$mdAria", "$timeout", "$mdGesture"];
				mdMaxlengthDirective.$inject = ["$animate", "$mdUtil"];
				placeholderDirective.$inject = ["$compile"];
				ngMessageDirective.$inject = ["$mdUtil"];
				mdSelectOnFocusDirective.$inject = ["$document", "$timeout"];
				mdInputInvalidMessagesAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil", "$log"];
				ngMessagesAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil", "$log"];
				ngMessageAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil", "$log"];
				var inputModule = angular.module("material.components.input", ["material.core"]).directive("mdInputContainer", mdInputContainerDirective).directive("label", labelDirective).directive("input", inputTextareaDirective).directive("textarea", inputTextareaDirective).directive("mdMaxlength", mdMaxlengthDirective).directive("placeholder", placeholderDirective).directive("ngMessages", ngMessagesDirective).directive("ngMessage", ngMessageDirective).directive("ngMessageExp", ngMessageDirective).directive("mdSelectOnFocus", mdSelectOnFocusDirective).animation(".md-input-invalid", mdInputInvalidMessagesAnimation).animation(".md-input-messages-animation", ngMessagesAnimation).animation(".md-input-message-animation", ngMessageAnimation);
				window._mdMocksIncluded && inputModule.service("$$mdInput", function ()
				{
					return {
						messages:
						{
							show: showInputMessages,
							hide: hideInputMessages,
							getElement: getMessagesElement
						}
					}
				}).service("mdInputInvalidAnimation", mdInputInvalidMessagesAnimation).service("mdInputMessagesAnimation", ngMessagesAnimation).service("mdInputMessageAnimation", ngMessageAnimation);

				function mdInputContainerDirective($mdTheming, $parse)
				{
					ContainerCtrl.$inject = ["$scope", "$element", "$attrs", "$animate"];
					var INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT", "MD-SELECT"];
					var LEFT_SELECTORS = INPUT_TAGS.reduce(function (selectors, isel)
					{
						return selectors.concat(["md-icon ~ " + isel, ".md-icon ~ " + isel])
					}, []).join(",");
					var RIGHT_SELECTORS = INPUT_TAGS.reduce(function (selectors, isel)
					{
						return selectors.concat([isel + " ~ md-icon", isel + " ~ .md-icon"])
					}, []).join(",");
					return {
						restrict: "E",
						compile: compile,
						controller: ContainerCtrl
					};

					function compile(tElement)
					{
						var leftIcon = tElement[0].querySelector(LEFT_SELECTORS);
						var rightIcon = tElement[0].querySelector(RIGHT_SELECTORS);
						leftIcon && tElement.addClass("md-icon-left");
						rightIcon && tElement.addClass("md-icon-right");
						return function postLink(scope, element)
						{
							$mdTheming(element)
						}
					}

					function ContainerCtrl($scope, $element, $attrs, $animate)
					{
						var self = this;
						self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);
						self.delegateClick = function ()
						{
							self.input.focus()
						};
						self.element = $element;
						self.setFocused = function (isFocused)
						{
							$element.toggleClass("md-input-focused", !!isFocused)
						};
						self.setHasValue = function (hasValue)
						{
							$element.toggleClass("md-input-has-value", !!hasValue)
						};
						self.setHasPlaceholder = function (hasPlaceholder)
						{
							$element.toggleClass("md-input-has-placeholder", !!hasPlaceholder)
						};
						self.setInvalid = function (isInvalid)
						{
							isInvalid ? $animate.addClass($element, "md-input-invalid") : $animate.removeClass($element, "md-input-invalid")
						};
						$scope.$watch(function ()
						{
							return self.label && self.input
						}, function (hasLabelAndInput)
						{
							hasLabelAndInput && !self.label.attr("for") && self.label.attr("for", self.input.attr("id"))
						})
					}
				}

				function labelDirective()
				{
					return {
						restrict: "E",
						require: "^?mdInputContainer",
						link: function (scope, element, attr, containerCtrl)
						{
							if (!containerCtrl || attr.mdNoFloat || element.hasClass("md-container-ignore")) return;
							containerCtrl.label = element;
							scope.$on("$destroy", function ()
							{
								containerCtrl.label = null
							})
						}
					}
				}

				function inputTextareaDirective($mdUtil, $window, $mdAria, $timeout, $mdGesture)
				{
					return {
						restrict: "E",
						require: ["^?mdInputContainer", "?ngModel", "?^form"],
						link: postLink
					};

					function postLink(scope, element, attr, ctrls)
					{
						var containerCtrl = ctrls[0];
						var hasNgModel = !!ctrls[1];
						var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
						var parentForm = ctrls[2];
						var isReadonly = angular.isDefined(attr.readonly);
						var mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);
						var tagName = element[0].tagName.toLowerCase();
						if (!containerCtrl) return;
						if ("hidden" === attr.type)
						{
							element.attr("aria-hidden", "true");
							return
						}
						if (containerCtrl.input)
						{
							if (containerCtrl.input[0].contains(element[0])) return;
							throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!")
						}
						containerCtrl.input = element;
						setupAttributeWatchers();
						var errorsSpacer = angular.element('<div class="md-errors-spacer">');
						element.after(errorsSpacer);
						var placeholderText = angular.isString(attr.placeholder) ? attr.placeholder.trim() : "";
						containerCtrl.label || placeholderText.length || $mdAria.expect(element, "aria-label");
						element.addClass("md-input");
						element.attr("id") || element.attr("id", "input_" + $mdUtil.nextUid());
						"input" === tagName && "number" === attr.type && attr.min && attr.max && !attr.step ? element.attr("step", "any") : "textarea" === tagName && setupTextarea();
						hasNgModel || inputCheckValue();
						var isErrorGetter = containerCtrl.isErrorGetter || function ()
						{
							return ngModelCtrl.$invalid && (ngModelCtrl.$touched || parentForm && parentForm.$submitted)
						};
						scope.$watch(isErrorGetter, containerCtrl.setInvalid);
						attr.ngValue && attr.$observe("value", inputCheckValue);
						ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
						ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);
						element.on("input", inputCheckValue);
						isReadonly || element.on("focus", function (ev)
						{
							$mdUtil.nextTick(function ()
							{
								containerCtrl.setFocused(true)
							})
						}).on("blur", function (ev)
						{
							$mdUtil.nextTick(function ()
							{
								containerCtrl.setFocused(false);
								inputCheckValue()
							})
						});
						scope.$on("$destroy", function ()
						{
							containerCtrl.setFocused(false);
							containerCtrl.setHasValue(false);
							containerCtrl.input = null
						});

						function ngModelPipelineCheckValue(arg)
						{
							containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
							return arg
						}

						function setupAttributeWatchers()
						{
							containerCtrl.label && attr.$observe("required", function (value)
							{
								containerCtrl.label.toggleClass("md-required", value && !mdNoAsterisk)
							})
						}

						function inputCheckValue()
						{
							containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity ||
							{}).badInput)
						}

						function setupTextarea()
						{
							var isAutogrowing = !attr.hasOwnProperty("mdNoAutogrow");
							attachResizeHandle();
							if (!isAutogrowing) return;
							var minRows = attr.hasOwnProperty("rows") ? parseInt(attr.rows) : NaN;
							var maxRows = attr.hasOwnProperty("maxRows") ? parseInt(attr.maxRows) : NaN;
							var scopeResizeListener = scope.$on("md-resize-textarea", growTextarea);
							var lineHeight = null;
							var node = element[0];
							$timeout(function ()
							{
								$mdUtil.nextTick(growTextarea)
							}, 10, false);
							element.on("input", growTextarea);
							hasNgModel && ngModelCtrl.$formatters.push(formattersListener);
							minRows || element.attr("rows", 1);
							angular.element($window).on("resize", growTextarea);
							scope.$on("$destroy", disableAutogrow);

							function growTextarea()
							{
								element.attr("rows", 1).css("height", "auto").addClass("md-no-flex");
								var height = getHeight();
								if (!lineHeight)
								{
									var originalPadding = element[0].style.padding || "";
									lineHeight = element.css("padding", 0).prop("offsetHeight");
									element[0].style.padding = originalPadding
								}
								minRows && lineHeight && (height = Math.max(height, lineHeight * minRows));
								if (maxRows && lineHeight)
								{
									var maxHeight = lineHeight * maxRows;
									if (maxHeight < height)
									{
										element.attr("md-no-autogrow", "");
										height = maxHeight
									}
									else element.removeAttr("md-no-autogrow")
								}
								lineHeight && element.attr("rows", Math.round(height / lineHeight));
								element.css("height", height + "px").removeClass("md-no-flex")
							}

							function getHeight()
							{
								var offsetHeight = node.offsetHeight;
								var line = node.scrollHeight - offsetHeight;
								return offsetHeight + Math.max(line, 0)
							}

							function formattersListener(value)
							{
								$mdUtil.nextTick(growTextarea);
								return value
							}

							function disableAutogrow()
							{
								if (!isAutogrowing) return;
								isAutogrowing = false;
								angular.element($window).off("resize", growTextarea);
								scopeResizeListener && scopeResizeListener();
								element.attr("md-no-autogrow", "").off("input", growTextarea);
								if (hasNgModel)
								{
									var listenerIndex = ngModelCtrl.$formatters.indexOf(formattersListener);
									listenerIndex > -1 && ngModelCtrl.$formatters.splice(listenerIndex, 1)
								}
							}

							function attachResizeHandle()
							{
								if (attr.hasOwnProperty("mdNoResize")) return;
								var handle = angular.element('<div class="md-resize-handle"></div>');
								var isDragging = false;
								var startHeight = 0;
								var container = containerCtrl.element;
								var dragGestureHandler = $mdGesture.register(handle, "drag",
								{
									horizontal: false
								});
								element.wrap('<div class="md-resize-wrapper">').after(handle);
								handle.on("mousedown", onMouseDown);
								container.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
								scope.$on("$destroy", function ()
								{
									handle.off("mousedown", onMouseDown).remove();
									container.off("$md.dragstart", onDragStart).off("$md.drag", onDrag).off("$md.dragend", onDragEnd);
									dragGestureHandler();
									handle = null;
									container = null;
									dragGestureHandler = null
								});

								function onMouseDown(ev)
								{
									ev.preventDefault();
									isDragging = true;
									ev.clientY;
									startHeight = parseFloat(element.css("height")) || element.prop("offsetHeight")
								}

								function onDragStart(ev)
								{
									if (!isDragging) return;
									ev.preventDefault();
									disableAutogrow();
									container.addClass("md-input-resized")
								}

								function onDrag(ev)
								{
									if (!isDragging) return;
									element.css("height", startHeight + ev.pointer.distanceY + "px")
								}

								function onDragEnd(ev)
								{
									if (!isDragging) return;
									isDragging = false;
									container.removeClass("md-input-resized")
								}
							}
							if (attr.hasOwnProperty("mdDetectHidden"))
							{
								var handleHiddenChange = (wasHidden = false, function ()
								{
									var isHidden = 0 === node.offsetHeight;
									false === isHidden && true === wasHidden && growTextarea();
									wasHidden = isHidden
								});
								scope.$watch(function ()
								{
									$mdUtil.nextTick(handleHiddenChange, false);
									return true
								})
							}
							var wasHidden
						}
					}
				}

				function mdMaxlengthDirective($animate, $mdUtil)
				{
					return {
						restrict: "A",
						require: ["ngModel", "^mdInputContainer"],
						link: postLink
					};

					function postLink(scope, element, attr, ctrls)
					{
						var maxlength = parseInt(attr.mdMaxlength);
						isNaN(maxlength) && (maxlength = -1);
						var ngModelCtrl = ctrls[0];
						var containerCtrl = ctrls[1];
						var charCountEl, errorsSpacer;
						var ngTrim = !angular.isDefined(attr.ngTrim) || $mdUtil.parseAttributeBoolean(attr.ngTrim);
						var isPasswordInput = "password" === attr.type;
						ngModelCtrl.$validators["md-maxlength"] = function (modelValue, viewValue)
						{
							if (!angular.isNumber(maxlength) || maxlength < 0) return true;
							renderCharCount();
							var elementVal = element.val() || viewValue;
							elementVal !== undefined && null !== elementVal || (elementVal = "");
							elementVal = ngTrim && !isPasswordInput && angular.isString(elementVal) ? elementVal.trim() : elementVal;
							return String(elementVal).length <= maxlength
						};
						ngModelCtrl.$isEmpty = function (value)
						{
							return 0 === calculateInputValueLength(value)
						};
						$mdUtil.nextTick(function ()
						{
							errorsSpacer = angular.element(containerCtrl.element[0].querySelector(".md-errors-spacer"));
							charCountEl = angular.element('<div class="md-char-counter">');
							errorsSpacer.append(charCountEl);
							attr.$observe("ngTrim", function (value)
							{
								ngTrim = !angular.isDefined(value) || $mdUtil.parseAttributeBoolean(value)
							});
							scope.$watch(attr.mdMaxlength, function (value)
							{
								maxlength = value;
								if (angular.isNumber(value) && value > 0)
								{
									charCountEl.parent().length || $animate.enter(charCountEl, errorsSpacer);
									renderCharCount()
								}
								else $animate.leave(charCountEl)
							})
						});

						function calculateInputValueLength(value)
						{
							value = ngTrim && !isPasswordInput && angular.isString(value) ? value.trim() : value;
							value !== undefined && null !== value || (value = "");
							return String(value).length
						}

						function renderCharCount()
						{
							if (!charCountEl || !charCountEl.parent()) return;
							charCountEl.text(calculateInputValueLength(element.val()) + " / " + maxlength)
						}
					}
				}

				function placeholderDirective($compile)
				{
					return {
						restrict: "A",
						require: "^^?mdInputContainer",
						priority: 200,
						link:
						{
							pre: preLink
						}
					};

					function preLink(scope, element, attr, inputContainer)
					{
						if (!inputContainer) return;
						var label = inputContainer.element.find("label");
						var noFloat = inputContainer.element.attr("md-no-float");
						if (label && label.length || "" === noFloat || scope.$eval(noFloat))
						{
							inputContainer.setHasPlaceholder(true);
							return
						}
						if ("MD-SELECT" != element[0].nodeName)
						{
							var newLabel = angular.element('<label ng-click="delegateClick()" tabindex="-1">' + attr.placeholder + "</label>");
							attr.$set("placeholder", null);
							inputContainer.element.addClass("md-icon-float").prepend(newLabel);
							$compile(newLabel)(scope)
						}
					}
				}

				function mdSelectOnFocusDirective($document, $timeout)
				{
					return {
						restrict: "A",
						link: postLink
					};

					function postLink(scope, element, attr)
					{
						if ("INPUT" !== element[0].nodeName && "TEXTAREA" !== element[0].nodeName) return;
						var preventMouseUp = false;
						element.on("focus", onFocus).on("mouseup", onMouseUp);
						scope.$on("$destroy", function ()
						{
							element.off("focus", onFocus).off("mouseup", onMouseUp)
						});

						function onFocus()
						{
							preventMouseUp = true;
							$timeout(function ()
							{
								$document[0].activeElement === element[0] && element[0].select();
								preventMouseUp = false
							}, 1, false)
						}

						function onMouseUp(event)
						{
							preventMouseUp && event.preventDefault()
						}
					}
				}
				var visibilityDirectives = ["ngIf", "ngShow", "ngHide", "ngSwitchWhen", "ngSwitchDefault"];

				function ngMessagesDirective()
				{
					return {
						restrict: "EA",
						link: postLink,
						require: "^^?mdInputContainer"
					};

					function postLink(scope, element, attrs, inputContainer)
					{
						if (!inputContainer) return;
						element.toggleClass("md-input-messages-animation", true);
						element.toggleClass("md-auto-hide", true);
						("false" == attrs.mdAutoHide || hasVisibiltyDirective(attrs)) && element.toggleClass("md-auto-hide", false)
					}

					function hasVisibiltyDirective(attrs)
					{
						return visibilityDirectives.some(function (attr)
						{
							return attrs[attr]
						})
					}
				}

				function ngMessageDirective($mdUtil)
				{
					return {
						restrict: "EA",
						compile: compile,
						priority: 100
					};

					function compile(tElement)
					{
						if (isInsideInputContainer(tElement)) initMessageElement(tElement);
						else if (isInsideFragment()) return function (scope, element)
						{
							isInsideInputContainer(element) && initMessageElement(tElement)
						};

						function isInsideFragment()
						{
							var nextNode = tElement[0];
							while (nextNode = nextNode.parentNode)
								if (nextNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return true;
							return false
						}

						function isInsideInputContainer(element)
						{
							return !!$mdUtil.getClosest(element, "md-input-container")
						}

						function initMessageElement(element)
						{
							element.toggleClass("md-input-message-animation", true)
						}
					}
				}
				var $$AnimateRunner, $animateCss, $mdUtil, $log;

				function mdInputInvalidMessagesAnimation($$AnimateRunner, $animateCss, $mdUtil, $log)
				{
					saveSharedServices($$AnimateRunner, $animateCss, $mdUtil, $log);
					return {
						addClass: function (element, className, done)
						{
							showInputMessages(element, done)
						}
					}
				}

				function ngMessagesAnimation($$AnimateRunner, $animateCss, $mdUtil, $log)
				{
					saveSharedServices($$AnimateRunner, $animateCss, $mdUtil, $log);
					return {
						enter: function (element, done)
						{
							showInputMessages(element, done)
						},
						leave: function (element, done)
						{
							hideInputMessages(element, done)
						},
						addClass: function (element, className, done)
						{
							"ng-hide" == className ? hideInputMessages(element, done) : done()
						},
						removeClass: function (element, className, done)
						{
							"ng-hide" == className ? showInputMessages(element, done) : done()
						}
					}
				}

				function ngMessageAnimation($$AnimateRunner, $animateCss, $mdUtil, $log)
				{
					saveSharedServices($$AnimateRunner, $animateCss, $mdUtil, $log);
					return {
						enter: function (element, done)
						{
							var animator = showMessage(element);
							animator.start().done(done)
						},
						leave: function (element, done)
						{
							var animator = hideMessage(element);
							animator.start().done(done)
						}
					}
				}

				function showInputMessages(element, done)
				{
					var animator, animators = [];
					var messages = getMessagesElement(element);
					var children = messages.children();
					if (0 == messages.length || 0 == children.length)
					{
						$log.warn("mdInput messages show animation called on invalid messages element: ", element);
						done();
						return
					}
					angular.forEach(children, function (child)
					{
						animator = showMessage(angular.element(child));
						animators.push(animator.start())
					});
					$$AnimateRunner.all(animators, done)
				}

				function hideInputMessages(element, done)
				{
					var animator, animators = [];
					var messages = getMessagesElement(element);
					var children = messages.children();
					if (0 == messages.length || 0 == children.length)
					{
						$log.warn("mdInput messages hide animation called on invalid messages element: ", element);
						done();
						return
					}
					angular.forEach(children, function (child)
					{
						animator = hideMessage(angular.element(child));
						animators.push(animator.start())
					});
					$$AnimateRunner.all(animators, done)
				}

				function showMessage(element)
				{
					var height = parseInt(window.getComputedStyle(element[0]).height);
					var topMargin = parseInt(window.getComputedStyle(element[0]).marginTop);
					var messages = getMessagesElement(element);
					var container = getInputElement(element);
					var alreadyVisible = topMargin > -height;
					if (alreadyVisible || messages.hasClass("md-auto-hide") && !container.hasClass("md-input-invalid")) return $animateCss(element,
					{});
					return $animateCss(element,
					{
						event: "enter",
						structural: true,
						from:
						{
							opacity: 0,
							"margin-top": -height + "px"
						},
						to:
						{
							opacity: 1,
							"margin-top": "0"
						},
						duration: .3
					})
				}

				function hideMessage(element)
				{
					var height = element[0].offsetHeight;
					var styles = window.getComputedStyle(element[0]);
					if (0 === parseInt(styles.opacity)) return $animateCss(element,
					{});
					return $animateCss(element,
					{
						event: "leave",
						structural: true,
						from:
						{
							opacity: 1,
							"margin-top": 0
						},
						to:
						{
							opacity: 0,
							"margin-top": -height + "px"
						},
						duration: .3
					})
				}

				function getInputElement(element)
				{
					var inputContainer = element.controller("mdInputContainer");
					return inputContainer.element
				}

				function getMessagesElement(element)
				{
					if (element.hasClass("md-input-messages-animation")) return element;
					if (element.hasClass("md-input-message-animation")) return angular.element($mdUtil.getClosest(element, function (node)
					{
						return node.classList.contains("md-input-messages-animation")
					}));
					return angular.element(element[0].querySelector(".md-input-messages-animation"))
				}

				function saveSharedServices(_$$AnimateRunner_, _$animateCss_, _$mdUtil_, _$log_)
				{
					$$AnimateRunner = _$$AnimateRunner_;
					$animateCss = _$animateCss_;
					$mdUtil = _$mdUtil_;
					$log = _$log_
				}
			})();
			(function ()
			{
				MdListController.$inject = ["$scope", "$element", "$mdListInkRipple"];
				mdListDirective.$inject = ["$mdTheming"];
				mdListItemDirective.$inject = ["$mdAria", "$mdConstant", "$mdUtil", "$timeout"];
				angular.module("material.components.list", ["material.core"]).controller("MdListController", MdListController).directive("mdList", mdListDirective).directive("mdListItem", mdListItemDirective);

				function mdListDirective($mdTheming)
				{
					return {
						restrict: "E",
						compile: function (tEl)
						{
							tEl[0].setAttribute("role", "list");
							return $mdTheming
						}
					}
				}

				function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout)
				{
					var proxiedTypes = ["md-checkbox", "md-switch", "md-menu"];
					return {
						restrict: "E",
						controller: "MdListController",
						compile: function (tEl, tAttrs)
						{
							var secondaryItems = tEl[0].querySelectorAll(".md-secondary");
							var hasProxiedElement;
							var proxyElement;
							var itemContainer = tEl;
							tEl[0].setAttribute("role", "listitem");
							if (tAttrs.ngClick || tAttrs.ngDblclick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) wrapIn("button");
							else if (!tEl.hasClass("md-no-proxy"))
							{
								for (var type, i = 0; type = proxiedTypes[i]; ++i)
									if (proxyElement = tEl[0].querySelector(type))
									{
										hasProxiedElement = true;
										break
									}
								hasProxiedElement ? wrapIn("div") : tEl.addClass("md-no-proxy")
							}
							wrapSecondaryItems();
							setupToggleAria();
							hasProxiedElement && "MD-MENU" === proxyElement.nodeName && setupProxiedMenu();

							function setupToggleAria()
							{
								var toggleTypes = ["md-switch", "md-checkbox"];
								var toggle;
								for (var toggleType, i = 0; toggleType = toggleTypes[i]; ++i)
									if ((toggle = tEl.find(toggleType)[0]) && !toggle.hasAttribute("aria-label"))
									{
										var p = tEl.find("p")[0];
										if (!p) return;
										toggle.setAttribute("aria-label", "Toggle " + p.textContent)
									}
							}

							function setupProxiedMenu()
							{
								var menuEl = angular.element(proxyElement);
								var isEndAligned = menuEl.parent().hasClass("md-secondary-container") || proxyElement.parentNode.firstElementChild !== proxyElement;
								var xAxisPosition = "left";
								isEndAligned && (xAxisPosition = "right");
								menuEl.attr("md-position-mode") || menuEl.attr("md-position-mode", xAxisPosition + " target");
								var menuOpenButton = menuEl.children().eq(0);
								hasClickEvent(menuOpenButton[0]) || menuOpenButton.attr("ng-click", "$mdMenu.open($event)");
								menuOpenButton.attr("aria-label") || menuOpenButton.attr("aria-label", "Open List Menu")
							}

							function wrapIn(type)
							{
								if ("div" == type)
								{
									itemContainer = angular.element('<div class="md-no-style md-list-item-inner">');
									itemContainer.append(tEl.contents());
									tEl.addClass("md-proxy-focus")
								}
								else
								{
									itemContainer = angular.element('<div class="md-button md-no-style">   <div class="md-list-item-inner"></div></div>');
									var buttonWrap = angular.element('<md-button class="md-no-style"></md-button>');
									copyAttributes(tEl[0], buttonWrap[0]);
									buttonWrap.attr("aria-label") || buttonWrap.attr("aria-label", $mdAria.getText(tEl));
									tEl.hasClass("md-no-focus") && buttonWrap.addClass("md-no-focus");
									itemContainer.prepend(buttonWrap);
									itemContainer.children().eq(1).append(tEl.contents());
									tEl.addClass("_md-button-wrap")
								}
								tEl[0].setAttribute("tabindex", "-1");
								tEl.append(itemContainer)
							}

							function wrapSecondaryItems()
							{
								var secondaryItemsWrapper = angular.element('<div class="md-secondary-container">');
								angular.forEach(secondaryItems, function (secondaryItem)
								{
									wrapSecondaryItem(secondaryItem, secondaryItemsWrapper)
								});
								itemContainer.append(secondaryItemsWrapper)
							}

							function wrapSecondaryItem(secondaryItem, container)
							{
								if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute("ng-click"))
								{
									$mdAria.expect(secondaryItem, "aria-label");
									var buttonWrapper = angular.element('<md-button class="md-secondary md-icon-button">');
									copyAttributes(secondaryItem, buttonWrapper[0], ["ng-if", "ng-hide", "ng-show"]);
									secondaryItem.setAttribute("tabindex", "-1");
									buttonWrapper.append(secondaryItem);
									secondaryItem = buttonWrapper[0]
								}
								secondaryItem && (!hasClickEvent(secondaryItem) || !tAttrs.ngClick && isProxiedElement(secondaryItem)) && angular.element(secondaryItem).removeClass("md-secondary");
								tEl.addClass("md-with-secondary");
								container.append(secondaryItem)
							}

							function copyAttributes(source, destination, extraAttrs)
							{
								var copiedAttrs = $mdUtil.prefixer(["ng-if", "ng-click", "ng-dblclick", "aria-label", "ng-disabled", "ui-sref", "href", "ng-href", "rel", "target", "ng-attr-ui-sref", "ui-sref-opts", "download"]);
								extraAttrs && (copiedAttrs = copiedAttrs.concat($mdUtil.prefixer(extraAttrs)));
								angular.forEach(copiedAttrs, function (attr)
								{
									if (source.hasAttribute(attr))
									{
										destination.setAttribute(attr, source.getAttribute(attr));
										source.removeAttribute(attr)
									}
								})
							}

							function isProxiedElement(el)
							{
								return -1 != proxiedTypes.indexOf(el.nodeName.toLowerCase())
							}

							function isButton(el)
							{
								var nodeName = el.nodeName.toUpperCase();
								return "MD-BUTTON" == nodeName || "BUTTON" == nodeName
							}

							function hasClickEvent(element)
							{
								var attr = element.attributes;
								for (var i = 0; i < attr.length; i++)
									if ("ngClick" === tAttrs.$normalize(attr[i].name)) return true;
								return false
							}
							return postLink;

							function postLink($scope, $element, $attr, ctrl)
							{
								$element.addClass("_md");
								var proxies = [],
									firstElement = $element[0].firstElementChild,
									isButtonWrap = $element.hasClass("_md-button-wrap"),
									clickChild = isButtonWrap ? firstElement.firstElementChild : firstElement,
									hasClick = clickChild && hasClickEvent(clickChild),
									noProxies = $element.hasClass("md-no-proxy");
								computeProxies();
								computeClickable();
								proxies.length && angular.forEach(proxies, function (proxy)
								{
									proxy = angular.element(proxy);
									$scope.mouseActive = false;
									proxy.on("mousedown", function ()
									{
										$scope.mouseActive = true;
										$timeout(function ()
										{
											$scope.mouseActive = false
										}, 100)
									}).on("focus", function ()
									{
										false === $scope.mouseActive && $element.addClass("md-focused");
										proxy.on("blur", function proxyOnBlur()
										{
											$element.removeClass("md-focused");
											proxy.off("blur", proxyOnBlur)
										})
									})
								});

								function computeProxies()
								{
									firstElement && firstElement.children && !hasClick && !noProxies && angular.forEach(proxiedTypes, function (type)
									{
										angular.forEach(firstElement.querySelectorAll(type + ":not(.md-secondary)"), function (child)
										{
											proxies.push(child)
										})
									})
								}

								function computeClickable()
								{
									if (1 == proxies.length || hasClick)
									{
										$element.addClass("md-clickable");
										hasClick || ctrl.attachRipple($scope, angular.element($element[0].querySelector(".md-no-style")))
									}
								}

								function isEventFromControl(event)
								{
									var forbiddenControls = ["md-slider"];
									if (!event.path) return -1 !== forbiddenControls.indexOf(event.target.tagName.toLowerCase());
									var maxPath = event.path.indexOf($element.children()[0]);
									for (var i = 0; i < maxPath; i++)
										if (-1 !== forbiddenControls.indexOf(event.path[i].tagName.toLowerCase())) return true
								}
								var clickChildKeypressListener = function (e)
								{
									if ("INPUT" != e.target.nodeName && "TEXTAREA" != e.target.nodeName && !e.target.isContentEditable)
									{
										var keyCode = e.which || e.keyCode;
										if (keyCode == $mdConstant.KEY_CODE.SPACE && clickChild)
										{
											clickChild.click();
											e.preventDefault();
											e.stopPropagation()
										}
									}
								};
								hasClick || proxies.length || clickChild && clickChild.addEventListener("keypress", clickChildKeypressListener);
								$element.off("click");
								$element.off("keypress");
								1 == proxies.length && clickChild && $element.children().eq(0).on("click", function (e)
								{
									if (isEventFromControl(e)) return;
									var parentButton = $mdUtil.getClosest(e.target, "BUTTON");
									!parentButton && clickChild.contains(e.target) && angular.forEach(proxies, function (proxy)
									{
										if (e.target !== proxy && !proxy.contains(e.target))
										{
											"MD-MENU" === proxy.nodeName && (proxy = proxy.children[0]);
											angular.element(proxy).triggerHandler("click")
										}
									})
								});
								$scope.$on("$destroy", function ()
								{
									clickChild && clickChild.removeEventListener("keypress", clickChildKeypressListener)
								})
							}
						}
					}
				}

				function MdListController($scope, $element, $mdListInkRipple)
				{
					var ctrl = this;
					ctrl.attachRipple = attachRipple;

					function attachRipple(scope, element)
					{
						var options = {};
						$mdListInkRipple.attach(scope, element, options)
					}
				}
			})();
			void angular.module("material.components.menu", ["material.core", "material.components.backdrop"]);
			void angular.module("material.components.menuBar", ["material.core", "material.components.icon", "material.components.menu"]);
			(function ()
			{
				MdNavBarController.$inject = ["$element", "$scope", "$timeout", "$mdConstant"];
				MdNavItem.$inject = ["$mdAria", "$$rAF", "$mdUtil", "$window"];
				MdNavItemController.$inject = ["$element"];
				MdNavBar.$inject = ["$mdAria", "$mdTheming"];
				angular.module("material.components.navBar", ["material.core"]).controller("MdNavBarController", MdNavBarController).directive("mdNavBar", MdNavBar).controller("MdNavItemController", MdNavItemController).directive("mdNavItem", MdNavItem);

				function MdNavBar($mdAria, $mdTheming)
				{
					return {
						restrict: "E",
						transclude: true,
						controller: MdNavBarController,
						controllerAs: "ctrl",
						bindToController: true,
						scope:
						{
							mdSelectedNavItem: "=?",
							mdNoInkBar: "=?",
							navBarAriaLabel: "@?"
						},
						template: '<div class="md-nav-bar"><nav role="navigation"><ul class="_md-nav-bar-list" ng-transclude role="listbox" tabindex="0" ng-focus="ctrl.onFocus()" ng-keydown="ctrl.onKeydown($event)" aria-label="{{ctrl.navBarAriaLabel}}"></ul></nav><md-nav-ink-bar ng-hide="ctrl.mdNoInkBar"></md-nav-ink-bar></div>',
						link: function (scope, element, attrs, ctrl)
						{
							$mdTheming(element);
							ctrl.navBarAriaLabel || $mdAria.expectAsync(element, "aria-label", angular.noop)
						}
					}
				}

				function MdNavBarController($element, $scope, $timeout, $mdConstant)
				{
					this._$timeout = $timeout;
					this._$scope = $scope;
					this._$mdConstant = $mdConstant;
					this.mdSelectedNavItem;
					this.navBarAriaLabel;
					this._navBarEl = $element[0];
					this._inkbar;
					var self = this;
					var deregisterTabWatch = this._$scope.$watch(function ()
					{
						return self._navBarEl.querySelectorAll("._md-nav-button").length
					}, function (newLength)
					{
						if (newLength > 0)
						{
							self._initTabs();
							deregisterTabWatch()
						}
					})
				}
				MdNavBarController.prototype._initTabs = function ()
				{
					this._inkbar = angular.element(this._navBarEl.querySelector("md-nav-ink-bar"));
					var self = this;
					this._$timeout(function ()
					{
						self._updateTabs(self.mdSelectedNavItem, undefined)
					});
					this._$scope.$watch("ctrl.mdSelectedNavItem", function (newValue, oldValue)
					{
						self._$timeout(function ()
						{
							self._updateTabs(newValue, oldValue)
						})
					})
				};
				MdNavBarController.prototype._updateTabs = function (newValue, oldValue)
				{
					var self = this;
					var tabs = this._getTabs();
					if (!tabs) return;
					var oldIndex = -1;
					var newIndex = -1;
					var newTab = this._getTabByName(newValue);
					var oldTab = this._getTabByName(oldValue);
					if (oldTab)
					{
						oldTab.setSelected(false);
						oldIndex = tabs.indexOf(oldTab)
					}
					if (newTab)
					{
						newTab.setSelected(true);
						newIndex = tabs.indexOf(newTab)
					}
					this._$timeout(function ()
					{
						self._updateInkBarStyles(newTab, newIndex, oldIndex)
					})
				};
				MdNavBarController.prototype._updateInkBarStyles = function (tab, newIndex, oldIndex)
				{
					this._inkbar.toggleClass("_md-left", newIndex < oldIndex).toggleClass("_md-right", newIndex > oldIndex);
					this._inkbar.css(
					{
						display: newIndex < 0 ? "none" : ""
					});
					if (tab)
					{
						var tabEl = tab.getButtonEl();
						var left = tabEl.offsetLeft;
						this._inkbar.css(
						{
							left: left + "px",
							width: tabEl.offsetWidth + "px"
						})
					}
				};
				MdNavBarController.prototype._getTabs = function ()
				{
					var controllers = Array.prototype.slice.call(this._navBarEl.querySelectorAll(".md-nav-item")).map(function (el)
					{
						return angular.element(el).controller("mdNavItem")
					});
					return controllers.indexOf(undefined) ? controllers : null
				};
				MdNavBarController.prototype._getTabByName = function (name)
				{
					return this._findTab(function (tab)
					{
						return tab.getName() == name
					})
				};
				MdNavBarController.prototype._getSelectedTab = function ()
				{
					return this._findTab(function (tab)
					{
						return tab.isSelected()
					})
				};
				MdNavBarController.prototype.getFocusedTab = function ()
				{
					return this._findTab(function (tab)
					{
						return tab.hasFocus()
					})
				};
				MdNavBarController.prototype._findTab = function (fn)
				{
					var tabs = this._getTabs();
					for (var i = 0; i < tabs.length; i++)
						if (fn(tabs[i])) return tabs[i];
					return null
				};
				MdNavBarController.prototype.onFocus = function ()
				{
					var tab = this._getSelectedTab();
					tab && tab.setFocused(true)
				};
				MdNavBarController.prototype._moveFocus = function (oldTab, newTab)
				{
					oldTab.setFocused(false);
					newTab.setFocused(true)
				};
				MdNavBarController.prototype.onKeydown = function (e)
				{
					var keyCodes = this._$mdConstant.KEY_CODE;
					var tabs = this._getTabs();
					var focusedTab = this.getFocusedTab();
					if (!focusedTab) return;
					var focusedTabIndex = tabs.indexOf(focusedTab);
					switch (e.keyCode)
					{
					case keyCodes.UP_ARROW:
					case keyCodes.LEFT_ARROW:
						focusedTabIndex > 0 && this._moveFocus(focusedTab, tabs[focusedTabIndex - 1]);
						break;
					case keyCodes.DOWN_ARROW:
					case keyCodes.RIGHT_ARROW:
						focusedTabIndex < tabs.length - 1 && this._moveFocus(focusedTab, tabs[focusedTabIndex + 1]);
						break;
					case keyCodes.SPACE:
					case keyCodes.ENTER:
						this._$timeout(function ()
						{
							focusedTab.getButtonEl().click()
						})
					}
				};

				function MdNavItem($mdAria, $$rAF, $mdUtil, $window)
				{
					return {
						restrict: "E",
						require: ["mdNavItem", "^mdNavBar"],
						controller: MdNavItemController,
						bindToController: true,
						controllerAs: "ctrl",
						replace: true,
						transclude: true,
						template: function (tElement, tAttrs)
						{
							var hasNavClick = tAttrs.mdNavClick;
							var hasNavHref = tAttrs.mdNavHref;
							var hasNavSref = tAttrs.mdNavSref;
							var hasSrefOpts = tAttrs.srefOpts;
							var navigationAttribute;
							var navigationOptions;
							var buttonTemplate;
							if ((hasNavClick ? 1 : 0) + (hasNavHref ? 1 : 0) + (hasNavSref ? 1 : 0) > 1) throw Error("Must not specify more than one of the md-nav-click, md-nav-href, or md-nav-sref attributes per nav-item directive.");
							hasNavClick ? navigationAttribute = 'ng-click="ctrl.mdNavClick()"' : hasNavHref ? navigationAttribute = 'ng-href="{{ctrl.mdNavHref}}"' : hasNavSref && (navigationAttribute = 'ui-sref="{{ctrl.mdNavSref}}"');
							navigationOptions = hasSrefOpts ? 'ui-sref-opts="{{ctrl.srefOpts}}" ' : "";
							navigationAttribute && (buttonTemplate = '<md-button class="_md-nav-button md-accent" ng-class="ctrl.getNgClassMap()" ng-blur="ctrl.setFocused(false)" ng-disabled="ctrl.disabled" tabindex="-1" ' + navigationOptions + navigationAttribute + '><span ng-transclude class="_md-nav-button-text"></span></md-button>');
							return '<li class="md-nav-item" role="option" aria-selected="{{ctrl.isSelected()}}">' + (buttonTemplate || "") + "</li>"
						},
						scope:
						{
							mdNavClick: "&?",
							mdNavHref: "@?",
							mdNavSref: "@?",
							srefOpts: "=?",
							name: "@"
						},
						link: function (scope, element, attrs, controllers)
						{
							var disconnect;
							$$rAF(function ()
							{
								var mdNavItem = controllers[0];
								var mdNavBar = controllers[1];
								var navButton = angular.element(element[0].querySelector("._md-nav-button"));
								mdNavItem.name || (mdNavItem.name = angular.element(element[0].querySelector("._md-nav-button-text")).text().trim());
								navButton.on("click", function ()
								{
									mdNavBar.mdSelectedNavItem = mdNavItem.name;
									scope.$apply()
								});
								mdNavItem.disabled = $mdUtil.parseAttributeBoolean(attrs["disabled"], false);
								if ("MutationObserver" in $window)
								{
									var config = {
										attributes: true,
										attributeFilter: ["disabled"]
									};
									var targetNode = element[0];
									var mutationCallback = function (mutationList)
									{
										$mdUtil.nextTick(function ()
										{
											mdNavItem.disabled = $mdUtil.parseAttributeBoolean(attrs[mutationList[0].attributeName], false)
										})
									};
									var observer = new MutationObserver(mutationCallback);
									observer.observe(targetNode, config);
									disconnect = observer.disconnect.bind(observer)
								}
								else attrs.$observe("disabled", function (value)
								{
									mdNavItem.disabled = $mdUtil.parseAttributeBoolean(value, false)
								});
								$mdAria.expectWithText(element, "aria-label")
							});
							scope.$on("destroy", function ()
							{
								disconnect()
							})
						}
					}
				}

				function MdNavItemController($element)
				{
					this._$element = $element;
					this.mdNavClick;
					this.mdNavHref;
					this.mdNavSref;
					this.srefOpts;
					this.name;
					this._selected = false;
					this._focused = false
				}
				MdNavItemController.prototype.getNgClassMap = function ()
				{
					return {
						"md-active": this._selected,
						"md-primary": this._selected,
						"md-unselected": !this._selected,
						"md-focused": this._focused
					}
				};
				MdNavItemController.prototype.getName = function ()
				{
					return this.name
				};
				MdNavItemController.prototype.getButtonEl = function ()
				{
					return this._$element[0].querySelector("._md-nav-button")
				};
				MdNavItemController.prototype.setSelected = function (isSelected)
				{
					this._selected = isSelected
				};
				MdNavItemController.prototype.isSelected = function ()
				{
					return this._selected
				};
				MdNavItemController.prototype.setFocused = function (isFocused)
				{
					this._focused = isFocused;
					isFocused && this.getButtonEl().focus()
				};
				MdNavItemController.prototype.hasFocus = function ()
				{
					return this._focused
				}
			})();
			(function ()
			{
				MdPanelService.$inject = ["presets", "$rootElement", "$rootScope", "$injector", "$window"];
				angular.module("material.components.panel", ["material.core", "material.components.backdrop"]).provider("$mdPanel", MdPanelProvider);
				var MD_PANEL_Z_INDEX = 80;
				var MD_PANEL_HIDDEN = "_md-panel-hidden";
				var FOCUS_TRAP_TEMPLATE = angular.element('<div class="_md-panel-focus-trap" tabindex="0"></div>');
				var _presets = {};

				function MdPanelProvider()
				{
					return {
						definePreset: definePreset,
						getAllPresets: getAllPresets,
						clearPresets: clearPresets,
						$get: $getProvider()
					}
				}

				function definePreset(name, preset)
				{
					if (!name || !preset) throw new Error("mdPanelProvider: The panel preset definition is malformed. The name and preset object are required.");
					if (_presets.hasOwnProperty(name)) throw new Error("mdPanelProvider: The panel preset you have requested has already been defined.");
					delete preset.id;
					delete preset.position;
					delete preset.animation;
					_presets[name] = preset
				}

				function getAllPresets()
				{
					return angular.copy(_presets)
				}

				function clearPresets()
				{
					_presets = {}
				}

				function $getProvider()
				{
					return ["$rootElement", "$rootScope", "$injector", "$window", function ($rootElement, $rootScope, $injector, $window)
					{
						return new MdPanelService(_presets, $rootElement, $rootScope, $injector, $window)
					}]
				}

				function MdPanelService(presets, $rootElement, $rootScope, $injector, $window)
				{
					this._defaultConfigOptions = {
						bindToController: true,
						clickOutsideToClose: false,
						disableParentScroll: false,
						escapeToClose: false,
						focusOnOpen: true,
						fullscreen: false,
						hasBackdrop: false,
						propagateContainerEvents: false,
						transformTemplate: angular.bind(this, this._wrapTemplate),
						trapFocus: false,
						zIndex: MD_PANEL_Z_INDEX
					};
					this._config = {};
					this._presets = presets;
					this._$rootElement = $rootElement;
					this._$rootScope = $rootScope;
					this._$injector = $injector;
					this._$window = $window;
					this._$mdUtil = this._$injector.get("$mdUtil");
					this._trackedPanels = {};
					this._groups = Object.create(null);
					this.animation = MdPanelAnimation.animation;
					this.xPosition = MdPanelPosition.xPosition;
					this.yPosition = MdPanelPosition.yPosition;
					this.interceptorTypes = MdPanelRef.interceptorTypes;
					this.closeReasons = MdPanelRef.closeReasons;
					this.absPosition = MdPanelPosition.absPosition
				}
				MdPanelService.prototype.create = function (preset, config)
				{
					if ("string" === typeof preset) preset = this._getPresetByName(preset);
					else if ("object" === typeof preset && (angular.isUndefined(config) || !config))
					{
						config = preset;
						preset = {}
					}
					preset = preset ||
					{};
					config = config ||
					{};
					if (angular.isDefined(config.id) && this._trackedPanels[config.id])
					{
						var trackedPanel = this._trackedPanels[config.id];
						angular.extend(trackedPanel.config, config);
						return trackedPanel
					}
					this._config = angular.extend(
					{
						id: config.id || "panel_" + this._$mdUtil.nextUid(),
						scope: this._$rootScope.$new(true),
						attachTo: this._$rootElement
					}, this._defaultConfigOptions, config, preset);
					var panelRef = new MdPanelRef(this._config, this._$injector);
					this._trackedPanels[config.id] = panelRef;
					if (this._config.groupName)
					{
						angular.isString(this._config.groupName) && (this._config.groupName = [this._config.groupName]);
						angular.forEach(this._config.groupName, function (group)
						{
							panelRef.addToGroup(group)
						})
					}
					this._config.scope.$on("$destroy", angular.bind(panelRef, panelRef.detach));
					return panelRef
				};
				MdPanelService.prototype.open = function (preset, config)
				{
					var panelRef = this.create(preset, config);
					return panelRef.open().then(function ()
					{
						return panelRef
					})
				};
				MdPanelService.prototype._getPresetByName = function (preset)
				{
					if (!this._presets[preset]) throw new Error("mdPanel: The panel preset configuration that you requested does not exist. Use the $mdPanelProvider to create a preset before requesting one.");
					return this._presets[preset]
				};
				MdPanelService.prototype.newPanelPosition = function ()
				{
					return new MdPanelPosition(this._$injector)
				};
				MdPanelService.prototype.newPanelAnimation = function ()
				{
					return new MdPanelAnimation(this._$injector)
				};
				MdPanelService.prototype.newPanelGroup = function (groupName, config)
				{
					if (!this._groups[groupName])
					{
						config = config ||
						{};
						var group = {
							panels: [],
							openPanels: [],
							maxOpen: config.maxOpen > 0 ? config.maxOpen : Infinity
						};
						this._groups[groupName] = group
					}
					return this._groups[groupName]
				};
				MdPanelService.prototype.setGroupMaxOpen = function (groupName, maxOpen)
				{
					if (!this._groups[groupName]) throw new Error("mdPanel: Group does not exist yet. Call newPanelGroup().");
					this._groups[groupName].maxOpen = maxOpen
				};
				MdPanelService.prototype._openCountExceedsMaxOpen = function (groupName)
				{
					if (this._groups[groupName])
					{
						var group = this._groups[groupName];
						return group.maxOpen > 0 && group.openPanels.length > group.maxOpen
					}
					return false
				};
				MdPanelService.prototype._closeFirstOpenedPanel = function (groupName)
				{
					this._groups[groupName].openPanels[0].close()
				};
				MdPanelService.prototype._wrapTemplate = function (origTemplate)
				{
					var template = origTemplate || "";
					return '<div class="md-panel-outer-wrapper">  <div class="md-panel _md-panel-offscreen">' + template + "</div></div>"
				};
				MdPanelService.prototype._wrapContentElement = function (contentElement)
				{
					var wrapper = angular.element('<div class="md-panel-outer-wrapper">');
					contentElement.addClass("md-panel _md-panel-offscreen");
					wrapper.append(contentElement);
					return wrapper
				};

				function MdPanelRef(config, $injector)
				{
					this._$q = $injector.get("$q");
					this._$mdCompiler = $injector.get("$mdCompiler");
					this._$mdConstant = $injector.get("$mdConstant");
					this._$mdUtil = $injector.get("$mdUtil");
					this._$mdTheming = $injector.get("$mdTheming");
					this._$rootScope = $injector.get("$rootScope");
					this._$animate = $injector.get("$animate");
					this._$mdPanel = $injector.get("$mdPanel");
					this._$log = $injector.get("$log");
					this._$window = $injector.get("$window");
					this._$$rAF = $injector.get("$$rAF");
					this.id = config.id;
					this.config = config;
					this.panelContainer;
					this.panelEl;
					this.isAttached = false;
					this._removeListeners = [];
					this._topFocusTrap;
					this._bottomFocusTrap;
					this._backdropRef;
					this._restoreScroll = null;
					this._interceptors = Object.create(null);
					this._compilerCleanup = null;
					this._restoreCache = {
						styles: "",
						classes: ""
					}
				}
				MdPanelRef.interceptorTypes = {
					CLOSE: "onClose"
				};
				MdPanelRef.prototype.open = function ()
				{
					var self = this;
					return this._$q(function (resolve, reject)
					{
						var done = self._done(resolve, self);
						var show = self._simpleBind(self.show, self);
						var checkGroupMaxOpen = function ()
						{
							self.config.groupName && angular.forEach(self.config.groupName, function (group)
							{
								self._$mdPanel._openCountExceedsMaxOpen(group) && self._$mdPanel._closeFirstOpenedPanel(group)
							})
						};
						self.attach().then(show).then(checkGroupMaxOpen).then(done).catch(reject)
					})
				};
				MdPanelRef.prototype.close = function (closeReason)
				{
					var self = this;
					return this._$q(function (resolve, reject)
					{
						self._callInterceptors(MdPanelRef.interceptorTypes.CLOSE).then(function ()
						{
							var done = self._done(resolve, self);
							var detach = self._simpleBind(self.detach, self);
							var onCloseSuccess = self.config["onCloseSuccess"] || angular.noop;
							onCloseSuccess = angular.bind(self, onCloseSuccess, self, closeReason);
							self.hide().then(detach).then(done).then(onCloseSuccess).catch(reject)
						}, reject)
					})
				};
				MdPanelRef.prototype.attach = function ()
				{
					if (this.isAttached && this.panelEl) return this._$q.when(this);
					var self = this;
					return this._$q(function (resolve, reject)
					{
						var done = self._done(resolve, self);
						var onDomAdded = self.config["onDomAdded"] || angular.noop;
						var addListeners = function (response)
						{
							self.isAttached = true;
							self._addEventListeners();
							return response
						};
						self._$q.all([self._createBackdrop(), self._createPanel().then(addListeners).catch(reject)]).then(onDomAdded).then(done).catch(reject)
					})
				};
				MdPanelRef.prototype.detach = function ()
				{
					if (!this.isAttached) return this._$q.when(this);
					var self = this;
					var onDomRemoved = self.config["onDomRemoved"] || angular.noop;
					var detachFn = function ()
					{
						self._removeEventListeners();
						self._topFocusTrap && self._topFocusTrap.parentNode && self._topFocusTrap.parentNode.removeChild(self._topFocusTrap);
						self._bottomFocusTrap && self._bottomFocusTrap.parentNode && self._bottomFocusTrap.parentNode.removeChild(self._bottomFocusTrap);
						self._restoreCache.classes && (self.panelEl[0].className = self._restoreCache.classes);
						self.panelEl[0].style.cssText = self._restoreCache.styles || "";
						self._compilerCleanup();
						self.panelContainer.remove();
						self.isAttached = false;
						return self._$q.when(self)
					};
					if (this._restoreScroll)
					{
						this._restoreScroll();
						this._restoreScroll = null
					}
					return this._$q(function (resolve, reject)
					{
						var done = self._done(resolve, self);
						self._$q.all([detachFn(), !self._backdropRef || self._backdropRef.detach()]).then(onDomRemoved).then(done).catch(reject)
					})
				};
				MdPanelRef.prototype.destroy = function ()
				{
					var self = this;
					this.config.groupName && angular.forEach(this.config.groupName, function (group)
					{
						self.removeFromGroup(group)
					});
					this.config.scope.$destroy();
					this.config.locals = null;
					this.config.onDomAdded = null;
					this.config.onDomRemoved = null;
					this.config.onRemoving = null;
					this.config.onOpenComplete = null;
					this._interceptors = null
				};
				MdPanelRef.prototype.show = function ()
				{
					if (!this.panelContainer) return this._$q(function (resolve, reject)
					{
						reject("mdPanel: Panel does not exist yet. Call open() or attach().")
					});
					if (!this.panelContainer.hasClass(MD_PANEL_HIDDEN)) return this._$q.when(this);
					var self = this;
					var animatePromise = function ()
					{
						self.panelContainer.removeClass(MD_PANEL_HIDDEN);
						return self._animateOpen()
					};
					return this._$q(function (resolve, reject)
					{
						var done = self._done(resolve, self);
						var onOpenComplete = self.config["onOpenComplete"] || angular.noop;
						var addToGroupOpen = function ()
						{
							self.config.groupName && angular.forEach(self.config.groupName, function (group)
							{
								self._$mdPanel._groups[group].openPanels.push(self)
							})
						};
						self._$q.all([self._backdropRef ? self._backdropRef.show() : self, animatePromise().then(function ()
						{
							self._focusOnOpen()
						}, reject)]).then(onOpenComplete).then(addToGroupOpen).then(done).catch(reject)
					})
				};
				MdPanelRef.prototype.hide = function ()
				{
					if (!this.panelContainer) return this._$q(function (resolve, reject)
					{
						reject("mdPanel: Panel does not exist yet. Call open() or attach().")
					});
					if (this.panelContainer.hasClass(MD_PANEL_HIDDEN)) return this._$q.when(this);
					var self = this;
					return this._$q(function (resolve, reject)
					{
						var done = self._done(resolve, self);
						var onRemoving = self.config["onRemoving"] || angular.noop;
						var hidePanel = function ()
						{
							self.panelContainer.addClass(MD_PANEL_HIDDEN)
						};
						var removeFromGroupOpen = function ()
						{
							if (self.config.groupName)
							{
								var index;
								angular.forEach(self.config.groupName, function (group)
								{
									group = self._$mdPanel._groups[group];
									index = group.openPanels.indexOf(self);
									index > -1 && group.openPanels.splice(index, 1)
								})
							}
						};
						var focusOnOrigin = function ()
						{
							var origin = self.config["origin"];
							origin && getElement(origin).focus()
						};
						self._$q.all([self._backdropRef ? self._backdropRef.hide() : self, self._animateClose().then(onRemoving).then(hidePanel).then(removeFromGroupOpen).then(focusOnOrigin).catch(reject)]).then(done, reject)
					})
				};
				MdPanelRef.prototype.addClass = function (newClass, toElement)
				{
					this._$log.warn("mdPanel: The addClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef.");
					if (!this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");
					toElement || this.panelContainer.hasClass(newClass) ? toElement && !this.panelEl.hasClass(newClass) && this.panelEl.addClass(newClass) : this.panelContainer.addClass(newClass)
				};
				MdPanelRef.prototype.removeClass = function (oldClass, fromElement)
				{
					this._$log.warn("mdPanel: The removeClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef.");
					if (!this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");
					!fromElement && this.panelContainer.hasClass(oldClass) ? this.panelContainer.removeClass(oldClass) : fromElement && this.panelEl.hasClass(oldClass) && this.panelEl.removeClass(oldClass)
				};
				MdPanelRef.prototype.toggleClass = function (toggleClass, onElement)
				{
					this._$log.warn("mdPanel: The toggleClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef.");
					if (!this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");
					onElement ? this.panelEl.toggleClass(toggleClass) : this.panelContainer.toggleClass(toggleClass)
				};
				MdPanelRef.prototype._compile = function ()
				{
					var self = this;
					return self._$mdCompiler.compile(self.config).then(function (compileData)
					{
						var config = self.config;
						if (config.contentElement)
						{
							var panelEl = compileData.element;
							self._restoreCache.styles = panelEl[0].style.cssText;
							self._restoreCache.classes = panelEl[0].className;
							self.panelContainer = self._$mdPanel._wrapContentElement(panelEl);
							self.panelEl = panelEl
						}
						else
						{
							self.panelContainer = compileData.link(config["scope"]);
							self.panelEl = angular.element(self.panelContainer[0].querySelector(".md-panel"))
						}
						self._compilerCleanup = compileData.cleanup;
						getElement(self.config["attachTo"]).append(self.panelContainer);
						return self
					})
				};
				MdPanelRef.prototype._createPanel = function ()
				{
					var self = this;
					return this._$q(function (resolve, reject)
					{
						self.config.locals || (self.config.locals = {});
						self.config.locals.mdPanelRef = self;
						self._compile().then(function ()
						{
							self.config["disableParentScroll"] && (self._restoreScroll = self._$mdUtil.disableScrollAround(null, self.panelContainer,
							{
								disableScrollMask: true
							}));
							self.config["panelClass"] && self.panelEl.addClass(self.config["panelClass"]);
							if (self.config["propagateContainerEvents"])
							{
								self.panelContainer.css("pointer-events", "none");
								self.panelEl.css("pointer-events", "all")
							}
							self._$animate.pin && self._$animate.pin(self.panelContainer, getElement(self.config["attachTo"]));
							self._configureTrapFocus();
							self._addStyles().then(function ()
							{
								resolve(self)
							}, reject)
						}, reject)
					})
				};
				MdPanelRef.prototype._addStyles = function ()
				{
					var self = this;
					return this._$q(function (resolve)
					{
						self.panelContainer.css("z-index", self.config["zIndex"]);
						self.panelEl.css("z-index", self.config["zIndex"] + 1);
						var hideAndResolve = function ()
						{
							self._setTheming();
							self.panelEl.removeClass("_md-panel-offscreen");
							self.panelContainer.addClass(MD_PANEL_HIDDEN);
							resolve(self)
						};
						if (self.config["fullscreen"])
						{
							self.panelEl.addClass("_md-panel-fullscreen");
							hideAndResolve();
							return
						}
						var positionConfig = self.config["position"];
						if (!positionConfig)
						{
							hideAndResolve();
							return
						}
						self._$rootScope["$$postDigest"](function ()
						{
							self._updatePosition(true);
							self._setTheming();
							resolve(self)
						})
					})
				};
				MdPanelRef.prototype._setTheming = function ()
				{
					this._$mdTheming(this.panelEl);
					this._$mdTheming(this.panelContainer)
				};
				MdPanelRef.prototype.updatePosition = function (position)
				{
					if (!this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");
					this.config["position"] = position;
					this._updatePosition()
				};
				MdPanelRef.prototype._updatePosition = function (init)
				{
					var positionConfig = this.config["position"];
					if (positionConfig)
					{
						positionConfig._setPanelPosition(this.panelEl);
						if (init)
						{
							this.panelEl.removeClass("_md-panel-offscreen");
							this.panelContainer.addClass(MD_PANEL_HIDDEN)
						}
						this.panelEl.css(MdPanelPosition.absPosition.TOP, positionConfig.getTop());
						this.panelEl.css(MdPanelPosition.absPosition.BOTTOM, positionConfig.getBottom());
						this.panelEl.css(MdPanelPosition.absPosition.LEFT, positionConfig.getLeft());
						this.panelEl.css(MdPanelPosition.absPosition.RIGHT, positionConfig.getRight())
					}
				};
				MdPanelRef.prototype._focusOnOpen = function ()
				{
					if (this.config["focusOnOpen"])
					{
						var self = this;
						this._$rootScope["$$postDigest"](function ()
						{
							var target = self._$mdUtil.findFocusTarget(self.panelEl) || self.panelEl;
							target.focus()
						})
					}
				};
				MdPanelRef.prototype._createBackdrop = function ()
				{
					if (this.config.hasBackdrop)
					{
						if (!this._backdropRef)
						{
							var backdropAnimation = this._$mdPanel.newPanelAnimation().openFrom(this.config.attachTo).withAnimation(
							{
								open: "_md-opaque-enter",
								close: "_md-opaque-leave"
							});
							this.config.animation && backdropAnimation.duration(this.config.animation._rawDuration);
							var backdropConfig = {
								animation: backdropAnimation,
								attachTo: this.config.attachTo,
								focusOnOpen: false,
								panelClass: "_md-panel-backdrop",
								zIndex: this.config.zIndex - 1
							};
							this._backdropRef = this._$mdPanel.create(backdropConfig)
						}
						if (!this._backdropRef.isAttached) return this._backdropRef.attach()
					}
				};
				MdPanelRef.prototype._addEventListeners = function ()
				{
					this._configureEscapeToClose();
					this._configureClickOutsideToClose();
					this._configureScrollListener()
				};
				MdPanelRef.prototype._removeEventListeners = function ()
				{
					this._removeListeners && this._removeListeners.forEach(function (removeFn)
					{
						removeFn()
					});
					this._removeListeners = []
				};
				MdPanelRef.prototype._configureEscapeToClose = function ()
				{
					if (this.config["escapeToClose"])
					{
						var parentTarget = getElement(this.config["attachTo"]);
						var self = this;
						var keyHandlerFn = function (ev)
						{
							if (ev.keyCode === self._$mdConstant.KEY_CODE.ESCAPE)
							{
								ev.stopPropagation();
								ev.preventDefault();
								self.close(MdPanelRef.closeReasons.ESCAPE)
							}
						};
						this.panelContainer.on("keydown", keyHandlerFn);
						parentTarget.on("keydown", keyHandlerFn);
						this._removeListeners.push(function ()
						{
							self.panelContainer.off("keydown", keyHandlerFn);
							parentTarget.off("keydown", keyHandlerFn)
						})
					}
				};
				MdPanelRef.prototype._configureClickOutsideToClose = function ()
				{
					if (this.config["clickOutsideToClose"])
					{
						var target = this.config["propagateContainerEvents"] ? angular.element(document.body) : this.panelContainer;
						var sourceEl;
						var mousedownHandler = function (ev)
						{
							sourceEl = ev.target
						};
						var self = this;
						var mouseupHandler = function (ev)
						{
							if (self.config["propagateContainerEvents"]) sourceEl === self.panelEl[0] || self.panelEl[0].contains(sourceEl) || self.close();
							else if (sourceEl === target[0] && ev.target === target[0])
							{
								ev.stopPropagation();
								ev.preventDefault();
								self.close(MdPanelRef.closeReasons.CLICK_OUTSIDE)
							}
						};
						target.on("mousedown", mousedownHandler);
						target.on("mouseup", mouseupHandler);
						this._removeListeners.push(function ()
						{
							target.off("mousedown", mousedownHandler);
							target.off("mouseup", mouseupHandler)
						})
					}
				};
				MdPanelRef.prototype._configureScrollListener = function ()
				{
					if (!this.config["disableParentScroll"])
					{
						var updatePosition = angular.bind(this, this._updatePosition);
						var debouncedUpdatePosition = this._$$rAF.throttle(updatePosition);
						var self = this;
						var onScroll = function ()
						{
							debouncedUpdatePosition()
						};
						this._$window.addEventListener("scroll", onScroll, true);
						this._removeListeners.push(function ()
						{
							self._$window.removeEventListener("scroll", onScroll, true)
						})
					}
				};
				MdPanelRef.prototype._configureTrapFocus = function ()
				{
					this.panelEl.attr("tabIndex", "-1");
					if (this.config["trapFocus"])
					{
						var element = this.panelEl;
						this._topFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
						this._bottomFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
						var focusHandler = function ()
						{
							element.focus()
						};
						this._topFocusTrap.addEventListener("focus", focusHandler);
						this._bottomFocusTrap.addEventListener("focus", focusHandler);
						this._removeListeners.push(this._simpleBind(function ()
						{
							this._topFocusTrap.removeEventListener("focus", focusHandler);
							this._bottomFocusTrap.removeEventListener("focus", focusHandler)
						}, this));
						element[0].parentNode.insertBefore(this._topFocusTrap, element[0]);
						element.after(this._bottomFocusTrap)
					}
				};
				MdPanelRef.prototype.updateAnimation = function (animation)
				{
					this.config["animation"] = animation;
					this._backdropRef && this._backdropRef.config.animation.duration(animation._rawDuration)
				};
				MdPanelRef.prototype._animateOpen = function ()
				{
					this.panelContainer.addClass("md-panel-is-showing");
					var animationConfig = this.config["animation"];
					if (!animationConfig)
					{
						this.panelContainer.addClass("_md-panel-shown");
						return this._$q.when(this)
					}
					var self = this;
					return this._$q(function (resolve)
					{
						var done = self._done(resolve, self);
						var warnAndOpen = function ()
						{
							self._$log.warn("mdPanel: MdPanel Animations failed. Showing panel without animating.");
							done()
						};
						animationConfig.animateOpen(self.panelEl).then(done, warnAndOpen)
					})
				};
				MdPanelRef.prototype._animateClose = function ()
				{
					var animationConfig = this.config["animation"];
					if (!animationConfig)
					{
						this.panelContainer.removeClass("md-panel-is-showing");
						this.panelContainer.removeClass("_md-panel-shown");
						return this._$q.when(this)
					}
					var self = this;
					return this._$q(function (resolve)
					{
						var done = function ()
						{
							self.panelContainer.removeClass("md-panel-is-showing");
							resolve(self)
						};
						var warnAndClose = function ()
						{
							self._$log.warn("mdPanel: MdPanel Animations failed. Hiding panel without animating.");
							done()
						};
						animationConfig.animateClose(self.panelEl).then(done, warnAndClose)
					})
				};
				MdPanelRef.prototype.registerInterceptor = function (type, callback)
				{
					var error = null;
					angular.isString(type) ? angular.isFunction(callback) || (error = "Interceptor callback must be a function, instead got " + typeof callback) : error = "Interceptor type must be a string, instead got " + typeof type;
					if (error) throw new Error("MdPanel: " + error);
					var interceptors = this._interceptors[type] = this._interceptors[type] || []; - 1 === interceptors.indexOf(callback) && interceptors.push(callback);
					return this
				};
				MdPanelRef.prototype.removeInterceptor = function (type, callback)
				{
					var index = this._interceptors[type] ? this._interceptors[type].indexOf(callback) : -1;
					index > -1 && this._interceptors[type].splice(index, 1);
					return this
				};
				MdPanelRef.prototype.removeAllInterceptors = function (type)
				{
					type ? this._interceptors[type] = [] : this._interceptors = Object.create(null);
					return this
				};
				MdPanelRef.prototype._callInterceptors = function (type)
				{
					var self = this;
					var $q = self._$q;
					var interceptors = self._interceptors && self._interceptors[type] || [];
					return interceptors.reduceRight(function (promise, interceptor)
					{
						var isPromiseLike = interceptor && angular.isFunction(interceptor.then);
						var response = isPromiseLike ? interceptor : null;
						return promise.then(function ()
						{
							if (!response) try
							{
								response = interceptor(self)
							}
							catch (e)
							{
								response = $q.reject(e)
							}
							return response
						})
					}, $q.resolve(self))
				};
				MdPanelRef.prototype._simpleBind = function (callback, self)
				{
					return function (value)
					{
						return callback.apply(self, value)
					}
				};
				MdPanelRef.prototype._done = function (callback, self)
				{
					return function ()
					{
						callback(self)
					}
				};
				MdPanelRef.prototype.addToGroup = function (groupName)
				{
					this._$mdPanel._groups[groupName] || this._$mdPanel.newPanelGroup(groupName);
					var group = this._$mdPanel._groups[groupName];
					var index = group.panels.indexOf(this);
					index < 0 && group.panels.push(this)
				};
				MdPanelRef.prototype.removeFromGroup = function (groupName)
				{
					if (!this._$mdPanel._groups[groupName]) throw new Error("mdPanel: The group " + groupName + " does not exist.");
					var group = this._$mdPanel._groups[groupName];
					var index = group.panels.indexOf(this);
					index > -1 && group.panels.splice(index, 1)
				};
				MdPanelRef.closeReasons = {
					CLICK_OUTSIDE: "clickOutsideToClose",
					ESCAPE: "escapeToClose"
				};

				function MdPanelPosition($injector)
				{
					this._$window = $injector.get("$window");
					this._isRTL = "rtl" === $injector.get("$mdUtil").bidi();
					this._$mdConstant = $injector.get("$mdConstant");
					this._absolute = false;
					this._relativeToEl;
					this._top = "";
					this._bottom = "";
					this._left = "";
					this._right = "";
					this._translateX = [];
					this._translateY = [];
					this._positions = [];
					this._actualPosition
				}
				MdPanelPosition.xPosition = {
					CENTER: "center",
					ALIGN_START: "align-start",
					ALIGN_END: "align-end",
					OFFSET_START: "offset-start",
					OFFSET_END: "offset-end"
				};
				MdPanelPosition.yPosition = {
					CENTER: "center",
					ALIGN_TOPS: "align-tops",
					ALIGN_BOTTOMS: "align-bottoms",
					ABOVE: "above",
					BELOW: "below"
				};
				MdPanelPosition.absPosition = {
					TOP: "top",
					RIGHT: "right",
					BOTTOM: "bottom",
					LEFT: "left"
				};
				MdPanelPosition.viewportMargin = 8;
				MdPanelPosition.prototype.absolute = function ()
				{
					this._absolute = true;
					return this
				};
				MdPanelPosition.prototype._setPosition = function (position, value)
				{
					if (position === MdPanelPosition.absPosition.RIGHT || position === MdPanelPosition.absPosition.LEFT) this._left = this._right = "";
					else
					{
						if (position !== MdPanelPosition.absPosition.BOTTOM && position !== MdPanelPosition.absPosition.TOP)
						{
							var positions = Object.keys(MdPanelPosition.absPosition).join().toLowerCase();
							throw new Error("mdPanel: Position must be one of " + positions + ".")
						}
						this._top = this._bottom = ""
					}
					this["_" + position] = angular.isString(value) ? value : "0";
					return this
				};
				MdPanelPosition.prototype.top = function (top)
				{
					return this._setPosition(MdPanelPosition.absPosition.TOP, top)
				};
				MdPanelPosition.prototype.bottom = function (bottom)
				{
					return this._setPosition(MdPanelPosition.absPosition.BOTTOM, bottom)
				};
				MdPanelPosition.prototype.start = function (start)
				{
					var position = this._isRTL ? MdPanelPosition.absPosition.RIGHT : MdPanelPosition.absPosition.LEFT;
					return this._setPosition(position, start)
				};
				MdPanelPosition.prototype.end = function (end)
				{
					var position = this._isRTL ? MdPanelPosition.absPosition.LEFT : MdPanelPosition.absPosition.RIGHT;
					return this._setPosition(position, end)
				};
				MdPanelPosition.prototype.left = function (left)
				{
					return this._setPosition(MdPanelPosition.absPosition.LEFT, left)
				};
				MdPanelPosition.prototype.right = function (right)
				{
					return this._setPosition(MdPanelPosition.absPosition.RIGHT, right)
				};
				MdPanelPosition.prototype.centerHorizontally = function ()
				{
					this._left = "50%";
					this._right = "";
					this._translateX = ["-50%"];
					return this
				};
				MdPanelPosition.prototype.centerVertically = function ()
				{
					this._top = "50%";
					this._bottom = "";
					this._translateY = ["-50%"];
					return this
				};
				MdPanelPosition.prototype.center = function ()
				{
					return this.centerHorizontally().centerVertically()
				};
				MdPanelPosition.prototype.relativeTo = function (element)
				{
					this._absolute = false;
					this._relativeToEl = getElement(element);
					return this
				};
				MdPanelPosition.prototype.addPanelPosition = function (xPosition, yPosition)
				{
					if (!this._relativeToEl) throw new Error("mdPanel: addPanelPosition can only be used with relative positioning. Set relativeTo first.");
					this._validateXPosition(xPosition);
					this._validateYPosition(yPosition);
					this._positions.push(
					{
						x: xPosition,
						y: yPosition
					});
					return this
				};
				MdPanelPosition.prototype._validateYPosition = function (yPosition)
				{
					if (null == yPosition) return;
					var positionKeys = Object.keys(MdPanelPosition.yPosition);
					var positionValues = [];
					for (var key, i = 0; key = positionKeys[i]; i++)
					{
						var position = MdPanelPosition.yPosition[key];
						positionValues.push(position);
						if (position === yPosition) return
					}
					throw new Error("mdPanel: Panel y position only accepts the following values:\n" + positionValues.join(" | "))
				};
				MdPanelPosition.prototype._validateXPosition = function (xPosition)
				{
					if (null == xPosition) return;
					var positionKeys = Object.keys(MdPanelPosition.xPosition);
					var positionValues = [];
					for (var key, i = 0; key = positionKeys[i]; i++)
					{
						var position = MdPanelPosition.xPosition[key];
						positionValues.push(position);
						if (position === xPosition) return
					}
					throw new Error("mdPanel: Panel x Position only accepts the following values:\n" + positionValues.join(" | "))
				};
				MdPanelPosition.prototype.withOffsetX = function (offsetX)
				{
					this._translateX.push(addUnits(offsetX));
					return this
				};
				MdPanelPosition.prototype.withOffsetY = function (offsetY)
				{
					this._translateY.push(addUnits(offsetY));
					return this
				};
				MdPanelPosition.prototype.getTop = function ()
				{
					return this._top
				};
				MdPanelPosition.prototype.getBottom = function ()
				{
					return this._bottom
				};
				MdPanelPosition.prototype.getLeft = function ()
				{
					return this._left
				};
				MdPanelPosition.prototype.getRight = function ()
				{
					return this._right
				};
				MdPanelPosition.prototype.getTransform = function ()
				{
					var translateX = this._reduceTranslateValues("translateX", this._translateX);
					var translateY = this._reduceTranslateValues("translateY", this._translateY);
					return (translateX + " " + translateY).trim()
				};
				MdPanelPosition.prototype._setTransform = function (panelEl)
				{
					return panelEl.css(this._$mdConstant.CSS.TRANSFORM, this.getTransform())
				};
				MdPanelPosition.prototype._isOnscreen = function (panelEl)
				{
					var left = parseInt(this.getLeft());
					var top = parseInt(this.getTop());
					if (this._translateX.length || this._translateY.length)
					{
						var prefixedTransform = this._$mdConstant.CSS.TRANSFORM;
						var offsets = getComputedTranslations(panelEl, prefixedTransform);
						left += offsets.x;
						top += offsets.y
					}
					var right = left + panelEl[0].offsetWidth;
					var bottom = top + panelEl[0].offsetHeight;
					return left >= 0 && top >= 0 && bottom <= this._$window.innerHeight && right <= this._$window.innerWidth
				};
				MdPanelPosition.prototype.getActualPosition = function ()
				{
					return this._actualPosition
				};
				MdPanelPosition.prototype._reduceTranslateValues = function (translateFn, values)
				{
					return values.map(function (translation)
					{
						var translationValue = angular.isFunction(translation) ? addUnits(translation(this)) : translation;
						return translateFn + "(" + translationValue + ")"
					}, this).join(" ")
				};
				MdPanelPosition.prototype._setPanelPosition = function (panelEl)
				{
					panelEl.removeClass("_md-panel-position-adjusted");
					if (this._absolute)
					{
						this._setTransform(panelEl);
						return
					}
					if (this._actualPosition)
					{
						this._calculatePanelPosition(panelEl, this._actualPosition);
						this._setTransform(panelEl);
						this._constrainToViewport(panelEl);
						return
					}
					for (var i = 0; i < this._positions.length; i++)
					{
						this._actualPosition = this._positions[i];
						this._calculatePanelPosition(panelEl, this._actualPosition);
						this._setTransform(panelEl);
						if (this._isOnscreen(panelEl)) return
					}
					this._constrainToViewport(panelEl)
				};
				MdPanelPosition.prototype._constrainToViewport = function (panelEl)
				{
					var margin = MdPanelPosition.viewportMargin;
					var initialTop = this._top;
					var initialLeft = this._left;
					if (this.getTop())
					{
						var top = parseInt(this.getTop());
						var bottom = panelEl[0].offsetHeight + top;
						var viewportHeight = this._$window.innerHeight;
						top < margin ? this._top = margin + "px" : bottom > viewportHeight && (this._top = top - (bottom - viewportHeight + margin) + "px")
					}
					if (this.getLeft())
					{
						var left = parseInt(this.getLeft());
						var right = panelEl[0].offsetWidth + left;
						var viewportWidth = this._$window.innerWidth;
						left < margin ? this._left = margin + "px" : right > viewportWidth && (this._left = left - (right - viewportWidth + margin) + "px")
					}
					panelEl.toggleClass("_md-panel-position-adjusted", this._top !== initialTop || this._left !== initialLeft)
				};
				MdPanelPosition.prototype._reverseXPosition = function (position)
				{
					if (position === MdPanelPosition.xPosition.CENTER) return position;
					var start = "start";
					var end = "end";
					return position.indexOf(start) > -1 ? position.replace(start, end) : position.replace(end, start)
				};
				MdPanelPosition.prototype._bidi = function (position)
				{
					return this._isRTL ? this._reverseXPosition(position) : position
				};
				MdPanelPosition.prototype._calculatePanelPosition = function (panelEl, position)
				{
					var panelBounds = panelEl[0].getBoundingClientRect();
					var panelWidth = Math.max(panelBounds.width, panelEl[0].clientWidth);
					var panelHeight = Math.max(panelBounds.height, panelEl[0].clientHeight);
					var targetBounds = this._relativeToEl[0].getBoundingClientRect();
					var targetLeft = targetBounds.left;
					var targetRight = targetBounds.right;
					var targetWidth = targetBounds.width;
					switch (this._bidi(position.x))
					{
					case MdPanelPosition.xPosition.OFFSET_START:
						this._left = targetLeft - panelWidth + "px";
						break;
					case MdPanelPosition.xPosition.ALIGN_END:
						this._left = targetRight - panelWidth + "px";
						break;
					case MdPanelPosition.xPosition.CENTER:
						var left = targetLeft + .5 * targetWidth - .5 * panelWidth;
						this._left = left + "px";
						break;
					case MdPanelPosition.xPosition.ALIGN_START:
						this._left = targetLeft + "px";
						break;
					case MdPanelPosition.xPosition.OFFSET_END:
						this._left = targetRight + "px"
					}
					var targetTop = targetBounds.top;
					var targetBottom = targetBounds.bottom;
					var targetHeight = targetBounds.height;
					switch (position.y)
					{
					case MdPanelPosition.yPosition.ABOVE:
						this._top = targetTop - panelHeight + "px";
						break;
					case MdPanelPosition.yPosition.ALIGN_BOTTOMS:
						this._top = targetBottom - panelHeight + "px";
						break;
					case MdPanelPosition.yPosition.CENTER:
						var top = targetTop + .5 * targetHeight - .5 * panelHeight;
						this._top = top + "px";
						break;
					case MdPanelPosition.yPosition.ALIGN_TOPS:
						this._top = targetTop + "px";
						break;
					case MdPanelPosition.yPosition.BELOW:
						this._top = targetBottom + "px"
					}
				};

				function MdPanelAnimation($injector)
				{
					this._$mdUtil = $injector.get("$mdUtil");
					this._openFrom;
					this._closeTo;
					this._animationClass = "";
					this._openDuration;
					this._closeDuration;
					this._rawDuration
				}
				MdPanelAnimation.animation = {
					SLIDE: "md-panel-animate-slide",
					SCALE: "md-panel-animate-scale",
					FADE: "md-panel-animate-fade"
				};
				MdPanelAnimation.prototype.openFrom = function (openFrom)
				{
					openFrom = openFrom.target ? openFrom.target : openFrom;
					this._openFrom = this._getPanelAnimationTarget(openFrom);
					this._closeTo || (this._closeTo = this._openFrom);
					return this
				};
				MdPanelAnimation.prototype.closeTo = function (closeTo)
				{
					this._closeTo = this._getPanelAnimationTarget(closeTo);
					return this
				};
				MdPanelAnimation.prototype.duration = function (duration)
				{
					if (duration)
						if (angular.isNumber(duration)) this._openDuration = this._closeDuration = toSeconds(duration);
						else if (angular.isObject(duration))
					{
						this._openDuration = toSeconds(duration.open);
						this._closeDuration = toSeconds(duration.close)
					}
					this._rawDuration = duration;
					return this;

					function toSeconds(value)
					{
						if (angular.isNumber(value)) return value / 1e3
					}
				};
				MdPanelAnimation.prototype._getPanelAnimationTarget = function (location)
				{
					return angular.isDefined(location.top) || angular.isDefined(location.left) ?
					{
						element: undefined,
						bounds:
						{
							top: location.top || 0,
							left: location.left || 0
						}
					} : this._getBoundingClientRect(getElement(location))
				};
				MdPanelAnimation.prototype.withAnimation = function (cssClass)
				{
					this._animationClass = cssClass;
					return this
				};
				MdPanelAnimation.prototype.animateOpen = function (panelEl)
				{
					var animator = this._$mdUtil.dom.animator;
					this._fixBounds(panelEl);
					var animationOptions = {};
					var panelTransform = panelEl[0].style.transform || "";
					var openFrom = animator.toTransformCss(panelTransform);
					var openTo = animator.toTransformCss(panelTransform);
					switch (this._animationClass)
					{
					case MdPanelAnimation.animation.SLIDE:
						panelEl.css("opacity", "1");
						animationOptions = {
							transitionInClass: "_md-panel-animate-enter"
						};
						var openSlide = animator.calculateSlideToOrigin(panelEl, this._openFrom) || "";
						openFrom = animator.toTransformCss(openSlide + " " + panelTransform);
						break;
					case MdPanelAnimation.animation.SCALE:
						animationOptions = {
							transitionInClass: "_md-panel-animate-enter"
						};
						var openScale = animator.calculateZoomToOrigin(panelEl, this._openFrom) || "";
						openFrom = animator.toTransformCss(openScale + " " + panelTransform);
						break;
					case MdPanelAnimation.animation.FADE:
						animationOptions = {
							transitionInClass: "_md-panel-animate-enter"
						};
						break;
					default:
						animationOptions = angular.isString(this._animationClass) ?
						{
							transitionInClass: this._animationClass
						} :
						{
							transitionInClass: this._animationClass["open"],
							transitionOutClass: this._animationClass["close"]
						}
					}
					animationOptions.duration = this._openDuration;
					return animator.translate3d(panelEl, openFrom, openTo, animationOptions)
				};
				MdPanelAnimation.prototype.animateClose = function (panelEl)
				{
					var animator = this._$mdUtil.dom.animator;
					var reverseAnimationOptions = {};
					var panelTransform = panelEl[0].style.transform || "";
					var closeFrom = animator.toTransformCss(panelTransform);
					var closeTo = animator.toTransformCss(panelTransform);
					switch (this._animationClass)
					{
					case MdPanelAnimation.animation.SLIDE:
						panelEl.css("opacity", "1");
						reverseAnimationOptions = {
							transitionInClass: "_md-panel-animate-leave"
						};
						var closeSlide = animator.calculateSlideToOrigin(panelEl, this._closeTo) || "";
						closeTo = animator.toTransformCss(closeSlide + " " + panelTransform);
						break;
					case MdPanelAnimation.animation.SCALE:
						reverseAnimationOptions = {
							transitionInClass: "_md-panel-animate-scale-out _md-panel-animate-leave"
						};
						var closeScale = animator.calculateZoomToOrigin(panelEl, this._closeTo) || "";
						closeTo = animator.toTransformCss(closeScale + " " + panelTransform);
						break;
					case MdPanelAnimation.animation.FADE:
						reverseAnimationOptions = {
							transitionInClass: "_md-panel-animate-fade-out _md-panel-animate-leave"
						};
						break;
					default:
						reverseAnimationOptions = angular.isString(this._animationClass) ?
						{
							transitionOutClass: this._animationClass
						} :
						{
							transitionInClass: this._animationClass["close"],
							transitionOutClass: this._animationClass["open"]
						}
					}
					reverseAnimationOptions.duration = this._closeDuration;
					return animator.translate3d(panelEl, closeFrom, closeTo, reverseAnimationOptions)
				};
				MdPanelAnimation.prototype._fixBounds = function (panelEl)
				{
					var panelWidth = panelEl[0].offsetWidth;
					var panelHeight = panelEl[0].offsetHeight;
					this._openFrom && null == this._openFrom.bounds.height && (this._openFrom.bounds.height = panelHeight);
					this._openFrom && null == this._openFrom.bounds.width && (this._openFrom.bounds.width = panelWidth);
					this._closeTo && null == this._closeTo.bounds.height && (this._closeTo.bounds.height = panelHeight);
					this._closeTo && null == this._closeTo.bounds.width && (this._closeTo.bounds.width = panelWidth)
				};
				MdPanelAnimation.prototype._getBoundingClientRect = function (element)
				{
					if (element instanceof angular.element) return {
						element: element,
						bounds: element[0].getBoundingClientRect()
					}
				};

				function getElement(el)
				{
					var queryResult = angular.isString(el) ? document.querySelector(el) : el;
					return angular.element(queryResult)
				}

				function getComputedTranslations(el, property)
				{
					var transform = getComputedStyle(el[0] || el)[property];
					var openIndex = transform.indexOf("(");
					var closeIndex = transform.lastIndexOf(")");
					var output = {
						x: 0,
						y: 0
					};
					if (openIndex > -1 && closeIndex > -1)
					{
						var parsedValues = transform.substring(openIndex + 1, closeIndex).split(", ").slice(-2);
						output.x = parseInt(parsedValues[0]);
						output.y = parseInt(parsedValues[1])
					}
					return output
				}

				function addUnits(value)
				{
					return angular.isNumber(value) ? value + "px" : value
				}
			})();
			void angular.module("material.components.progressCircular", ["material.core"]);
			(function ()
			{
				MdProgressLinearDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
				angular.module("material.components.progressLinear", ["material.core"]).directive("mdProgressLinear", MdProgressLinearDirective);

				function MdProgressLinearDirective($mdTheming, $mdUtil, $log)
				{
					var MODE_DETERMINATE = "determinate";
					var MODE_INDETERMINATE = "indeterminate";
					var MODE_BUFFER = "buffer";
					var MODE_QUERY = "query";
					var DISABLED_CLASS = "_md-progress-linear-disabled";
					return {
						restrict: "E",
						template: '<div class="md-container"><div class="md-dashed"></div><div class="md-bar md-bar1"></div><div class="md-bar md-bar2"></div></div>',
						compile: compile
					};

					function compile(tElement, tAttrs, transclude)
					{
						tElement.attr("aria-valuemin", 0);
						tElement.attr("aria-valuemax", 100);
						tElement.attr("role", "progressbar");
						return postLink
					}

					function postLink(scope, element, attr)
					{
						$mdTheming(element);
						var lastMode;
						var isDisabled = attr.hasOwnProperty("disabled");
						var toVendorCSS = $mdUtil.dom.animator.toCss;
						var bar1 = angular.element(element[0].querySelector(".md-bar1"));
						var bar2 = angular.element(element[0].querySelector(".md-bar2"));
						var container = angular.element(element[0].querySelector(".md-container"));
						element.attr("md-mode", mode()).toggleClass(DISABLED_CLASS, isDisabled);
						validateMode();
						watchAttributes();

						function watchAttributes()
						{
							attr.$observe("value", function (value)
							{
								var percentValue = clamp(value);
								element.attr("aria-valuenow", percentValue);
								mode() != MODE_QUERY && animateIndicator(bar2, percentValue)
							});
							attr.$observe("mdBufferValue", function (value)
							{
								animateIndicator(bar1, clamp(value))
							});
							attr.$observe("disabled", function (value)
							{
								isDisabled = true === value || false === value ? !!value : angular.isDefined(value);
								element.toggleClass(DISABLED_CLASS, isDisabled);
								container.toggleClass(lastMode, !isDisabled)
							});
							attr.$observe("mdMode", function (mode)
							{
								lastMode && container.removeClass(lastMode);
								switch (mode)
								{
								case MODE_QUERY:
								case MODE_BUFFER:
								case MODE_DETERMINATE:
								case MODE_INDETERMINATE:
									container.addClass(lastMode = "md-mode-" + mode);
									break;
								default:
									container.addClass(lastMode = "md-mode-" + MODE_INDETERMINATE)
								}
							})
						}

						function validateMode()
						{
							if (angular.isUndefined(attr.mdMode))
							{
								var hasValue = angular.isDefined(attr.value);
								var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
								element.attr("md-mode", mode);
								attr.mdMode = mode
							}
						}

						function mode()
						{
							var value = (attr.mdMode || "").trim();
							if (value) switch (value)
							{
							case MODE_DETERMINATE:
							case MODE_INDETERMINATE:
							case MODE_BUFFER:
							case MODE_QUERY:
								break;
							default:
								value = MODE_INDETERMINATE
							}
							return value
						}

						function animateIndicator(target, value)
						{
							if (isDisabled || !mode()) return;
							var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [(value - 100) / 2, value / 100]);
							var styles = toVendorCSS(
							{
								transform: to
							});
							angular.element(target).css(styles)
						}
					}

					function clamp(value)
					{
						return Math.max(0, Math.min(value || 0, 100))
					}
				}
			})();
			(function ()
			{
				mdRadioGroupDirective.$inject = ["$mdUtil", "$mdConstant", "$mdTheming", "$timeout"];
				mdRadioButtonDirective.$inject = ["$mdAria", "$mdUtil", "$mdTheming"];
				angular.module("material.components.radioButton", ["material.core"]).directive("mdRadioGroup", mdRadioGroupDirective).directive("mdRadioButton", mdRadioButtonDirective);

				function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout)
				{
					RadioGroupController.prototype = createRadioGroupControllerProto();
					return {
						restrict: "E",
						controller: ["$element", RadioGroupController],
						require: ["mdRadioGroup", "?ngModel"],
						link:
						{
							pre: linkRadioGroup
						}
					};

					function linkRadioGroup(scope, element, attr, ctrls)
					{
						element.addClass("_md");
						$mdTheming(element);
						var rgCtrl = ctrls[0];
						var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
						rgCtrl.init(ngModelCtrl);
						scope.mouseActive = false;
						element.attr(
						{
							role: "radiogroup",
							tabIndex: element.attr("tabindex") || "0"
						}).on("keydown", keydownListener).on("mousedown", function (event)
						{
							scope.mouseActive = true;
							$timeout(function ()
							{
								scope.mouseActive = false
							}, 100)
						}).on("focus", function ()
						{
							false === scope.mouseActive && rgCtrl.$element.addClass("md-focused")
						}).on("blur", function ()
						{
							rgCtrl.$element.removeClass("md-focused")
						});

						function setFocus()
						{
							element.hasClass("md-focused") || element.addClass("md-focused")
						}

						function keydownListener(ev)
						{
							var keyCode = ev.which || ev.keyCode;
							if (keyCode != $mdConstant.KEY_CODE.ENTER && ev.currentTarget != ev.target) return;
							switch (keyCode)
							{
							case $mdConstant.KEY_CODE.LEFT_ARROW:
							case $mdConstant.KEY_CODE.UP_ARROW:
								ev.preventDefault();
								rgCtrl.selectPrevious();
								setFocus();
								break;
							case $mdConstant.KEY_CODE.RIGHT_ARROW:
							case $mdConstant.KEY_CODE.DOWN_ARROW:
								ev.preventDefault();
								rgCtrl.selectNext();
								setFocus();
								break;
							case $mdConstant.KEY_CODE.ENTER:
								var form = angular.element($mdUtil.getClosest(element[0], "form"));
								form.length > 0 && form.triggerHandler("submit")
							}
						}
					}

					function RadioGroupController($element)
					{
						this._radioButtonRenderFns = [];
						this.$element = $element
					}

					function createRadioGroupControllerProto()
					{
						return {
							init: function (ngModelCtrl)
							{
								this._ngModelCtrl = ngModelCtrl;
								this._ngModelCtrl.$render = angular.bind(this, this.render)
							},
							add: function (rbRender)
							{
								this._radioButtonRenderFns.push(rbRender)
							},
							remove: function (rbRender)
							{
								var index = this._radioButtonRenderFns.indexOf(rbRender); - 1 !== index && this._radioButtonRenderFns.splice(index, 1)
							},
							render: function ()
							{
								this._radioButtonRenderFns.forEach(function (rbRender)
								{
									rbRender()
								})
							},
							setViewValue: function (value, eventType)
							{
								this._ngModelCtrl.$setViewValue(value, eventType);
								this.render()
							},
							getViewValue: function ()
							{
								return this._ngModelCtrl.$viewValue
							},
							selectNext: function ()
							{
								return changeSelectedButton(this.$element, 1)
							},
							selectPrevious: function ()
							{
								return changeSelectedButton(this.$element, -1)
							},
							setActiveDescendant: function (radioId)
							{
								this.$element.attr("aria-activedescendant", radioId)
							},
							isDisabled: function ()
							{
								return this.$element[0].hasAttribute("disabled")
							}
						}
					}

					function changeSelectedButton(parent, increment)
					{
						var buttons = $mdUtil.iterator(parent[0].querySelectorAll("md-radio-button"), true);
						if (buttons.count())
						{
							var validate = function (button)
							{
								return !angular.element(button).attr("disabled")
							};
							var selected = parent[0].querySelector("md-radio-button.md-checked");
							var target = buttons[increment < 0 ? "previous" : "next"](selected, validate) || buttons.first();
							angular.element(target).triggerHandler("click")
						}
					}
				}

				function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming)
				{
					var CHECKED_CSS = "md-checked";
					return {
						restrict: "E",
						require: "^mdRadioGroup",
						transclude: true,
						template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-off"></div><div class="md-on"></div></div><div ng-transclude class="md-label"></div>',
						link: link
					};

					function link(scope, element, attr, rgCtrl)
					{
						var lastChecked;
						$mdTheming(element);
						configureAria(element, scope);
						attr.ngValue ? $mdUtil.nextTick(initialize, false) : initialize();

						function initialize()
						{
							if (!rgCtrl) throw "RadioButton: No RadioGroupController could be found.";
							rgCtrl.add(render);
							attr.$observe("value", render);
							element.on("click", listener).on("$destroy", function ()
							{
								rgCtrl.remove(render)
							})
						}

						function listener(ev)
						{
							if (element[0].hasAttribute("disabled") || rgCtrl.isDisabled()) return;
							scope.$apply(function ()
							{
								rgCtrl.setViewValue(attr.value, ev && ev.type)
							})
						}

						function render()
						{
							var checked = rgCtrl.getViewValue() == attr.value;
							if (checked === lastChecked) return;
							"md-radio-group" !== element[0].parentNode.nodeName.toLowerCase() && element.parent().toggleClass(CHECKED_CSS, checked);
							checked && rgCtrl.setActiveDescendant(element.attr("id"));
							lastChecked = checked;
							element.attr("aria-checked", checked).toggleClass(CHECKED_CSS, checked)
						}

						function configureAria(element, scope)
						{
							element.attr(
							{
								id: attr.id || "radio_" + $mdUtil.nextUid(),
								role: "radio",
								"aria-checked": "false"
							});
							$mdAria.expectWithText(element, "aria-label")
						}
					}
				}
			})();
			(function ()
			{
				SelectDirective.$inject = ["$mdSelect", "$mdUtil", "$mdConstant", "$mdTheming", "$mdAria", "$parse", "$sce", "$injector"];
				SelectMenuDirective.$inject = ["$parse", "$mdUtil", "$mdConstant", "$mdTheming"];
				OptionDirective.$inject = ["$mdButtonInkRipple", "$mdUtil", "$mdTheming"];
				SelectProvider.$inject = ["$$interimElementProvider"];
				var SELECT_EDGE_MARGIN = 8;
				var selectNextId = 0;
				var CHECKBOX_SELECTION_INDICATOR = angular.element('<div class="md-container"><div class="md-icon"></div></div>');
				angular.module("material.components.select", ["material.core", "material.components.backdrop"]).directive("mdSelect", SelectDirective).directive("mdSelectMenu", SelectMenuDirective).directive("mdOption", OptionDirective).directive("mdOptgroup", OptgroupDirective).directive("mdSelectHeader", SelectHeaderDirective).provider("$mdSelect", SelectProvider);

				function SelectDirective($mdSelect, $mdUtil, $mdConstant, $mdTheming, $mdAria, $parse, $sce, $injector)
				{
					var keyCodes = $mdConstant.KEY_CODE;
					keyCodes.SPACE, keyCodes.ENTER, keyCodes.UP_ARROW, keyCodes.DOWN_ARROW;
					return {
						restrict: "E",
						require: ["^?mdInputContainer", "mdSelect", "ngModel", "?^form"],
						compile: compile,
						controller: function () {}
					};

					function compile(element, attr)
					{
						var valueEl = angular.element("<md-select-value><span></span></md-select-value>");
						valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>');
						valueEl.addClass("md-select-value");
						valueEl[0].hasAttribute("id") || valueEl.attr("id", "select_value_label_" + $mdUtil.nextUid());
						var mdContentEl = element.find("md-content");
						mdContentEl.length || element.append(angular.element("<md-content>").append(element.contents()));
						mdContentEl.attr("role", "presentation");
						if (attr.mdOnOpen)
						{
							element.find("md-content").prepend(angular.element('<div> <md-progress-circular md-mode="indeterminate" ng-if="$$loadingAsyncDone === false" md-diameter="25px"></md-progress-circular></div>'));
							element.find("md-option").attr("ng-show", "$$loadingAsyncDone")
						}
						if (attr.name)
						{
							var autofillClone = angular.element('<select class="md-visually-hidden"></select>');
							autofillClone.attr(
							{
								name: attr.name,
								"aria-hidden": "true",
								tabindex: "-1"
							});
							var opts = element.find("md-option");
							angular.forEach(opts, function (el)
							{
								var newEl = angular.element("<option>" + el.innerHTML + "</option>");
								el.hasAttribute("ng-value") ? newEl.attr("ng-value", el.getAttribute("ng-value")) : el.hasAttribute("value") && newEl.attr("value", el.getAttribute("value"));
								autofillClone.append(newEl)
							});
							autofillClone.append('<option ng-value="' + attr.ngModel + '" selected></option>');
							element.parent().append(autofillClone)
						}
						var isMultiple = $mdUtil.parseAttributeBoolean(attr.multiple);
						var multipleContent = isMultiple ? "multiple" : "";
						var selectTemplate = '<div class="md-select-menu-container" aria-hidden="true" role="presentation"><md-select-menu role="presentation" {0}>{1}</md-select-menu></div>';
						selectTemplate = $mdUtil.supplant(selectTemplate, [multipleContent, element.html()]);
						element.empty().append(valueEl);
						element.append(selectTemplate);
						attr.tabindex || attr.$set("tabindex", 0);
						return function postLink(scope, element, attr, ctrls)
						{
							var untouched = true;
							var isDisabled, ariaLabelBase;
							var containerCtrl = ctrls[0];
							var mdSelectCtrl = ctrls[1];
							var ngModelCtrl = ctrls[2];
							var formCtrl = ctrls[3];
							var valueEl = element.find("md-select-value");
							var isReadonly = angular.isDefined(attr.readonly);
							var disableAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);
							disableAsterisk && element.addClass("md-no-asterisk");
							if (containerCtrl)
							{
								var isErrorGetter = containerCtrl.isErrorGetter || function ()
								{
									return ngModelCtrl.$invalid && (ngModelCtrl.$touched || formCtrl && formCtrl.$submitted)
								};
								if (containerCtrl.input && element.find("md-select-header").find("input")[0] !== containerCtrl.input[0]) throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
								containerCtrl.input = element;
								containerCtrl.label || $mdAria.expect(element, "aria-label", element.attr("placeholder"));
								scope.$watch(isErrorGetter, containerCtrl.setInvalid)
							}
							var selectContainer, selectScope, selectMenuCtrl;
							findSelectContainer();
							$mdTheming(element);
							formCtrl && angular.isDefined(attr.multiple) && $mdUtil.nextTick(function ()
							{
								var hasModelValue = ngModelCtrl.$modelValue || ngModelCtrl.$viewValue;
								hasModelValue && formCtrl.$setPristine()
							});
							var originalRender = ngModelCtrl.$render;
							ngModelCtrl.$render = function ()
							{
								originalRender();
								syncLabelText();
								syncAriaLabel();
								inputCheckValue()
							};
							attr.$observe("placeholder", ngModelCtrl.$render);
							containerCtrl && containerCtrl.label && attr.$observe("required", function (value)
							{
								containerCtrl.label.toggleClass("md-required", value && !disableAsterisk)
							});
							mdSelectCtrl.setLabelText = function (text)
							{
								mdSelectCtrl.setIsPlaceholder(!text);
								var isSelectLabelFromUser = false;
								if (attr.mdSelectedText && attr.mdSelectedHtml) throw Error("md-select cannot have both `md-selected-text` and `md-selected-html`");
								if (attr.mdSelectedText || attr.mdSelectedHtml)
								{
									text = $parse(attr.mdSelectedText || attr.mdSelectedHtml)(scope);
									isSelectLabelFromUser = true
								}
								else if (!text)
								{
									var tmpPlaceholder = attr.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : "");
									text = tmpPlaceholder || "";
									isSelectLabelFromUser = true
								}
								var target = valueEl.children().eq(0);
								attr.mdSelectedHtml ? target.html($sce.getTrustedHtml(text)) : isSelectLabelFromUser ? target.text(text) : target.html(text)
							};
							mdSelectCtrl.setIsPlaceholder = function (isPlaceholder)
							{
								if (isPlaceholder)
								{
									valueEl.addClass("md-select-placeholder");
									containerCtrl && containerCtrl.label && containerCtrl.label.addClass("md-placeholder")
								}
								else
								{
									valueEl.removeClass("md-select-placeholder");
									containerCtrl && containerCtrl.label && containerCtrl.label.removeClass("md-placeholder")
								}
							};
							if (!isReadonly)
							{
								element.on("focus", function (ev)
								{
									containerCtrl && containerCtrl.setFocused(true)
								});
								element.on("blur", function (event)
								{
									if (untouched)
									{
										untouched = false;
										selectScope._mdSelectIsOpen && event.stopImmediatePropagation()
									}
									if (selectScope._mdSelectIsOpen) return;
									containerCtrl && containerCtrl.setFocused(false);
									inputCheckValue()
								})
							}
							mdSelectCtrl.triggerClose = function ()
							{
								$parse(attr.mdOnClose)(scope)
							};
							scope.$$postDigest(function ()
							{
								initAriaLabel();
								syncLabelText();
								syncAriaLabel()
							});

							function initAriaLabel()
							{
								var labelText = element.attr("aria-label") || element.attr("placeholder");
								!labelText && containerCtrl && containerCtrl.label && (labelText = containerCtrl.label.text());
								ariaLabelBase = labelText;
								$mdAria.expect(element, "aria-label", labelText)
							}
							scope.$watch(function ()
							{
								return selectMenuCtrl.selectedLabels()
							}, syncLabelText);

							function syncLabelText()
							{
								if (selectContainer)
								{
									selectMenuCtrl = selectMenuCtrl || selectContainer.find("md-select-menu").controller("mdSelectMenu");
									mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels())
								}
							}

							function syncAriaLabel()
							{
								if (!ariaLabelBase) return;
								var ariaLabels = selectMenuCtrl.selectedLabels(
								{
									mode: "aria"
								});
								element.attr("aria-label", ariaLabels.length ? ariaLabelBase + ": " + ariaLabels : ariaLabelBase)
							}
							var deregisterWatcher;
							attr.$observe("ngMultiple", function (val)
							{
								deregisterWatcher && deregisterWatcher();
								var parser = $parse(val);
								deregisterWatcher = scope.$watch(function ()
								{
									return parser(scope)
								}, function (multiple, prevVal)
								{
									if (multiple === undefined && prevVal === undefined) return;
									multiple ? element.attr("multiple", "multiple") : element.removeAttr("multiple");
									element.attr("aria-multiselectable", multiple ? "true" : "false");
									if (selectContainer)
									{
										selectMenuCtrl.setMultiple(multiple);
										originalRender = ngModelCtrl.$render;
										ngModelCtrl.$render = function ()
										{
											originalRender();
											syncLabelText();
											syncAriaLabel();
											inputCheckValue()
										};
										ngModelCtrl.$render()
									}
								})
							});
							attr.$observe("disabled", function (disabled)
							{
								angular.isString(disabled) && (disabled = true);
								if (isDisabled !== undefined && isDisabled === disabled) return;
								isDisabled = disabled;
								disabled ? element.attr(
								{
									"aria-disabled": "true"
								}).removeAttr("tabindex").off("click", openSelect).off("keydown", handleKeypress) : element.attr(
								{
									tabindex: attr.tabindex,
									"aria-disabled": "false"
								}).on("click", openSelect).on("keydown", handleKeypress)
							});
							if (!attr.hasOwnProperty("disabled") && !attr.hasOwnProperty("ngDisabled"))
							{
								element.attr(
								{
									"aria-disabled": "false"
								});
								element.on("click", openSelect);
								element.on("keydown", handleKeypress)
							}
							var ariaAttrs = {
								role: "listbox",
								"aria-expanded": "false",
								"aria-multiselectable": isMultiple && !attr.ngMultiple ? "true" : "false"
							};
							element[0].hasAttribute("id") || (ariaAttrs.id = "select_" + $mdUtil.nextUid());
							var containerId = "select_container_" + $mdUtil.nextUid();
							selectContainer.attr("id", containerId);
							element.find("md-select-menu").length || (ariaAttrs["aria-owns"] = containerId);
							element.attr(ariaAttrs);
							scope.$on("$destroy", function ()
							{
								$mdSelect.destroy().finally(function ()
								{
									if (containerCtrl)
									{
										containerCtrl.setFocused(false);
										containerCtrl.setHasValue(false);
										containerCtrl.input = null
									}
									ngModelCtrl.$setTouched()
								})
							});

							function inputCheckValue()
							{
								containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity ||
								{}).badInput)
							}

							function findSelectContainer()
							{
								selectContainer = angular.element(element[0].querySelector(".md-select-menu-container"));
								selectScope = scope;
								if (attr.mdContainerClass)
								{
									var value = selectContainer[0].getAttribute("class") + " " + attr.mdContainerClass;
									selectContainer[0].setAttribute("class", value)
								}
								selectMenuCtrl = selectContainer.find("md-select-menu").controller("mdSelectMenu");
								selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
								element.on("$destroy", function ()
								{
									selectContainer.remove()
								})
							}

							function handleKeypress(e)
							{
								if ($mdConstant.isNavigationKey(e))
								{
									e.preventDefault();
									openSelect(e)
								}
								else if (shouldHandleKey(e, $mdConstant))
								{
									e.preventDefault();
									var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
									if (!node || node.hasAttribute("disabled")) return;
									var optionCtrl = angular.element(node).controller("mdOption");
									selectMenuCtrl.isMultiple || selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
									selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
									selectMenuCtrl.refreshViewValue()
								}
							}

							function openSelect()
							{
								selectScope._mdSelectIsOpen = true;
								element.attr("aria-expanded", "true");
								$mdSelect.show(
								{
									scope: selectScope,
									preserveScope: true,
									skipCompile: true,
									element: selectContainer,
									target: element[0],
									selectCtrl: mdSelectCtrl,
									preserveElement: true,
									hasBackdrop: true,
									loadingAsync: !!attr.mdOnOpen && (scope.$eval(attr.mdOnOpen) || true)
								}).finally(function ()
								{
									selectScope._mdSelectIsOpen = false;
									element.focus();
									element.attr("aria-expanded", "false");
									ngModelCtrl.$setTouched()
								})
							}
						}
					}
				}

				function SelectMenuDirective($parse, $mdUtil, $mdConstant, $mdTheming)
				{
					SelectMenuController.$inject = ["$scope", "$attrs", "$element"];
					return {
						restrict: "E",
						require: ["mdSelectMenu"],
						scope: false,
						controller: SelectMenuController,
						link:
						{
							pre: preLink
						}
					};

					function preLink(scope, element, attr, ctrls)
					{
						var selectCtrl = ctrls[0];
						element.addClass("_md");
						$mdTheming(element);
						element.on("click", clickListener);
						element.on("keypress", keyListener);

						function keyListener(e)
						{
							13 != e.keyCode && 32 != e.keyCode || clickListener(e)
						}

						function clickListener(ev)
						{
							var option = $mdUtil.getClosest(ev.target, "md-option");
							var optionCtrl = option && angular.element(option).data("$mdOptionController");
							if (!option || !optionCtrl) return;
							if (option.hasAttribute("disabled"))
							{
								ev.stopImmediatePropagation();
								return false
							}
							var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);
							var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);
							scope.$apply(function ()
							{
								if (selectCtrl.isMultiple) isSelected ? selectCtrl.deselect(optionHashKey) : selectCtrl.select(optionHashKey, optionCtrl.value);
								else if (!isSelected)
								{
									selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
									selectCtrl.select(optionHashKey, optionCtrl.value)
								}
								selectCtrl.refreshViewValue()
							})
						}
					}

					function SelectMenuController($scope, $attrs, $element)
					{
						var self = this;
						self.isMultiple = angular.isDefined($attrs.multiple);
						self.selected = {};
						self.options = {};
						$scope.$watchCollection(function ()
						{
							return self.options
						}, function ()
						{
							self.ngModel.$render()
						});
						var deregisterCollectionWatch;
						var defaultIsEmpty;
						self.setMultiple = function (isMultiple)
						{
							var ngModel = self.ngModel;
							defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;
							self.isMultiple = isMultiple;
							deregisterCollectionWatch && deregisterCollectionWatch();
							if (self.isMultiple)
							{
								ngModel.$validators["md-multiple"] = validateArray;
								ngModel.$render = renderMultiple;
								$scope.$watchCollection(self.modelBinding, function (value)
								{
									validateArray(value) && renderMultiple(value)
								});
								ngModel.$isEmpty = function (value)
								{
									return !value || 0 === value.length
								}
							}
							else
							{
								delete ngModel.$validators["md-multiple"];
								ngModel.$render = renderSingular
							}

							function validateArray(modelValue, viewValue)
							{
								return angular.isArray(modelValue || viewValue || [])
							}
						};
						var searchStr = "";
						var clearSearchTimeout, optNodes, optText;
						var CLEAR_SEARCH_AFTER = 300;
						self.optNodeForKeyboardSearch = function (e)
						{
							clearSearchTimeout && clearTimeout(clearSearchTimeout);
							clearSearchTimeout = setTimeout(function ()
							{
								clearSearchTimeout = undefined;
								searchStr = "";
								optText = undefined;
								optNodes = undefined
							}, CLEAR_SEARCH_AFTER);
							searchStr += e.key;
							var search = new RegExp("^" + searchStr, "i");
							if (!optNodes)
							{
								optNodes = $element.find("md-option");
								optText = new Array(optNodes.length);
								angular.forEach(optNodes, function (el, i)
								{
									optText[i] = el.textContent.trim()
								})
							}
							for (var i = 0; i < optText.length; ++i)
								if (search.test(optText[i])) return optNodes[i]
						};
						self.init = function (ngModel, binding)
						{
							self.ngModel = ngModel;
							self.modelBinding = binding;
							self.ngModel.$isEmpty = function ($viewValue)
							{
								return !self.options[self.hashGetter($viewValue)]
							};
							var trackByOption = $mdUtil.getModelOption(ngModel, "trackBy");
							if (trackByOption)
							{
								var trackByLocals = {};
								var trackByParsed = $parse(trackByOption);
								self.hashGetter = function (value, valueScope)
								{
									trackByLocals.$value = value;
									return trackByParsed(valueScope || $scope, trackByLocals)
								}
							}
							else self.hashGetter = function getHashValue(value)
							{
								if (angular.isObject(value)) return "object_" + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));
								return value
							};
							self.setMultiple(self.isMultiple)
						};
						self.selectedLabels = function (opts)
						{
							opts = opts ||
							{};
							var mode = opts.mode || "html";
							var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll("md-option[selected]"));
							if (selectedOptionEls.length)
							{
								var mapFn;
								"html" == mode ? mapFn = function (el)
								{
									if (el.hasAttribute("md-option-empty")) return "";
									var html = el.innerHTML;
									var rippleContainer = el.querySelector(".md-ripple-container");
									rippleContainer && (html = html.replace(rippleContainer.outerHTML, ""));
									var checkboxContainer = el.querySelector(".md-container");
									checkboxContainer && (html = html.replace(checkboxContainer.outerHTML, ""));
									return html
								} : "aria" == mode && (mapFn = function (el)
								{
									return el.hasAttribute("aria-label") ? el.getAttribute("aria-label") : el.textContent
								});
								return $mdUtil.uniq(selectedOptionEls.map(mapFn)).join(", ")
							}
							return ""
						};
						self.select = function (hashKey, hashedValue)
						{
							var option = self.options[hashKey];
							option && option.setSelected(true);
							self.selected[hashKey] = hashedValue
						};
						self.deselect = function (hashKey)
						{
							var option = self.options[hashKey];
							option && option.setSelected(false);
							delete self.selected[hashKey]
						};
						self.addOption = function (hashKey, optionCtrl)
						{
							if (angular.isDefined(self.options[hashKey])) throw new Error('Duplicate md-option values are not allowed in a select. Duplicate value "' + optionCtrl.value + '" found.');
							self.options[hashKey] = optionCtrl;
							if (angular.isDefined(self.selected[hashKey]))
							{
								self.select(hashKey, optionCtrl.value);
								angular.isDefined(self.ngModel.$modelValue) && self.hashGetter(self.ngModel.$modelValue) === hashKey && self.ngModel.$validate();
								self.refreshViewValue()
							}
						};
						self.removeOption = function (hashKey)
						{
							delete self.options[hashKey]
						};
						self.refreshViewValue = function ()
						{
							var values = [];
							var option;
							for (var hashKey in self.selected)(option = self.options[hashKey]) ? values.push(option.value) : values.push(self.selected[hashKey]);
							var usingTrackBy = $mdUtil.getModelOption(self.ngModel, "trackBy");
							var newVal = self.isMultiple ? values : values[0];
							var prevVal = self.ngModel.$modelValue;
							if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal + "" !== newVal)
							{
								self.ngModel.$setViewValue(newVal);
								self.ngModel.$render()
							}
						};

						function renderMultiple()
						{
							var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
							if (!angular.isArray(newSelectedValues)) return;
							var oldSelected = Object.keys(self.selected);
							var newSelectedHashes = newSelectedValues.map(self.hashGetter);
							var deselected = oldSelected.filter(function (hash)
							{
								return -1 === newSelectedHashes.indexOf(hash)
							});
							deselected.forEach(self.deselect);
							newSelectedHashes.forEach(function (hashKey, i)
							{
								self.select(hashKey, newSelectedValues[i])
							})
						}

						function renderSingular()
						{
							var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
							Object.keys(self.selected).forEach(self.deselect);
							self.select(self.hashGetter(value), value)
						}
					}
				}

				function OptionDirective($mdButtonInkRipple, $mdUtil, $mdTheming)
				{
					OptionController.$inject = ["$element"];
					return {
						restrict: "E",
						require: ["mdOption", "^^mdSelectMenu"],
						controller: OptionController,
						compile: compile
					};

					function compile(element, attr)
					{
						element.append(angular.element('<div class="md-text">').append(element.contents()));
						element.attr("tabindex", attr.tabindex || "0");
						hasDefinedValue(attr) || element.attr("md-option-empty", "");
						return postLink
					}

					function hasDefinedValue(attr)
					{
						var value = attr.value;
						var ngValue = attr.ngValue;
						return value || ngValue
					}

					function postLink(scope, element, attr, ctrls)
					{
						var optionCtrl = ctrls[0];
						var selectCtrl = ctrls[1];
						$mdTheming(element);
						if (selectCtrl.isMultiple)
						{
							element.addClass("md-checkbox-enabled");
							element.prepend(CHECKBOX_SELECTION_INDICATOR.clone())
						}
						angular.isDefined(attr.ngValue) ? scope.$watch(attr.ngValue, setOptionValue) : angular.isDefined(attr.value) ? setOptionValue(attr.value) : scope.$watch(function ()
						{
							return element.text().trim()
						}, setOptionValue);
						attr.$observe("disabled", function (disabled)
						{
							disabled ? element.attr("tabindex", "-1") : element.attr("tabindex", "0")
						});
						scope.$$postDigest(function ()
						{
							attr.$observe("selected", function (selected)
							{
								if (!angular.isDefined(selected)) return;
								"string" == typeof selected && (selected = true);
								if (selected)
								{
									selectCtrl.isMultiple || selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
									selectCtrl.select(optionCtrl.hashKey, optionCtrl.value)
								}
								else selectCtrl.deselect(optionCtrl.hashKey);
								selectCtrl.refreshViewValue()
							})
						});
						$mdButtonInkRipple.attach(scope, element);
						configureAria();

						function setOptionValue(newValue, oldValue, prevAttempt)
						{
							if (!selectCtrl.hashGetter)
							{
								prevAttempt || scope.$$postDigest(function ()
								{
									setOptionValue(newValue, oldValue, true)
								});
								return
							}
							var oldHashKey = selectCtrl.hashGetter(oldValue, scope);
							var newHashKey = selectCtrl.hashGetter(newValue, scope);
							optionCtrl.hashKey = newHashKey;
							optionCtrl.value = newValue;
							selectCtrl.removeOption(oldHashKey, optionCtrl);
							selectCtrl.addOption(newHashKey, optionCtrl)
						}
						scope.$on("$destroy", function ()
						{
							selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl)
						});

						function configureAria()
						{
							var ariaAttrs = {
								role: "option",
								"aria-selected": "false"
							};
							element[0].hasAttribute("id") || (ariaAttrs.id = "select_option_" + $mdUtil.nextUid());
							element.attr(ariaAttrs)
						}
					}

					function OptionController($element)
					{
						this.selected = false;
						this.setSelected = function (isSelected)
						{
							if (isSelected && !this.selected) $element.attr(
							{
								selected: "selected",
								"aria-selected": "true"
							});
							else if (!isSelected && this.selected)
							{
								$element.removeAttr("selected");
								$element.attr("aria-selected", "false")
							}
							this.selected = isSelected
						}
					}
				}

				function OptgroupDirective()
				{
					return {
						restrict: "E",
						compile: compile
					};

					function compile(el, attrs)
					{
						hasSelectHeader() || setupLabelElement();

						function hasSelectHeader()
						{
							return el.parent().find("md-select-header").length
						}

						function setupLabelElement()
						{
							var labelElement = el.find("label");
							if (!labelElement.length)
							{
								labelElement = angular.element("<label>");
								el.prepend(labelElement)
							}
							labelElement.addClass("md-container-ignore");
							labelElement.attr("aria-hidden", "true");
							attrs.label && labelElement.text(attrs.label)
						}
					}
				}

				function SelectHeaderDirective()
				{
					return {
						restrict: "E"
					}
				}

				function SelectProvider($$interimElementProvider)
				{
					selectDefaultOptions.$inject = ["$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document"];
					return $$interimElementProvider("$mdSelect").setDefaults(
					{
						methods: ["target"],
						options: selectDefaultOptions
					});

					function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document)
					{
						var ERROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!";
						var animator = $mdUtil.dom.animator;
						var keyCodes = $mdConstant.KEY_CODE;
						return {
							parent: "body",
							themable: true,
							onShow: onShow,
							onRemove: onRemove,
							hasBackdrop: true,
							disableParentScroll: true
						};

						function onRemove(scope, element, opts)
						{
							var animationRunner = null;
							var destroyListener = scope.$on("$destroy", function ()
							{
								animationRunner.end()
							});
							opts = opts ||
							{};
							opts.cleanupInteraction();
							opts.cleanupResizing();
							opts.hideBackdrop();
							return true === opts.$destroy ? cleanElement() : animateRemoval().then(cleanElement);

							function animateRemoval()
							{
								animationRunner = $animateCss(element,
								{
									addClass: "md-leave"
								});
								return animationRunner.start()
							}

							function cleanElement()
							{
								destroyListener();
								element.removeClass("md-active").attr("aria-hidden", "true").css("display", "none");
								element.parent().find("md-select-value").removeAttr("aria-hidden");
								announceClosed(opts);
								!opts.$destroy && opts.restoreFocus && opts.target.focus()
							}
						}

						function onShow(scope, element, opts)
						{
							watchAsyncLoad();
							sanitizeAndConfigure(scope, opts);
							opts.hideBackdrop = showBackdrop(scope, element, opts);
							return showDropDown(scope, element, opts).then(function (response)
							{
								element.attr("aria-hidden", "false");
								opts.alreadyOpen = true;
								opts.cleanupInteraction = activateInteraction();
								opts.cleanupResizing = activateResizing();
								autoFocus(opts.focusedNode);
								return response
							}, opts.hideBackdrop);

							function showDropDown(scope, element, opts)
							{
								opts.parent !== element.parent() && element.parent().attr("aria-owns", element.attr("id"));
								element.parent().find("md-select-value").attr("aria-hidden", "true");
								opts.parent.append(element);
								return $q(function (resolve, reject)
								{
									try
									{
										$animateCss(element,
										{
											removeClass: "md-leave",
											duration: 0
										}).start().then(positionAndFocusMenu).then(resolve)
									}
									catch (e)
									{
										reject(e)
									}
								})
							}

							function positionAndFocusMenu()
							{
								return $q(function (resolve)
								{
									if (opts.isRemoved) return $q.reject(false);
									var info = calculateMenuPositions(scope, element, opts);
									info.container.element.css(animator.toCss(info.container.styles));
									info.dropDown.element.css(animator.toCss(info.dropDown.styles));
									$$rAF(function ()
									{
										element.addClass("md-active");
										info.dropDown.element.css(animator.toCss(
										{
											transform: ""
										}));
										resolve()
									})
								})
							}

							function showBackdrop(scope, element, options)
							{
								options.disableParentScroll && !$mdUtil.getClosest(options.target, "MD-DIALOG") ? options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent) : options.disableParentScroll = false;
								if (options.hasBackdrop)
								{
									options.backdrop = $mdUtil.createBackdrop(scope, "md-select-backdrop md-click-catcher");
									$animate.enter(options.backdrop, $document[0].body, null,
									{
										duration: 0
									})
								}
								return function hideBackdrop()
								{
									options.backdrop && options.backdrop.remove();
									options.disableParentScroll && options.restoreScroll();
									delete options.restoreScroll
								}
							}

							function autoFocus(focusedNode)
							{
								focusedNode && !focusedNode.hasAttribute("disabled") && focusedNode.focus()
							}

							function sanitizeAndConfigure(scope, options)
							{
								var selectEl = element.find("md-select-menu");
								if (!options.target) throw new Error($mdUtil.supplant(ERROR_TARGET_EXPECTED, [options.target]));
								angular.extend(options,
								{
									isRemoved: false,
									target: angular.element(options.target),
									parent: angular.element(options.parent),
									selectEl: selectEl,
									contentEl: element.find("md-content"),
									optionNodes: selectEl[0].getElementsByTagName("md-option")
								})
							}

							function activateResizing()
							{
								var debouncedOnResize = function (scope, target, options)
								{
									return function ()
									{
										if (options.isRemoved) return;
										var updates = calculateMenuPositions(scope, target, options);
										var container = updates.container;
										var dropDown = updates.dropDown;
										container.element.css(animator.toCss(container.styles));
										dropDown.element.css(animator.toCss(dropDown.styles))
									}
								}(scope, element, opts);
								var window = angular.element($window);
								window.on("resize", debouncedOnResize);
								window.on("orientationchange", debouncedOnResize);
								return function deactivateResizing()
								{
									window.off("resize", debouncedOnResize);
									window.off("orientationchange", debouncedOnResize)
								}
							}

							function watchAsyncLoad()
							{
								if (opts.loadingAsync && !opts.isRemoved)
								{
									scope.$$loadingAsyncDone = false;
									$q.when(opts.loadingAsync).then(function ()
									{
										scope.$$loadingAsyncDone = true;
										delete opts.loadingAsync
									}).then(function ()
									{
										$$rAF(positionAndFocusMenu)
									})
								}
							}

							function activateInteraction()
							{
								if (opts.isRemoved) return;
								var dropDown = opts.selectEl;
								var selectCtrl = dropDown.controller("mdSelectMenu") ||
								{};
								element.addClass("md-clickable");
								opts.backdrop && opts.backdrop.on("click", onBackdropClick);
								dropDown.on("keydown", onMenuKeyDown);
								dropDown.on("click", checkCloseMenu);
								return function cleanupInteraction()
								{
									opts.backdrop && opts.backdrop.off("click", onBackdropClick);
									dropDown.off("keydown", onMenuKeyDown);
									dropDown.off("click", checkCloseMenu);
									element.removeClass("md-clickable");
									opts.isRemoved = true
								};

								function onBackdropClick(e)
								{
									e.preventDefault();
									e.stopPropagation();
									opts.restoreFocus = false;
									$mdUtil.nextTick($mdSelect.hide, true)
								}

								function onMenuKeyDown(ev)
								{
									ev.preventDefault();
									ev.stopPropagation();
									switch (ev.keyCode)
									{
									case keyCodes.UP_ARROW:
										return focusPrevOption();
									case keyCodes.DOWN_ARROW:
										return focusNextOption();
									case keyCodes.SPACE:
									case keyCodes.ENTER:
										var option = $mdUtil.getClosest(ev.target, "md-option");
										if (option)
										{
											dropDown.triggerHandler(
											{
												type: "click",
												target: option
											});
											ev.preventDefault()
										}
										checkCloseMenu(ev);
										break;
									case keyCodes.TAB:
									case keyCodes.ESCAPE:
										ev.stopPropagation();
										ev.preventDefault();
										opts.restoreFocus = true;
										$mdUtil.nextTick($mdSelect.hide, true);
										break;
									default:
										if (shouldHandleKey(ev, $mdConstant))
										{
											var optNode = dropDown.controller("mdSelectMenu").optNodeForKeyboardSearch(ev);
											opts.focusedNode = optNode || opts.focusedNode;
											optNode && optNode.focus()
										}
									}
								}

								function focusOption(direction)
								{
									var optionsArray = $mdUtil.nodesToArray(opts.optionNodes);
									var index = optionsArray.indexOf(opts.focusedNode);
									var newOption;
									do {
										-1 === index ? index = 0 : "next" === direction && index < optionsArray.length - 1 ? index++ : "prev" === direction && index > 0 && index--;
										newOption = optionsArray[index];
										newOption.hasAttribute("disabled") && (newOption = undefined)
									} while (!newOption && index < optionsArray.length - 1 && index > 0);
									newOption && newOption.focus();
									opts.focusedNode = newOption
								}

								function focusNextOption()
								{
									focusOption("next")
								}

								function focusPrevOption()
								{
									focusOption("prev")
								}

								function checkCloseMenu(ev)
								{
									if (ev && "click" == ev.type && ev.currentTarget != dropDown[0]) return;
									if (mouseOnScrollbar()) return;
									var option = $mdUtil.getClosest(ev.target, "md-option");
									if (option && option.hasAttribute && !option.hasAttribute("disabled"))
									{
										ev.preventDefault();
										ev.stopPropagation();
										if (!selectCtrl.isMultiple)
										{
											opts.restoreFocus = true;
											$mdUtil.nextTick(function ()
											{
												$mdSelect.hide(selectCtrl.ngModel.$viewValue)
											}, true)
										}
									}

									function mouseOnScrollbar()
									{
										var clickOnScrollbar = false;
										if (ev && ev.currentTarget.children.length > 0)
										{
											var child = ev.currentTarget.children[0];
											var hasScrollbar = child.scrollHeight > child.clientHeight;
											if (hasScrollbar && child.children.length > 0)
											{
												var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
												relPosX > child.querySelector("md-option").offsetWidth && (clickOnScrollbar = true)
											}
										}
										return clickOnScrollbar
									}
								}
							}
						}

						function announceClosed(opts)
						{
							var mdSelect = opts.selectCtrl;
							if (mdSelect)
							{
								var menuController = opts.selectEl.controller("mdSelectMenu");
								mdSelect.setLabelText(menuController ? menuController.selectedLabels() : "");
								mdSelect.triggerClose()
							}
						}

						function calculateMenuPositions(scope, element, opts)
						{
							var centeredNode, containerNode = element[0],
								targetNode = opts.target[0].children[0],
								parentNode = $document[0].body,
								selectNode = opts.selectEl[0],
								contentNode = opts.contentEl[0],
								parentRect = parentNode.getBoundingClientRect(),
								targetRect = targetNode.getBoundingClientRect(),
								shouldOpenAroundTarget = false,
								bounds = {
									left: parentRect.left + SELECT_EDGE_MARGIN,
									top: SELECT_EDGE_MARGIN,
									bottom: parentRect.height - SELECT_EDGE_MARGIN,
									right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
								},
								spaceAvailable = {
									top: targetRect.top - bounds.top,
									left: targetRect.left - bounds.left,
									right: bounds.right - (targetRect.left + targetRect.width),
									bottom: bounds.bottom - (targetRect.top + targetRect.height)
								},
								maxWidth = parentRect.width - 2 * SELECT_EDGE_MARGIN,
								selectedNode = selectNode.querySelector("md-option[selected]"),
								optionNodes = selectNode.getElementsByTagName("md-option"),
								optgroupNodes = selectNode.getElementsByTagName("md-optgroup"),
								isScrollable = calculateScrollable(element, contentNode);
							var loading = isPromiseLike(opts.loadingAsync);
							centeredNode = loading ? contentNode.firstElementChild || contentNode : selectedNode || (optgroupNodes.length ? optgroupNodes[0] : optionNodes.length ? optionNodes[0] : contentNode.firstElementChild || contentNode);
							contentNode.offsetWidth > maxWidth ? contentNode.style["max-width"] = maxWidth + "px" : contentNode.style.maxWidth = null;
							shouldOpenAroundTarget && (contentNode.style["min-width"] = targetRect.width + "px");
							isScrollable && selectNode.classList.add("md-overflow");
							var focusedNode = centeredNode;
							if ("MD-OPTGROUP" === (focusedNode.tagName || "").toUpperCase())
							{
								focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
								centeredNode = focusedNode
							}
							opts.focusedNode = focusedNode;
							containerNode.style.display = "block";
							var selectMenuRect = selectNode.getBoundingClientRect();
							var centeredRect = getOffsetRect(centeredNode);
							if (centeredNode)
							{
								var centeredStyle = $window.getComputedStyle(centeredNode);
								centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
								centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0
							}
							if (isScrollable)
							{
								var scrollBuffer = contentNode.offsetHeight / 2;
								contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;
								spaceAvailable.top < scrollBuffer ? contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top) : spaceAvailable.bottom < scrollBuffer && (contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom))
							}
							var left, top, transformOrigin, minWidth, fontSize;
							if (shouldOpenAroundTarget)
							{
								left = targetRect.left;
								top = targetRect.top + targetRect.height;
								transformOrigin = "50% 0";
								if (top + selectMenuRect.height > bounds.bottom)
								{
									top = targetRect.top - selectMenuRect.height;
									transformOrigin = "50% 100%"
								}
							}
							else
							{
								left = targetRect.left + centeredRect.left - centeredRect.paddingLeft + 2;
								top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2;
								transformOrigin = centeredRect.left + targetRect.width / 2 + "px " + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + "px 0px";
								minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);
								fontSize = window.getComputedStyle(targetNode)["font-size"]
							}
							var containerRect = containerNode.getBoundingClientRect();
							var scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1)) / 100;
							var scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1)) / 100;
							return {
								container:
								{
									element: angular.element(containerNode),
									styles:
									{
										left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
										top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
										"min-width": minWidth,
										"font-size": fontSize
									}
								},
								dropDown:
								{
									element: angular.element(selectNode),
									styles:
									{
										transformOrigin: transformOrigin,
										transform: opts.alreadyOpen ? "" : $mdUtil.supplant("scale({0},{1})", [scaleX, scaleY])
									}
								}
							}
						}
					}

					function isPromiseLike(obj)
					{
						return obj && angular.isFunction(obj.then)
					}

					function clamp(min, n, max)
					{
						return Math.max(min, Math.min(n, max))
					}

					function getOffsetRect(node)
					{
						return node ?
						{
							left: node.offsetLeft,
							top: node.offsetTop,
							width: node.offsetWidth,
							height: node.offsetHeight
						} :
						{
							left: 0,
							top: 0,
							width: 0,
							height: 0
						}
					}

					function calculateScrollable(element, contentNode)
					{
						var isScrollable = false;
						try
						{
							var oldDisplay = element[0].style.display;
							element[0].style.display = "block";
							isScrollable = contentNode.scrollHeight > contentNode.offsetHeight;
							element[0].style.display = oldDisplay
						}
						finally
						{}
						return isScrollable
					}
				}

				function shouldHandleKey(ev, $mdConstant)
				{
					var char = String.fromCharCode(ev.keyCode);
					var isNonUsefulKey = ev.keyCode <= 31;
					return char && char.length && !isNonUsefulKey && !$mdConstant.isMetaKey(ev) && !$mdConstant.isFnLockKey(ev) && !$mdConstant.hasModifierKey(ev)
				}
			})();
			(function ()
			{
				angular.module("material.components.showHide", ["material.core"]).directive("ngShow", createDirective("ngShow", true)).directive("ngHide", createDirective("ngHide", false));

				function createDirective(name, targetValue)
				{
					return ["$mdUtil", "$window", function ($mdUtil, $window)
					{
						return {
							restrict: "A",
							multiElement: true,
							link: function ($scope, $element, $attr)
							{
								var unregister = $scope.$on("$md-resize-enable", function ()
								{
									unregister();
									var node = $element[0];
									var cachedTransitionStyles = node.nodeType === $window.Node.ELEMENT_NODE ? $window.getComputedStyle(node) :
									{};
									$scope.$watch($attr[name], function (value)
									{
										if (!!value === targetValue)
										{
											$mdUtil.nextTick(function ()
											{
												$scope.$broadcast("$md-resize")
											});
											var opts = {
												cachedTransitionStyles: cachedTransitionStyles
											};
											$mdUtil.dom.animator.waitTransitionEnd($element, opts).then(function ()
											{
												$scope.$broadcast("$md-resize")
											})
										}
									})
								})
							}
						}
					}]
				}
			})();
			(function ()
			{
				SidenavService.$inject = ["$mdComponentRegistry", "$mdUtil", "$q", "$log"];
				SidenavDirective.$inject = ["$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$mdInteraction", "$animate", "$compile", "$parse", "$log", "$q", "$document", "$window", "$$rAF"];
				SidenavController.$inject = ["$scope", "$attrs", "$mdComponentRegistry", "$q", "$interpolate"];
				angular.module("material.components.sidenav", ["material.core", "material.components.backdrop"]).factory("$mdSidenav", SidenavService).directive("mdSidenav", SidenavDirective).directive("mdSidenavFocus", SidenavFocusDirective).controller("$mdSidenavController", SidenavController);

				function SidenavService($mdComponentRegistry, $mdUtil, $q, $log)
				{
					var errorMsg = "SideNav '{0}' is not available! Did you use md-component-id='{0}'?";
					var service = {
						find: findInstance,
						waitFor: waitForInstance
					};
					return function (handle, enableWait)
					{
						if (angular.isUndefined(handle)) return service;
						var shouldWait = true === enableWait;
						var instance = service.find(handle, shouldWait);
						return !instance && shouldWait ? service.waitFor(handle) : !instance && angular.isUndefined(enableWait) ? addLegacyAPI(service, handle) : instance
					};

					function addLegacyAPI(service, handle)
					{
						var falseFn = function ()
						{
							return false
						};
						var rejectFn = function ()
						{
							return $q.when($mdUtil.supplant(errorMsg, [handle || ""]))
						};
						return angular.extend(
						{
							isLockedOpen: falseFn,
							isOpen: falseFn,
							toggle: rejectFn,
							open: rejectFn,
							close: rejectFn,
							onClose: angular.noop,
							then: function (callback)
							{
								return waitForInstance(handle).then(callback || angular.noop)
							}
						}, service)
					}

					function findInstance(handle, shouldWait)
					{
						var instance = $mdComponentRegistry.get(handle);
						if (!instance && !shouldWait)
						{
							$log.error($mdUtil.supplant(errorMsg, [handle || ""]));
							return undefined
						}
						return instance
					}

					function waitForInstance(handle)
					{
						return $mdComponentRegistry.when(handle).catch($log.error)
					}
				}

				function SidenavFocusDirective()
				{
					return {
						restrict: "A",
						require: "^mdSidenav",
						link: function (scope, element, attr, sidenavCtrl) {}
					}
				}

				function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $mdInteraction, $animate, $compile, $parse, $log, $q, $document, $window, $$rAF)
				{
					return {
						restrict: "E",
						scope:
						{
							isOpen: "=?mdIsOpen"
						},
						controller: "$mdSidenavController",
						compile: function (element)
						{
							element.addClass("md-closed").attr("tabIndex", "-1");
							return postLink
						}
					};

					function postLink(scope, element, attr, sidenavCtrl)
					{
						var lastParentOverFlow;
						var backdrop;
						var disableScrollTarget = null;
						var triggeringInteractionType;
						var triggeringElement = null;
						var previousContainerStyles;
						var promise = $q.when(true);
						var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);
						var ngWindow = angular.element($window);
						var isLocked = function ()
						{
							return isLockedOpenParsed(scope.$parent,
							{
								$media: function (arg)
								{
									$log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
									return $mdMedia(arg)
								},
								$mdMedia: $mdMedia
							})
						};
						if (attr.mdDisableScrollTarget)
						{
							disableScrollTarget = $document[0].querySelector(attr.mdDisableScrollTarget);
							disableScrollTarget ? disableScrollTarget = angular.element(disableScrollTarget) : $log.warn($mdUtil.supplant('mdSidenav: couldn\'t find element matching selector "{selector}". Falling back to parent.',
							{
								selector: attr.mdDisableScrollTarget
							}))
						}
						disableScrollTarget || (disableScrollTarget = element.parent());
						attr.hasOwnProperty("mdDisableBackdrop") || (backdrop = $mdUtil.createBackdrop(scope, "md-sidenav-backdrop md-opaque ng-enter"));
						if (attr.hasOwnProperty("mdDisableCloseEvents")) var disableCloseEvents = true;
						element.addClass("_md");
						$mdTheming(element);
						backdrop && $mdTheming.inherit(backdrop, element);
						element.on("$destroy", function ()
						{
							backdrop && backdrop.remove();
							sidenavCtrl.destroy()
						});
						scope.$on("$destroy", function ()
						{
							backdrop && backdrop.remove()
						});
						scope.$watch(isLocked, updateIsLocked);
						scope.$watch("isOpen", updateIsOpen);
						sidenavCtrl.$toggleOpen = toggleOpen;

						function updateIsLocked(isLocked, oldValue)
						{
							scope.isLockedOpen = isLocked;
							isLocked === oldValue ? element.toggleClass("md-locked-open", !!isLocked) : $animate[isLocked ? "addClass" : "removeClass"](element, "md-locked-open");
							backdrop && backdrop.toggleClass("md-locked-open", !!isLocked)
						}

						function updateIsOpen(isOpen)
						{
							var focusEl = $mdUtil.findFocusTarget(element) || $mdUtil.findFocusTarget(element, "[md-sidenav-focus]") || element;
							var parent = element.parent();
							if (!disableCloseEvents)
							{
								parent[isOpen ? "on" : "off"]("keydown", onKeyDown);
								backdrop && backdrop[isOpen ? "on" : "off"]("click", close)
							}
							var restorePositioning = updateContainerPositions(parent, isOpen);
							if (isOpen)
							{
								triggeringElement = $document[0].activeElement;
								triggeringInteractionType = $mdInteraction.getLastInteractionType()
							}
							disableParentScroll(isOpen);
							return promise = $q.all([isOpen && backdrop ? $animate.enter(backdrop, parent) : backdrop ? $animate.leave(backdrop) : $q.when(true), $animate[isOpen ? "removeClass" : "addClass"](element, "md-closed")]).then(function ()
							{
								if (scope.isOpen)
								{
									$$rAF(function ()
									{
										ngWindow.triggerHandler("resize")
									});
									focusEl && focusEl.focus()
								}
								restorePositioning && restorePositioning()
							})
						}

						function updateContainerPositions(parent, willOpen)
						{
							var drawerEl = element[0];
							var scrollTop = parent[0].scrollTop;
							if (willOpen && scrollTop)
							{
								previousContainerStyles = {
									top: drawerEl.style.top,
									bottom: drawerEl.style.bottom,
									height: drawerEl.style.height
								};
								var positionStyle = {
									top: scrollTop + "px",
									bottom: "auto",
									height: parent[0].clientHeight + "px"
								};
								element.css(positionStyle);
								backdrop.css(positionStyle)
							}
							if (!willOpen && previousContainerStyles) return function ()
							{
								drawerEl.style.top = previousContainerStyles.top;
								drawerEl.style.bottom = previousContainerStyles.bottom;
								drawerEl.style.height = previousContainerStyles.height;
								backdrop[0].style.top = null;
								backdrop[0].style.bottom = null;
								backdrop[0].style.height = null;
								previousContainerStyles = null
							}
						}

						function disableParentScroll(disabled)
						{
							if (disabled && !lastParentOverFlow)
							{
								lastParentOverFlow = disableScrollTarget.css("overflow");
								disableScrollTarget.css("overflow", "hidden")
							}
							else if (angular.isDefined(lastParentOverFlow))
							{
								disableScrollTarget.css("overflow", lastParentOverFlow);
								lastParentOverFlow = undefined
							}
						}

						function toggleOpen(isOpen)
						{
							if (scope.isOpen == isOpen) return $q.when(true);
							scope.isOpen && sidenavCtrl.onCloseCb && sidenavCtrl.onCloseCb();
							return $q(function (resolve)
							{
								scope.isOpen = isOpen;
								$mdUtil.nextTick(function ()
								{
									promise.then(function (result)
									{
										if (!scope.isOpen && triggeringElement && "keyboard" === triggeringInteractionType)
										{
											triggeringElement.focus();
											triggeringElement = null
										}
										resolve(result)
									})
								})
							})
						}

						function onKeyDown(ev)
						{
							var isEscape = ev.keyCode === $mdConstant.KEY_CODE.ESCAPE;
							return isEscape ? close(ev) : $q.when(true)
						}

						function close(ev)
						{
							ev.preventDefault();
							return sidenavCtrl.close()
						}
					}
				}

				function SidenavController($scope, $attrs, $mdComponentRegistry, $q, $interpolate)
				{
					var self = this;
					self.isOpen = function ()
					{
						return !!$scope.isOpen
					};
					self.isLockedOpen = function ()
					{
						return !!$scope.isLockedOpen
					};
					self.onClose = function (callback)
					{
						self.onCloseCb = callback;
						return self
					};
					self.open = function ()
					{
						return self.$toggleOpen(true)
					};
					self.close = function ()
					{
						return self.$toggleOpen(false)
					};
					self.toggle = function ()
					{
						return self.$toggleOpen(!$scope.isOpen)
					};
					self.$toggleOpen = function (value)
					{
						return $q.when($scope.isOpen = value)
					};
					var rawId = $attrs.mdComponentId;
					var hasDataBinding = rawId && rawId.indexOf($interpolate.startSymbol()) > -1;
					var componentId = hasDataBinding ? $interpolate(rawId)($scope.$parent) : rawId;
					self.destroy = $mdComponentRegistry.register(self, componentId);
					hasDataBinding && $attrs.$observe("mdComponentId", function (id)
					{
						if (id && id !== self.$$mdHandle)
						{
							self.destroy();
							self.destroy = $mdComponentRegistry.register(self, id)
						}
					})
				}
			})();
			(function ()
			{
				SliderDirective.$inject = ["$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log", "$timeout"];
				angular.module("material.components.slider", ["material.core"]).directive("mdSlider", SliderDirective).directive("mdSliderContainer", SliderContainerDirective);

				function SliderContainerDirective()
				{
					return {
						controller: function () {},
						compile: function (elem)
						{
							var slider = elem.find("md-slider");
							if (!slider) return;
							var vertical = slider.attr("md-vertical");
							vertical !== undefined && elem.attr("md-vertical", "");
							slider.attr("flex") || slider.attr("flex", "");
							return function postLink(scope, element, attr, ctrl)
							{
								element.addClass("_md");

								function setDisable(value)
								{
									element.children().attr("disabled", value);
									element.find("input").attr("disabled", value)
								}
								var stopDisabledWatch = angular.noop;
								attr.disabled ? setDisable(true) : attr.ngDisabled && (stopDisabledWatch = scope.$watch(attr.ngDisabled, function (value)
								{
									setDisable(value)
								}));
								scope.$on("$destroy", function ()
								{
									stopDisabledWatch()
								});
								var initialMaxWidth;
								ctrl.fitInputWidthToTextLength = function (length)
								{
									var input = element[0].querySelector("md-input-container");
									if (input)
									{
										var computedStyle = getComputedStyle(input);
										var minWidth = parseInt(computedStyle.minWidth);
										var padding = parseInt(computedStyle.paddingLeft) + parseInt(computedStyle.paddingRight);
										initialMaxWidth = initialMaxWidth || parseInt(computedStyle.maxWidth);
										var newMaxWidth = Math.max(initialMaxWidth, minWidth + padding + minWidth / 2 * length);
										input.style.maxWidth = newMaxWidth + "px"
									}
								}
							}
						}
					}
				}

				function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log, $timeout)
				{
					return {
						scope:
						{},
						require: ["?ngModel", "?^mdSliderContainer"],
						template: '<div class="md-slider-wrapper"><div class="md-slider-content"><div class="md-track-container"><div class="md-track"></div><div class="md-track md-track-fill"></div><div class="md-track-ticks"></div></div><div class="md-thumb-container"><div class="md-thumb"></div><div class="md-focus-thumb"></div><div class="md-focus-ring"></div><div class="md-sign"><span class="md-thumb-text"></span></div><div class="md-disabled-thumb"></div></div></div></div>',
						compile: compile
					};

					function compile(tElement, tAttrs)
					{
						var wrapper = angular.element(tElement[0].getElementsByClassName("md-slider-wrapper"));
						var tabIndex = tAttrs.tabindex || 0;
						wrapper.attr("tabindex", tabIndex);
						(tAttrs.disabled || tAttrs.ngDisabled) && wrapper.attr("tabindex", -1);
						tElement.attr("role", "slider");
						$mdAria.expect(tElement, "aria-label");
						return postLink
					}

					function postLink(scope, element, attr, ctrls)
					{
						$mdTheming(element);
						var ngModelCtrl = ctrls[0] ||
						{
							$setViewValue: function (val)
							{
								this.$viewValue = val;
								this.$viewChangeListeners.forEach(function (cb)
								{
									cb()
								})
							},
							$parsers: [],
							$formatters: [],
							$viewChangeListeners: []
						};
						var containerCtrl = ctrls[1];
						angular.element($mdUtil.getClosest(element, "_md-slider-container", true));
						var isDisabled = attr.ngDisabled ? angular.bind(null, $parse(attr.ngDisabled), scope.$parent) : function ()
						{
							return element[0].hasAttribute("disabled")
						};
						var thumb = angular.element(element[0].querySelector(".md-thumb"));
						var thumbText = angular.element(element[0].querySelector(".md-thumb-text"));
						var thumbContainer = thumb.parent();
						var trackContainer = angular.element(element[0].querySelector(".md-track-container"));
						var activeTrack = angular.element(element[0].querySelector(".md-track-fill"));
						var tickContainer = angular.element(element[0].querySelector(".md-track-ticks"));
						var wrapper = angular.element(element[0].getElementsByClassName("md-slider-wrapper"));
						angular.element(element[0].getElementsByClassName("md-slider-content"));
						var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5e3);
						var DEFAULT_ROUND = 3;
						var vertical = angular.isDefined(attr.mdVertical);
						var discrete = angular.isDefined(attr.mdDiscrete);
						var invert = angular.isDefined(attr.mdInvert);
						angular.isDefined(attr.min) ? attr.$observe("min", updateMin) : updateMin(0);
						angular.isDefined(attr.max) ? attr.$observe("max", updateMax) : updateMax(100);
						angular.isDefined(attr.step) ? attr.$observe("step", updateStep) : updateStep(1);
						angular.isDefined(attr.round) ? attr.$observe("round", updateRound) : updateRound(DEFAULT_ROUND);
						angular.noop;
						attr.ngDisabled && scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);
						$mdGesture.register(wrapper, "drag",
						{
							horizontal: !vertical
						});
						scope.mouseActive = false;
						wrapper.on("keydown", keydownListener).on("mousedown", mouseDownListener).on("focus", focusListener).on("blur", blurListener).on("$md.pressdown", onPressDown).on("$md.pressup", onPressUp).on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);

						function updateAll()
						{
							refreshSliderDimensions();
							ngModelRender()
						}
						setTimeout(updateAll, 0);
						var debouncedUpdateAll = $$rAF.throttle(updateAll);
						angular.element($window).on("resize", debouncedUpdateAll);
						scope.$on("$destroy", function ()
						{
							angular.element($window).off("resize", debouncedUpdateAll)
						});
						ngModelCtrl.$render = ngModelRender;
						ngModelCtrl.$viewChangeListeners.push(ngModelRender);
						ngModelCtrl.$formatters.push(minMaxValidator);
						ngModelCtrl.$formatters.push(stepValidator);
						var min;
						var max;
						var step;
						var round;

						function updateMin(value)
						{
							min = parseFloat(value);
							ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$modelValue, min, max);
							element.attr("aria-valuemin", value);
							updateAll()
						}

						function updateMax(value)
						{
							max = parseFloat(value);
							ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$modelValue, min, max);
							element.attr("aria-valuemax", value);
							updateAll()
						}

						function updateStep(value)
						{
							step = parseFloat(value)
						}

						function updateRound(value)
						{
							round = minMaxValidator(parseInt(value), 0, 6)
						}

						function updateAriaDisabled()
						{
							element.attr("aria-disabled", !!isDisabled())
						}
						var tickCanvas, tickCtx;

						function redrawTicks()
						{
							if (!discrete || isDisabled()) return;
							if (angular.isUndefined(step)) return;
							if (step <= 0)
							{
								var msg = "Slider step value must be greater than zero when in discrete mode";
								$log.error(msg);
								throw new Error(msg)
							}
							var numSteps = Math.floor((max - min) / step);
							if (!tickCanvas)
							{
								tickCanvas = angular.element("<canvas>").css("position", "absolute");
								tickContainer.append(tickCanvas);
								tickCtx = tickCanvas[0].getContext("2d")
							}
							var dimensions = getSliderDimensions();
							if (dimensions && !dimensions.height && !dimensions.width)
							{
								refreshSliderDimensions();
								dimensions = sliderDimensions
							}
							tickCanvas[0].width = dimensions.width;
							tickCanvas[0].height = dimensions.height;
							var distance;
							for (var i = 0; i <= numSteps; i++)
							{
								var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
								tickCtx.fillStyle = trackTicksStyle.color || "black";
								distance = Math.floor((vertical ? dimensions.height : dimensions.width) * (i / numSteps));
								tickCtx.fillRect(vertical ? 0 : distance - 1, vertical ? distance - 1 : 0, vertical ? dimensions.width : 2, vertical ? 2 : dimensions.height)
							}
						}

						function clearTicks()
						{
							if (tickCanvas && tickCtx)
							{
								var dimensions = getSliderDimensions();
								tickCtx.clearRect(0, 0, dimensions.width, dimensions.height)
							}
						}
						var sliderDimensions = {};
						refreshSliderDimensions();

						function refreshSliderDimensions()
						{
							sliderDimensions = trackContainer[0].getBoundingClientRect()
						}

						function getSliderDimensions()
						{
							throttledRefreshDimensions();
							return sliderDimensions
						}

						function keydownListener(ev)
						{
							if (isDisabled()) return;
							var changeAmount;
							(vertical ? ev.keyCode === $mdConstant.KEY_CODE.DOWN_ARROW : ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) ? changeAmount = -step: (vertical ? ev.keyCode === $mdConstant.KEY_CODE.UP_ARROW : ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) && (changeAmount = step);
							changeAmount = invert ? -changeAmount : changeAmount;
							if (changeAmount)
							{
								(ev.metaKey || ev.ctrlKey || ev.altKey) && (changeAmount *= 4);
								ev.preventDefault();
								ev.stopPropagation();
								scope.$evalAsync(function ()
								{
									setModelValue(ngModelCtrl.$viewValue + changeAmount)
								})
							}
						}

						function mouseDownListener()
						{
							redrawTicks();
							scope.mouseActive = true;
							wrapper.removeClass("md-focused");
							$timeout(function ()
							{
								scope.mouseActive = false
							}, 100)
						}

						function focusListener()
						{
							false === scope.mouseActive && wrapper.addClass("md-focused")
						}

						function blurListener()
						{
							wrapper.removeClass("md-focused");
							element.removeClass("md-active");
							clearTicks()
						}

						function setModelValue(value)
						{
							ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)))
						}

						function ngModelRender()
						{
							isNaN(ngModelCtrl.$viewValue) && (ngModelCtrl.$viewValue = ngModelCtrl.$modelValue);
							ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$viewValue);
							var percent = valueToPercent(ngModelCtrl.$viewValue);
							scope.modelValue = ngModelCtrl.$viewValue;
							element.attr("aria-valuenow", ngModelCtrl.$viewValue);
							setSliderPercent(percent);
							thumbText.text(ngModelCtrl.$viewValue)
						}

						function minMaxValidator(value, minValue, maxValue)
						{
							if (angular.isNumber(value))
							{
								minValue = angular.isNumber(minValue) ? minValue : min;
								maxValue = angular.isNumber(maxValue) ? maxValue : max;
								return Math.max(minValue, Math.min(maxValue, value))
							}
						}

						function stepValidator(value)
						{
							if (angular.isNumber(value))
							{
								var formattedValue = Math.round((value - min) / step) * step + min;
								formattedValue = Math.round(formattedValue * Math.pow(10, round)) / Math.pow(10, round);
								containerCtrl && containerCtrl.fitInputWidthToTextLength && $mdUtil.debounce(function ()
								{
									containerCtrl.fitInputWidthToTextLength(formattedValue.toString().length)
								}, 100)();
								return formattedValue
							}
						}

						function setSliderPercent(percent)
						{
							percent = clamp(percent);
							var thumbPosition = 100 * percent + "%";
							var activeTrackPercent = invert ? 100 * (1 - percent) + "%" : thumbPosition;
							vertical ? thumbContainer.css("bottom", thumbPosition) : $mdUtil.bidiProperty(thumbContainer, "left", "right", thumbPosition);
							activeTrack.css(vertical ? "height" : "width", activeTrackPercent);
							element.toggleClass(invert ? "md-max" : "md-min", 0 === percent);
							element.toggleClass(invert ? "md-min" : "md-max", 1 === percent)
						}
						var isDragging = false;

						function onPressDown(ev)
						{
							if (isDisabled()) return;
							element.addClass("md-active");
							element[0].focus();
							refreshSliderDimensions();
							var exactVal = percentToValue(positionToPercent(vertical ? ev.pointer.y : ev.pointer.x));
							var closestVal = minMaxValidator(stepValidator(exactVal));
							scope.$apply(function ()
							{
								setModelValue(closestVal);
								setSliderPercent(valueToPercent(closestVal))
							})
						}

						function onPressUp(ev)
						{
							if (isDisabled()) return;
							element.removeClass("md-dragging");
							var exactVal = percentToValue(positionToPercent(vertical ? ev.pointer.y : ev.pointer.x));
							var closestVal = minMaxValidator(stepValidator(exactVal));
							scope.$apply(function ()
							{
								setModelValue(closestVal);
								ngModelRender()
							})
						}

						function onDragStart(ev)
						{
							if (isDisabled()) return;
							isDragging = true;
							ev.stopPropagation();
							element.addClass("md-dragging");
							setSliderFromEvent(ev)
						}

						function onDrag(ev)
						{
							if (!isDragging) return;
							ev.stopPropagation();
							setSliderFromEvent(ev)
						}

						function onDragEnd(ev)
						{
							if (!isDragging) return;
							ev.stopPropagation();
							isDragging = false
						}

						function setSliderFromEvent(ev)
						{
							discrete ? adjustThumbPosition(vertical ? ev.pointer.y : ev.pointer.x) : doSlide(vertical ? ev.pointer.y : ev.pointer.x)
						}

						function doSlide(x)
						{
							scope.$evalAsync(function ()
							{
								setModelValue(percentToValue(positionToPercent(x)))
							})
						}

						function adjustThumbPosition(x)
						{
							var exactVal = percentToValue(positionToPercent(x));
							var closestVal = minMaxValidator(stepValidator(exactVal));
							setSliderPercent(positionToPercent(x));
							thumbText.text(closestVal)
						}

						function clamp(value)
						{
							return Math.max(0, Math.min(value || 0, 1))
						}

						function positionToPercent(position)
						{
							var offset = vertical ? sliderDimensions.top : sliderDimensions.left;
							var size = vertical ? sliderDimensions.height : sliderDimensions.width;
							var calc = (position - offset) / size;
							vertical || "rtl" !== $mdUtil.bidi() || (calc = 1 - calc);
							return Math.max(0, Math.min(1, vertical ? 1 - calc : calc))
						}

						function percentToValue(percent)
						{
							var adjustedPercent = invert ? 1 - percent : percent;
							return min + adjustedPercent * (max - min)
						}

						function valueToPercent(val)
						{
							var percent = (val - min) / (max - min);
							return invert ? 1 - percent : percent
						}
					}
				}
			})();
			(function ()
			{
				MdSticky.$inject = ["$mdConstant", "$$rAF", "$mdUtil", "$compile"];
				angular.module("material.components.sticky", ["material.core", "material.components.content"]).factory("$mdSticky", MdSticky);

				function MdSticky($mdConstant, $$rAF, $mdUtil, $compile)
				{
					var browserStickySupport = $mdUtil.checkStickySupport();
					return function registerStickyElement(scope, element, stickyClone)
					{
						var contentCtrl = element.controller("mdContent");
						if (!contentCtrl) return;
						if (browserStickySupport) element.css(
						{
							position: browserStickySupport,
							top: 0,
							"z-index": 2
						});
						else
						{
							var $$sticky = contentCtrl.$element.data("$$sticky");
							if (!$$sticky)
							{
								$$sticky = setupSticky(contentCtrl);
								contentCtrl.$element.data("$$sticky", $$sticky)
							}
							var cloneElement = stickyClone || $compile(element.clone())(scope);
							var deregister = $$sticky.add(element, cloneElement);
							scope.$on("$destroy", deregister)
						}
					};

					function setupSticky(contentCtrl)
					{
						var contentEl = contentCtrl.$element;
						var debouncedRefreshElements = $$rAF.throttle(refreshElements);
						setupAugmentedScrollEvents(contentEl);
						contentEl.on("$scrollstart", debouncedRefreshElements);
						contentEl.on("$scroll", onScroll);
						var self;
						return self = {
							prev: null,
							current: null,
							next: null,
							items: [],
							add: add,
							refreshElements: refreshElements
						};

						function add(element, stickyClone)
						{
							stickyClone.addClass("md-sticky-clone");
							var item = {
								element: element,
								clone: stickyClone
							};
							self.items.push(item);
							$mdUtil.nextTick(function ()
							{
								contentEl.prepend(item.clone)
							});
							debouncedRefreshElements();
							return function remove()
							{
								self.items.forEach(function (item, index)
								{
									if (item.element[0] === element[0])
									{
										self.items.splice(index, 1);
										item.clone.remove()
									}
								});
								debouncedRefreshElements()
							}
						}

						function refreshElements()
						{
							self.items.forEach(refreshPosition);
							self.items = self.items.sort(function (a, b)
							{
								return a.top < b.top ? -1 : 1
							});
							var item;
							var currentScrollTop = contentEl.prop("scrollTop");
							for (var i = self.items.length - 1; i >= 0; i--)
								if (currentScrollTop > self.items[i].top)
								{
									item = self.items[i];
									break
								}
							setCurrentItem(item)
						}

						function refreshPosition(item)
						{
							var current = item.element[0];
							item.top = 0;
							item.left = 0;
							item.right = 0;
							while (current && current !== contentEl[0])
							{
								item.top += current.offsetTop;
								item.left += current.offsetLeft;
								current.offsetParent && (item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft);
								current = current.offsetParent
							}
							item.height = item.element.prop("offsetHeight");
							var defaultVal = $mdUtil.floatingScrollbars() ? "0" : undefined;
							$mdUtil.bidi(item.clone, "margin-left", item.left, defaultVal);
							$mdUtil.bidi(item.clone, "margin-right", defaultVal, item.right)
						}

						function onScroll()
						{
							var scrollTop = contentEl.prop("scrollTop");
							var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
							onScroll.prevScrollTop = scrollTop;
							if (0 === scrollTop)
							{
								setCurrentItem(null);
								return
							}
							if (isScrollingDown)
							{
								if (self.next && self.next.top <= scrollTop)
								{
									setCurrentItem(self.next);
									return
								}
								if (self.current && self.next && self.next.top - scrollTop <= self.next.height)
								{
									translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
									return
								}
							}
							if (!isScrollingDown)
							{
								if (self.current && self.prev && scrollTop < self.current.top)
								{
									setCurrentItem(self.prev);
									return
								}
								if (self.next && self.current && scrollTop >= self.next.top - self.current.height)
								{
									translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
									return
								}
							}
							self.current && translate(self.current, scrollTop)
						}

						function setCurrentItem(item)
						{
							if (self.current === item) return;
							if (self.current)
							{
								translate(self.current, null);
								setStickyState(self.current, null)
							}
							item && setStickyState(item, "active");
							self.current = item;
							var index = self.items.indexOf(item);
							self.next = self.items[index + 1];
							self.prev = self.items[index - 1];
							setStickyState(self.next, "next");
							setStickyState(self.prev, "prev")
						}

						function setStickyState(item, state)
						{
							if (!item || item.state === state) return;
							if (item.state)
							{
								item.clone.attr("sticky-prev-state", item.state);
								item.element.attr("sticky-prev-state", item.state)
							}
							item.clone.attr("sticky-state", state);
							item.element.attr("sticky-state", state);
							item.state = state
						}

						function translate(item, amount)
						{
							if (!item) return;
							if (null === amount || amount === undefined)
							{
								if (item.translateY)
								{
									item.translateY = null;
									item.clone.css($mdConstant.CSS.TRANSFORM, "")
								}
							}
							else
							{
								item.translateY = amount;
								$mdUtil.bidi(item.clone, $mdConstant.CSS.TRANSFORM, "translate3d(" + item.left + "px," + amount + "px,0)", "translateY(" + amount + "px)")
							}
						}
					}

					function setupAugmentedScrollEvents(element)
					{
						var SCROLL_END_DELAY = 200;
						var isScrolling;
						var lastScrollTime;
						element.on("scroll touchmove", function ()
						{
							if (!isScrolling)
							{
								isScrolling = true;
								$$rAF.throttle(loopScrollEvent);
								element.triggerHandler("$scrollstart")
							}
							element.triggerHandler("$scroll");
							lastScrollTime = +$mdUtil.now()
						});

						function loopScrollEvent()
						{
							if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY)
							{
								isScrolling = false;
								element.triggerHandler("$scrollend")
							}
							else
							{
								element.triggerHandler("$scroll");
								$$rAF.throttle(loopScrollEvent)
							}
						}
					}
				}
			})();
			(function ()
			{
				MdSubheaderDirective.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil", "$mdAria"];
				angular.module("material.components.subheader", ["material.core", "material.components.sticky"]).directive("mdSubheader", MdSubheaderDirective);

				function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil, $mdAria)
				{
					return {
						restrict: "E",
						replace: true,
						transclude: true,
						template: '<div class="md-subheader _md">  <div class="md-subheader-inner">    <div class="md-subheader-content"></div>  </div></div>',
						link: function postLink(scope, element, attr, controllers, transclude)
						{
							$mdTheming(element);
							element.addClass("_md");
							$mdUtil.prefixer().removeAttribute(element, "ng-repeat");
							var outerHTML = element[0].outerHTML;

							function getContent(el)
							{
								return angular.element(el[0].querySelector(".md-subheader-content"))
							}
							attr.$set("role", "heading");
							$mdAria.expect(element, "aria-level", "2");
							transclude(scope, function (clone)
							{
								getContent(element).append(clone)
							});
							element.hasClass("md-no-sticky") || transclude(scope, function (clone)
							{
								var wrapper = $compile('<div class="md-subheader-wrapper" aria-hidden="true">' + outerHTML + "</div>")(scope);
								$mdUtil.nextTick(function ()
								{
									getContent(wrapper).append(clone)
								});
								$mdSticky(scope, element, wrapper)
							})
						}
					}
				}
			})();
			(function ()
			{
				angular.module("material.components.swipe", ["material.core"]).directive("mdSwipeLeft", getDirective("SwipeLeft")).directive("mdSwipeRight", getDirective("SwipeRight")).directive("mdSwipeUp", getDirective("SwipeUp")).directive("mdSwipeDown", getDirective("SwipeDown"));

				function getDirective(name)
				{
					DirectiveFactory.$inject = ["$parse"];
					var directiveName = "md" + name;
					var eventName = "$md." + name.toLowerCase();
					return DirectiveFactory;

					function DirectiveFactory($parse)
					{
						return {
							restrict: "A",
							link: postLink
						};

						function postLink(scope, element, attr)
						{
							var fn = $parse(attr[directiveName]);
							element.on(eventName, function (ev)
							{
								var currentTarget = ev.currentTarget;
								scope.$applyAsync(function ()
								{
									fn(scope,
									{
										$event: ev,
										$target:
										{
											current: currentTarget
										}
									})
								})
							})
						}
					}
				}
			})();
			(function ()
			{
				MdSwitch.$inject = ["mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture", "$timeout"];
				angular.module("material.components.switch", ["material.core", "material.components.checkbox"]).directive("mdSwitch", MdSwitch);

				function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture, $timeout)
				{
					var checkboxDirective = mdCheckboxDirective[0];
					return {
						restrict: "E",
						priority: $mdConstant.BEFORE_NG_ARIA,
						transclude: true,
						template: '<div class="md-container"><div class="md-bar"></div><div class="md-thumb-container"><div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div></div></div><div ng-transclude class="md-label"></div>',
						require: ["^?mdInputContainer", "?ngModel", "?^form"],
						compile: mdSwitchCompile
					};

					function mdSwitchCompile(element, attr)
					{
						var checkboxLink = checkboxDirective.compile(element, attr).post;
						element.addClass("md-dragging");
						return function (scope, element, attr, ctrls)
						{
							ctrls[0];
							var ngModel = ctrls[1] || $mdUtil.fakeNgModel();
							ctrls[2];
							var disabledGetter = null;
							null != attr.disabled ? disabledGetter = function ()
							{
								return true
							} : attr.ngDisabled && (disabledGetter = $parse(attr.ngDisabled));
							var thumbContainer = angular.element(element[0].querySelector(".md-thumb-container"));
							var switchContainer = angular.element(element[0].querySelector(".md-container"));
							var labelContainer = angular.element(element[0].querySelector(".md-label"));
							$$rAF(function ()
							{
								element.removeClass("md-dragging")
							});
							checkboxLink(scope, element, attr, ctrls);
							disabledGetter && scope.$watch(disabledGetter, function (isDisabled)
							{
								element.attr("tabindex", isDisabled ? -1 : 0)
							});
							attr.$observe("mdInvert", function (newValue)
							{
								var isInverted = $mdUtil.parseAttributeBoolean(newValue);
								isInverted ? element.prepend(labelContainer) : element.prepend(switchContainer);
								element.toggleClass("md-inverted", isInverted)
							});
							$mdGesture.register(switchContainer, "drag");
							switchContainer.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
							var drag;

							function onDragStart(ev)
							{
								if (disabledGetter && disabledGetter(scope)) return;
								ev.stopPropagation();
								element.addClass("md-dragging");
								drag = {
									width: thumbContainer.prop("offsetWidth")
								}
							}

							function onDrag(ev)
							{
								if (!drag) return;
								ev.stopPropagation();
								ev.srcEvent && ev.srcEvent.preventDefault();
								var percent = ev.pointer.distanceX / drag.width;
								var translate = ngModel.$viewValue ? 1 + percent : percent;
								translate = Math.max(0, Math.min(1, translate));
								thumbContainer.css($mdConstant.CSS.TRANSFORM, "translate3d(" + 100 * translate + "%,0,0)");
								drag.translate = translate
							}

							function onDragEnd(ev)
							{
								if (!drag) return;
								ev.stopPropagation();
								element.removeClass("md-dragging");
								thumbContainer.css($mdConstant.CSS.TRANSFORM, "");
								var isChanged = ngModel.$viewValue ? drag.translate < .5 : drag.translate > .5;
								isChanged && applyModelValue(!ngModel.$viewValue);
								drag = null;
								scope.skipToggle = true;
								$timeout(function ()
								{
									scope.skipToggle = false
								}, 1)
							}

							function applyModelValue(newValue)
							{
								scope.$apply(function ()
								{
									ngModel.$setViewValue(newValue);
									ngModel.$render()
								})
							}
						}
					}
				}
			})();
			void angular.module("material.components.tabs", ["material.core", "material.components.icon"]);
			(function ()
			{
				angular.module("material.components.tabs").service("MdTabsPaginationService", MdTabsPaginationService);

				function MdTabsPaginationService()
				{
					return {
						decreasePageOffset: decreasePageOffset,
						increasePageOffset: increasePageOffset,
						getTabOffsets: getTabOffsets,
						getTotalTabsWidth: getTotalTabsWidth
					};

					function decreasePageOffset(elements, currentOffset)
					{
						var i, firstVisibleTabOffset, canvas = elements.canvas,
							tabOffsets = getTabOffsets(elements);
						for (i = 0; i < tabOffsets.length; i++)
							if (tabOffsets[i] >= currentOffset)
							{
								firstVisibleTabOffset = tabOffsets[i];
								break
							}
						return Math.max(0, firstVisibleTabOffset - canvas.clientWidth)
					}

					function increasePageOffset(elements, currentOffset)
					{
						var i, firstHiddenTabOffset, canvas = elements.canvas,
							maxOffset = getTotalTabsWidth(elements) - canvas.clientWidth,
							tabOffsets = getTabOffsets(elements);
						for (i = 0; i < tabOffsets.length, tabOffsets[i] <= currentOffset + canvas.clientWidth; i++) firstHiddenTabOffset = tabOffsets[i];
						return Math.min(maxOffset, firstHiddenTabOffset)
					}

					function getTabOffsets(elements)
					{
						var i, tab, currentOffset = 0,
							offsets = [];
						for (i = 0; i < elements.tabs.length; i++)
						{
							tab = elements.tabs[i];
							offsets.push(currentOffset);
							currentOffset += tab.offsetWidth
						}
						return offsets
					}

					function getTotalTabsWidth(elements)
					{
						var i, tab, sum = 0;
						for (i = 0; i < elements.tabs.length; i++)
						{
							tab = elements.tabs[i];
							sum += tab.offsetWidth
						}
						return sum
					}
				}
			})();
			(function ()
			{
				MdToastDirective.$inject = ["$mdToast"];
				MdToastProvider.$inject = ["$$interimElementProvider"];
				angular.module("material.components.toast", ["material.core", "material.components.button"]).directive("mdToast", MdToastDirective).provider("$mdToast", MdToastProvider);

				function MdToastDirective($mdToast)
				{
					return {
						restrict: "E",
						link: function postLink(scope, element)
						{
							element.addClass("_md");
							scope.$on("$destroy", function ()
							{
								$mdToast.destroy()
							})
						}
					}
				}

				function MdToastProvider($$interimElementProvider)
				{
					MdToastController.$inject = ["$mdToast", "$scope"];
					toastDefaultOptions.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia"];
					var ACTION_RESOLVE = "ok";
					var activeToastContent;
					var $mdToast = $$interimElementProvider("$mdToast").setDefaults(
					{
						methods: ["position", "hideDelay", "capsule", "parent", "position", "toastClass"],
						options: toastDefaultOptions
					}).addPreset("simple",
					{
						argOption: "textContent",
						methods: ["textContent", "content", "action", "highlightAction", "highlightClass", "theme", "parent"],
						options: ["$mdToast", "$mdTheming", function ($mdToast, $mdTheming)
						{
							return {
								template: '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">  <div class="md-toast-content">    <span class="md-toast-text" role="alert" aria-relevant="all" aria-atomic="true">      {{ toast.content }}    </span>    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()"         ng-class="highlightClasses">      {{ toast.action }}    </md-button>  </div></md-toast>',
								controller: MdToastController,
								theme: $mdTheming.defaultTheme(),
								controllerAs: "toast",
								bindToController: true
							}
						}]
					}).addMethod("updateTextContent", updateTextContent).addMethod("updateContent", updateTextContent);

					function updateTextContent(newContent)
					{
						activeToastContent = newContent
					}
					return $mdToast;

					function MdToastController($mdToast, $scope)
					{
						this.$onInit = function ()
						{
							var self = this;
							self.highlightAction && ($scope.highlightClasses = ["md-highlight", self.highlightClass]);
							$scope.$watch(function ()
							{
								return activeToastContent
							}, function ()
							{
								self.content = activeToastContent
							});
							this.resolve = function ()
							{
								$mdToast.hide(ACTION_RESOLVE)
							}
						}
					}

					function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia)
					{
						var SWIPE_EVENTS = "$md.swipeleft $md.swiperight $md.swipeup $md.swipedown";
						return {
							onShow: onShow,
							onRemove: onRemove,
							toastClass: "",
							position: "bottom left",
							themable: true,
							hideDelay: 3e3,
							autoWrap: true,
							transformTemplate: function (template, options)
							{
								var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template);
								if (shouldAddWrapper)
								{
									var templateRoot = document.createElement("md-template");
									templateRoot.innerHTML = template;
									for (var i = 0; i < templateRoot.children.length; i++)
										if ("MD-TOAST" === templateRoot.children[i].nodeName)
										{
											var wrapper = angular.element('<div class="md-toast-content">');
											wrapper.append(angular.element(templateRoot.children[i].childNodes));
											templateRoot.children[i].appendChild(wrapper[0])
										}
									return templateRoot.innerHTML
								}
								return template || ""
							}
						};

						function onShow(scope, element, options)
						{
							activeToastContent = options.textContent || options.content;
							var isSmScreen = !$mdMedia("gt-sm");
							element = $mdUtil.extractElementByName(element, "md-toast", true);
							options.element = element;
							options.onSwipe = function (ev, gesture)
							{
								var swipe = ev.type.replace("$md.", "");
								var direction = swipe.replace("swipe", "");
								if ("down" === direction && -1 != options.position.indexOf("top") && !isSmScreen || "up" === direction && (-1 != options.position.indexOf("bottom") || isSmScreen)) return;
								if (("left" === direction || "right" === direction) && isSmScreen) return;
								element.addClass("md-" + swipe);
								$mdUtil.nextTick($mdToast.cancel)
							};
							options.openClass = toastOpenClass(options.position);
							element.addClass(options.toastClass);
							options.parent.addClass(options.openClass);
							$mdUtil.hasComputedStyle(options.parent, "position", "static") && options.parent.css("position", "relative");
							element.on(SWIPE_EVENTS, options.onSwipe);
							element.addClass(isSmScreen ? "md-bottom" : options.position.split(" ").map(function (pos)
							{
								return "md-" + pos
							}).join(" "));
							options.parent && options.parent.addClass("md-toast-animating");
							return $animate.enter(element, options.parent).then(function ()
							{
								options.parent && options.parent.removeClass("md-toast-animating")
							})
						}

						function onRemove(scope, element, options)
						{
							element.off(SWIPE_EVENTS, options.onSwipe);
							options.parent && options.parent.addClass("md-toast-animating");
							options.openClass && options.parent.removeClass(options.openClass);
							return (true == options.$destroy ? element.remove() : $animate.leave(element)).then(function ()
							{
								options.parent && options.parent.removeClass("md-toast-animating");
								$mdUtil.hasComputedStyle(options.parent, "position", "static") && options.parent.css("position", "")
							})
						}

						function toastOpenClass(position)
						{
							if (!$mdMedia("gt-xs")) return "md-toast-open-bottom";
							return "md-toast-open-" + (position.indexOf("top") > -1 ? "top" : "bottom")
						}
					}
				}
			})();
			(function ()
			{
				mdToolbarDirective.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"];
				angular.module("material.components.toolbar", ["material.core", "material.components.content"]).directive("mdToolbar", mdToolbarDirective);

				function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate)
				{
					var translateY = angular.bind(null, $mdUtil.supplant, "translate3d(0,{0}px,0)");
					return {
						template: "",
						restrict: "E",
						link: function (scope, element, attr)
						{
							element.addClass("_md");
							$mdTheming(element);
							$mdUtil.nextTick(function ()
							{
								element.addClass("_md-toolbar-transitions")
							}, false);
							angular.isDefined(attr.mdScrollShrink) && setupScrollShrink();

							function setupScrollShrink()
							{
								var toolbarHeight;
								var contentElement;
								var disableScrollShrink = angular.noop;
								var y = 0;
								var prevScrollTop = 0;
								var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || .5;
								var debouncedContentScroll = $$rAF.throttle(onContentScroll);
								var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5e3);
								scope.$on("$mdContentLoaded", onMdContentLoad);
								attr.$observe("mdScrollShrink", onChangeScrollShrink);
								attr.ngShow && scope.$watch(attr.ngShow, updateToolbarHeight);
								attr.ngHide && scope.$watch(attr.ngHide, updateToolbarHeight);
								scope.$on("$destroy", disableScrollShrink);

								function onChangeScrollShrink(shrinkWithScroll)
								{
									var closestContent = element.parent().find("md-content");
									!contentElement && closestContent.length && onMdContentLoad(null, closestContent);
									shrinkWithScroll = scope.$eval(shrinkWithScroll);
									false === shrinkWithScroll ? disableScrollShrink() : disableScrollShrink = enableScrollShrink()
								}

								function onMdContentLoad($event, newContentEl)
								{
									if (newContentEl && element.parent()[0] === newContentEl.parent()[0])
									{
										contentElement && contentElement.off("scroll", debouncedContentScroll);
										contentElement = newContentEl;
										disableScrollShrink = enableScrollShrink()
									}
								}

								function onContentScroll(e)
								{
									var scrollTop = e ? e.target.scrollTop : prevScrollTop;
									debouncedUpdateHeight();
									y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
									element.css($mdConstant.CSS.TRANSFORM, translateY([-y * shrinkSpeedFactor]));
									contentElement.css($mdConstant.CSS.TRANSFORM, translateY([(toolbarHeight - y) * shrinkSpeedFactor]));
									prevScrollTop = scrollTop;
									$mdUtil.nextTick(function ()
									{
										var hasWhiteFrame = element.hasClass("md-whiteframe-z1");
										hasWhiteFrame && !y ? $animate.removeClass(element, "md-whiteframe-z1") : !hasWhiteFrame && y && $animate.addClass(element, "md-whiteframe-z1")
									})
								}

								function enableScrollShrink()
								{
									if (!contentElement) return angular.noop;
									contentElement.on("scroll", debouncedContentScroll);
									contentElement.attr("scroll-shrink", "true");
									$mdUtil.nextTick(updateToolbarHeight, false);
									return function disableScrollShrink()
									{
										contentElement.off("scroll", debouncedContentScroll);
										contentElement.attr("scroll-shrink", "false");
										updateToolbarHeight()
									}
								}

								function updateToolbarHeight()
								{
									toolbarHeight = element.prop("offsetHeight");
									var margin = -toolbarHeight * shrinkSpeedFactor + "px";
									contentElement.css(
									{
										"margin-top": margin,
										"margin-bottom": margin
									});
									onContentScroll()
								}
							}
						}
					}
				}
			})();
			(function ()
			{
				MdTooltipDirective.$inject = ["$timeout", "$window", "$$rAF", "$document", "$interpolate", "$mdUtil", "$mdPanel", "$$mdTooltipRegistry"];
				angular.module("material.components.tooltip", ["material.core", "material.components.panel"]).directive("mdTooltip", MdTooltipDirective).service("$$mdTooltipRegistry", MdTooltipRegistry);

				function MdTooltipDirective($timeout, $window, $$rAF, $document, $interpolate, $mdUtil, $mdPanel, $$mdTooltipRegistry)
				{
					var ENTER_EVENTS = "focus touchstart mouseenter";
					var LEAVE_EVENTS = "blur touchcancel mouseleave";
					var TOOLTIP_DEFAULT_Z_INDEX = 100;
					var TOOLTIP_DEFAULT_SHOW_DELAY = 0;
					var TOOLTIP_DEFAULT_DIRECTION = "bottom";
					var TOOLTIP_DIRECTIONS = {
						top:
						{
							x: $mdPanel.xPosition.CENTER,
							y: $mdPanel.yPosition.ABOVE
						},
						right:
						{
							x: $mdPanel.xPosition.OFFSET_END,
							y: $mdPanel.yPosition.CENTER
						},
						bottom:
						{
							x: $mdPanel.xPosition.CENTER,
							y: $mdPanel.yPosition.BELOW
						},
						left:
						{
							x: $mdPanel.xPosition.OFFSET_START,
							y: $mdPanel.yPosition.CENTER
						}
					};
					return {
						restrict: "E",
						priority: 210,
						scope:
						{
							mdZIndex: "=?mdZIndex",
							mdDelay: "=?mdDelay",
							mdVisible: "=?mdVisible",
							mdAutohide: "=?mdAutohide",
							mdDirection: "@?mdDirection"
						},
						link: linkFunc
					};

					function linkFunc(scope, element, attr)
					{
						var tooltipId = "md-tooltip-" + $mdUtil.nextUid();
						var parent = $mdUtil.getParentWithPointerEvents(element);
						var debouncedOnResize = $$rAF.throttle(updatePosition);
						var mouseActive = false;
						var origin, position, panelPosition, panelRef, autohide, showTimeout, elementFocusedOnWindowBlur = null;
						setDefaults();
						addAriaLabel();
						element.detach();
						updatePosition();
						bindEvents();
						configureWatchers();

						function setDefaults()
						{
							scope.mdZIndex = scope.mdZIndex || TOOLTIP_DEFAULT_Z_INDEX;
							scope.mdDelay = scope.mdDelay || TOOLTIP_DEFAULT_SHOW_DELAY;
							TOOLTIP_DIRECTIONS[scope.mdDirection] || (scope.mdDirection = TOOLTIP_DEFAULT_DIRECTION)
						}

						function addAriaLabel(labelText)
						{
							var interpolatedText = labelText || $interpolate(element.text().trim())(scope.$parent);
							if (!parent.attr("aria-label") && !parent.attr("aria-labelledby") || parent.attr("md-labeled-by-tooltip"))
							{
								parent.attr("aria-label", interpolatedText);
								parent.attr("md-labeled-by-tooltip") || parent.attr("md-labeled-by-tooltip", tooltipId)
							}
						}

						function updatePosition()
						{
							setDefaults();
							panelRef && panelRef.panelEl && panelRef.panelEl.removeClass(origin);
							origin = "md-origin-" + scope.mdDirection;
							position = TOOLTIP_DIRECTIONS[scope.mdDirection];
							panelPosition = $mdPanel.newPanelPosition().relativeTo(parent).addPanelPosition(position.x, position.y);
							if (panelRef && panelRef.panelEl)
							{
								panelRef.panelEl.addClass(origin);
								panelRef.updatePosition(panelPosition)
							}
						}

						function bindEvents()
						{
							if (parent[0] && "MutationObserver" in $window)
							{
								var attributeObserver = new MutationObserver(function (mutations)
								{
									isDisabledMutation(mutations) && $mdUtil.nextTick(function ()
									{
										setVisible(false)
									})
								});
								attributeObserver.observe(parent[0],
								{
									attributes: true
								})
							}
							elementFocusedOnWindowBlur = false;
							$$mdTooltipRegistry.register("scroll", windowScrollEventHandler, true);
							$$mdTooltipRegistry.register("blur", windowBlurEventHandler);
							$$mdTooltipRegistry.register("resize", debouncedOnResize);
							scope.$on("$destroy", onDestroy);
							parent.on("mousedown", mousedownEventHandler);
							parent.on(ENTER_EVENTS, enterEventHandler);

							function isDisabledMutation(mutations)
							{
								mutations.some(function (mutation)
								{
									return "disabled" === mutation.attributeName && parent[0].disabled
								});
								return false
							}

							function windowScrollEventHandler()
							{
								setVisible(false)
							}

							function windowBlurEventHandler()
							{
								elementFocusedOnWindowBlur = document.activeElement === parent[0]
							}

							function enterEventHandler($event)
							{
								if ("focus" === $event.type && elementFocusedOnWindowBlur) elementFocusedOnWindowBlur = false;
								else if (!scope.mdVisible)
								{
									parent.on(LEAVE_EVENTS, leaveEventHandler);
									setVisible(true);
									"touchstart" === $event.type && parent.one("touchend", function ()
									{
										$mdUtil.nextTick(function ()
										{
											$document.one("touchend", leaveEventHandler)
										}, false)
									})
								}
							}

							function leaveEventHandler()
							{
								autohide = scope.hasOwnProperty("mdAutohide") ? scope.mdAutohide : attr.hasOwnProperty("mdAutohide");
								if (autohide || mouseActive || $document[0].activeElement !== parent[0])
								{
									if (showTimeout)
									{
										$timeout.cancel(showTimeout);
										setVisible.queued = false;
										showTimeout = null
									}
									parent.off(LEAVE_EVENTS, leaveEventHandler);
									parent.triggerHandler("blur");
									setVisible(false)
								}
								mouseActive = false
							}

							function mousedownEventHandler()
							{
								mouseActive = true
							}

							function onDestroy()
							{
								$$mdTooltipRegistry.deregister("scroll", windowScrollEventHandler, true);
								$$mdTooltipRegistry.deregister("blur", windowBlurEventHandler);
								$$mdTooltipRegistry.deregister("resize", debouncedOnResize);
								parent.off(ENTER_EVENTS, enterEventHandler).off(LEAVE_EVENTS, leaveEventHandler).off("mousedown", mousedownEventHandler);
								leaveEventHandler();
								attributeObserver && attributeObserver.disconnect()
							}
						}

						function configureWatchers()
						{
							if (element[0] && "MutationObserver" in $window)
							{
								var attributeObserver = new MutationObserver(function (mutations)
								{
									mutations.forEach(function (mutation)
									{
										"md-visible" !== mutation.attributeName || scope.visibleWatcher || (scope.visibleWatcher = scope.$watch("mdVisible", onVisibleChanged))
									})
								});
								attributeObserver.observe(element[0],
								{
									attributes: true
								});
								attr.hasOwnProperty("mdVisible") && (scope.visibleWatcher = scope.$watch("mdVisible", onVisibleChanged))
							}
							else scope.visibleWatcher = scope.$watch("mdVisible", onVisibleChanged);
							scope.$watch("mdDirection", updatePosition);
							element.one("$destroy", onElementDestroy);
							parent.one("$destroy", onElementDestroy);
							scope.$on("$destroy", function ()
							{
								setVisible(false);
								panelRef && panelRef.destroy();
								attributeObserver && attributeObserver.disconnect();
								element.remove()
							});
							element.text().indexOf($interpolate.startSymbol()) > -1 && scope.$watch(function ()
							{
								return element.text().trim()
							}, addAriaLabel);

							function onElementDestroy()
							{
								scope.$destroy()
							}
						}

						function setVisible(value)
						{
							if (setVisible.queued && setVisible.value === !!value || !setVisible.queued && scope.mdVisible === !!value) return;
							setVisible.value = !!value;
							if (!setVisible.queued)
								if (value)
								{
									setVisible.queued = true;
									showTimeout = $timeout(function ()
									{
										scope.mdVisible = setVisible.value;
										setVisible.queued = false;
										showTimeout = null;
										scope.visibleWatcher || onVisibleChanged(scope.mdVisible)
									}, scope.mdDelay)
								}
							else $mdUtil.nextTick(function ()
							{
								scope.mdVisible = false;
								scope.visibleWatcher || onVisibleChanged(false)
							})
						}

						function onVisibleChanged(isVisible)
						{
							isVisible ? showTooltip() : hideTooltip()
						}

						function showTooltip()
						{
							if (!element[0].textContent.trim()) throw new Error("Text for the tooltip has not been provided. Please include text within the mdTooltip element.");
							if (!panelRef)
							{
								var attachTo = angular.element(document.body);
								var panelAnimation = $mdPanel.newPanelAnimation().openFrom(parent).closeTo(parent).withAnimation(
								{
									open: "md-show",
									close: "md-hide"
								});
								var panelConfig = {
									id: tooltipId,
									attachTo: attachTo,
									contentElement: element,
									propagateContainerEvents: true,
									panelClass: "md-tooltip",
									animation: panelAnimation,
									position: panelPosition,
									zIndex: scope.mdZIndex,
									focusOnOpen: false,
									onDomAdded: function ()
									{
										panelRef.panelEl.addClass(origin)
									}
								};
								panelRef = $mdPanel.create(panelConfig)
							}
							panelRef.open().then(function ()
							{
								panelRef.panelEl.attr("role", "tooltip")
							})
						}

						function hideTooltip()
						{
							panelRef && panelRef.close()
						}
					}
				}

				function MdTooltipRegistry()
				{
					var listeners = {};
					var ngWindow = angular.element(window);
					return {
						register: register,
						deregister: deregister
					};

					function globalEventHandler(event)
					{
						listeners[event.type] && listeners[event.type].forEach(function (currentHandler)
						{
							currentHandler.call(this, event)
						}, this)
					}

					function register(type, handler, useCapture)
					{
						var handlers = listeners[type] = listeners[type] || [];
						handlers.length || (useCapture ? window.addEventListener(type, globalEventHandler, true) : ngWindow.on(type, globalEventHandler)); - 1 === handlers.indexOf(handler) && handlers.push(handler)
					}

					function deregister(type, handler, useCapture)
					{
						var handlers = listeners[type];
						var index = handlers ? handlers.indexOf(handler) : -1;
						if (index > -1)
						{
							handlers.splice(index, 1);
							0 === handlers.length && (useCapture ? window.removeEventListener(type, globalEventHandler, true) : ngWindow.off(type, globalEventHandler))
						}
					}
				}
			})();
			(function ()
			{
				MdTruncateController.$inject = ["$element"];
				angular.module("material.components.truncate", ["material.core"]).directive("mdTruncate", MdTruncateDirective);

				function MdTruncateDirective()
				{
					return {
						restrict: "AE",
						controller: MdTruncateController
					}
				}

				function MdTruncateController($element)
				{
					$element.addClass("md-truncate")
				}
			})();
			(function ()
			{
				VirtualRepeatContainerController.$inject = ["$$rAF", "$mdUtil", "$mdConstant", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"];
				VirtualRepeatController.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF", "$mdUtil"];
				VirtualRepeatDirective.$inject = ["$parse"];
				angular.module("material.components.virtualRepeat", ["material.core", "material.components.showHide"]).directive("mdVirtualRepeatContainer", VirtualRepeatContainerDirective).directive("mdVirtualRepeat", VirtualRepeatDirective).directive("mdForceHeight", ForceHeightDirective);

				function VirtualRepeatContainerDirective()
				{
					return {
						controller: VirtualRepeatContainerController,
						template: virtualRepeatContainerTemplate,
						compile: function virtualRepeatContainerCompile($element, $attrs)
						{
							$element.addClass("md-virtual-repeat-container").addClass($attrs.hasOwnProperty("mdOrientHorizontal") ? "md-orient-horizontal" : "md-orient-vertical")
						}
					}
				}

				function virtualRepeatContainerTemplate($element)
				{
					return '<div class="md-virtual-repeat-scroller" role="presentation"><div class="md-virtual-repeat-sizer" role="presentation"></div><div class="md-virtual-repeat-offsetter" role="presentation">' + $element[0].innerHTML + "</div></div>"
				}
				var NUM_EXTRA = 3;

				function VirtualRepeatContainerController($$rAF, $mdUtil, $mdConstant, $parse, $rootScope, $window, $scope, $element, $attrs)
				{
					this.$rootScope = $rootScope;
					this.$scope = $scope;
					this.$element = $element;
					this.$attrs = $attrs;
					this.size = 0;
					this.scrollSize = 0;
					this.scrollOffset = 0;
					this.horizontal = this.$attrs.hasOwnProperty("mdOrientHorizontal");
					this.repeater = null;
					this.autoShrink = this.$attrs.hasOwnProperty("mdAutoShrink");
					this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
					this.originalSize = null;
					this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
					this.oldElementSize = null;
					this.maxElementPixels = $mdConstant.ELEMENT_MAX_PIXELS;
					if (this.$attrs.mdTopIndex)
					{
						this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
						this.topIndex = this.bindTopIndex(this.$scope);
						if (!angular.isDefined(this.topIndex))
						{
							this.topIndex = 0;
							this.bindTopIndex.assign(this.$scope, 0)
						}
						this.$scope.$watch(this.bindTopIndex, angular.bind(this, function (newIndex)
						{
							newIndex !== this.topIndex && this.scrollToIndex(newIndex)
						}))
					}
					else this.topIndex = 0;
					this.scroller = $element[0].querySelector(".md-virtual-repeat-scroller");
					this.sizer = this.scroller.querySelector(".md-virtual-repeat-sizer");
					this.offsetter = this.scroller.querySelector(".md-virtual-repeat-offsetter");
					var boundUpdateSize = angular.bind(this, this.updateSize);
					$$rAF(angular.bind(this, function ()
					{
						boundUpdateSize();
						var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, false);
						var jWindow = angular.element($window);
						this.size || debouncedUpdateSize();
						jWindow.on("resize", debouncedUpdateSize);
						$scope.$on("$destroy", function ()
						{
							jWindow.off("resize", debouncedUpdateSize)
						});
						$scope.$emit("$md-resize-enable");
						$scope.$on("$md-resize", boundUpdateSize)
					}))
				}
				VirtualRepeatContainerController.prototype.register = function (repeaterCtrl)
				{
					this.repeater = repeaterCtrl;
					angular.element(this.scroller).on("scroll wheel touchmove touchend", angular.bind(this, this.handleScroll_))
				};
				VirtualRepeatContainerController.prototype.isHorizontal = function ()
				{
					return this.horizontal
				};
				VirtualRepeatContainerController.prototype.getSize = function ()
				{
					return this.size
				};
				VirtualRepeatContainerController.prototype.setSize_ = function (size)
				{
					var dimension = this.getDimensionName_();
					this.size = size;
					this.$element[0].style[dimension] = size + "px"
				};
				VirtualRepeatContainerController.prototype.unsetSize_ = function ()
				{
					this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
					this.oldElementSize = null
				};
				VirtualRepeatContainerController.prototype.updateSize = function ()
				{
					if (this.originalSize) return;
					this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
					this.handleScroll_();
					this.repeater && this.repeater.containerUpdated()
				};
				VirtualRepeatContainerController.prototype.getScrollSize = function ()
				{
					return this.scrollSize
				};
				VirtualRepeatContainerController.prototype.getDimensionName_ = function ()
				{
					return this.isHorizontal() ? "width" : "height"
				};
				VirtualRepeatContainerController.prototype.sizeScroller_ = function (size)
				{
					var dimension = this.getDimensionName_();
					var crossDimension = this.isHorizontal() ? "height" : "width";
					this.sizer.innerHTML = "";
					if (size < this.maxElementPixels) this.sizer.style[dimension] = size + "px";
					else
					{
						this.sizer.style[dimension] = "auto";
						this.sizer.style[crossDimension] = "auto";
						var numChildren = Math.floor(size / this.maxElementPixels);
						var sizerChild = document.createElement("div");
						sizerChild.style[dimension] = this.maxElementPixels + "px";
						sizerChild.style[crossDimension] = "1px";
						for (var i = 0; i < numChildren; i++) this.sizer.appendChild(sizerChild.cloneNode(false));
						sizerChild.style[dimension] = size - numChildren * this.maxElementPixels + "px";
						this.sizer.appendChild(sizerChild)
					}
				};
				VirtualRepeatContainerController.prototype.autoShrink_ = function (size)
				{
					var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
					if (this.autoShrink && shrinkSize !== this.size)
					{
						null === this.oldElementSize && (this.oldElementSize = this.$element[0].style[this.getDimensionName_()]);
						var currentSize = this.originalSize || this.size;
						if (!currentSize || shrinkSize < currentSize)
						{
							this.originalSize || (this.originalSize = this.size);
							this.setSize_(shrinkSize)
						}
						else if (null !== this.originalSize)
						{
							this.unsetSize_();
							var _originalSize = this.originalSize;
							this.originalSize = null;
							_originalSize || this.updateSize();
							this.setSize_(_originalSize || this.size)
						}
						this.repeater.containerUpdated()
					}
				};
				VirtualRepeatContainerController.prototype.setScrollSize = function (itemsSize)
				{
					var size = itemsSize + this.offsetSize;
					if (this.scrollSize === size) return;
					this.sizeScroller_(size);
					this.autoShrink_(size);
					this.scrollSize = size
				};
				VirtualRepeatContainerController.prototype.getScrollOffset = function ()
				{
					return this.scrollOffset
				};
				VirtualRepeatContainerController.prototype.scrollTo = function (position)
				{
					this.scroller[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = position;
					this.handleScroll_()
				};
				VirtualRepeatContainerController.prototype.scrollToIndex = function (index)
				{
					var itemSize = this.repeater.getItemSize();
					var itemsLength = this.repeater.itemsLength;
					index > itemsLength && (index = itemsLength - 1);
					this.scrollTo(itemSize * index)
				};
				VirtualRepeatContainerController.prototype.resetScroll = function ()
				{
					this.scrollTo(0)
				};
				VirtualRepeatContainerController.prototype.handleScroll_ = function ()
				{
					var ltr = "rtl" != document.dir && "rtl" != document.body.dir;
					if (!ltr && !this.maxSize)
					{
						this.scroller.scrollLeft = this.scrollSize;
						this.maxSize = this.scroller.scrollLeft
					}
					var offset = this.isHorizontal() ? ltr ? this.scroller.scrollLeft : this.maxSize - this.scroller.scrollLeft : this.scroller.scrollTop;
					if (offset === this.scrollOffset || offset > this.scrollSize - this.size) return;
					var itemSize = this.repeater.getItemSize();
					if (!itemSize) return;
					var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA);
					var transform = (this.isHorizontal() ? "translateX(" : "translateY(") + (!this.isHorizontal() || ltr ? numItems * itemSize : -numItems * itemSize) + "px)";
					this.scrollOffset = offset;
					this.offsetter.style.webkitTransform = transform;
					this.offsetter.style.transform = transform;
					if (this.bindTopIndex)
					{
						var topIndex = Math.floor(offset / itemSize);
						if (topIndex !== this.topIndex && topIndex < this.repeater.getItemCount())
						{
							this.topIndex = topIndex;
							this.bindTopIndex.assign(this.$scope, topIndex);
							this.$rootScope.$$phase || this.$scope.$digest()
						}
					}
					this.repeater.containerUpdated()
				};

				function VirtualRepeatDirective($parse)
				{
					return {
						controller: VirtualRepeatController,
						priority: 1e3,
						require: ["mdVirtualRepeat", "^^mdVirtualRepeatContainer"],
						restrict: "A",
						terminal: true,
						transclude: "element",
						compile: function VirtualRepeatCompile($element, $attrs)
						{
							var expression = $attrs.mdVirtualRepeat;
							var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/);
							var repeatName = match[1];
							var repeatListExpression = $parse(match[2]);
							var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);
							return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude)
							{
								ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName)
							}
						}
					}
				}

				function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF, $mdUtil)
				{
					this.$scope = $scope;
					this.$element = $element;
					this.$attrs = $attrs;
					this.$browser = $browser;
					this.$document = $document;
					this.$mdUtil = $mdUtil;
					this.$rootScope = $rootScope;
					this.$$rAF = $$rAF;
					this.onDemand = $mdUtil.parseAttributeBoolean($attrs.mdOnDemand);
					this.browserCheckUrlChange = $browser.$$checkUrlChange;
					this.newStartIndex = 0;
					this.newEndIndex = 0;
					this.newVisibleEnd = 0;
					this.startIndex = 0;
					this.endIndex = 0;
					this.itemSize = $scope.$eval($attrs.mdItemSize) || null;
					this.isFirstRender = true;
					this.isVirtualRepeatUpdating_ = false;
					this.itemsLength = 0;
					this.unwatchItemSize_ = angular.noop;
					this.blocks = {};
					this.pooledBlocks = [];
					$scope.$on("$destroy", angular.bind(this, this.cleanupBlocks_))
				}
				VirtualRepeatController.Block;
				VirtualRepeatController.prototype.link_ = function (container, transclude, repeatName, repeatListExpression, extraName)
				{
					this.container = container;
					this.transclude = transclude;
					this.repeatName = repeatName;
					this.rawRepeatListExpression = repeatListExpression;
					this.extraName = extraName;
					this.sized = false;
					this.repeatListExpression = angular.bind(this, this.repeatListExpression_);
					this.container.register(this)
				};
				VirtualRepeatController.prototype.cleanupBlocks_ = function ()
				{
					angular.forEach(this.pooledBlocks, function cleanupBlock(block)
					{
						block.element.remove()
					})
				};
				VirtualRepeatController.prototype.readItemSize_ = function ()
				{
					if (this.itemSize) return;
					this.items = this.repeatListExpression(this.$scope);
					this.parentNode = this.$element[0].parentNode;
					var block = this.getBlock_(0);
					block.element[0].parentNode || this.parentNode.appendChild(block.element[0]);
					this.itemSize = block.element[0][this.container.isHorizontal() ? "offsetWidth" : "offsetHeight"] || null;
					this.blocks[0] = block;
					this.poolBlock_(0);
					this.itemSize && this.containerUpdated()
				};
				VirtualRepeatController.prototype.repeatListExpression_ = function (scope)
				{
					var repeatList = this.rawRepeatListExpression(scope);
					if (this.onDemand && repeatList)
					{
						var virtualList = new VirtualRepeatModelArrayLike(repeatList);
						virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
						return virtualList
					}
					return repeatList
				};
				VirtualRepeatController.prototype.containerUpdated = function ()
				{
					if (!this.itemSize)
					{
						this.unwatchItemSize_ && this.unwatchItemSize_ !== angular.noop && this.unwatchItemSize_();
						this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function (items)
						{
							items && items.length && this.readItemSize_()
						}));
						this.$rootScope.$$phase || this.$scope.$digest();
						return
					}
					this.sized || (this.items = this.repeatListExpression(this.$scope));
					if (!this.sized)
					{
						this.unwatchItemSize_();
						this.sized = true;
						this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function (items, oldItems)
						{
							this.isVirtualRepeatUpdating_ || this.virtualRepeatUpdate_(items, oldItems)
						}))
					}
					this.updateIndexes_();
					if (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize())
					{
						this.items instanceof VirtualRepeatModelArrayLike && this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
						this.virtualRepeatUpdate_(this.items, this.items)
					}
				};
				VirtualRepeatController.prototype.getItemSize = function ()
				{
					return this.itemSize
				};
				VirtualRepeatController.prototype.getItemCount = function ()
				{
					return this.itemsLength
				};
				VirtualRepeatController.prototype.virtualRepeatUpdate_ = function (items, oldItems)
				{
					this.isVirtualRepeatUpdating_ = true;
					var itemsLength = items && items.length || 0;
					var lengthChanged = false;
					if (this.items && itemsLength < this.items.length && 0 !== this.container.getScrollOffset())
					{
						this.items = items;
						var previousScrollOffset = this.container.getScrollOffset();
						this.container.resetScroll();
						this.container.scrollTo(previousScrollOffset)
					}
					if (itemsLength !== this.itemsLength)
					{
						lengthChanged = true;
						this.itemsLength = itemsLength
					}
					this.items = items;
					(items !== oldItems || lengthChanged) && this.updateIndexes_();
					this.parentNode = this.$element[0].parentNode;
					lengthChanged && this.container.setScrollSize(itemsLength * this.itemSize);
					Object.keys(this.blocks).forEach(function (blockIndex)
					{
						var index = parseInt(blockIndex, 10);
						(index < this.newStartIndex || index >= this.newEndIndex) && this.poolBlock_(index)
					}, this);
					this.$browser.$$checkUrlChange = angular.noop;
					var i, block, newStartBlocks = [],
						newEndBlocks = [];
					for (i = this.newStartIndex; i < this.newEndIndex && null == this.blocks[i]; i++)
					{
						block = this.getBlock_(i);
						this.updateBlock_(block, i);
						newStartBlocks.push(block)
					}
					for (; null != this.blocks[i]; i++) this.updateBlock_(this.blocks[i], i);
					var maxIndex = i - 1;
					for (; i < this.newEndIndex; i++)
					{
						block = this.getBlock_(i);
						this.updateBlock_(block, i);
						newEndBlocks.push(block)
					}
					newStartBlocks.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling);
					newEndBlocks.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
					this.$browser.$$checkUrlChange = this.browserCheckUrlChange;
					this.startIndex = this.newStartIndex;
					this.endIndex = this.newEndIndex;
					if (this.isFirstRender)
					{
						this.isFirstRender = false;
						var firstRenderStartIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
						this.$mdUtil.nextTick(function ()
						{
							this.container.scrollToIndex(firstRenderStartIndex)
						}.bind(this))
					}
					this.isVirtualRepeatUpdating_ = false
				};
				VirtualRepeatController.prototype.getBlock_ = function (index)
				{
					if (this.pooledBlocks.length) return this.pooledBlocks.pop();
					var block;
					this.transclude(angular.bind(this, function (clone, scope)
					{
						block = {
							element: clone,
							new: true,
							scope: scope
						};
						this.updateScope_(scope, index);
						this.parentNode.appendChild(clone[0])
					}));
					return block
				};
				VirtualRepeatController.prototype.updateBlock_ = function (block, index)
				{
					this.blocks[index] = block;
					if (!block.new && block.scope.$index === index && block.scope[this.repeatName] === this.items[index]) return;
					block.new = false;
					this.updateScope_(block.scope, index);
					this.$rootScope.$$phase || block.scope.$digest()
				};
				VirtualRepeatController.prototype.updateScope_ = function (scope, index)
				{
					scope.$index = index;
					scope[this.repeatName] = this.items && this.items[index];
					this.extraName && (scope[this.extraName(this.$scope)] = this.items[index])
				};
				VirtualRepeatController.prototype.poolBlock_ = function (index)
				{
					this.pooledBlocks.push(this.blocks[index]);
					this.parentNode.removeChild(this.blocks[index].element[0]);
					delete this.blocks[index]
				};
				VirtualRepeatController.prototype.domFragmentFromBlocks_ = function (blocks)
				{
					var fragment = this.$document[0].createDocumentFragment();
					blocks.forEach(function (block)
					{
						fragment.appendChild(block.element[0])
					});
					return fragment
				};
				VirtualRepeatController.prototype.updateIndexes_ = function ()
				{
					var itemsLength = this.items ? this.items.length : 0;
					var containerLength = Math.ceil(this.container.getSize() / this.itemSize);
					this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize)));
					this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
					this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
					this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA)
				};

				function VirtualRepeatModelArrayLike(model)
				{
					if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) throw Error("When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength() ");
					this.model = model
				}
				VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function (start, end)
				{
					for (var i = start; i < end; i++) this.hasOwnProperty(i) || (this[i] = this.model.getItemAtIndex(i));
					this.length = this.model.getLength()
				};

				function ForceHeightDirective($mdUtil)
				{
					return {
						restrict: "A",
						link: function (scope, element, attrs)
						{
							var height = scope.$eval(attrs.mdForceHeight) || null;
							height && element && (element[0].style.height = height)
						}
					}
				}
				ForceHeightDirective.$inject = ["$mdUtil"]
			})();
			(function ()
			{
				MdWhiteframeDirective.$inject = ["$log"];
				angular.module("material.components.whiteframe", ["material.core"]).directive("mdWhiteframe", MdWhiteframeDirective);

				function MdWhiteframeDirective($log)
				{
					var DISABLE_DP = -1;
					var MIN_DP = 1;
					var MAX_DP = 24;
					var DEFAULT_DP = 4;
					return {
						link: postLink
					};

					function postLink(scope, element, attr)
					{
						var oldClass = "";
						attr.$observe("mdWhiteframe", function (elevation)
						{
							elevation = parseInt(elevation, 10) || DEFAULT_DP;
							if (elevation != DISABLE_DP && (elevation > MAX_DP || elevation < MIN_DP))
							{
								$log.warn("md-whiteframe attribute value is invalid. It should be a number between " + MIN_DP + " and " + MAX_DP, element[0]);
								elevation = DEFAULT_DP
							}
							var newClass = elevation == DISABLE_DP ? "" : "md-whiteframe-" + elevation + "dp";
							attr.$updateClass(newClass, oldClass);
							oldClass = newClass
						})
					}
				}
			})();
			(function ()
			{
				MdAutocompleteCtrl.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q", "$log", "$mdLiveAnnouncer"];
				angular.module("material.components.autocomplete").controller("MdAutocompleteCtrl", MdAutocompleteCtrl);
				var ITEM_HEIGHT = 48,
					MAX_ITEMS = 5,
					MENU_PADDING = 8,
					INPUT_PADDING = 2;

				function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q, $log, $mdLiveAnnouncer)
				{
					var ctrl = this,
						itemParts = $scope.itemsExpr.split(/ in /i),
						itemExpr = itemParts[1],
						elements = null,
						cache = {},
						noBlur = false,
						selectedItemWatchers = [],
						hasFocus = false,
						fetchesInProgress = 0,
						enableWrapScroll = null,
						inputModelCtrl = null,
						debouncedOnResize = $mdUtil.debounce(onWindowResize);
					defineProperty("hidden", handleHiddenChange, true);
					ctrl.scope = $scope;
					ctrl.parent = $scope.$parent;
					ctrl.itemName = itemParts[0];
					ctrl.matches = [];
					ctrl.loading = false;
					ctrl.hidden = true;
					ctrl.index = null;
					ctrl.id = $mdUtil.nextUid();
					ctrl.isDisabled = null;
					ctrl.isRequired = null;
					ctrl.isReadonly = null;
					ctrl.hasNotFound = false;
					ctrl.keydown = keydown;
					ctrl.blur = blur;
					ctrl.focus = focus;
					ctrl.clear = clearValue;
					ctrl.select = select;
					ctrl.listEnter = onListEnter;
					ctrl.listLeave = onListLeave;
					ctrl.mouseUp = onMouseup;
					ctrl.getCurrentDisplayValue = getCurrentDisplayValue;
					ctrl.registerSelectedItemWatcher = registerSelectedItemWatcher;
					ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
					ctrl.notFoundVisible = notFoundVisible;
					ctrl.loadingIsVisible = loadingIsVisible;
					ctrl.positionDropdown = positionDropdown;
					var ReportType = {
						Count: 1,
						Selected: 2
					};
					return init();

					function init()
					{
						$mdUtil.initOptionalProperties($scope, $attrs,
						{
							searchText: "",
							selectedItem: null,
							clearButton: false
						});
						$mdTheming($element);
						configureWatchers();
						$mdUtil.nextTick(function ()
						{
							gatherElements();
							moveDropdown();
							$scope.autofocus && $element.on("focus", focusInputElement)
						})
					}

					function updateModelValidators()
					{
						if (!$scope.requireMatch || !inputModelCtrl) return;
						inputModelCtrl.$setValidity("md-require-match", !!$scope.selectedItem || !$scope.searchText)
					}

					function positionDropdown()
					{
						if (!elements) return $mdUtil.nextTick(positionDropdown, false, $scope);
						var dropdownHeight = ($scope.dropdownItems || MAX_ITEMS) * ITEM_HEIGHT;
						var styles, hrect = elements.wrap.getBoundingClientRect(),
							vrect = elements.snap.getBoundingClientRect(),
							root = elements.root.getBoundingClientRect(),
							top = vrect.bottom - root.top,
							bot = root.bottom - vrect.top,
							left = hrect.left - root.left,
							width = hrect.width,
							offset = getVerticalOffset(),
							position = $scope.dropdownPosition;
						position || (position = top > bot && root.height - top - MENU_PADDING < dropdownHeight ? "top" : "bottom");
						if ($attrs.mdFloatingLabel)
						{
							left += INPUT_PADDING;
							width -= 2 * INPUT_PADDING
						}
						styles = {
							left: left + "px",
							minWidth: width + "px",
							maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + "px"
						};
						if ("top" === position)
						{
							styles.top = "auto";
							styles.bottom = bot + "px";
							styles.maxHeight = Math.min(dropdownHeight, hrect.top - root.top - MENU_PADDING) + "px"
						}
						else
						{
							var bottomSpace = root.bottom - hrect.bottom - MENU_PADDING + $mdUtil.getViewportTop();
							styles.top = top - offset + "px";
							styles.bottom = "auto";
							styles.maxHeight = Math.min(dropdownHeight, bottomSpace) + "px"
						}
						elements.$.scrollContainer.css(styles);
						$mdUtil.nextTick(correctHorizontalAlignment, false);

						function getVerticalOffset()
						{
							var offset = 0;
							var inputContainer = $element.find("md-input-container");
							if (inputContainer.length)
							{
								var input = inputContainer.find("input");
								offset = inputContainer.prop("offsetHeight");
								offset -= input.prop("offsetTop");
								offset -= input.prop("offsetHeight");
								offset += inputContainer.prop("offsetTop")
							}
							return offset
						}

						function correctHorizontalAlignment()
						{
							var dropdown = elements.scrollContainer.getBoundingClientRect(),
								styles = {};
							dropdown.right > root.right - MENU_PADDING && (styles.left = hrect.right - dropdown.width + "px");
							elements.$.scrollContainer.css(styles)
						}
					}

					function moveDropdown()
					{
						if (!elements.$.root.length) return;
						$mdTheming(elements.$.scrollContainer);
						elements.$.scrollContainer.detach();
						elements.$.root.append(elements.$.scrollContainer);
						$animate.pin && $animate.pin(elements.$.scrollContainer, $rootElement)
					}

					function focusInputElement()
					{
						elements.input.focus()
					}

					function configureWatchers()
					{
						var wait = parseInt($scope.delay, 10) || 0;
						$attrs.$observe("disabled", function (value)
						{
							ctrl.isDisabled = $mdUtil.parseAttributeBoolean(value, false)
						});
						$attrs.$observe("required", function (value)
						{
							ctrl.isRequired = $mdUtil.parseAttributeBoolean(value, false)
						});
						$attrs.$observe("readonly", function (value)
						{
							ctrl.isReadonly = $mdUtil.parseAttributeBoolean(value, false)
						});
						$scope.$watch("searchText", wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
						$scope.$watch("selectedItem", selectedItemChange);
						angular.element($window).on("resize", debouncedOnResize);
						$scope.$on("$destroy", cleanup)
					}

					function cleanup()
					{
						ctrl.hidden || $mdUtil.enableScrolling();
						angular.element($window).off("resize", debouncedOnResize);
						if (elements)
						{
							var items = ["ul", "scroller", "scrollContainer", "input"];
							angular.forEach(items, function (key)
							{
								elements.$[key].remove()
							})
						}
					}

					function onWindowResize()
					{
						ctrl.hidden || positionDropdown()
					}

					function gatherElements()
					{
						var snapWrap = gatherSnapWrap();
						elements = {
							main: $element[0],
							scrollContainer: $element[0].querySelector(".md-virtual-repeat-container"),
							scroller: $element[0].querySelector(".md-virtual-repeat-scroller"),
							ul: $element.find("ul")[0],
							input: $element.find("input")[0],
							wrap: snapWrap.wrap,
							snap: snapWrap.snap,
							root: document.body
						};
						elements.li = elements.ul.getElementsByTagName("li");
						elements.$ = getAngularElements(elements);
						inputModelCtrl = elements.$.input.controller("ngModel")
					}

					function gatherSnapWrap()
					{
						var element;
						var value;
						for (element = $element; element.length; element = element.parent())
						{
							value = element.attr("md-autocomplete-snap");
							if (angular.isDefined(value)) break
						}
						if (element.length) return {
							snap: element[0],
							wrap: "width" === value.toLowerCase() ? element[0] : $element.find("md-autocomplete-wrap")[0]
						};
						var wrap = $element.find("md-autocomplete-wrap")[0];
						return {
							snap: wrap,
							wrap: wrap
						}
					}

					function getAngularElements(elements)
					{
						var obj = {};
						for (var key in elements) elements.hasOwnProperty(key) && (obj[key] = angular.element(elements[key]));
						return obj
					}

					function handleHiddenChange(hidden, oldHidden)
					{
						if (!hidden && oldHidden)
						{
							positionDropdown();
							reportMessages(true, ReportType.Count | ReportType.Selected);
							if (elements)
							{
								$mdUtil.disableScrollAround(elements.ul);
								enableWrapScroll = disableElementScrollEvents(angular.element(elements.wrap))
							}
						}
						else if (hidden && !oldHidden)
						{
							$mdUtil.enableScrolling();
							if (enableWrapScroll)
							{
								enableWrapScroll();
								enableWrapScroll = null
							}
						}
					}

					function disableElementScrollEvents(element)
					{
						function preventDefault(e)
						{
							e.preventDefault()
						}
						element.on("wheel", preventDefault);
						element.on("touchmove", preventDefault);
						return function ()
						{
							element.off("wheel", preventDefault);
							element.off("touchmove", preventDefault)
						}
					}

					function onListEnter()
					{
						noBlur = true
					}

					function onListLeave()
					{
						hasFocus || ctrl.hidden || elements.input.focus();
						noBlur = false;
						ctrl.hidden = shouldHide()
					}

					function onMouseup()
					{
						elements.input.focus()
					}

					function selectedItemChange(selectedItem, previousSelectedItem)
					{
						updateModelValidators();
						selectedItem ? getDisplayValue(selectedItem).then(function (val)
						{
							$scope.searchText = val;
							handleSelectedItemChange(selectedItem, previousSelectedItem)
						}) : previousSelectedItem && $scope.searchText && getDisplayValue(previousSelectedItem).then(function (displayValue)
						{
							angular.isString($scope.searchText) && displayValue.toString().toLowerCase() === $scope.searchText.toLowerCase() && ($scope.searchText = "")
						});
						selectedItem !== previousSelectedItem && announceItemChange()
					}

					function announceItemChange()
					{
						angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem))
					}

					function announceTextChange()
					{
						angular.isFunction($scope.textChange) && $scope.textChange()
					}

					function handleSelectedItemChange(selectedItem, previousSelectedItem)
					{
						selectedItemWatchers.forEach(function (watcher)
						{
							watcher(selectedItem, previousSelectedItem)
						})
					}

					function registerSelectedItemWatcher(cb)
					{
						-1 == selectedItemWatchers.indexOf(cb) && selectedItemWatchers.push(cb)
					}

					function unregisterSelectedItemWatcher(cb)
					{
						var i = selectedItemWatchers.indexOf(cb); - 1 != i && selectedItemWatchers.splice(i, 1)
					}

					function handleSearchText(searchText, previousSearchText)
					{
						ctrl.index = getDefaultIndex();
						if (searchText === previousSearchText) return;
						updateModelValidators();
						getDisplayValue($scope.selectedItem).then(function (val)
						{
							if (searchText !== val)
							{
								$scope.selectedItem = null;
								searchText !== previousSearchText && announceTextChange();
								if (isMinLengthMet()) handleQuery();
								else
								{
									ctrl.matches = [];
									setLoading(false);
									reportMessages(false, ReportType.Count)
								}
							}
						})
					}

					function blur($event)
					{
						hasFocus = false;
						if (!noBlur)
						{
							ctrl.hidden = shouldHide();
							evalAttr("ngBlur",
							{
								$event: $event
							})
						}
					}

					function doBlur(forceBlur)
					{
						if (forceBlur)
						{
							noBlur = false;
							hasFocus = false
						}
						elements.input.blur()
					}

					function focus($event)
					{
						hasFocus = true;
						isSearchable() && isMinLengthMet() && handleQuery();
						ctrl.hidden = shouldHide();
						evalAttr("ngFocus",
						{
							$event: $event
						})
					}

					function keydown(event)
					{
						switch (event.keyCode)
						{
						case $mdConstant.KEY_CODE.DOWN_ARROW:
							if (ctrl.loading) return;
							event.stopPropagation();
							event.preventDefault();
							ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
							updateScroll();
							reportMessages(false, ReportType.Selected);
							break;
						case $mdConstant.KEY_CODE.UP_ARROW:
							if (ctrl.loading) return;
							event.stopPropagation();
							event.preventDefault();
							ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
							updateScroll();
							reportMessages(false, ReportType.Selected);
							break;
						case $mdConstant.KEY_CODE.TAB:
							onListLeave();
							if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
							select(ctrl.index);
							break;
						case $mdConstant.KEY_CODE.ENTER:
							if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
							if (hasSelection()) return;
							event.stopPropagation();
							event.preventDefault();
							select(ctrl.index);
							break;
						case $mdConstant.KEY_CODE.ESCAPE:
							event.preventDefault();
							if (!shouldProcessEscape()) return;
							event.stopPropagation();
							clearSelectedItem();
							$scope.searchText && hasEscapeOption("clear") && clearSearchText();
							ctrl.hidden = true;
							hasEscapeOption("blur") && doBlur(true)
						}
					}

					function getMinLength()
					{
						return angular.isNumber($scope.minLength) ? $scope.minLength : 1
					}

					function getDisplayValue(item)
					{
						return $q.when(getItemText(item) || item).then(function (itemText)
						{
							itemText && !angular.isString(itemText) && $log.warn("md-autocomplete: Could not resolve display value to a string. Please check the `md-item-text` attribute.");
							return itemText
						});

						function getItemText(item)
						{
							return item && $scope.itemText ? $scope.itemText(getItemAsNameVal(item)) : null
						}
					}

					function getItemAsNameVal(item)
					{
						if (!item) return undefined;
						var locals = {};
						ctrl.itemName && (locals[ctrl.itemName] = item);
						return locals
					}

					function getDefaultIndex()
					{
						return $scope.autoselect ? 0 : -1
					}

					function setLoading(value)
					{
						ctrl.loading != value && (ctrl.loading = value);
						ctrl.hidden = shouldHide()
					}

					function shouldHide()
					{
						return !shouldShow()
					}

					function isSearchable()
					{
						if (ctrl.loading && !hasMatches()) return false;
						if (hasSelection()) return false;
						if (!hasFocus) return false;
						return true
					}

					function shouldProcessEscape()
					{
						return hasEscapeOption("blur") || !ctrl.hidden || ctrl.loading || hasEscapeOption("clear") && $scope.searchText
					}

					function hasEscapeOption(option)
					{
						return !$scope.escapeOptions || -1 !== $scope.escapeOptions.toLowerCase().indexOf(option)
					}

					function shouldShow()
					{
						if (ctrl.isReadonly) return false;
						if (!isSearchable()) return false;
						return isMinLengthMet() && hasMatches() || notFoundVisible()
					}

					function hasMatches()
					{
						return !!ctrl.matches.length
					}

					function hasSelection()
					{
						return !!ctrl.scope.selectedItem
					}

					function loadingIsVisible()
					{
						return ctrl.loading && !hasSelection()
					}

					function getCurrentDisplayValue()
					{
						return getDisplayValue(ctrl.matches[ctrl.index])
					}

					function isMinLengthMet()
					{
						return ($scope.searchText || "").length >= getMinLength()
					}

					function defineProperty(key, handler, value)
					{
						Object.defineProperty(ctrl, key,
						{
							get: function ()
							{
								return value
							},
							set: function (newValue)
							{
								var oldValue = value;
								value = newValue;
								handler(newValue, oldValue)
							}
						})
					}

					function select(index)
					{
						$mdUtil.nextTick(function ()
						{
							getDisplayValue(ctrl.matches[index]).then(function (val)
							{
								var ngModel = elements.$.input.controller("ngModel");
								ngModel.$setViewValue(val);
								ngModel.$render()
							}).finally(function ()
							{
								$scope.selectedItem = ctrl.matches[index];
								setLoading(false)
							})
						}, false)
					}

					function clearValue()
					{
						clearSelectedItem();
						clearSearchText()
					}

					function clearSelectedItem()
					{
						ctrl.index = 0;
						ctrl.matches = []
					}

					function clearSearchText()
					{
						setLoading(true);
						$scope.searchText = "";
						var eventObj = document.createEvent("CustomEvent");
						eventObj.initCustomEvent("change", true, true,
						{
							value: ""
						});
						elements.input.dispatchEvent(eventObj);
						elements.input.blur();
						$scope.searchText = "";
						elements.input.focus()
					}

					function fetchResults(searchText)
					{
						var items = $scope.$parent.$eval(itemExpr),
							term = searchText.toLowerCase(),
							isList = angular.isArray(items),
							isPromise = !!items.then;
						isList ? onResultsRetrieved(items) : isPromise && handleAsyncResults(items);

						function handleAsyncResults(items)
						{
							if (!items) return;
							items = $q.when(items);
							fetchesInProgress++;
							setLoading(true);
							$mdUtil.nextTick(function ()
							{
								items.then(onResultsRetrieved).finally(function ()
								{
									0 === --fetchesInProgress && setLoading(false)
								})
							}, true, $scope)
						}

						function onResultsRetrieved(matches)
						{
							cache[term] = matches;
							if ((searchText || "") !== ($scope.searchText || "")) return;
							handleResults(matches)
						}
					}

					function reportMessages(isPolite, types)
					{
						var politeness = isPolite ? "polite" : "assertive";
						var messages = [];
						types & ReportType.Selected && -1 !== ctrl.index && messages.push(getCurrentDisplayValue());
						types & ReportType.Count && messages.push($q.resolve(getCountMessage()));
						$q.all(messages).then(function (data)
						{
							$mdLiveAnnouncer.announce(data.join(" "), politeness)
						})
					}

					function getCountMessage()
					{
						switch (ctrl.matches.length)
						{
						case 0:
							return "There are no matches available.";
						case 1:
							return "There is 1 match available.";
						default:
							return "There are " + ctrl.matches.length + " matches available."
						}
					}

					function updateScroll()
					{
						if (!elements.li[0]) return;
						var height = elements.li[0].offsetHeight,
							top = height * ctrl.index,
							bot = top + height,
							hgt = elements.scroller.clientHeight,
							scrollTop = elements.scroller.scrollTop;
						top < scrollTop ? scrollTo(top) : bot > scrollTop + hgt && scrollTo(bot - hgt)
					}

					function isPromiseFetching()
					{
						return 0 !== fetchesInProgress
					}

					function scrollTo(offset)
					{
						elements.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(offset)
					}

					function notFoundVisible()
					{
						var textLength = (ctrl.scope.searchText || "").length;
						return ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || isPromiseFetching()) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection()
					}

					function handleQuery()
					{
						var searchText = $scope.searchText || "";
						var term = searchText.toLowerCase();
						!$scope.noCache && cache[term] ? handleResults(cache[term]) : fetchResults(searchText);
						ctrl.hidden = shouldHide()
					}

					function handleResults(results)
					{
						ctrl.matches = results;
						ctrl.hidden = shouldHide();
						ctrl.loading && setLoading(false);
						$scope.selectOnMatch && selectItemOnMatch();
						positionDropdown();
						reportMessages(true, ReportType.Count)
					}

					function selectItemOnMatch()
					{
						var searchText = $scope.searchText,
							matches = ctrl.matches,
							item = matches[0];
						1 === matches.length && getDisplayValue(item).then(function (displayValue)
						{
							var isMatching = searchText == displayValue;
							$scope.matchInsensitive && !isMatching && (isMatching = searchText.toLowerCase() == displayValue.toLowerCase());
							isMatching && select(0)
						})
					}

					function evalAttr(attr, locals)
					{
						$attrs[attr] && $scope.$parent.$eval($attrs[attr], locals ||
						{})
					}
				}
			})();
			(function ()
			{
				MdAutocomplete.$inject = ["$$mdSvgRegistry"];
				angular.module("material.components.autocomplete").directive("mdAutocomplete", MdAutocomplete);

				function MdAutocomplete($$mdSvgRegistry)
				{
					return {
						controller: "MdAutocompleteCtrl",
						controllerAs: "$mdAutocompleteCtrl",
						scope:
						{
							inputName: "@mdInputName",
							inputMinlength: "@mdInputMinlength",
							inputMaxlength: "@mdInputMaxlength",
							searchText: "=?mdSearchText",
							selectedItem: "=?mdSelectedItem",
							itemsExpr: "@mdItems",
							itemText: "&mdItemText",
							placeholder: "@placeholder",
							noCache: "=?mdNoCache",
							requireMatch: "=?mdRequireMatch",
							selectOnMatch: "=?mdSelectOnMatch",
							matchInsensitive: "=?mdMatchCaseInsensitive",
							itemChange: "&?mdSelectedItemChange",
							textChange: "&?mdSearchTextChange",
							minLength: "=?mdMinLength",
							delay: "=?mdDelay",
							autofocus: "=?mdAutofocus",
							floatingLabel: "@?mdFloatingLabel",
							autoselect: "=?mdAutoselect",
							menuClass: "@?mdMenuClass",
							menuContainerClass: "@?mdMenuContainerClass",
							inputClass: "@?mdInputClass",
							inputId: "@?mdInputId",
							escapeOptions: "@?mdEscapeOptions",
							dropdownItems: "=?mdDropdownItems",
							dropdownPosition: "@?mdDropdownPosition",
							clearButton: "=?mdClearButton"
						},
						compile: function (tElement, tAttrs)
						{
							var attributes = ["md-select-on-focus", "md-no-asterisk", "ng-trim", "ng-pattern"];
							var input = tElement.find("input");
							attributes.forEach(function (attribute)
							{
								var attrValue = tAttrs[tAttrs.$normalize(attribute)];
								null !== attrValue && input.attr(attribute, attrValue)
							});
							return function (scope, element, attrs, ctrl)
							{
								ctrl.hasNotFound = !!element.attr("md-has-not-found");
								angular.isDefined(attrs.mdClearButton) || scope.floatingLabel || (scope.clearButton = true)
							}
						},
						template: function (element, attr)
						{
							var noItemsTemplate = getNoItemsTemplate(),
								itemTemplate = getItemTemplate(),
								leftover = element.html(),
								tabindex = attr.tabindex;
							var menuContainerClass = attr.mdMenuContainerClass ? " " + attr.mdMenuContainerClass : "";
							noItemsTemplate && element.attr("md-has-not-found", true);
							element.attr("tabindex", "-1");
							return "        <md-autocomplete-wrap            ng-class=\"{ 'md-whiteframe-z1': !floatingLabel,                         'md-menu-showing': !$mdAutocompleteCtrl.hidden,                         'md-show-clear-button': !!clearButton }\">          " + getInputElement() + "          " + getClearButton() + '          <md-progress-linear              class="' + (attr.mdFloatingLabel ? "md-inline" : "") + '"              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"></md-progress-linear>          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"              ng-hide="$mdAutocompleteCtrl.hidden"              class="md-autocomplete-suggestions-container md-whiteframe-z1' + menuContainerClass + '"              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              role="presentation">            <ul class="md-autocomplete-suggestions"                ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}">              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  ng-click="$mdAutocompleteCtrl.select($index)"                  md-extra-name="$mdAutocompleteCtrl.itemName">                  ' + itemTemplate + "                  </li>" + noItemsTemplate + "            </ul>          </md-virtual-repeat-container>        </md-autocomplete-wrap>";

							function getItemTemplate()
							{
								var templateTag = element.find("md-item-template").detach(),
									html = templateTag.length ? templateTag.html() : element.html();
								templateTag.length || element.empty();
								return "<md-autocomplete-parent-scope md-autocomplete-replace>" + html + "</md-autocomplete-parent-scope>"
							}

							function getNoItemsTemplate()
							{
								var templateTag = element.find("md-not-found").detach(),
									template = templateTag.length ? templateTag.html() : "";
								return template ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"                         md-autocomplete-parent-scope>' + template + "</li>" : ""
							}

							function getInputElement()
							{
								return attr.mdFloatingLabel ? '            <md-input-container ng-if="floatingLabel">              <label>{{floatingLabel}}</label>              <input type="search"                  ' + (null != tabindex ? 'tabindex="' + tabindex + '"' : "") + '                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                  name="{{inputName}}"                  ng-class="::inputClass"                  autocomplete="off"                  ng-required="$mdAutocompleteCtrl.isRequired"                  ng-readonly="$mdAutocompleteCtrl.isReadonly"                  ng-minlength="inputMinlength"                  ng-maxlength="inputMaxlength"                  ng-disabled="$mdAutocompleteCtrl.isDisabled"                  ng-model="$mdAutocompleteCtrl.scope.searchText"                  ng-model-options="{ allowInvalid: true }"                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"                  ng-blur="$mdAutocompleteCtrl.blur($event)"                  ng-focus="$mdAutocompleteCtrl.focus($event)"                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                  aria-label="{{floatingLabel}}"                  aria-autocomplete="list"                  role="combobox"                  aria-haspopup="true"                  aria-activedescendant=""                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + "</div>            </md-input-container>" : '            <input type="search"                ' + (null != tabindex ? 'tabindex="' + tabindex + '"' : "") + '                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"                name="{{inputName}}"                ng-class="::inputClass"                ng-if="!floatingLabel"                autocomplete="off"                ng-required="$mdAutocompleteCtrl.isRequired"                ng-disabled="$mdAutocompleteCtrl.isDisabled"                ng-readonly="$mdAutocompleteCtrl.isReadonly"                ng-minlength="inputMinlength"                ng-maxlength="inputMaxlength"                ng-model="$mdAutocompleteCtrl.scope.searchText"                ng-keydown="$mdAutocompleteCtrl.keydown($event)"                ng-blur="$mdAutocompleteCtrl.blur($event)"                ng-focus="$mdAutocompleteCtrl.focus($event)"                placeholder="{{placeholder}}"                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                aria-label="{{placeholder}}"                aria-autocomplete="list"                role="combobox"                aria-haspopup="true"                aria-activedescendant=""                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>'
							}

							function getClearButton()
							{
								return '<button type="button" aria-label="Clear Input" tabindex="-1" ng-if="clearButton && $mdAutocompleteCtrl.scope.searchText" ng-click="$mdAutocompleteCtrl.clear($event)"><md-icon md-svg-src="' + $$mdSvgRegistry.mdClose + '"></md-icon></button>'
							}
						}
					}
				}
			})();
			(function ()
			{
				MdAutocompleteItemScopeDirective.$inject = ["$compile", "$mdUtil"];
				angular.module("material.components.autocomplete").directive("mdAutocompleteParentScope", MdAutocompleteItemScopeDirective);

				function MdAutocompleteItemScopeDirective($compile, $mdUtil)
				{
					return {
						restrict: "AE",
						compile: compile,
						terminal: true,
						transclude: "element"
					};

					function compile(tElement, tAttr, transclude)
					{
						return function postLink(scope, element, attr)
						{
							var ctrl = scope.$mdAutocompleteCtrl;
							var newScope = ctrl.parent.$new();
							var itemName = ctrl.itemName;
							watchVariable("$index", "$index");
							watchVariable("item", itemName);
							connectScopes();
							transclude(newScope, function (clone)
							{
								element.after(clone)
							});

							function watchVariable(variable, alias)
							{
								newScope[alias] = scope[variable];
								scope.$watch(variable, function (value)
								{
									$mdUtil.nextTick(function ()
									{
										newScope[alias] = value
									})
								})
							}

							function connectScopes()
							{
								var scopeDigesting = false;
								var newScopeDigesting = false;
								scope.$watch(function ()
								{
									if (newScopeDigesting || scopeDigesting) return;
									scopeDigesting = true;
									scope.$$postDigest(function ()
									{
										newScopeDigesting || newScope.$digest();
										scopeDigesting = newScopeDigesting = false
									})
								});
								newScope.$watch(function ()
								{
									newScopeDigesting = true
								})
							}
						}
					}
				}
			})();
			(function ()
			{
				MdHighlightCtrl.$inject = ["$scope", "$element", "$attrs"];
				angular.module("material.components.autocomplete").controller("MdHighlightCtrl", MdHighlightCtrl);

				function MdHighlightCtrl($scope, $element, $attrs)
				{
					this.$scope = $scope;
					this.$element = $element;
					this.$attrs = $attrs;
					this.regex = null
				}
				MdHighlightCtrl.prototype.init = function (unsafeTermFn, unsafeContentFn)
				{
					this.flags = this.$attrs.mdHighlightFlags || "";
					this.unregisterFn = this.$scope.$watch(function ($scope)
					{
						return {
							term: unsafeTermFn($scope),
							contentText: unsafeContentFn($scope)
						}
					}.bind(this), this.onRender.bind(this), true);
					this.$element.on("$destroy", this.unregisterFn)
				};
				MdHighlightCtrl.prototype.onRender = function (state, prevState)
				{
					var contentText = state.contentText;
					null !== this.regex && state.term === prevState.term || (this.regex = this.createRegex(state.term, this.flags));
					state.term ? this.applyRegex(contentText) : this.$element.text(contentText)
				};
				MdHighlightCtrl.prototype.applyRegex = function (text)
				{
					var tokens = this.resolveTokens(text);
					this.$element.empty();
					tokens.forEach(function (token)
					{
						if (token.isMatch)
						{
							var tokenEl = angular.element('<span class="highlight">').text(token.text);
							this.$element.append(tokenEl)
						}
						else this.$element.append(document.createTextNode(token))
					}.bind(this))
				};
				MdHighlightCtrl.prototype.resolveTokens = function (string)
				{
					var tokens = [];
					var lastIndex = 0;
					string.replace(this.regex, function (match, index)
					{
						appendToken(lastIndex, index);
						tokens.push(
						{
							text: match,
							isMatch: true
						});
						lastIndex = index + match.length
					});
					appendToken(lastIndex);
					return tokens;

					function appendToken(from, to)
					{
						var targetText = string.slice(from, to);
						targetText && tokens.push(targetText)
					}
				};
				MdHighlightCtrl.prototype.createRegex = function (term, flags)
				{
					var startFlag = "",
						endFlag = "";
					var regexTerm = this.sanitizeRegex(term);
					flags.indexOf("^") >= 0 && (startFlag = "^");
					flags.indexOf("$") >= 0 && (endFlag = "$");
					return new RegExp(startFlag + regexTerm + endFlag, flags.replace(/[$^]/g, ""))
				};
				MdHighlightCtrl.prototype.sanitizeRegex = function (term)
				{
					return term && term.toString().replace(/[\\^$*+?.()|{}[\]]/g, "\\$&")
				}
			})();
			(function ()
			{
				MdHighlight.$inject = ["$interpolate", "$parse"];
				angular.module("material.components.autocomplete").directive("mdHighlightText", MdHighlight);

				function MdHighlight($interpolate, $parse)
				{
					return {
						terminal: true,
						controller: "MdHighlightCtrl",
						compile: function mdHighlightCompile(tElement, tAttr)
						{
							var termExpr = $parse(tAttr.mdHighlightText);
							var unsafeContentExpr = $interpolate(tElement.html());
							return function mdHighlightLink(scope, element, attr, ctrl)
							{
								ctrl.init(termExpr, unsafeContentExpr)
							}
						}
					}
				}
			})();
			(function ()
			{
				MdChipCtrl.$inject = ["$scope", "$element", "$mdConstant", "$timeout", "$mdUtil"];
				angular.module("material.components.chips").controller("MdChipCtrl", MdChipCtrl);

				function MdChipCtrl($scope, $element, $mdConstant, $timeout, $mdUtil)
				{
					this.$scope = $scope;
					this.$element = $element;
					this.$mdConstant = $mdConstant;
					this.$timeout = $timeout;
					this.$mdUtil = $mdUtil;
					this.isEditing = false;
					this.parentController = undefined;
					this.enableChipEdit = false
				}
				MdChipCtrl.prototype.init = function (controller)
				{
					this.parentController = controller;
					this.enableChipEdit = this.parentController.enableChipEdit;
					if (this.enableChipEdit)
					{
						this.$element.on("keydown", this.chipKeyDown.bind(this));
						this.$element.on("dblclick", this.chipMouseDoubleClick.bind(this));
						this.getChipContent().addClass("_md-chip-content-edit-is-enabled")
					}
				};
				MdChipCtrl.prototype.getChipContent = function ()
				{
					var chipContents = this.$element[0].getElementsByClassName("md-chip-content");
					return angular.element(chipContents[0])
				};
				MdChipCtrl.prototype.getContentElement = function ()
				{
					return angular.element(this.getChipContent().contents()[0])
				};
				MdChipCtrl.prototype.getChipIndex = function ()
				{
					return parseInt(this.$element.attr("index"))
				};
				MdChipCtrl.prototype.goOutOfEditMode = function ()
				{
					if (!this.isEditing) return;
					this.isEditing = false;
					this.$element.removeClass("_md-chip-editing");
					this.getChipContent()[0].contentEditable = "false";
					var chipIndex = this.getChipIndex();
					var content = this.getContentElement().text();
					if (content)
					{
						this.parentController.updateChipContents(chipIndex, this.getContentElement().text());
						this.$mdUtil.nextTick(function ()
						{
							this.parentController.selectedChip === chipIndex && this.parentController.focusChip(chipIndex)
						}.bind(this))
					}
					else this.parentController.removeChipAndFocusInput(chipIndex)
				};
				MdChipCtrl.prototype.selectNodeContents = function (node)
				{
					var range, selection;
					if (document.body.createTextRange)
					{
						range = document.body.createTextRange();
						range.moveToElementText(node);
						range.select()
					}
					else if (window.getSelection)
					{
						selection = window.getSelection();
						range = document.createRange();
						range.selectNodeContents(node);
						selection.removeAllRanges();
						selection.addRange(range)
					}
				};
				MdChipCtrl.prototype.goInEditMode = function ()
				{
					this.isEditing = true;
					this.$element.addClass("_md-chip-editing");
					this.getChipContent()[0].contentEditable = "true";
					this.getChipContent().on("blur", function ()
					{
						this.goOutOfEditMode()
					}.bind(this));
					this.selectNodeContents(this.getChipContent()[0])
				};
				MdChipCtrl.prototype.chipKeyDown = function (event)
				{
					if (this.isEditing || event.keyCode !== this.$mdConstant.KEY_CODE.ENTER && event.keyCode !== this.$mdConstant.KEY_CODE.SPACE)
					{
						if (this.isEditing && event.keyCode === this.$mdConstant.KEY_CODE.ENTER)
						{
							event.preventDefault();
							this.goOutOfEditMode()
						}
					}
					else
					{
						event.preventDefault();
						this.goInEditMode()
					}
				};
				MdChipCtrl.prototype.chipMouseDoubleClick = function ()
				{
					this.enableChipEdit && !this.isEditing && this.goInEditMode()
				}
			})();
			(function ()
			{
				MdChip.$inject = ["$mdTheming", "$mdUtil", "$compile", "$timeout"];
				angular.module("material.components.chips").directive("mdChip", MdChip);
				var DELETE_HINT_TEMPLATE = '    <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">      {{$mdChipsCtrl.deleteHint}}    </span>';

				function MdChip($mdTheming, $mdUtil, $compile, $timeout)
				{
					var deleteHintTemplate = $mdUtil.processTemplate(DELETE_HINT_TEMPLATE);
					return {
						restrict: "E",
						require: ["^?mdChips", "mdChip"],
						link: postLink,
						controller: "MdChipCtrl"
					};

					function postLink(scope, element, attr, ctrls)
					{
						var chipsController = ctrls.shift();
						var chipController = ctrls.shift();
						var chipContentElement = angular.element(element[0].querySelector(".md-chip-content"));
						$mdTheming(element);
						if (chipsController)
						{
							chipController.init(chipsController);
							chipContentElement.append($compile(deleteHintTemplate)(scope));
							chipContentElement.on("blur", function ()
							{
								chipsController.resetSelectedChip();
								chipsController.$scope.$applyAsync()
							})
						}
						$timeout(function ()
						{
							if (!chipsController) return;
							chipsController.shouldFocusLastChip && chipsController.focusLastChipThenInput()
						})
					}
				}
			})();
			(function ()
			{
				MdChipRemove.$inject = ["$timeout"];
				angular.module("material.components.chips").directive("mdChipRemove", MdChipRemove);

				function MdChipRemove($timeout)
				{
					return {
						restrict: "A",
						require: "^mdChips",
						scope: false,
						link: postLink
					};

					function postLink(scope, element, attr, ctrl)
					{
						element.on("click", function (event)
						{
							scope.$apply(function ()
							{
								ctrl.removeChip(scope.$$replacedScope.$index)
							})
						});
						$timeout(function ()
						{
							element.attr(
							{
								tabindex: -1,
								"aria-hidden": true
							});
							element.find("button").attr("tabindex", "-1")
						})
					}
				}
			})();
			(function ()
			{
				MdChipTransclude.$inject = ["$compile"];
				angular.module("material.components.chips").directive("mdChipTransclude", MdChipTransclude);

				function MdChipTransclude($compile)
				{
					return {
						restrict: "EA",
						terminal: true,
						link: link,
						scope: false
					};

					function link(scope, element, attr)
					{
						var ctrl = scope.$parent.$mdChipsCtrl,
							newScope = ctrl.parent.$new(false, ctrl.parent);
						newScope.$$replacedScope = scope;
						newScope.$chip = scope.$chip;
						newScope.$index = scope.$index;
						newScope.$mdChipsCtrl = ctrl;
						var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);
						element.html(newHtml);
						$compile(element.contents())(newScope)
					}
				}
			})();
			(function ()
			{
				MdChipsCtrl.$inject = ["$scope", "$attrs", "$mdConstant", "$log", "$element", "$timeout", "$mdUtil", "$exceptionHandler"];
				var DEFAULT_CHIP_APPEND_DELAY = 300;
				angular.module("material.components.chips").controller("MdChipsCtrl", MdChipsCtrl);

				function MdChipsCtrl($scope, $attrs, $mdConstant, $log, $element, $timeout, $mdUtil, $exceptionHandler)
				{
					this.$timeout = $timeout;
					this.$mdConstant = $mdConstant;
					this.$scope = $scope;
					this.parent = $scope.$parent;
					this.$mdUtil = $mdUtil;
					this.$log = $log;
					this.$exceptionHandler = $exceptionHandler;
					this.$element = $element;
					this.$attrs = $attrs;
					this.ngModelCtrl = null;
					this.userInputNgModelCtrl = null;
					this.autocompleteCtrl = null;
					this.userInputElement = null;
					this.items = [];
					this.selectedChip = -1;
					this.enableChipEdit = $mdUtil.parseAttributeBoolean($attrs.mdEnableChipEdit);
					this.addOnBlur = $mdUtil.parseAttributeBoolean($attrs.mdAddOnBlur);
					this.inputAriaLabel = "Chips input.";
					this.containerHint = "Chips container. Use arrow keys to select chips.";
					this.deleteHint = "Press delete to remove this chip.";
					this.deleteButtonLabel = "Remove";
					this.chipBuffer = "";
					this.useTransformChip = false;
					this.useOnAdd = false;
					this.useOnRemove = false;
					this.wrapperId = "";
					this.contentIds = [];
					this.ariaTabIndex = null;
					this.chipAppendDelay = DEFAULT_CHIP_APPEND_DELAY;
					this.deRegister = [];
					this.init()
				}
				MdChipsCtrl.prototype.init = function ()
				{
					var ctrl = this;
					this.wrapperId = "_md-chips-wrapper-" + this.$mdUtil.nextUid();
					this.deRegister.push(this.$scope.$watchCollection("$mdChipsCtrl.items", function ()
					{
						ctrl.setupInputAria();
						ctrl.setupWrapperAria()
					}));
					this.deRegister.push(this.$attrs.$observe("mdChipAppendDelay", function (newValue)
					{
						ctrl.chipAppendDelay = parseInt(newValue) || DEFAULT_CHIP_APPEND_DELAY
					}))
				};
				MdChipsCtrl.prototype.$onDestroy = function $onDestroy()
				{
					var $destroyFn;
					while ($destroyFn = this.deRegister.pop()) $destroyFn.call(this)
				};
				MdChipsCtrl.prototype.setupInputAria = function ()
				{
					var input = this.$element.find("input");
					if (!input) return;
					input.attr("role", "textbox");
					input.attr("aria-multiline", true)
				};
				MdChipsCtrl.prototype.setupWrapperAria = function ()
				{
					var ctrl = this,
						wrapper = this.$element.find("md-chips-wrap");
					if (this.items && this.items.length)
					{
						wrapper.attr("role", "listbox");
						this.contentIds = this.items.map(function ()
						{
							return ctrl.wrapperId + "-chip-" + ctrl.$mdUtil.nextUid()
						});
						wrapper.attr("aria-owns", this.contentIds.join(" "))
					}
					else
					{
						wrapper.removeAttr("role");
						wrapper.removeAttr("aria-owns")
					}
				};
				MdChipsCtrl.prototype.inputKeydown = function (event)
				{
					var chipBuffer = this.getChipBuffer();
					if (this.autocompleteCtrl && event.isDefaultPrevented && event.isDefaultPrevented()) return;
					if (event.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE)
					{
						if (0 !== this.getCursorPosition(event.target)) return;
						event.preventDefault();
						event.stopPropagation();
						this.items.length && this.selectAndFocusChipSafe(this.items.length - 1);
						return
					}(!this.separatorKeys || this.separatorKeys.length < 1) && (this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER]);
					if (-1 !== this.separatorKeys.indexOf(event.keyCode))
					{
						if (this.autocompleteCtrl && this.requireMatch || !chipBuffer) return;
						event.preventDefault();
						if (this.hasMaxChipsReached()) return;
						this.appendChip(chipBuffer.trim());
						this.resetChipBuffer();
						return false
					}
				};
				MdChipsCtrl.prototype.getCursorPosition = function (element)
				{
					try
					{
						if (element.selectionStart === element.selectionEnd) return element.selectionStart
					}
					catch (e)
					{
						if (!element.value) return 0
					}
				};
				MdChipsCtrl.prototype.updateChipContents = function (chipIndex, chipContents)
				{
					if (chipIndex >= 0 && chipIndex < this.items.length)
					{
						this.items[chipIndex] = chipContents;
						this.updateNgModel(true)
					}
				};
				MdChipsCtrl.prototype.isEditingChip = function ()
				{
					return !!this.$element[0].querySelector("._md-chip-editing")
				};
				MdChipsCtrl.prototype.isRemovable = function ()
				{
					if (!this.ngModelCtrl) return false;
					return this.readonly ? this.removable : !angular.isDefined(this.removable) || this.removable
				};
				MdChipsCtrl.prototype.chipKeydown = function (event)
				{
					if (this.getChipBuffer()) return;
					if (this.isEditingChip()) return;
					switch (event.keyCode)
					{
					case this.$mdConstant.KEY_CODE.BACKSPACE:
					case this.$mdConstant.KEY_CODE.DELETE:
						if (this.selectedChip < 0) return;
						event.preventDefault();
						if (!this.isRemovable()) return;
						this.removeAndSelectAdjacentChip(this.selectedChip, event);
						break;
					case this.$mdConstant.KEY_CODE.LEFT_ARROW:
						event.preventDefault();
						(this.selectedChip < 0 || this.readonly && 0 === this.selectedChip) && (this.selectedChip = this.items.length);
						this.items.length && this.selectAndFocusChipSafe(this.selectedChip - 1);
						break;
					case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
						event.preventDefault();
						this.selectAndFocusChipSafe(this.selectedChip + 1);
						break;
					case this.$mdConstant.KEY_CODE.ESCAPE:
					case this.$mdConstant.KEY_CODE.TAB:
						if (this.selectedChip < 0) return;
						event.preventDefault();
						this.onFocus()
					}
				};
				MdChipsCtrl.prototype.getPlaceholder = function ()
				{
					var useSecondary = this.items && this.items.length && ("" === this.secondaryPlaceholder || this.secondaryPlaceholder);
					return useSecondary ? this.secondaryPlaceholder : this.placeholder
				};
				MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function (index, event)
				{
					var self = this;
					var selIndex = self.getAdjacentChipIndex(index);
					this.$element[0].querySelector("md-chips-wrap");
					this.$element[0].querySelector('md-chip[index="' + index + '"]');
					self.removeChip(index, event);
					self.$timeout(function ()
					{
						self.$timeout(function ()
						{
							self.selectAndFocusChipSafe(selIndex)
						})
					})
				};
				MdChipsCtrl.prototype.resetSelectedChip = function ()
				{
					this.selectedChip = -1;
					this.ariaTabIndex = null
				};
				MdChipsCtrl.prototype.getAdjacentChipIndex = function (index)
				{
					var len = this.items.length - 1;
					return 0 === len ? -1 : index === len ? index - 1 : index
				};
				MdChipsCtrl.prototype.appendChip = function (newChip)
				{
					this.shouldFocusLastChip = !this.addOnBlur;
					if (this.useTransformChip && this.transformChip)
					{
						var transformedChip = this.transformChip(
						{
							$chip: newChip
						});
						angular.isDefined(transformedChip) && (newChip = transformedChip)
					}
					if (angular.isObject(newChip))
					{
						var identical = this.items.some(function (item)
						{
							return angular.equals(newChip, item)
						});
						if (identical) return
					}
					if (null == newChip || this.items.indexOf(newChip) + 1) return;
					var length = this.items.push(newChip);
					var index = length - 1;
					this.updateNgModel();
					this.useOnAdd && this.onAdd && this.onAdd(
					{
						$chip: newChip,
						$index: index
					})
				};
				MdChipsCtrl.prototype.useTransformChipExpression = function ()
				{
					this.useTransformChip = true
				};
				MdChipsCtrl.prototype.useOnAddExpression = function ()
				{
					this.useOnAdd = true
				};
				MdChipsCtrl.prototype.useOnRemoveExpression = function ()
				{
					this.useOnRemove = true
				};
				MdChipsCtrl.prototype.useOnSelectExpression = function ()
				{
					this.useOnSelect = true
				};
				MdChipsCtrl.prototype.getChipBuffer = function ()
				{
					var chipBuffer = this.userInputElement ? this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value : this.chipBuffer;
					return angular.isString(chipBuffer) ? chipBuffer : ""
				};
				MdChipsCtrl.prototype.resetChipBuffer = function ()
				{
					if (this.userInputElement)
						if (this.userInputNgModelCtrl)
						{
							this.userInputNgModelCtrl.$setViewValue("");
							this.userInputNgModelCtrl.$render()
						}
					else this.userInputElement[0].value = "";
					else this.chipBuffer = ""
				};
				MdChipsCtrl.prototype.hasMaxChipsReached = function ()
				{
					angular.isString(this.maxChips) && (this.maxChips = parseInt(this.maxChips, 10) || 0);
					return this.maxChips > 0 && this.items.length >= this.maxChips
				};
				MdChipsCtrl.prototype.validateModel = function ()
				{
					this.ngModelCtrl.$setValidity("md-max-chips", !this.hasMaxChipsReached());
					this.ngModelCtrl.$validate()
				};
				MdChipsCtrl.prototype.updateNgModel = function (skipValidation)
				{
					skipValidation || this.validateModel();
					angular.forEach(this.ngModelCtrl.$viewChangeListeners, function (listener)
					{
						try
						{
							listener()
						}
						catch (e)
						{
							this.$exceptionHandler(e)
						}
					})
				};
				MdChipsCtrl.prototype.removeChip = function (index, event)
				{
					var removed = this.items.splice(index, 1);
					this.updateNgModel();
					removed && removed.length && this.useOnRemove && this.onRemove && this.onRemove(
					{
						$chip: removed[0],
						$index: index,
						$event: event
					})
				};
				MdChipsCtrl.prototype.removeChipAndFocusInput = function (index, $event)
				{
					this.removeChip(index, $event);
					if (this.autocompleteCtrl)
					{
						this.autocompleteCtrl.hidden = true;
						this.$mdUtil.nextTick(this.onFocus.bind(this))
					}
					else this.onFocus()
				};
				MdChipsCtrl.prototype.selectAndFocusChipSafe = function (index)
				{
					if (!this.items.length || -1 === index) return this.focusInput();
					if (index >= this.items.length)
					{
						if (!this.readonly) return this.onFocus();
						index = 0
					}
					index = Math.max(index, 0);
					index = Math.min(index, this.items.length - 1);
					this.selectChip(index);
					this.focusChip(index)
				};
				MdChipsCtrl.prototype.focusLastChipThenInput = function ()
				{
					var ctrl = this;
					ctrl.shouldFocusLastChip = false;
					ctrl.focusChip(this.items.length - 1);
					ctrl.$timeout(function ()
					{
						ctrl.focusInput()
					}, ctrl.chipAppendDelay)
				};
				MdChipsCtrl.prototype.focusInput = function ()
				{
					this.selectChip(-1);
					this.onFocus()
				};
				MdChipsCtrl.prototype.selectChip = function (index)
				{
					if (index >= -1 && index <= this.items.length)
					{
						this.selectedChip = index;
						this.useOnSelect && this.onSelect && this.onSelect(
						{
							$chip: this.items[index]
						})
					}
					else this.$log.warn("Selected Chip index out of bounds; ignoring.")
				};
				MdChipsCtrl.prototype.selectAndFocusChip = function (index)
				{
					this.selectChip(index); - 1 !== index && this.focusChip(index)
				};
				MdChipsCtrl.prototype.focusChip = function (index)
				{
					var chipContent = this.$element[0].querySelector('md-chip[index="' + index + '"] .md-chip-content');
					this.ariaTabIndex = index;
					chipContent.focus()
				};
				MdChipsCtrl.prototype.configureNgModel = function (ngModelCtrl)
				{
					this.ngModelCtrl = ngModelCtrl;
					var self = this;
					ngModelCtrl.$isEmpty = function (value)
					{
						return !value || 0 === value.length
					};
					ngModelCtrl.$render = function ()
					{
						self.items = self.ngModelCtrl.$viewValue
					}
				};
				MdChipsCtrl.prototype.onFocus = function ()
				{
					var input = this.$element[0].querySelector("input");
					input && input.focus();
					this.resetSelectedChip()
				};
				MdChipsCtrl.prototype.onInputFocus = function ()
				{
					this.inputHasFocus = true;
					this.setupInputAria();
					this.resetSelectedChip()
				};
				MdChipsCtrl.prototype.onInputBlur = function ()
				{
					this.inputHasFocus = false;
					if (this.shouldAddOnBlur())
					{
						this.appendChip(this.getChipBuffer().trim());
						this.resetChipBuffer()
					}
				};
				MdChipsCtrl.prototype.configureInput = function configureInput(inputElement)
				{
					var ngModelCtrl = inputElement.controller("ngModel");
					var ctrl = this;
					if (ngModelCtrl)
					{
						this.deRegister.push(this.$scope.$watch(function ()
						{
							return ngModelCtrl.$touched
						}, function (isTouched)
						{
							isTouched && ctrl.ngModelCtrl.$setTouched()
						}));
						this.deRegister.push(this.$scope.$watch(function ()
						{
							return ngModelCtrl.$dirty
						}, function (isDirty)
						{
							isDirty && ctrl.ngModelCtrl.$setDirty()
						}))
					}
				};
				MdChipsCtrl.prototype.configureUserInput = function (inputElement)
				{
					this.userInputElement = inputElement;
					var ngModelCtrl = inputElement.controller("ngModel");
					ngModelCtrl !== this.ngModelCtrl && (this.userInputNgModelCtrl = ngModelCtrl);
					var scope = this.$scope;
					var ctrl = this;
					var scopeApplyFn = function (event, fn)
					{
						scope.$evalAsync(angular.bind(ctrl, fn, event))
					};
					inputElement.attr(
					{
						tabindex: 0
					}).on("keydown", function (event)
					{
						scopeApplyFn(event, ctrl.inputKeydown)
					}).on("focus", function (event)
					{
						scopeApplyFn(event, ctrl.onInputFocus)
					}).on("blur", function (event)
					{
						scopeApplyFn(event, ctrl.onInputBlur)
					})
				};
				MdChipsCtrl.prototype.configureAutocomplete = function (ctrl)
				{
					if (ctrl)
					{
						this.autocompleteCtrl = ctrl;
						ctrl.registerSelectedItemWatcher(angular.bind(this, function (item)
						{
							if (item)
							{
								if (this.hasMaxChipsReached()) return;
								this.appendChip(item);
								this.resetChipBuffer()
							}
						}));
						this.$element.find("input").on("focus", angular.bind(this, this.onInputFocus)).on("blur", angular.bind(this, this.onInputBlur))
					}
				};
				MdChipsCtrl.prototype.shouldAddOnBlur = function ()
				{
					this.validateModel();
					var chipBuffer = this.getChipBuffer().trim();
					var isModelValid = this.ngModelCtrl.$isEmpty(this.ngModelCtrl.$modelValue) || this.ngModelCtrl.$valid;
					var isAutocompleteShowing = this.autocompleteCtrl && !this.autocompleteCtrl.hidden;
					this.userInputNgModelCtrl && (isModelValid = isModelValid && this.userInputNgModelCtrl.$valid);
					return this.addOnBlur && !this.requireMatch && chipBuffer && isModelValid && !isAutocompleteShowing
				};
				MdChipsCtrl.prototype.hasFocus = function ()
				{
					return this.inputHasFocus || this.selectedChip >= 0
				};
				MdChipsCtrl.prototype.contentIdFor = function (index)
				{
					return this.contentIds[index]
				}
			})();
			(function ()
			{
				MdChips.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout", "$$mdSvgRegistry"];
				angular.module("material.components.chips").directive("mdChips", MdChips);
				var MD_CHIPS_TEMPLATE = '      <md-chips-wrap          id="{{$mdChipsCtrl.wrapperId}}"          tabindex="{{$mdChipsCtrl.readonly ? 0 : -1}}"          ng-keydown="$mdChipsCtrl.chipKeydown($event)"          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(),                       \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly,                      \'md-removable\': $mdChipsCtrl.isRemovable() }"          aria-setsize="{{$mdChipsCtrl.items.length}}"          class="md-chips">        <span ng-if="$mdChipsCtrl.readonly" class="md-visually-hidden">          {{$mdChipsCtrl.containerHint}}        </span>        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}">          <div class="md-chip-content"              tabindex="{{$mdChipsCtrl.ariaTabIndex == $index ? 0 : -1}}"              id="{{$mdChipsCtrl.contentIdFor($index)}}"              role="option"              aria-selected="{{$mdChipsCtrl.selectedChip === $index}}"              aria-posinset="{{$index}}"              ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>          <div ng-if="$mdChipsCtrl.isRemovable()"               class="md-chip-remove-container"               tabindex="-1"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>        </md-chip>        <div class="md-chip-input-container" ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl">          <div md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>        </div>      </md-chips-wrap>';
				var CHIP_INPUT_TEMPLATE = '        <input            class="md-input"            tabindex="0"            aria-label="{{$mdChipsCtrl.inputAriaLabel}}"             placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            ng-model="$mdChipsCtrl.chipBuffer"            ng-focus="$mdChipsCtrl.onInputFocus()"            ng-blur="$mdChipsCtrl.onInputBlur()"            ng-keydown="$mdChipsCtrl.inputKeydown($event)">';
				var CHIP_DEFAULT_TEMPLATE = "      <span>{{$chip}}</span>";
				var CHIP_REMOVE_TEMPLATE = '      <button          class="md-chip-remove"          ng-if="$mdChipsCtrl.isRemovable()"          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index, $event)"          type="button"          tabindex="-1">        <md-icon md-svg-src="{{ $mdChipsCtrl.mdCloseIcon }}"></md-icon>        <span class="md-visually-hidden">          {{$mdChipsCtrl.deleteButtonLabel}}        </span>      </button>';

				function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout, $$mdSvgRegistry)
				{
					var templates = getTemplates();
					return {
						template: function (element, attrs)
						{
							attrs["$mdUserTemplate"] = element.clone();
							return templates.chips
						},
						require: ["mdChips"],
						restrict: "E",
						controller: "MdChipsCtrl",
						controllerAs: "$mdChipsCtrl",
						bindToController: true,
						compile: compile,
						scope:
						{
							readonly: "=readonly",
							removable: "=mdRemovable",
							placeholder: "@",
							secondaryPlaceholder: "@",
							maxChips: "@mdMaxChips",
							transformChip: "&mdTransformChip",
							onAppend: "&mdOnAppend",
							onAdd: "&mdOnAdd",
							onRemove: "&mdOnRemove",
							onSelect: "&mdOnSelect",
							inputAriaLabel: "@",
							containerHint: "@",
							deleteHint: "@",
							deleteButtonLabel: "@",
							separatorKeys: "=?mdSeparatorKeys",
							requireMatch: "=?mdRequireMatch",
							chipAppendDelayString: "@?mdChipAppendDelay",
							ngChange: "&"
						}
					};

					function compile(element, attr)
					{
						var userTemplate = attr["$mdUserTemplate"];
						attr["$mdUserTemplate"] = null;
						var chipTemplate = getTemplateByQuery("md-chips>md-chip-template");
						var chipRemoveSelector = $mdUtil.prefixer().buildList("md-chip-remove").map(function (attr)
						{
							return "md-chips>*[" + attr + "]"
						}).join(",");
						var chipRemoveTemplate = getTemplateByQuery(chipRemoveSelector) || templates.remove,
							chipContentsTemplate = chipTemplate || templates.default,
							chipInputTemplate = getTemplateByQuery("md-chips>md-autocomplete") || getTemplateByQuery("md-chips>input") || templates.input,
							staticChips = userTemplate.find("md-chip");
						userTemplate[0].querySelector("md-chip-template>*[md-chip-remove]") && $log.warn("invalid placement of md-chip-remove within md-chip-template.");

						function getTemplateByQuery(query)
						{
							if (!attr.ngModel) return;
							var element = userTemplate[0].querySelector(query);
							return element && element.outerHTML
						}
						return function postLink(scope, element, attrs, controllers)
						{
							$mdUtil.initOptionalProperties(scope, attr);
							$mdTheming(element);
							var mdChipsCtrl = controllers[0];
							chipTemplate && (mdChipsCtrl.enableChipEdit = false);
							mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;
							mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate;
							mdChipsCtrl.chipInputTemplate = chipInputTemplate;
							mdChipsCtrl.mdCloseIcon = $$mdSvgRegistry.mdClose;
							element.attr(
							{
								tabindex: -1
							}).on("focus", function ()
							{
								mdChipsCtrl.onFocus()
							}).on("click", function ()
							{
								mdChipsCtrl.readonly || -1 !== mdChipsCtrl.selectedChip || mdChipsCtrl.onFocus()
							});
							if (attr.ngModel)
							{
								mdChipsCtrl.configureNgModel(element.controller("ngModel"));
								attrs.mdTransformChip && mdChipsCtrl.useTransformChipExpression();
								attrs.mdOnAppend && mdChipsCtrl.useOnAppendExpression();
								attrs.mdOnAdd && mdChipsCtrl.useOnAddExpression();
								attrs.mdOnRemove && mdChipsCtrl.useOnRemoveExpression();
								attrs.mdOnSelect && mdChipsCtrl.useOnSelectExpression();
								chipInputTemplate != templates.input && scope.$watch("$mdChipsCtrl.readonly", function (readonly)
								{
									readonly || $mdUtil.nextTick(function ()
									{
										if (0 === chipInputTemplate.indexOf("<md-autocomplete"))
										{
											var autocompleteEl = element.find("md-autocomplete");
											mdChipsCtrl.configureAutocomplete(autocompleteEl.controller("mdAutocomplete"))
										}
										mdChipsCtrl.configureUserInput(element.find("input"))
									})
								});
								$mdUtil.nextTick(function ()
								{
									var input = element.find("input");
									if (input)
									{
										mdChipsCtrl.configureInput(input);
										input.toggleClass("md-input", true)
									}
								})
							}
							if (staticChips.length > 0)
							{
								var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
								$timeout(function ()
								{
									element.find("md-chips-wrap").prepend(compiledStaticChips)
								})
							}
						}
					}

					function getTemplates()
					{
						return {
							chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
							input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
							default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
							remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
						}
					}
				}
			})();
			(function ()
			{
				angular.module("material.components.chips").controller("MdContactChipsCtrl", MdContactChipsCtrl);

				function MdContactChipsCtrl()
				{
					this.selectedItem = null;
					this.searchText = ""
				}
				MdContactChipsCtrl.prototype.queryContact = function (searchText)
				{
					return this.contactQuery(
					{
						$query: searchText
					})
				};
				MdContactChipsCtrl.prototype.itemName = function (item)
				{
					return item[this.contactName]
				}
			})();
			(function ()
			{
				MdContactChips.$inject = ["$mdTheming", "$mdUtil"];
				angular.module("material.components.chips").directive("mdContactChips", MdContactChips);
				var MD_CONTACT_CHIPS_TEMPLATE = '      <md-chips class="md-contact-chips"          ng-model="$mdContactChipsCtrl.contacts"          ng-change="$mdContactChipsCtrl.ngChange($mdContactChipsCtrl.contacts)"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-chip-append-delay="{{$mdContactChipsCtrl.chipAppendDelay}}"           md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-min-length="$mdContactChipsCtrl.minLength"              md-autoselect              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              </span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>            </div>          </md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            </div>            <div class="md-contact-name">              {{$chip[$mdContactChipsCtrl.contactName]}}            </div>          </md-chip-template>      </md-chips>';

				function MdContactChips($mdTheming, $mdUtil)
				{
					return {
						template: function (element, attrs)
						{
							return MD_CONTACT_CHIPS_TEMPLATE
						},
						restrict: "E",
						controller: "MdContactChipsCtrl",
						controllerAs: "$mdContactChipsCtrl",
						bindToController: true,
						compile: compile,
						scope:
						{
							contactQuery: "&mdContacts",
							placeholder: "@",
							secondaryPlaceholder: "@",
							contactName: "@mdContactName",
							contactImage: "@mdContactImage",
							contactEmail: "@mdContactEmail",
							contacts: "=ngModel",
							ngChange: "&",
							requireMatch: "=?mdRequireMatch",
							minLength: "=?mdMinLength",
							highlightFlags: "@?mdHighlightFlags",
							chipAppendDelay: "@?mdChipAppendDelay"
						}
					};

					function compile(element, attr)
					{
						return function postLink(scope, element, attrs, controllers)
						{
							var contactChipsController = controllers;
							$mdUtil.initOptionalProperties(scope, attr);
							$mdTheming(element);
							element.attr("tabindex", "-1");
							attrs.$observe("mdChipAppendDelay", function (newValue)
							{
								contactChipsController.chipAppendDelay = newValue
							})
						}
					}
				}
			})();
			void
			function ()
			{
				CalendarCtrl.$inject = ["$element", "$scope", "$$mdDateUtil", "$mdUtil", "$mdConstant", "$mdTheming", "$$rAF", "$attrs", "$mdDateLocale"];
				angular.module("material.components.datepicker").directive("mdCalendar", calendarDirective);

				function calendarDirective()
				{
					return {
						template: function (tElement, tAttr)
						{
							var extraAttrs = tAttr.hasOwnProperty("ngIf") ? "" : 'ng-if="calendarCtrl.isInitialized"';
							var template = '<div ng-switch="calendarCtrl.currentView" ' + extraAttrs + '><md-calendar-year ng-switch-when="year"></md-calendar-year><md-calendar-month ng-switch-default></md-calendar-month></div>';
							return template
						},
						scope:
						{
							minDate: "=mdMinDate",
							maxDate: "=mdMaxDate",
							dateFilter: "=mdDateFilter",
							_mode: "@mdMode",
							_currentView: "@mdCurrentView"
						},
						require: ["ngModel", "mdCalendar"],
						controller: CalendarCtrl,
						controllerAs: "calendarCtrl",
						bindToController: true,
						link: function (scope, element, attrs, controllers)
						{
							var ngModelCtrl = controllers[0];
							var mdCalendarCtrl = controllers[1];
							mdCalendarCtrl.configureNgModel(ngModelCtrl)
						}
					}
				}
				var FALLBACK_WIDTH = 340;
				var nextUniqueId = 0;
				var MODE_MAP = {
					day: "month",
					month: "year"
				};

				function CalendarCtrl($element, $scope, $$mdDateUtil, $mdUtil, $mdConstant, $mdTheming, $$rAF, $attrs, $mdDateLocale)
				{
					$mdTheming($element);
					this.$element = $element;
					this.$scope = $scope;
					this.dateUtil = $$mdDateUtil;
					this.$mdUtil = $mdUtil;
					this.keyCode = $mdConstant.KEY_CODE;
					this.$$rAF = $$rAF;
					this.$mdDateLocale = $mdDateLocale;
					this.today = this.dateUtil.createDateAtMidnight();
					this.ngModelCtrl = null;
					this.SELECTED_DATE_CLASS = "md-calendar-selected-date";
					this.TODAY_CLASS = "md-calendar-date-today";
					this.FOCUSED_DATE_CLASS = "md-focus";
					this.id = nextUniqueId++;
					this.displayDate = null;
					this.selectedDate = null;
					this.firstRenderableDate = null;
					this.lastRenderableDate = null;
					this.isInitialized = false;
					this.width = 0;
					this.scrollbarWidth = 0;
					$attrs.tabindex || $element.attr("tabindex", "-1");
					var boundKeyHandler = angular.bind(this, this.handleKeyEvent);
					var handleKeyElement;
					handleKeyElement = $element.parent().hasClass("md-datepicker-calendar") ? angular.element(document.body) : $element;
					handleKeyElement.on("keydown", boundKeyHandler);
					$scope.$on("$destroy", function ()
					{
						handleKeyElement.off("keydown", boundKeyHandler)
					});
					1 === angular.version.major && angular.version.minor <= 4 && this.$onInit()
				}
				CalendarCtrl.prototype.$onInit = function ()
				{
					if (this._mode && MODE_MAP.hasOwnProperty(this._mode))
					{
						this.currentView = MODE_MAP[this._mode];
						this.mode = this._mode
					}
					else
					{
						this.currentView = this._currentView || "month";
						this.mode = null
					}
					var dateLocale = this.$mdDateLocale;
					this.minDate && this.minDate > dateLocale.firstRenderableDate ? this.firstRenderableDate = this.minDate : this.firstRenderableDate = dateLocale.firstRenderableDate;
					this.maxDate && this.maxDate < dateLocale.lastRenderableDate ? this.lastRenderableDate = this.maxDate : this.lastRenderableDate = dateLocale.lastRenderableDate
				};
				CalendarCtrl.prototype.configureNgModel = function (ngModelCtrl)
				{
					var self = this;
					self.ngModelCtrl = ngModelCtrl;
					self.$mdUtil.nextTick(function ()
					{
						self.isInitialized = true
					});
					ngModelCtrl.$render = function ()
					{
						var value = this.$viewValue;
						self.$scope.$broadcast("md-calendar-parent-changed", value);
						self.selectedDate || (self.selectedDate = value);
						self.displayDate || (self.displayDate = self.selectedDate || self.today)
					}
				};
				CalendarCtrl.prototype.setNgModelValue = function (date)
				{
					var value = this.dateUtil.createDateAtMidnight(date);
					this.focus(value);
					this.$scope.$emit("md-calendar-change", value);
					this.ngModelCtrl.$setViewValue(value);
					this.ngModelCtrl.$render();
					return value
				};
				CalendarCtrl.prototype.setCurrentView = function (newView, time)
				{
					var self = this;
					self.$mdUtil.nextTick(function ()
					{
						self.currentView = newView;
						time && (self.displayDate = angular.isDate(time) ? time : new Date(time))
					})
				};
				CalendarCtrl.prototype.focus = function (date)
				{
					if (this.dateUtil.isValidDate(date))
					{
						var previousFocus = this.$element[0].querySelector("." + this.FOCUSED_DATE_CLASS);
						previousFocus && previousFocus.classList.remove(this.FOCUSED_DATE_CLASS);
						var cellId = this.getDateId(date, this.currentView);
						var cell = document.getElementById(cellId);
						if (cell)
						{
							cell.classList.add(this.FOCUSED_DATE_CLASS);
							cell.focus();
							this.displayDate = date
						}
					}
					else
					{
						var rootElement = this.$element[0].querySelector("[ng-switch]");
						rootElement && rootElement.focus()
					}
				};
				CalendarCtrl.prototype.changeSelectedDate = function (date)
				{
					var selectedDateClass = this.SELECTED_DATE_CLASS;
					var prevDateCell = this.$element[0].querySelector("." + selectedDateClass);
					if (prevDateCell)
					{
						prevDateCell.classList.remove(selectedDateClass);
						prevDateCell.setAttribute("aria-selected", "false")
					}
					if (date)
					{
						var dateCell = document.getElementById(this.getDateId(date, this.currentView));
						if (dateCell)
						{
							dateCell.classList.add(selectedDateClass);
							dateCell.setAttribute("aria-selected", "true")
						}
					}
					this.selectedDate = date
				};
				CalendarCtrl.prototype.getActionFromKeyEvent = function (event)
				{
					var keyCode = this.keyCode;
					switch (event.which)
					{
					case keyCode.ENTER:
						return "select";
					case keyCode.RIGHT_ARROW:
						return "move-right";
					case keyCode.LEFT_ARROW:
						return "move-left";
					case keyCode.DOWN_ARROW:
						return event.metaKey ? "move-page-down" : "move-row-down";
					case keyCode.UP_ARROW:
						return event.metaKey ? "move-page-up" : "move-row-up";
					case keyCode.PAGE_DOWN:
						return "move-page-down";
					case keyCode.PAGE_UP:
						return "move-page-up";
					case keyCode.HOME:
						return "start";
					case keyCode.END:
						return "end";
					default:
						return null
					}
				};
				CalendarCtrl.prototype.handleKeyEvent = function (event)
				{
					var self = this;
					this.$scope.$apply(function ()
					{
						if (event.which == self.keyCode.ESCAPE || event.which == self.keyCode.TAB)
						{
							self.$scope.$emit("md-calendar-close");
							event.which == self.keyCode.TAB && event.preventDefault();
							return
						}
						var action = self.getActionFromKeyEvent(event);
						if (action)
						{
							event.preventDefault();
							event.stopPropagation();
							self.$scope.$broadcast("md-calendar-parent-action", action)
						}
					})
				};
				CalendarCtrl.prototype.hideVerticalScrollbar = function (childCtrl)
				{
					var self = this;
					var element = childCtrl.$element[0];
					var scrollMask = element.querySelector(".md-calendar-scroll-mask");
					self.width > 0 ? setWidth() : self.$$rAF(function ()
					{
						var scroller = childCtrl.calendarScroller;
						self.scrollbarWidth = scroller.offsetWidth - scroller.clientWidth;
						self.width = element.querySelector("table").offsetWidth;
						setWidth()
					});

					function setWidth()
					{
						var width = self.width || FALLBACK_WIDTH;
						var scrollbarWidth = self.scrollbarWidth;
						var scroller = childCtrl.calendarScroller;
						scrollMask.style.width = width + "px";
						scroller.style.width = width + scrollbarWidth + "px";
						scroller.style.paddingRight = scrollbarWidth + "px"
					}
				};
				CalendarCtrl.prototype.getDateId = function (date, namespace)
				{
					if (!namespace) throw new Error("A namespace for the date id has to be specified.");
					return ["md", this.id, namespace, date.getFullYear(), date.getMonth(), date.getDate()].join("-")
				};
				CalendarCtrl.prototype.updateVirtualRepeat = function ()
				{
					var scope = this.$scope;
					var virtualRepeatResizeListener = scope.$on("$md-resize-enable", function ()
					{
						scope.$$phase || scope.$apply();
						virtualRepeatResizeListener()
					})
				}
			}();
			void
			function ()
			{
				CalendarMonthCtrl.$inject = ["$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$mdDateLocale"];
				angular.module("material.components.datepicker").directive("mdCalendarMonth", calendarDirective);
				var TBODY_HEIGHT = 265;
				var TBODY_SINGLE_ROW_HEIGHT = 45;

				function calendarDirective()
				{
					return {
						template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table><div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container" md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody md-calendar-month-body role="rowgroup" md-virtual-repeat="i in monthCtrl.items" md-month-offset="$index" class="md-calendar-month" md-start-index="monthCtrl.getSelectedMonthIndex()" md-item-size="' + TBODY_HEIGHT + '"><tr aria-hidden="true" md-force-height="\'' + TBODY_HEIGHT + "px'\"></tr></tbody></table></md-virtual-repeat-container></div>",
						require: ["^^mdCalendar", "mdCalendarMonth"],
						controller: CalendarMonthCtrl,
						controllerAs: "monthCtrl",
						bindToController: true,
						link: function (scope, element, attrs, controllers)
						{
							var calendarCtrl = controllers[0];
							var monthCtrl = controllers[1];
							monthCtrl.initialize(calendarCtrl)
						}
					}
				}

				function CalendarMonthCtrl($element, $scope, $animate, $q, $$mdDateUtil, $mdDateLocale)
				{
					this.$element = $element;
					this.$scope = $scope;
					this.$animate = $animate;
					this.$q = $q;
					this.dateUtil = $$mdDateUtil;
					this.dateLocale = $mdDateLocale;
					this.calendarScroller = $element[0].querySelector(".md-virtual-repeat-scroller");
					this.isInitialized = false;
					this.isMonthTransitionInProgress = false;
					var self = this;
					this.cellClickHandler = function ()
					{
						var timestamp = $$mdDateUtil.getTimestampFromNode(this);
						self.$scope.$apply(function ()
						{
							self.calendarCtrl.setNgModelValue(timestamp)
						})
					};
					this.headerClickHandler = function ()
					{
						self.calendarCtrl.setCurrentView("year", $$mdDateUtil.getTimestampFromNode(this))
					}
				}
				CalendarMonthCtrl.prototype.initialize = function (calendarCtrl)
				{
					this.items = {
						length: this.dateUtil.getMonthDistance(calendarCtrl.firstRenderableDate, calendarCtrl.lastRenderableDate) + 2
					};
					this.calendarCtrl = calendarCtrl;
					this.attachScopeListeners();
					calendarCtrl.updateVirtualRepeat();
					calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render()
				};
				CalendarMonthCtrl.prototype.getSelectedMonthIndex = function ()
				{
					var calendarCtrl = this.calendarCtrl;
					return this.dateUtil.getMonthDistance(calendarCtrl.firstRenderableDate, calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today)
				};
				CalendarMonthCtrl.prototype.changeDisplayDate = function (date)
				{
					if (!this.isInitialized)
					{
						this.buildWeekHeader();
						this.calendarCtrl.hideVerticalScrollbar(this);
						this.isInitialized = true;
						return this.$q.when()
					}
					if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) return this.$q.when();
					this.isMonthTransitionInProgress = true;
					var animationPromise = this.animateDateChange(date);
					this.calendarCtrl.displayDate = date;
					var self = this;
					animationPromise.then(function ()
					{
						self.isMonthTransitionInProgress = false
					});
					return animationPromise
				};
				CalendarMonthCtrl.prototype.animateDateChange = function (date)
				{
					if (this.dateUtil.isValidDate(date))
					{
						var monthDistance = this.dateUtil.getMonthDistance(this.calendarCtrl.firstRenderableDate, date);
						this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT
					}
					return this.$q.when()
				};
				CalendarMonthCtrl.prototype.buildWeekHeader = function ()
				{
					var firstDayOfWeek = this.dateLocale.firstDayOfWeek;
					var shortDays = this.dateLocale.shortDays;
					var row = document.createElement("tr");
					for (var i = 0; i < 7; i++)
					{
						var th = document.createElement("th");
						th.textContent = shortDays[(i + firstDayOfWeek) % 7];
						row.appendChild(th)
					}
					this.$element.find("thead").append(row)
				};
				CalendarMonthCtrl.prototype.attachScopeListeners = function ()
				{
					var self = this;
					self.$scope.$on("md-calendar-parent-changed", function (event, value)
					{
						self.calendarCtrl.changeSelectedDate(value);
						self.changeDisplayDate(value)
					});
					self.$scope.$on("md-calendar-parent-action", angular.bind(this, this.handleKeyEvent))
				};
				CalendarMonthCtrl.prototype.handleKeyEvent = function (event, action)
				{
					var calendarCtrl = this.calendarCtrl;
					var displayDate = calendarCtrl.displayDate;
					if ("select" === action) calendarCtrl.setNgModelValue(displayDate);
					else
					{
						var date = null;
						var dateUtil = this.dateUtil;
						switch (action)
						{
						case "move-right":
							date = dateUtil.incrementDays(displayDate, 1);
							break;
						case "move-left":
							date = dateUtil.incrementDays(displayDate, -1);
							break;
						case "move-page-down":
							date = dateUtil.incrementMonths(displayDate, 1);
							break;
						case "move-page-up":
							date = dateUtil.incrementMonths(displayDate, -1);
							break;
						case "move-row-down":
							date = dateUtil.incrementDays(displayDate, 7);
							break;
						case "move-row-up":
							date = dateUtil.incrementDays(displayDate, -7);
							break;
						case "start":
							date = dateUtil.getFirstDateOfMonth(displayDate);
							break;
						case "end":
							date = dateUtil.getLastDateOfMonth(displayDate)
						}
						if (date)
						{
							date = this.dateUtil.clampDate(date, calendarCtrl.minDate, calendarCtrl.maxDate);
							this.changeDisplayDate(date).then(function ()
							{
								calendarCtrl.focus(date)
							})
						}
					}
				}
			}();
			void
			function ()
			{
				mdCalendarMonthBodyDirective.$inject = ["$compile", "$$mdSvgRegistry"];
				CalendarMonthBodyCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
				angular.module("material.components.datepicker").directive("mdCalendarMonthBody", mdCalendarMonthBodyDirective);

				function mdCalendarMonthBodyDirective($compile, $$mdSvgRegistry)
				{
					var ARROW_ICON = $compile('<md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon>')(
					{})[0];
					return {
						require: ["^^mdCalendar", "^^mdCalendarMonth", "mdCalendarMonthBody"],
						scope:
						{
							offset: "=mdMonthOffset"
						},
						controller: CalendarMonthBodyCtrl,
						controllerAs: "mdMonthBodyCtrl",
						bindToController: true,
						link: function (scope, element, attrs, controllers)
						{
							var calendarCtrl = controllers[0];
							var monthCtrl = controllers[1];
							var monthBodyCtrl = controllers[2];
							monthBodyCtrl.calendarCtrl = calendarCtrl;
							monthBodyCtrl.monthCtrl = monthCtrl;
							monthBodyCtrl.arrowIcon = ARROW_ICON.cloneNode(true);
							scope.$watch(function ()
							{
								return monthBodyCtrl.offset
							}, function (offset)
							{
								angular.isNumber(offset) && monthBodyCtrl.generateContent()
							})
						}
					}
				}

				function CalendarMonthBodyCtrl($element, $$mdDateUtil, $mdDateLocale)
				{
					this.$element = $element;
					this.dateUtil = $$mdDateUtil;
					this.dateLocale = $mdDateLocale;
					this.monthCtrl = null;
					this.calendarCtrl = null;
					this.offset = null;
					this.focusAfterAppend = null
				}
				CalendarMonthBodyCtrl.prototype.generateContent = function ()
				{
					var date = this.dateUtil.incrementMonths(this.calendarCtrl.firstRenderableDate, this.offset);
					this.$element.empty().append(this.buildCalendarForMonth(date));
					if (this.focusAfterAppend)
					{
						this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS);
						this.focusAfterAppend.focus();
						this.focusAfterAppend = null
					}
				};
				CalendarMonthBodyCtrl.prototype.buildDateCell = function (opt_date)
				{
					var monthCtrl = this.monthCtrl;
					var calendarCtrl = this.calendarCtrl;
					var cell = document.createElement("td");
					cell.tabIndex = -1;
					cell.classList.add("md-calendar-date");
					cell.setAttribute("role", "gridcell");
					if (opt_date)
					{
						cell.setAttribute("tabindex", "-1");
						cell.setAttribute("aria-label", this.dateLocale.longDateFormatter(opt_date));
						cell.id = calendarCtrl.getDateId(opt_date, "month");
						cell.setAttribute("data-timestamp", opt_date.getTime());
						this.dateUtil.isSameDay(opt_date, calendarCtrl.today) && cell.classList.add(calendarCtrl.TODAY_CLASS);
						if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate))
						{
							cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS);
							cell.setAttribute("aria-selected", "true")
						}
						var cellText = this.dateLocale.dates[opt_date.getDate()];
						if (this.isDateEnabled(opt_date))
						{
							var selectionIndicator = document.createElement("span");
							selectionIndicator.classList.add("md-calendar-date-selection-indicator");
							selectionIndicator.textContent = cellText;
							cell.appendChild(selectionIndicator);
							cell.addEventListener("click", monthCtrl.cellClickHandler);
							calendarCtrl.displayDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.displayDate) && (this.focusAfterAppend = cell)
						}
						else
						{
							cell.classList.add("md-calendar-date-disabled");
							cell.textContent = cellText
						}
					}
					return cell
				};
				CalendarMonthBodyCtrl.prototype.isDateEnabled = function (opt_date)
				{
					return this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date))
				};
				CalendarMonthBodyCtrl.prototype.buildDateRow = function (rowNumber)
				{
					var row = document.createElement("tr");
					row.setAttribute("role", "row");
					row.setAttribute("aria-label", this.dateLocale.weekNumberFormatter(rowNumber));
					return row
				};
				CalendarMonthBodyCtrl.prototype.buildCalendarForMonth = function (opt_dateInMonth)
				{
					var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date;
					var firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date);
					var firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth);
					var numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date);
					var monthBody = document.createDocumentFragment();
					var rowNumber = 1;
					var row = this.buildDateRow(rowNumber);
					monthBody.appendChild(row);
					var isFinalMonth = this.offset === this.monthCtrl.items.length - 1;
					var blankCellOffset = 0;
					var monthLabelCell = document.createElement("td");
					var monthLabelCellContent = document.createElement("span");
					var calendarCtrl = this.calendarCtrl;
					monthLabelCellContent.textContent = this.dateLocale.monthHeaderFormatter(date);
					monthLabelCell.appendChild(monthLabelCellContent);
					monthLabelCell.classList.add("md-calendar-month-label");
					if (calendarCtrl.maxDate && firstDayOfMonth > calendarCtrl.maxDate) monthLabelCell.classList.add("md-calendar-month-label-disabled");
					else if (!calendarCtrl.mode)
					{
						monthLabelCell.addEventListener("click", this.monthCtrl.headerClickHandler);
						monthLabelCell.setAttribute("data-timestamp", firstDayOfMonth.getTime());
						monthLabelCell.setAttribute("aria-label", this.dateLocale.monthFormatter(date));
						monthLabelCell.classList.add("md-calendar-label-clickable");
						monthLabelCell.appendChild(this.arrowIcon.cloneNode(true))
					}
					if (firstDayOfTheWeek <= 2)
					{
						monthLabelCell.setAttribute("colspan", "7");
						var monthLabelRow = this.buildDateRow();
						monthLabelRow.appendChild(monthLabelCell);
						monthBody.insertBefore(monthLabelRow, row);
						if (isFinalMonth) return monthBody
					}
					else
					{
						blankCellOffset = 3;
						monthLabelCell.setAttribute("colspan", "3");
						row.appendChild(monthLabelCell)
					}
					for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) row.appendChild(this.buildDateCell());
					var dayOfWeek = firstDayOfTheWeek;
					var iterationDate = firstDayOfMonth;
					for (var d = 1; d <= numberOfDaysInMonth; d++)
					{
						if (7 === dayOfWeek)
						{
							if (isFinalMonth) return monthBody;
							dayOfWeek = 0;
							rowNumber++;
							row = this.buildDateRow(rowNumber);
							monthBody.appendChild(row)
						}
						iterationDate.setDate(d);
						var cell = this.buildDateCell(iterationDate);
						row.appendChild(cell);
						dayOfWeek++
					}
					while (row.childNodes.length < 7) row.appendChild(this.buildDateCell());
					while (monthBody.childNodes.length < 6)
					{
						var whitespaceRow = this.buildDateRow();
						for (var j = 0; j < 7; j++) whitespaceRow.appendChild(this.buildDateCell());
						monthBody.appendChild(whitespaceRow)
					}
					return monthBody
				};
				CalendarMonthBodyCtrl.prototype.getLocaleDay_ = function (date)
				{
					return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7
				}
			}();
			void
			function ()
			{
				CalendarYearCtrl.$inject = ["$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$mdUtil"];
				angular.module("material.components.datepicker").directive("mdCalendarYear", calendarDirective);
				var TBODY_HEIGHT = 88;

				function calendarDirective()
				{
					return {
						template: '<div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody md-calendar-year-body role="rowgroup" md-virtual-repeat="i in yearCtrl.items" md-year-offset="$index" class="md-calendar-year" md-start-index="yearCtrl.getFocusedYearIndex()" md-item-size="' + TBODY_HEIGHT + '"><tr aria-hidden="true" md-force-height="\'' + TBODY_HEIGHT + "px'\"></tr></tbody></table></md-virtual-repeat-container></div>",
						require: ["^^mdCalendar", "mdCalendarYear"],
						controller: CalendarYearCtrl,
						controllerAs: "yearCtrl",
						bindToController: true,
						link: function (scope, element, attrs, controllers)
						{
							var calendarCtrl = controllers[0];
							var yearCtrl = controllers[1];
							yearCtrl.initialize(calendarCtrl)
						}
					}
				}

				function CalendarYearCtrl($element, $scope, $animate, $q, $$mdDateUtil, $mdUtil)
				{
					this.$element = $element;
					this.$scope = $scope;
					this.$animate = $animate;
					this.$q = $q;
					this.dateUtil = $$mdDateUtil;
					this.calendarScroller = $element[0].querySelector(".md-virtual-repeat-scroller");
					this.isInitialized = false;
					this.isMonthTransitionInProgress = false;
					this.$mdUtil = $mdUtil;
					var self = this;
					this.cellClickHandler = function ()
					{
						self.onTimestampSelected($$mdDateUtil.getTimestampFromNode(this))
					}
				}
				CalendarYearCtrl.prototype.initialize = function (calendarCtrl)
				{
					this.items = {
						length: this.dateUtil.getYearDistance(calendarCtrl.firstRenderableDate, calendarCtrl.lastRenderableDate) + 1
					};
					this.calendarCtrl = calendarCtrl;
					this.attachScopeListeners();
					calendarCtrl.updateVirtualRepeat();
					calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render()
				};
				CalendarYearCtrl.prototype.getFocusedYearIndex = function ()
				{
					var calendarCtrl = this.calendarCtrl;
					return this.dateUtil.getYearDistance(calendarCtrl.firstRenderableDate, calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today)
				};
				CalendarYearCtrl.prototype.changeDate = function (date)
				{
					if (!this.isInitialized)
					{
						this.calendarCtrl.hideVerticalScrollbar(this);
						this.isInitialized = true;
						return this.$q.when()
					}
					if (this.dateUtil.isValidDate(date) && !this.isMonthTransitionInProgress)
					{
						var self = this;
						var animationPromise = this.animateDateChange(date);
						self.isMonthTransitionInProgress = true;
						self.calendarCtrl.displayDate = date;
						return animationPromise.then(function ()
						{
							self.isMonthTransitionInProgress = false
						})
					}
				};
				CalendarYearCtrl.prototype.animateDateChange = function (date)
				{
					if (this.dateUtil.isValidDate(date))
					{
						var monthDistance = this.dateUtil.getYearDistance(this.calendarCtrl.firstRenderableDate, date);
						this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT
					}
					return this.$q.when()
				};
				CalendarYearCtrl.prototype.handleKeyEvent = function (event, action)
				{
					var self = this;
					var calendarCtrl = self.calendarCtrl;
					var displayDate = calendarCtrl.displayDate;
					if ("select" === action) self.changeDate(displayDate).then(function ()
					{
						self.onTimestampSelected(displayDate)
					});
					else
					{
						var date = null;
						var dateUtil = self.dateUtil;
						switch (action)
						{
						case "move-right":
							date = dateUtil.incrementMonths(displayDate, 1);
							break;
						case "move-left":
							date = dateUtil.incrementMonths(displayDate, -1);
							break;
						case "move-row-down":
							date = dateUtil.incrementMonths(displayDate, 6);
							break;
						case "move-row-up":
							date = dateUtil.incrementMonths(displayDate, -6)
						}
						if (date)
						{
							var min = calendarCtrl.minDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.minDate) : null;
							var max = calendarCtrl.maxDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.maxDate) : null;
							date = dateUtil.getFirstDateOfMonth(self.dateUtil.clampDate(date, min, max));
							self.changeDate(date).then(function ()
							{
								calendarCtrl.focus(date)
							})
						}
					}
				};
				CalendarYearCtrl.prototype.attachScopeListeners = function ()
				{
					var self = this;
					self.$scope.$on("md-calendar-parent-changed", function (event, value)
					{
						self.calendarCtrl.changeSelectedDate(value ? self.dateUtil.getFirstDateOfMonth(value) : value);
						self.changeDate(value)
					});
					self.$scope.$on("md-calendar-parent-action", angular.bind(self, self.handleKeyEvent))
				};
				CalendarYearCtrl.prototype.onTimestampSelected = function (timestamp)
				{
					var calendarCtrl = this.calendarCtrl;
					calendarCtrl.mode ? this.$mdUtil.nextTick(function ()
					{
						calendarCtrl.setNgModelValue(timestamp)
					}) : calendarCtrl.setCurrentView("month", timestamp)
				}
			}();
			void
			function ()
			{
				CalendarYearBodyCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
				angular.module("material.components.datepicker").directive("mdCalendarYearBody", mdCalendarYearDirective);

				function mdCalendarYearDirective()
				{
					return {
						require: ["^^mdCalendar", "^^mdCalendarYear", "mdCalendarYearBody"],
						scope:
						{
							offset: "=mdYearOffset"
						},
						controller: CalendarYearBodyCtrl,
						controllerAs: "mdYearBodyCtrl",
						bindToController: true,
						link: function (scope, element, attrs, controllers)
						{
							var calendarCtrl = controllers[0];
							var yearCtrl = controllers[1];
							var yearBodyCtrl = controllers[2];
							yearBodyCtrl.calendarCtrl = calendarCtrl;
							yearBodyCtrl.yearCtrl = yearCtrl;
							scope.$watch(function ()
							{
								return yearBodyCtrl.offset
							}, function (offset)
							{
								angular.isNumber(offset) && yearBodyCtrl.generateContent()
							})
						}
					}
				}

				function CalendarYearBodyCtrl($element, $$mdDateUtil, $mdDateLocale)
				{
					this.$element = $element;
					this.dateUtil = $$mdDateUtil;
					this.dateLocale = $mdDateLocale;
					this.calendarCtrl = null;
					this.yearCtrl = null;
					this.offset = null;
					this.focusAfterAppend = null
				}
				CalendarYearBodyCtrl.prototype.generateContent = function ()
				{
					var date = this.dateUtil.incrementYears(this.calendarCtrl.firstRenderableDate, this.offset);
					this.$element.empty().append(this.buildCalendarForYear(date));
					if (this.focusAfterAppend)
					{
						this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS);
						this.focusAfterAppend.focus();
						this.focusAfterAppend = null
					}
				};
				CalendarYearBodyCtrl.prototype.buildMonthCell = function (year, month)
				{
					var calendarCtrl = this.calendarCtrl;
					var yearCtrl = this.yearCtrl;
					var cell = this.buildBlankCell();
					var firstOfMonth = new Date(year, month, 1);
					cell.setAttribute("aria-label", this.dateLocale.monthFormatter(firstOfMonth));
					cell.id = calendarCtrl.getDateId(firstOfMonth, "year");
					cell.setAttribute("data-timestamp", firstOfMonth.getTime());
					this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.today) && cell.classList.add(calendarCtrl.TODAY_CLASS);
					if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.selectedDate))
					{
						cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS);
						cell.setAttribute("aria-selected", "true")
					}
					var cellText = this.dateLocale.shortMonths[month];
					if (this.dateUtil.isMonthWithinRange(firstOfMonth, calendarCtrl.minDate, calendarCtrl.maxDate))
					{
						var selectionIndicator = document.createElement("span");
						selectionIndicator.classList.add("md-calendar-date-selection-indicator");
						selectionIndicator.textContent = cellText;
						cell.appendChild(selectionIndicator);
						cell.addEventListener("click", yearCtrl.cellClickHandler);
						calendarCtrl.displayDate && this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.displayDate) && (this.focusAfterAppend = cell)
					}
					else
					{
						cell.classList.add("md-calendar-date-disabled");
						cell.textContent = cellText
					}
					return cell
				};
				CalendarYearBodyCtrl.prototype.buildBlankCell = function ()
				{
					var cell = document.createElement("td");
					cell.tabIndex = -1;
					cell.classList.add("md-calendar-date");
					cell.setAttribute("role", "gridcell");
					cell.setAttribute("tabindex", "-1");
					return cell
				};
				CalendarYearBodyCtrl.prototype.buildCalendarForYear = function (date)
				{
					var year = date.getFullYear();
					var yearBody = document.createDocumentFragment();
					var i;
					var firstRow = document.createElement("tr");
					var labelCell = document.createElement("td");
					labelCell.className = "md-calendar-month-label";
					labelCell.textContent = year;
					firstRow.appendChild(labelCell);
					for (i = 0; i < 6; i++) firstRow.appendChild(this.buildMonthCell(year, i));
					yearBody.appendChild(firstRow);
					var secondRow = document.createElement("tr");
					secondRow.appendChild(this.buildBlankCell());
					for (i = 6; i < 12; i++) secondRow.appendChild(this.buildMonthCell(year, i));
					yearBody.appendChild(secondRow);
					return yearBody
				}
			}();
			void void angular.module("material.components.datepicker").config(["$provide", function ($provide)
			{
				function DateLocaleProvider()
				{
					this.months = null;
					this.shortMonths = null;
					this.days = null;
					this.shortDays = null;
					this.dates = null;
					this.firstDayOfWeek = 0;
					this.formatDate = null;
					this.parseDate = null;
					this.monthHeaderFormatter = null;
					this.weekNumberFormatter = null;
					this.longDateFormatter = null;
					this.isDateComplete = null;
					this.msgCalendar = "";
					this.msgOpenCalendar = ""
				}
				DateLocaleProvider.prototype.$get = function ($locale, $filter)
				{
					function defaultFormatDate(date, timezone)
					{
						if (!date) return "";
						var localeTime = date.toLocaleTimeString();
						var formatDate = date;
						0 !== date.getHours() || -1 === localeTime.indexOf("11:") && -1 === localeTime.indexOf("23:") || (formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0));
						return $filter("date")(formatDate, "M/d/yyyy", timezone)
					}

					function defaultParseDate(dateString)
					{
						return new Date(dateString)
					}

					function defaultIsDateComplete(dateString)
					{
						dateString = dateString.trim();
						var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ .,]+|[/-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
						return re.test(dateString)
					}

					function defaultMonthHeaderFormatter(date)
					{
						return service.shortMonths[date.getMonth()] + " " + date.getFullYear()
					}

					function defaultMonthFormatter(date)
					{
						return service.months[date.getMonth()] + " " + date.getFullYear()
					}

					function defaultWeekNumberFormatter(number)
					{
						return "Week " + number
					}

					function defaultLongDateFormatter(date)
					{
						return [service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear()].join(" ")
					}
					var defaultShortDays = $locale.DATETIME_FORMATS.SHORTDAY.map(function (day)
					{
						return day.substring(0, 1)
					});
					var defaultDates = Array(32);
					for (var i = 1; i <= 31; i++) defaultDates[i] = i;
					var defaultMsgCalendar = "Calendar";
					var defaultMsgOpenCalendar = "Open calendar";
					var defaultFirstRenderableDate = new Date(1880, 0, 1);
					var defaultLastRendereableDate = new Date(defaultFirstRenderableDate.getFullYear() + 250, 0, 1);
					var service = {
						months: this.months || $locale.DATETIME_FORMATS.MONTH,
						shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
						days: this.days || $locale.DATETIME_FORMATS.DAY,
						shortDays: this.shortDays || defaultShortDays,
						dates: this.dates || defaultDates,
						firstDayOfWeek: this.firstDayOfWeek || 0,
						formatDate: this.formatDate || defaultFormatDate,
						parseDate: this.parseDate || defaultParseDate,
						isDateComplete: this.isDateComplete || defaultIsDateComplete,
						monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter,
						monthFormatter: this.monthFormatter || defaultMonthFormatter,
						weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter,
						longDateFormatter: this.longDateFormatter || defaultLongDateFormatter,
						msgCalendar: this.msgCalendar || defaultMsgCalendar,
						msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar,
						firstRenderableDate: this.firstRenderableDate || defaultFirstRenderableDate,
						lastRenderableDate: this.lastRenderableDate || defaultLastRendereableDate
					};
					return service
				};
				DateLocaleProvider.prototype.$get.$inject = ["$locale", "$filter"];
				$provide.provider("$mdDateLocale", new DateLocaleProvider)
			}]);
			void void angular.module("material.components.datepicker").factory("$$mdDateUtil", function ()
			{
				return {
					getFirstDateOfMonth: getFirstDateOfMonth,
					getNumberOfDaysInMonth: getNumberOfDaysInMonth,
					getDateInNextMonth: getDateInNextMonth,
					getDateInPreviousMonth: getDateInPreviousMonth,
					isInNextMonth: isInNextMonth,
					isInPreviousMonth: isInPreviousMonth,
					getDateMidpoint: getDateMidpoint,
					isSameMonthAndYear: isSameMonthAndYear,
					getWeekOfMonth: getWeekOfMonth,
					incrementDays: incrementDays,
					incrementMonths: incrementMonths,
					getLastDateOfMonth: getLastDateOfMonth,
					isSameDay: isSameDay,
					getMonthDistance: getMonthDistance,
					isValidDate: isValidDate,
					setDateTimeToMidnight: setDateTimeToMidnight,
					createDateAtMidnight: createDateAtMidnight,
					isDateWithinRange: isDateWithinRange,
					incrementYears: incrementYears,
					getYearDistance: getYearDistance,
					clampDate: clampDate,
					getTimestampFromNode: getTimestampFromNode,
					isMonthWithinRange: isMonthWithinRange
				};

				function getFirstDateOfMonth(date)
				{
					return new Date(date.getFullYear(), date.getMonth(), 1)
				}

				function getNumberOfDaysInMonth(date)
				{
					return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
				}

				function getDateInNextMonth(date)
				{
					return new Date(date.getFullYear(), date.getMonth() + 1, 1)
				}

				function getDateInPreviousMonth(date)
				{
					return new Date(date.getFullYear(), date.getMonth() - 1, 1)
				}

				function isSameMonthAndYear(d1, d2)
				{
					return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth()
				}

				function isSameDay(d1, d2)
				{
					return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2)
				}

				function isInNextMonth(startDate, endDate)
				{
					var nextMonth = getDateInNextMonth(startDate);
					return isSameMonthAndYear(nextMonth, endDate)
				}

				function isInPreviousMonth(startDate, endDate)
				{
					var previousMonth = getDateInPreviousMonth(startDate);
					return isSameMonthAndYear(endDate, previousMonth)
				}

				function getDateMidpoint(d1, d2)
				{
					return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2)
				}

				function getWeekOfMonth(date)
				{
					var firstDayOfMonth = getFirstDateOfMonth(date);
					return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7)
				}

				function incrementDays(date, numberOfDays)
				{
					return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays)
				}

				function incrementMonths(date, numberOfMonths)
				{
					var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1);
					var numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
					numberOfDaysInMonth < date.getDate() ? dateInTargetMonth.setDate(numberOfDaysInMonth) : dateInTargetMonth.setDate(date.getDate());
					return dateInTargetMonth
				}

				function getMonthDistance(start, end)
				{
					return 12 * (end.getFullYear() - start.getFullYear()) + (end.getMonth() - start.getMonth())
				}

				function getLastDateOfMonth(date)
				{
					return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date))
				}

				function isValidDate(date)
				{
					return date && date.getTime && !isNaN(date.getTime())
				}

				function setDateTimeToMidnight(date)
				{
					isValidDate(date) && date.setHours(0, 0, 0, 0)
				}

				function createDateAtMidnight(opt_value)
				{
					var date;
					date = angular.isUndefined(opt_value) ? new Date : new Date(opt_value);
					setDateTimeToMidnight(date);
					return date
				}

				function isDateWithinRange(date, minDate, maxDate)
				{
					var dateAtMidnight = createDateAtMidnight(date);
					var minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null;
					var maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null;
					return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) && (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight)
				}

				function incrementYears(date, numberOfYears)
				{
					return incrementMonths(date, 12 * numberOfYears)
				}

				function getYearDistance(start, end)
				{
					return end.getFullYear() - start.getFullYear()
				}

				function clampDate(date, minDate, maxDate)
				{
					var boundDate = date;
					minDate && date < minDate && (boundDate = new Date(minDate.getTime()));
					maxDate && date > maxDate && (boundDate = new Date(maxDate.getTime()));
					return boundDate
				}

				function getTimestampFromNode(node)
				{
					if (node && node.hasAttribute("data-timestamp")) return Number(node.getAttribute("data-timestamp"))
				}

				function isMonthWithinRange(date, minDate, maxDate)
				{
					var month = date.getMonth();
					var year = date.getFullYear();
					return (!minDate || minDate.getFullYear() < year || minDate.getMonth() <= month) && (!maxDate || maxDate.getFullYear() > year || maxDate.getMonth() >= month)
				}
			});
			void
			function ()
			{
				DatePickerCtrl.$inject = ["$scope", "$element", "$attrs", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF", "$filter"];
				datePickerDirective.$inject = ["$$mdSvgRegistry", "$mdUtil", "$mdAria", "inputDirective"];
				angular.module("material.components.datepicker").directive("mdDatepicker", datePickerDirective);

				function datePickerDirective($$mdSvgRegistry, $mdUtil, $mdAria, inputDirective)
				{
					return {
						template: function (tElement, tAttrs)
						{
							var hiddenIcons = tAttrs.mdHideIcons;
							var ariaLabelValue = tAttrs.ariaLabel || tAttrs.mdPlaceholder;
							var calendarButton = "all" === hiddenIcons || "calendar" === hiddenIcons ? "" : '<md-button class="md-datepicker-button md-icon-button" type="button" tabindex="-1" aria-hidden="true" ng-click="ctrl.openCalendarPane($event)"><md-icon class="md-datepicker-calendar-icon" aria-label="md-calendar" md-svg-src="' + $$mdSvgRegistry.mdCalendar + '"></md-icon></md-button>';
							var triangleButton = "";
							if ("all" !== hiddenIcons && "triangle" !== hiddenIcons)
							{
								triangleButton = '<md-button type="button" md-no-ink class="md-datepicker-triangle-button md-icon-button" ng-click="ctrl.openCalendarPane($event)" aria-label="{{::ctrl.locale.msgOpenCalendar}}"><div class="md-datepicker-expand-triangle"></div></md-button>';
								tElement.addClass(HAS_TRIANGLE_ICON_CLASS)
							}
							return calendarButton + '<div class="md-datepicker-input-container" ng-class="{\'md-datepicker-focused\': ctrl.isFocused}"><input ' + (ariaLabelValue ? 'aria-label="' + ariaLabelValue + '" ' : "") + 'class="md-datepicker-input" aria-haspopup="true" aria-expanded="{{ctrl.isCalendarOpen}}" ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)"> ' + triangleButton + '</div><div class="md-datepicker-calendar-pane md-whiteframe-z1" id="{{::ctrl.calendarPaneId}}"><div class="md-datepicker-input-mask"><div class="md-datepicker-input-mask-opaque"></div></div><div class="md-datepicker-calendar"><md-calendar role="dialog" aria-label="{{::ctrl.locale.msgCalendar}}" md-current-view="{{::ctrl.currentView}}" md-mode="{{::ctrl.mode}}" md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate" md-date-filter="ctrl.dateFilter" ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen"></md-calendar></div></div>'
						},
						require: ["ngModel", "mdDatepicker", "?^mdInputContainer", "?^form"],
						scope:
						{
							minDate: "=mdMinDate",
							maxDate: "=mdMaxDate",
							placeholder: "@mdPlaceholder",
							currentView: "@mdCurrentView",
							mode: "@mdMode",
							dateFilter: "=mdDateFilter",
							isOpen: "=?mdIsOpen",
							debounceInterval: "=mdDebounceInterval",
							dateLocale: "=mdDateLocale"
						},
						controller: DatePickerCtrl,
						controllerAs: "ctrl",
						bindToController: true,
						link: function (scope, element, attr, controllers)
						{
							var ngModelCtrl = controllers[0];
							var mdDatePickerCtrl = controllers[1];
							var mdInputContainer = controllers[2];
							var parentForm = controllers[3];
							var mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);
							mdDatePickerCtrl.configureNgModel(ngModelCtrl, mdInputContainer, inputDirective);
							if (mdInputContainer)
							{
								var spacer = element[0].querySelector(".md-errors-spacer");
								spacer && element.after(angular.element("<div>").append(spacer));
								mdInputContainer.setHasPlaceholder(attr.mdPlaceholder);
								mdInputContainer.input = element;
								mdInputContainer.element.addClass(INPUT_CONTAINER_CLASS).toggleClass(HAS_CALENDAR_ICON_CLASS, "calendar" !== attr.mdHideIcons && "all" !== attr.mdHideIcons);
								mdInputContainer.label ? mdNoAsterisk || attr.$observe("required", function (value)
								{
									mdInputContainer.label.toggleClass("md-required", !!value)
								}) : $mdAria.expect(element, "aria-label", attr.mdPlaceholder);
								scope.$watch(mdInputContainer.isErrorGetter || function ()
								{
									return ngModelCtrl.$invalid && (ngModelCtrl.$touched || parentForm && parentForm.$submitted)
								}, mdInputContainer.setInvalid)
							}
							else if (parentForm) var parentSubmittedWatcher = scope.$watch(function ()
							{
								return parentForm.$submitted
							}, function (isSubmitted)
							{
								if (isSubmitted)
								{
									mdDatePickerCtrl.updateErrorState();
									parentSubmittedWatcher()
								}
							})
						}
					}
				}
				var EXTRA_INPUT_SIZE = 3;
				var INVALID_CLASS = "md-datepicker-invalid";
				var OPEN_CLASS = "md-datepicker-open";
				var INPUT_CONTAINER_CLASS = "_md-datepicker-floating-label";
				var HAS_CALENDAR_ICON_CLASS = "_md-datepicker-has-calendar-icon";
				var HAS_TRIANGLE_ICON_CLASS = "_md-datepicker-has-triangle-icon";
				var DEFAULT_DEBOUNCE_INTERVAL = 500;
				var CALENDAR_PANE_HEIGHT = 368;
				var CALENDAR_PANE_WIDTH = 360;
				var IS_MOBILE_REGEX = /ipad|iphone|ipod|android/i;

				function DatePickerCtrl($scope, $element, $attrs, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF, $filter)
				{
					this.$window = $window;
					this.dateUtil = $$mdDateUtil;
					this.$mdConstant = $mdConstant;
					this.$mdUtil = $mdUtil;
					this.$$rAF = $$rAF;
					this.$mdDateLocale = $mdDateLocale;
					this.documentElement = angular.element(document.documentElement);
					this.ngModelCtrl = null;
					this.inputElement = $element[0].querySelector("input");
					this.ngInputElement = angular.element(this.inputElement);
					this.inputContainer = $element[0].querySelector(".md-datepicker-input-container");
					this.calendarPane = $element[0].querySelector(".md-datepicker-calendar-pane");
					this.calendarButton = $element[0].querySelector(".md-datepicker-button");
					this.inputMask = angular.element($element[0].querySelector(".md-datepicker-input-mask-opaque"));
					this.$element = $element;
					this.$attrs = $attrs;
					this.$scope = $scope;
					this.date = null;
					this.isFocused = false;
					this.isDisabled;
					this.setDisabled($element[0].disabled || angular.isString($attrs.disabled));
					this.isCalendarOpen = false;
					this.openOnFocus = $attrs.hasOwnProperty("mdOpenOnFocus");
					this.mdInputContainer = null;
					this.calendarPaneOpenedFrom = null;
					this.calendarPaneId = "md-date-pane-" + $mdUtil.nextUid();
					this.bodyClickHandler = angular.bind(this, this.handleBodyClick);
					this.windowEventName = IS_MOBILE_REGEX.test(navigator.userAgent || navigator.vendor || window.opera) ? "orientationchange" : "resize";
					this.windowEventHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100);
					this.windowBlurHandler = angular.bind(this, this.handleWindowBlur);
					this.ngDateFilter = $filter("date");
					this.leftMargin = 20;
					this.topMargin = null;
					if ($attrs.tabindex)
					{
						this.ngInputElement.attr("tabindex", $attrs.tabindex);
						$attrs.$set("tabindex", null)
					}
					else $attrs.$set("tabindex", "-1");
					$attrs.$set("aria-owns", this.calendarPaneId);
					$mdTheming($element);
					$mdTheming(angular.element(this.calendarPane));
					var self = this;
					$scope.$on("$destroy", function ()
					{
						self.detachCalendarPane()
					});
					$attrs.mdIsOpen && $scope.$watch("ctrl.isOpen", function (shouldBeOpen)
					{
						shouldBeOpen ? self.openCalendarPane(
						{
							target: self.inputElement
						}) : self.closeCalendarPane()
					});
					1 === angular.version.major && angular.version.minor <= 4 && this.$onInit()
				}
				DatePickerCtrl.prototype.$onInit = function ()
				{
					this.locale = this.dateLocale ? angular.extend(
					{}, this.$mdDateLocale, this.dateLocale) : this.$mdDateLocale;
					this.installPropertyInterceptors();
					this.attachChangeListeners();
					this.attachInteractionListeners()
				};
				DatePickerCtrl.prototype.configureNgModel = function (ngModelCtrl, mdInputContainer, inputDirective)
				{
					this.ngModelCtrl = ngModelCtrl;
					this.mdInputContainer = mdInputContainer;
					this.$attrs.$set("type", "date");
					inputDirective[0].link.pre(this.$scope,
					{
						on: angular.noop,
						val: angular.noop,
						0:
						{}
					}, this.$attrs, [ngModelCtrl]);
					var self = this;
					self.ngModelCtrl.$formatters.push(function (value)
					{
						var parsedValue = angular.isDefined(value) ? value : null;
						if (!(value instanceof Date))
						{
							parsedValue = Date.parse(value);
							!isNaN(parsedValue) && angular.isNumber(parsedValue) && (value = new Date(parsedValue));
							if (value && !(value instanceof Date)) throw Error("The ng-model for md-datepicker must be a Date instance or a value that can be parsed into a date. Currently the model is of type: " + typeof value)
						}
						self.onExternalChange(value);
						return value
					});
					ngModelCtrl.$viewChangeListeners.unshift(angular.bind(this, this.updateErrorState));
					var updateOn = self.$mdUtil.getModelOption(ngModelCtrl, "updateOn");
					updateOn && this.ngInputElement.on(updateOn, angular.bind(this.$element, this.$element.triggerHandler, updateOn))
				};
				DatePickerCtrl.prototype.attachChangeListeners = function ()
				{
					var self = this;
					self.$scope.$on("md-calendar-change", function (event, date)
					{
						self.setModelValue(date);
						self.onExternalChange(date);
						self.closeCalendarPane()
					});
					self.ngInputElement.on("input", angular.bind(self, self.resizeInputElement));
					var debounceInterval = angular.isDefined(this.debounceInterval) ? this.debounceInterval : DEFAULT_DEBOUNCE_INTERVAL;
					self.ngInputElement.on("input", self.$mdUtil.debounce(self.handleInputEvent, debounceInterval, self))
				};
				DatePickerCtrl.prototype.attachInteractionListeners = function ()
				{
					var self = this;
					var $scope = this.$scope;
					var keyCodes = this.$mdConstant.KEY_CODE;
					self.ngInputElement.on("keydown", function (event)
					{
						if (event.altKey && event.keyCode == keyCodes.DOWN_ARROW)
						{
							self.openCalendarPane(event);
							$scope.$digest()
						}
					});
					if (self.openOnFocus)
					{
						self.ngInputElement.on("focus", angular.bind(self, self.openCalendarPane));
						angular.element(self.$window).on("blur", self.windowBlurHandler);
						$scope.$on("$destroy", function ()
						{
							angular.element(self.$window).off("blur", self.windowBlurHandler)
						})
					}
					$scope.$on("md-calendar-close", function ()
					{
						self.closeCalendarPane()
					})
				};
				DatePickerCtrl.prototype.installPropertyInterceptors = function ()
				{
					var self = this;
					if (this.$attrs.ngDisabled)
					{
						var scope = this.$scope.$parent;
						scope && scope.$watch(this.$attrs.ngDisabled, function (isDisabled)
						{
							self.setDisabled(isDisabled)
						})
					}
					Object.defineProperty(this, "placeholder",
					{
						get: function ()
						{
							return self.inputElement.placeholder
						},
						set: function (value)
						{
							self.inputElement.placeholder = value || ""
						}
					})
				};
				DatePickerCtrl.prototype.setDisabled = function (isDisabled)
				{
					this.isDisabled = isDisabled;
					this.inputElement.disabled = isDisabled;
					this.calendarButton && (this.calendarButton.disabled = isDisabled)
				};
				DatePickerCtrl.prototype.updateErrorState = function (opt_date)
				{
					var date = opt_date || this.date;
					this.clearErrorState();
					if (this.dateUtil.isValidDate(date))
					{
						date = this.dateUtil.createDateAtMidnight(date);
						if (this.dateUtil.isValidDate(this.minDate))
						{
							var minDate = this.dateUtil.createDateAtMidnight(this.minDate);
							this.ngModelCtrl.$setValidity("mindate", date >= minDate)
						}
						if (this.dateUtil.isValidDate(this.maxDate))
						{
							var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate);
							this.ngModelCtrl.$setValidity("maxdate", date <= maxDate)
						}
						angular.isFunction(this.dateFilter) && this.ngModelCtrl.$setValidity("filtered", this.dateFilter(date))
					}
					else this.ngModelCtrl.$setValidity("valid", null == date);
					angular.element(this.inputContainer).toggleClass(INVALID_CLASS, !this.ngModelCtrl.$valid)
				};
				DatePickerCtrl.prototype.clearErrorState = function ()
				{
					this.inputContainer.classList.remove(INVALID_CLASS);
					["mindate", "maxdate", "filtered", "valid"].forEach(function (field)
					{
						this.ngModelCtrl.$setValidity(field, true)
					}, this)
				};
				DatePickerCtrl.prototype.resizeInputElement = function ()
				{
					this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE
				};
				DatePickerCtrl.prototype.handleInputEvent = function ()
				{
					var inputString = this.inputElement.value;
					var parsedDate = inputString ? this.locale.parseDate(inputString) : null;
					this.dateUtil.setDateTimeToMidnight(parsedDate);
					var isValidInput = "" == inputString || this.dateUtil.isValidDate(parsedDate) && this.locale.isDateComplete(inputString) && this.isDateEnabled(parsedDate);
					if (isValidInput)
					{
						this.setModelValue(parsedDate);
						this.date = parsedDate
					}
					this.updateErrorState(parsedDate)
				};
				DatePickerCtrl.prototype.isDateEnabled = function (opt_date)
				{
					return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date))
				};
				DatePickerCtrl.prototype.attachCalendarPane = function ()
				{
					var calendarPane = this.calendarPane;
					var body = document.body;
					calendarPane.style.transform = "";
					this.$element.addClass(OPEN_CLASS);
					this.mdInputContainer && this.mdInputContainer.element.addClass(OPEN_CLASS);
					angular.element(body).addClass("md-datepicker-is-showing");
					var elementRect = this.inputContainer.getBoundingClientRect();
					var bodyRect = body.getBoundingClientRect();
					(!this.topMargin || this.topMargin < 0) && (this.topMargin = (this.inputMask.parent().prop("clientHeight") - this.ngInputElement.prop("clientHeight")) / 2);
					var paneTop = elementRect.top - bodyRect.top - this.topMargin;
					var paneLeft = elementRect.left - bodyRect.left - this.leftMargin;
					var viewportTop = bodyRect.top < 0 && 0 == document.body.scrollTop ? -bodyRect.top : document.body.scrollTop;
					var viewportLeft = bodyRect.left < 0 && 0 == document.body.scrollLeft ? -bodyRect.left : document.body.scrollLeft;
					var viewportBottom = viewportTop + this.$window.innerHeight;
					var viewportRight = viewportLeft + this.$window.innerWidth;
					this.inputMask.css(
					{
						position: "absolute",
						left: this.leftMargin + "px",
						top: this.topMargin + "px",
						width: elementRect.width - 1 + "px",
						height: elementRect.height - 2 + "px"
					});
					if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight)
					{
						if (viewportRight - CALENDAR_PANE_WIDTH > 0) paneLeft = viewportRight - CALENDAR_PANE_WIDTH;
						else
						{
							paneLeft = viewportLeft;
							var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH;
							calendarPane.style.transform = "scale(" + scale + ")"
						}
						calendarPane.classList.add("md-datepicker-pos-adjusted")
					}
					if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom && viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop)
					{
						paneTop = viewportBottom - CALENDAR_PANE_HEIGHT;
						calendarPane.classList.add("md-datepicker-pos-adjusted")
					}
					calendarPane.style.left = paneLeft + "px";
					calendarPane.style.top = paneTop + "px";
					document.body.appendChild(calendarPane);
					this.$$rAF(function ()
					{
						calendarPane.classList.add("md-pane-open")
					})
				};
				DatePickerCtrl.prototype.detachCalendarPane = function ()
				{
					this.$element.removeClass(OPEN_CLASS);
					this.mdInputContainer && this.mdInputContainer.element.removeClass(OPEN_CLASS);
					angular.element(document.body).removeClass("md-datepicker-is-showing");
					this.calendarPane.classList.remove("md-pane-open");
					this.calendarPane.classList.remove("md-datepicker-pos-adjusted");
					this.isCalendarOpen && this.$mdUtil.enableScrolling();
					this.calendarPane.parentNode && this.calendarPane.parentNode.removeChild(this.calendarPane)
				};
				DatePickerCtrl.prototype.openCalendarPane = function (event)
				{
					if (!this.isCalendarOpen && !this.isDisabled && !this.inputFocusedOnWindowBlur)
					{
						this.isCalendarOpen = this.isOpen = true;
						this.calendarPaneOpenedFrom = event.target;
						this.$mdUtil.disableScrollAround(this.calendarPane);
						this.attachCalendarPane();
						this.focusCalendar();
						this.evalAttr("ngFocus");
						var self = this;
						this.$mdUtil.nextTick(function ()
						{
							self.documentElement.on("click touchstart", self.bodyClickHandler)
						}, false);
						window.addEventListener(this.windowEventName, this.windowEventHandler)
					}
				};
				DatePickerCtrl.prototype.closeCalendarPane = function ()
				{
					if (this.isCalendarOpen)
					{
						var self = this;
						self.detachCalendarPane();
						self.ngModelCtrl.$setTouched();
						self.evalAttr("ngBlur");
						self.documentElement.off("click touchstart", self.bodyClickHandler);
						window.removeEventListener(self.windowEventName, self.windowEventHandler);
						self.calendarPaneOpenedFrom.focus();
						self.calendarPaneOpenedFrom = null;
						self.openOnFocus ? self.$mdUtil.nextTick(reset) : reset()
					}

					function reset()
					{
						self.isCalendarOpen = self.isOpen = false
					}
				};
				DatePickerCtrl.prototype.getCalendarCtrl = function ()
				{
					return angular.element(this.calendarPane.querySelector("md-calendar")).controller("mdCalendar")
				};
				DatePickerCtrl.prototype.focusCalendar = function ()
				{
					var self = this;
					this.$mdUtil.nextTick(function ()
					{
						self.getCalendarCtrl().focus()
					}, false)
				};
				DatePickerCtrl.prototype.setFocused = function (isFocused)
				{
					isFocused || this.ngModelCtrl.$setTouched();
					this.openOnFocus || this.evalAttr(isFocused ? "ngFocus" : "ngBlur");
					this.isFocused = isFocused
				};
				DatePickerCtrl.prototype.handleBodyClick = function (event)
				{
					if (this.isCalendarOpen)
					{
						var isInCalendar = this.$mdUtil.getClosest(event.target, "md-calendar");
						isInCalendar || this.closeCalendarPane();
						this.$scope.$digest()
					}
				};
				DatePickerCtrl.prototype.handleWindowBlur = function ()
				{
					this.inputFocusedOnWindowBlur = document.activeElement === this.inputElement
				};
				DatePickerCtrl.prototype.evalAttr = function (attr)
				{
					this.$attrs[attr] && this.$scope.$parent.$eval(this.$attrs[attr])
				};
				DatePickerCtrl.prototype.setModelValue = function (value)
				{
					var timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone");
					this.ngModelCtrl.$setViewValue(this.ngDateFilter(value, "yyyy-MM-dd", timezone))
				};
				DatePickerCtrl.prototype.onExternalChange = function (value)
				{
					var timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone");
					this.date = value;
					this.inputElement.value = this.locale.formatDate(value, timezone);
					this.mdInputContainer && this.mdInputContainer.setHasValue(!!value);
					this.resizeInputElement();
					this.updateErrorState()
				}
			}();
			(function ()
			{
				angular.module("material.components.icon").directive("mdIcon", ["$mdIcon", "$mdTheming", "$mdAria", "$sce", mdIconDirective]);

				function mdIconDirective($mdIcon, $mdTheming, $mdAria, $sce)
				{
					return {
						restrict: "E",
						link: postLink
					};

					function postLink(scope, element, attr)
					{
						$mdTheming(element);
						var lastFontIcon = attr.mdFontIcon;
						var lastFontSet = $mdIcon.fontSet(attr.mdFontSet);
						prepareForFontIcon();
						attr.$observe("mdFontIcon", fontIconChanged);
						attr.$observe("mdFontSet", fontIconChanged);
						element[0].getAttribute(attr.$attr.mdSvgSrc);
						var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || "");
						if (!attr.role)
						{
							$mdAria.expect(element, "role", "img");
							attr.role = "img"
						}
						if ("img" === attr.role && !attr.ariaHidden && !$mdAria.hasAriaLabel(element))
						{
							var iconName;
							attr.alt ? $mdAria.expect(element, "aria-label", attr.alt) : $mdAria.parentHasAriaLabel(element, 2) ? $mdAria.expect(element, "aria-hidden", "true") : (iconName = attr.mdFontIcon || attr.mdSvgIcon || element.text()) ? $mdAria.expect(element, "aria-label", iconName) : $mdAria.expect(element, "aria-hidden", "true")
						}
						attrName && attr.$observe(attrName, function (attrVal)
						{
							element.empty();
							attrVal && $mdIcon(attrVal).then(function (svg)
							{
								element.empty();
								element.append(svg)
							})
						});

						function prepareForFontIcon()
						{
							if (!attr.mdSvgIcon && !attr.mdSvgSrc)
							{
								attr.mdFontIcon && element.addClass("md-font " + attr.mdFontIcon);
								element.addClass(lastFontSet)
							}
						}

						function fontIconChanged()
						{
							if (!attr.mdSvgIcon && !attr.mdSvgSrc)
							{
								if (attr.mdFontIcon)
								{
									element.removeClass(lastFontIcon);
									element.addClass(attr.mdFontIcon);
									lastFontIcon = attr.mdFontIcon
								}
								var fontSet = $mdIcon.fontSet(attr.mdFontSet);
								if (lastFontSet !== fontSet)
								{
									element.removeClass(lastFontSet);
									element.addClass(fontSet);
									lastFontSet = fontSet
								}
							}
						}
					}
				}
			})();
			(function ()
			{
				MdIconService.$inject = ["config", "$templateRequest", "$q", "$log", "$mdUtil", "$sce"];
				angular.module("material.components.icon").constant("$$mdSvgRegistry",
				{
					mdTabsArrow: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwb2x5Z29uIHBvaW50cz0iMTUuNCw3LjQgMTQsNiA4LDEyIDE0LDE4IDE1LjQsMTYuNiAxMC44LDEyICIvPjwvZz48L3N2Zz4=",
					mdClose: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xOSA2LjQxbC0xLjQxLTEuNDEtNS41OSA1LjU5LTUuNTktNS41OS0xLjQxIDEuNDEgNS41OSA1LjU5LTUuNTkgNS41OSAxLjQxIDEuNDEgNS41OS01LjU5IDUuNTkgNS41OSAxLjQxLTEuNDEtNS41OS01LjU5eiIvPjwvZz48L3N2Zz4=",
					mdCancel: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xMiAyYy01LjUzIDAtMTAgNC40Ny0xMCAxMHM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTAtNC40Ny0xMC0xMC0xMHptNSAxMy41OWwtMS40MSAxLjQxLTMuNTktMy41OS0zLjU5IDMuNTktMS40MS0xLjQxIDMuNTktMy41OS0zLjU5LTMuNTkgMS40MS0xLjQxIDMuNTkgMy41OSAzLjU5LTMuNTkgMS40MSAxLjQxLTMuNTkgMy41OSAzLjU5IDMuNTl6Ii8+PC9nPjwvc3ZnPg==",
					mdMenu: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0zLDZIMjFWOEgzVjZNMywxMUgyMVYxM0gzVjExTTMsMTZIMjFWMThIM1YxNloiIC8+PC9zdmc+",
					mdToggleArrow: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGQ9Ik0yNCAxNmwtMTIgMTIgMi44MyAyLjgzIDkuMTctOS4xNyA5LjE3IDkuMTcgMi44My0yLjgzeiIvPjxwYXRoIGQ9Ik0wIDBoNDh2NDhoLTQ4eiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==",
					mdCalendar: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgM2gtMVYxaC0ydjJIOFYxSDZ2Mkg1Yy0xLjExIDAtMS45OS45LTEuOTkgMkwzIDE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY4aDE0djExek03IDEwaDV2NUg3eiIvPjwvc3ZnPg==",
					mdChecked: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz48L2c+PC9zdmc+"
				}).provider("$mdIcon", MdIconProvider);
				var config = {
					defaultViewBoxSize: 24,
					defaultFontSet: "material-icons",
					fontSets: []
				};

				function MdIconProvider()
				{}
				MdIconProvider.prototype = {
					icon: function (id, url, viewBoxSize)
					{
						-1 == id.indexOf(":") && (id = "$default:" + id);
						config[id] = new ConfigurationItem(url, viewBoxSize);
						return this
					},
					iconSet: function (id, url, viewBoxSize)
					{
						config[id] = new ConfigurationItem(url, viewBoxSize);
						return this
					},
					defaultIconSet: function (url, viewBoxSize)
					{
						var setName = "$default";
						config[setName] || (config[setName] = new ConfigurationItem(url, viewBoxSize));
						config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
						return this
					},
					defaultViewBoxSize: function (viewBoxSize)
					{
						config.defaultViewBoxSize = viewBoxSize;
						return this
					},
					fontSet: function fontSet(alias, className)
					{
						config.fontSets.push(
						{
							alias: alias,
							fontSet: className || alias
						});
						return this
					},
					defaultFontSet: function defaultFontSet(className)
					{
						config.defaultFontSet = className || "";
						return this
					},
					defaultIconSize: function defaultIconSize(iconSize)
					{
						config.defaultIconSize = iconSize;
						return this
					},
					$get: ["$templateRequest", "$q", "$log", "$mdUtil", "$sce", function ($templateRequest, $q, $log, $mdUtil, $sce)
					{
						return MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce)
					}]
				};

				function ConfigurationItem(url, viewBoxSize)
				{
					this.url = url;
					this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize
				}

				function MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce)
				{
					var iconCache = {};
					var svgCache = {};
					var urlRegex = /[-\w@:%+.~#?&//=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%+.~#?&//=]*)?/i;
					var dataUrlRegex = /^data:image\/svg\+xml[\s*;\w\-=]*?(base64)?,(.*)$/i;
					Icon.prototype = {
						clone: cloneSVG,
						prepare: prepareAndStyle
					};
					getIcon.fontSet = findRegisteredFontSet;
					return getIcon;

					function getIcon(id)
					{
						id = id || "";
						angular.isString(id) || (id = $sce.getTrustedUrl(id));
						if (iconCache[id]) return $q.when(transformClone(iconCache[id]));
						if (urlRegex.test(id) || dataUrlRegex.test(id)) return loadByURL(id).then(cacheIcon(id)); - 1 == id.indexOf(":") && (id = "$default:" + id);
						var load = config[id] ? loadByID : loadFromIconSet;
						return load(id).then(cacheIcon(id))
					}

					function findRegisteredFontSet(alias)
					{
						var useDefault = angular.isUndefined(alias) || !(alias && alias.length);
						if (useDefault) return config.defaultFontSet;
						var result = alias;
						angular.forEach(config.fontSets, function (it)
						{
							it.alias == alias && (result = it.fontSet || result)
						});
						return result
					}

					function transformClone(cacheElement)
					{
						var clone = cacheElement.clone();
						var cacheSuffix = "_cache" + $mdUtil.nextUid();
						clone.id && (clone.id += cacheSuffix);
						angular.forEach(clone.querySelectorAll("[id]"), function (item)
						{
							item.id += cacheSuffix
						});
						return clone
					}

					function cacheIcon(id)
					{
						return function updateCache(icon)
						{
							iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);
							return iconCache[id].clone()
						}
					}

					function loadByID(id)
					{
						var iconConfig = config[id];
						return loadByURL(iconConfig.url).then(function (icon)
						{
							return new Icon(icon, iconConfig)
						})
					}

					function loadFromIconSet(id)
					{
						var setName = id.substring(0, id.lastIndexOf(":")) || "$default";
						var iconSetConfig = config[setName];
						return iconSetConfig ? loadByURL(iconSetConfig.url).then(extractFromSet) : announceIdNotFound(id);

						function extractFromSet(set)
						{
							var iconName = id.slice(id.lastIndexOf(":") + 1);
							var icon = set.querySelector("#" + iconName);
							return icon ? new Icon(icon, iconSetConfig) : announceIdNotFound(id)
						}

						function announceIdNotFound(id)
						{
							var msg = "icon " + id + " not found";
							$log.warn(msg);
							return $q.reject(msg || id)
						}
					}

					function loadByURL(url)
					{
						function loadByDataUrl(url)
						{
							var results = dataUrlRegex.exec(url);
							var isBase64 = /base64/i.test(url);
							var data = isBase64 ? window.atob(results[2]) : results[2];
							return $q.when(angular.element(data)[0])
						}

						function loadByHttpUrl(url)
						{
							return $q(function (resolve, reject)
							{
								var announceAndReject = function (err)
									{
										var msg = angular.isString(err) ? err : err.message || err.data || err.statusText;
										$log.warn(msg);
										reject(err)
									},
									extractSvg = function (response)
									{
										svgCache[url] || (svgCache[url] = angular.element("<div>").append(response)[0].querySelector("svg"));
										resolve(svgCache[url])
									};
								$templateRequest(url, true).then(extractSvg, announceAndReject)
							})
						}
						return dataUrlRegex.test(url) ? loadByDataUrl(url) : loadByHttpUrl(url)
					}

					function isIcon(target)
					{
						return angular.isDefined(target.element) && angular.isDefined(target.config)
					}

					function Icon(el, config)
					{
						if (el && "symbol" === el.tagName.toLowerCase())
						{
							var viewbox = el.getAttribute("viewBox");
							el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').html(el.innerHTML)[0];
							viewbox && el.setAttribute("viewBox", viewbox)
						}
						el && "svg" !== el.tagName.toLowerCase() && (el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el.cloneNode(true))[0]);
						el.getAttribute("xmlns") || el.setAttribute("xmlns", "http://www.w3.org/2000/svg");
						this.element = el;
						this.config = config;
						this.prepare()
					}

					function prepareAndStyle()
					{
						var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
						angular.forEach(
						{
							fit: "",
							height: "100%",
							width: "100%",
							preserveAspectRatio: "xMidYMid meet",
							viewBox: this.element.getAttribute("viewBox") || "0 0 " + viewBoxSize + " " + viewBoxSize,
							focusable: false
						}, function (val, attr)
						{
							this.element.setAttribute(attr, val)
						}, this)
					}

					function cloneSVG()
					{
						return this.element.cloneNode(true)
					}
				}
			})();
			(function ()
			{
				MenuController.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q", "$log"];
				angular.module("material.components.menu").controller("mdMenuCtrl", MenuController);

				function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q, $log)
				{
					var prefixer = $mdUtil.prefixer();
					var menuContainer;
					var self = this;
					var triggerElement;
					this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;
					this.init = function init(setMenuContainer, opts)
					{
						opts = opts ||
						{};
						menuContainer = setMenuContainer;
						triggerElement = $element[0].querySelector(prefixer.buildSelector(["ng-click", "ng-mouseenter"]));
						triggerElement.setAttribute("aria-expanded", "false");
						this.isInMenuBar = opts.isInMenuBar;
						this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll(".md-nested-menu"));
						menuContainer.on("$mdInterimElementRemove", function ()
						{
							self.isOpen = false;
							$mdUtil.nextTick(function ()
							{
								self.onIsOpenChanged(self.isOpen)
							})
						});
						$mdUtil.nextTick(function ()
						{
							self.onIsOpenChanged(self.isOpen)
						});
						var menuContainerId = "menu_container_" + $mdUtil.nextUid();
						menuContainer.attr("id", menuContainerId);
						angular.element(triggerElement).attr(
						{
							"aria-owns": menuContainerId,
							"aria-haspopup": "true"
						});
						$scope.$on("$destroy", angular.bind(this, function ()
						{
							this.disableHoverListener();
							$mdMenu.destroy()
						}));
						menuContainer.on("$destroy", function ()
						{
							$mdMenu.destroy()
						})
					};
					var openMenuTimeout, menuItems, deregisterScopeListeners = [];
					this.enableHoverListener = function ()
					{
						deregisterScopeListeners.push($rootScope.$on("$mdMenuOpen", function (event, el)
						{
							if (menuContainer[0].contains(el[0]))
							{
								self.currentlyOpenMenu = el.controller("mdMenu");
								self.isAlreadyOpening = false;
								self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self))
							}
						}));
						deregisterScopeListeners.push($rootScope.$on("$mdMenuClose", function (event, el)
						{
							menuContainer[0].contains(el[0]) && (self.currentlyOpenMenu = undefined)
						}));
						menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
						menuItems.on("mouseenter", self.handleMenuItemHover);
						menuItems.on("mouseleave", self.handleMenuItemMouseLeave)
					};
					this.disableHoverListener = function ()
					{
						while (deregisterScopeListeners.length) deregisterScopeListeners.shift()();
						menuItems && menuItems.off("mouseenter", self.handleMenuItemHover);
						menuItems && menuItems.off("mouseleave", self.handleMenuItemMouseLeave)
					};
					this.handleMenuItemHover = function (event)
					{
						if (self.isAlreadyOpening) return;
						var nestedMenu = event.target.querySelector("md-menu") || $mdUtil.getClosest(event.target, "MD-MENU");
						openMenuTimeout = $timeout(function ()
						{
							nestedMenu && (nestedMenu = angular.element(nestedMenu).controller("mdMenu"));
							if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu)
							{
								var closeTo = self.nestLevel + 1;
								self.currentlyOpenMenu.close(true,
								{
									closeTo: closeTo
								});
								self.isAlreadyOpening = !!nestedMenu;
								nestedMenu && nestedMenu.open()
							}
							else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open)
							{
								self.isAlreadyOpening = !!nestedMenu;
								nestedMenu && nestedMenu.open()
							}
						}, nestedMenu ? 100 : 250);
						var focusableTarget = event.currentTarget.querySelector(".md-button:not([disabled])");
						focusableTarget && focusableTarget.focus()
					};
					this.handleMenuItemMouseLeave = function ()
					{
						if (openMenuTimeout)
						{
							$timeout.cancel(openMenuTimeout);
							openMenuTimeout = undefined
						}
					};
					this.open = function openMenu(ev)
					{
						ev && ev.stopPropagation();
						ev && ev.preventDefault();
						if (self.isOpen) return;
						self.enableHoverListener();
						self.isOpen = true;
						$mdUtil.nextTick(function ()
						{
							self.onIsOpenChanged(self.isOpen)
						});
						triggerElement = triggerElement || (ev ? ev.target : $element[0]);
						triggerElement.setAttribute("aria-expanded", "true");
						$scope.$emit("$mdMenuOpen", $element);
						$mdMenu.show(
						{
							scope: $scope,
							mdMenuCtrl: self,
							nestLevel: self.nestLevel,
							element: menuContainer,
							target: triggerElement,
							preserveElement: true,
							parent: "body"
						}).finally(function ()
						{
							triggerElement.setAttribute("aria-expanded", "false");
							self.disableHoverListener()
						})
					};
					this.onIsOpenChanged = function (isOpen)
					{
						if (isOpen)
						{
							menuContainer.attr("aria-hidden", "false");
							$element[0].classList.add("md-open");
							angular.forEach(self.nestedMenus, function (el)
							{
								el.classList.remove("md-open")
							})
						}
						else
						{
							menuContainer.attr("aria-hidden", "true");
							$element[0].classList.remove("md-open")
						}
						$scope.$mdMenuIsOpen = self.isOpen
					};
					this.focusMenuContainer = function focusMenuContainer()
					{
						var focusTarget = menuContainer[0].querySelector(prefixer.buildSelector(["md-menu-focus-target", "md-autofocus"]));
						focusTarget || (focusTarget = menuContainer[0].querySelector(".md-button:not([disabled])"));
						focusTarget.focus()
					};
					this.registerContainerProxy = function registerContainerProxy(handler)
					{
						this.containerProxy = handler
					};
					this.triggerContainerProxy = function triggerContainerProxy(ev)
					{
						this.containerProxy && this.containerProxy(ev)
					};
					this.destroy = function ()
					{
						return self.isOpen ? $mdMenu.destroy() : $q.when(false)
					};
					this.close = function closeMenu(skipFocus, closeOpts)
					{
						if (!self.isOpen) return;
						self.isOpen = false;
						$mdUtil.nextTick(function ()
						{
							self.onIsOpenChanged(self.isOpen)
						});
						var eventDetails = angular.extend(
						{}, closeOpts,
						{
							skipFocus: skipFocus
						});
						$scope.$emit("$mdMenuClose", $element, eventDetails);
						$mdMenu.hide(null, closeOpts);
						if (!skipFocus)
						{
							var el = self.restoreFocusTo || $element.find("button")[0];
							el instanceof angular.element && (el = el[0]);
							el && el.focus()
						}
					};
					this.positionMode = function positionMode()
					{
						var attachment = ($attrs.mdPositionMode || "target").split(" ");
						1 === attachment.length && attachment.push(attachment[0]);
						return {
							left: attachment[0],
							top: attachment[1]
						}
					};
					this.offsets = function offsets()
					{
						var position = ($attrs.mdOffset || "0 0").split(" ").map(parseFloat);
						if (2 === position.length) return {
							left: position[0],
							top: position[1]
						};
						if (1 === position.length) return {
							top: position[0],
							left: position[0]
						};
						throw Error("Invalid offsets specified. Please follow format <x, y> or <n>")
					};
					$scope.$mdMenu = {
						open: this.open,
						close: this.close
					};
					$scope.$mdOpenMenu = angular.bind(this, function ()
					{
						$log.warn("mdMenu: The $mdOpenMenu method is deprecated. Please use `$mdMenu.open`.");
						return this.open.apply(this, arguments)
					})
				}
			})();
			(function ()
			{
				MenuDirective.$inject = ["$mdUtil"];
				angular.module("material.components.menu").directive("mdMenu", MenuDirective);

				function MenuDirective($mdUtil)
				{
					var INVALID_PREFIX = "Invalid HTML for md-menu: ";
					return {
						restrict: "E",
						require: ["mdMenu", "?^mdMenuBar"],
						controller: "mdMenuCtrl",
						scope: true,
						compile: compile
					};

					function compile(templateElement)
					{
						templateElement.addClass("md-menu");
						var triggerEl = templateElement.children()[0];
						var prefixer = $mdUtil.prefixer();
						prefixer.hasAttribute(triggerEl, "ng-click") || (triggerEl = triggerEl.querySelector(prefixer.buildSelector(["ng-click", "ng-mouseenter"])) || triggerEl);
						var isButtonTrigger = "MD-BUTTON" === triggerEl.nodeName || "BUTTON" === triggerEl.nodeName;
						triggerEl && isButtonTrigger && !triggerEl.hasAttribute("type") && triggerEl.setAttribute("type", "button");
						if (!triggerEl) throw Error(INVALID_PREFIX + "Expected the menu to have a trigger element.");
						if (2 !== templateElement.children().length) throw Error(INVALID_PREFIX + "Expected two children elements. The second element must have a `md-menu-content` element.");
						triggerEl && triggerEl.setAttribute("aria-haspopup", "true");
						var nestedMenus = templateElement[0].querySelectorAll("md-menu");
						var nestingDepth = parseInt(templateElement[0].getAttribute("md-nest-level"), 10) || 0;
						nestedMenus && angular.forEach($mdUtil.nodesToArray(nestedMenus), function (menuEl)
						{
							menuEl.hasAttribute("md-position-mode") || menuEl.setAttribute("md-position-mode", "cascade");
							menuEl.classList.add("_md-nested-menu");
							menuEl.setAttribute("md-nest-level", nestingDepth + 1)
						});
						return link
					}

					function link(scope, element, attr, ctrls)
					{
						var mdMenuCtrl = ctrls[0];
						var isInMenuBar = !!ctrls[1];
						var menuContainer = angular.element('<div class="_md md-open-menu-container md-whiteframe-z2"></div>');
						var menuContents = element.children()[1];
						element.addClass("_md");
						menuContents.hasAttribute("role") || menuContents.setAttribute("role", "menu");
						menuContainer.append(menuContents);
						element.on("$destroy", function ()
						{
							menuContainer.remove()
						});
						element.append(menuContainer);
						menuContainer[0].style.display = "none";
						mdMenuCtrl.init(menuContainer,
						{
							isInMenuBar: isInMenuBar
						})
					}
				}
			})();
			(function ()
			{
				MenuProvider.$inject = ["$$interimElementProvider"];
				angular.module("material.components.menu").provider("$mdMenu", MenuProvider);

				function MenuProvider($$interimElementProvider)
				{
					menuDefaultOptions.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$log"];
					var MENU_EDGE_MARGIN = 8;
					return $$interimElementProvider("$mdMenu").setDefaults(
					{
						methods: ["target"],
						options: menuDefaultOptions
					});

					function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate, $log)
					{
						var prefixer = $mdUtil.prefixer();
						var animator = $mdUtil.dom.animator;
						return {
							parent: "body",
							onShow: onShow,
							onRemove: onRemove,
							hasBackdrop: true,
							disableParentScroll: true,
							skipCompile: true,
							preserveScope: true,
							multiple: true,
							themable: true
						};

						function showBackdrop(scope, element, options)
						{
							if (options.nestLevel) return angular.noop;
							options.disableParentScroll && !$mdUtil.getClosest(options.target, "MD-DIALOG") ? options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent) : options.disableParentScroll = false;
							if (options.hasBackdrop)
							{
								options.backdrop = $mdUtil.createBackdrop(scope, "md-menu-backdrop md-click-catcher");
								$animate.enter(options.backdrop, $document[0].body)
							}
							return function hideBackdrop()
							{
								options.backdrop && options.backdrop.remove();
								options.disableParentScroll && options.restoreScroll()
							}
						}

						function onRemove(scope, element, opts)
						{
							opts.cleanupInteraction();
							opts.cleanupBackdrop();
							opts.cleanupResizing();
							opts.hideBackdrop();
							element.removeClass("md-clickable");
							return true === opts.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);

							function animateRemoval()
							{
								return $animateCss(element,
								{
									addClass: "md-leave"
								}).start()
							}

							function detachAndClean()
							{
								element.removeClass("md-active");
								detachElement(element, opts);
								opts.alreadyOpen = false
							}
						}

						function onShow(scope, element, opts)
						{
							sanitizeAndConfigure(opts);
							opts.menuContentEl[0] ? $mdTheming.inherit(opts.menuContentEl, opts.target) : $log.warn("$mdMenu: Menu elements should always contain a `md-menu-content` element,otherwise interactivity features will not work properly.", element);
							opts.cleanupResizing = startRepositioningOnResize();
							opts.hideBackdrop = showBackdrop(scope, element, opts);
							return showMenu().then(function (response)
							{
								opts.alreadyOpen = true;
								opts.cleanupInteraction = activateInteraction();
								opts.cleanupBackdrop = setupBackdrop();
								element.addClass("md-clickable");
								return response
							});

							function showMenu()
							{
								opts.parent.append(element);
								element[0].style.display = "";
								return $q(function (resolve)
								{
									var position = calculateMenuPosition(element, opts);
									element.removeClass("md-leave");
									$animateCss(element,
									{
										addClass: "md-active",
										from: animator.toCss(position),
										to: animator.toCss(
										{
											transform: ""
										})
									}).start().then(resolve)
								})
							}

							function sanitizeAndConfigure()
							{
								if (!opts.target) throw Error("$mdMenu.show() expected a target to animate from in options.target");
								angular.extend(opts,
								{
									alreadyOpen: false,
									isRemoved: false,
									target: angular.element(opts.target),
									parent: angular.element(opts.parent),
									menuContentEl: angular.element(element[0].querySelector("md-menu-content"))
								})
							}

							function startRepositioningOnResize()
							{
								var repositionMenu = (target = element, options = opts, $$rAF.throttle(function ()
								{
									if (opts.isRemoved) return;
									var position = calculateMenuPosition(target, options);
									target.css(animator.toCss(position))
								}));
								var target, options;
								$window.addEventListener("resize", repositionMenu);
								$window.addEventListener("orientationchange", repositionMenu);
								return function stopRepositioningOnResize()
								{
									$window.removeEventListener("resize", repositionMenu);
									$window.removeEventListener("orientationchange", repositionMenu)
								}
							}

							function setupBackdrop()
							{
								if (!opts.backdrop) return angular.noop;
								opts.backdrop.on("click", onBackdropClick);
								return function ()
								{
									opts.backdrop.off("click", onBackdropClick)
								}
							}

							function onBackdropClick(event)
							{
								event.preventDefault();
								event.stopPropagation();
								scope.$apply(function ()
								{
									opts.mdMenuCtrl.close(true,
									{
										closeAll: true
									})
								})
							}

							function activateInteraction()
							{
								if (!opts.menuContentEl[0]) return angular.noop;
								opts.menuContentEl.on("keydown", onMenuKeyDown);
								opts.menuContentEl[0].addEventListener("click", captureClickListener, true);
								var focusTarget = opts.menuContentEl[0].querySelector(prefixer.buildSelector(["md-menu-focus-target", "md-autofocus"]));
								if (!focusTarget)
								{
									var childrenLen = opts.menuContentEl[0].children.length;
									for (var childIndex = 0; childIndex < childrenLen; childIndex++)
									{
										var child = opts.menuContentEl[0].children[childIndex];
										focusTarget = child.querySelector(".md-button:not([disabled])");
										if (focusTarget) break;
										if (child.firstElementChild && !child.firstElementChild.disabled)
										{
											focusTarget = child.firstElementChild;
											break
										}
									}
								}
								focusTarget && focusTarget.focus();
								return function cleanupInteraction()
								{
									opts.menuContentEl.off("keydown", onMenuKeyDown);
									opts.menuContentEl[0].removeEventListener("click", captureClickListener, true)
								};

								function onMenuKeyDown(ev)
								{
									var handled;
									switch (ev.keyCode)
									{
									case $mdConstant.KEY_CODE.ESCAPE:
										opts.mdMenuCtrl.close(false,
										{
											closeAll: true
										});
										handled = true;
										break;
									case $mdConstant.KEY_CODE.TAB:
										opts.mdMenuCtrl.close(false,
										{
											closeAll: true
										});
										handled = false;
										break;
									case $mdConstant.KEY_CODE.UP_ARROW:
										focusMenuItem(ev, opts.menuContentEl, opts, -1) || opts.nestLevel || opts.mdMenuCtrl.triggerContainerProxy(ev);
										handled = true;
										break;
									case $mdConstant.KEY_CODE.DOWN_ARROW:
										focusMenuItem(ev, opts.menuContentEl, opts, 1) || opts.nestLevel || opts.mdMenuCtrl.triggerContainerProxy(ev);
										handled = true;
										break;
									case $mdConstant.KEY_CODE.LEFT_ARROW:
										opts.nestLevel ? opts.mdMenuCtrl.close() : opts.mdMenuCtrl.triggerContainerProxy(ev);
										handled = true;
										break;
									case $mdConstant.KEY_CODE.RIGHT_ARROW:
										var parentMenu = $mdUtil.getClosest(ev.target, "MD-MENU");
										parentMenu && parentMenu != opts.parent[0] ? ev.target.click() : opts.mdMenuCtrl.triggerContainerProxy(ev);
										handled = true
									}
									if (handled)
									{
										ev.preventDefault();
										ev.stopImmediatePropagation()
									}
								}

								function captureClickListener(e)
								{
									var target = e.target;
									do {
										if (target == opts.menuContentEl[0]) return;
										if ((hasAnyAttribute(target, ["ng-click", "ng-href", "ui-sref"]) || "BUTTON" == target.nodeName || "MD-BUTTON" == target.nodeName) && !hasAnyAttribute(target, ["md-prevent-menu-close"]))
										{
											var closestMenu = $mdUtil.getClosest(target, "MD-MENU");
											target.hasAttribute("disabled") || closestMenu && closestMenu != opts.parent[0] || close();
											break
										}
									} while (target = target.parentNode);

									function close()
									{
										scope.$apply(function ()
										{
											opts.mdMenuCtrl.close(true,
											{
												closeAll: true
											})
										})
									}

									function hasAnyAttribute(target, attrs)
									{
										if (!target) return false;
										for (var attr, i = 0; attr = attrs[i]; ++i)
											if (prefixer.hasAttribute(target, attr)) return true;
										return false
									}
								}
							}
						}

						function focusMenuItem(e, menuEl, opts, direction)
						{
							var currentItem = $mdUtil.getClosest(e.target, "MD-MENU-ITEM");
							var items = $mdUtil.nodesToArray(menuEl[0].children);
							var currentIndex = items.indexOf(currentItem);
							var didFocus;
							for (var i = currentIndex + direction; i >= 0 && i < items.length; i += direction)
							{
								var focusTarget = items[i].querySelector(".md-button");
								didFocus = attemptFocus(focusTarget);
								if (didFocus) break
							}
							return didFocus
						}

						function attemptFocus(el)
						{
							if (el && -1 != el.getAttribute("tabindex"))
							{
								el.focus();
								return $document[0].activeElement == el
							}
						}

						function detachElement(element, opts)
						{
							opts.preserveElement ? toNode(element).style.display = "none" : toNode(element).parentNode === toNode(opts.parent) && toNode(opts.parent).removeChild(toNode(element))
						}

						function calculateMenuPosition(el, opts)
						{
							var containerNode = el[0],
								openMenuNode = el[0].firstElementChild,
								openMenuNodeRect = openMenuNode.getBoundingClientRect(),
								boundryNode = $document[0].body,
								boundryNodeRect = boundryNode.getBoundingClientRect();
							var menuStyle = $window.getComputedStyle(openMenuNode);
							var originNode = opts.target[0].querySelector(prefixer.buildSelector("md-menu-origin")) || opts.target[0],
								originNodeRect = originNode.getBoundingClientRect();
							var bounds = {
								left: boundryNodeRect.left + MENU_EDGE_MARGIN,
								top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
								bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
								right: boundryNodeRect.right - MENU_EDGE_MARGIN
							};
							var alignTarget, alignTargetRect = {
									top: 0,
									left: 0,
									right: 0,
									bottom: 0
								},
								existingOffsets = {
									top: 0,
									left: 0,
									right: 0,
									bottom: 0
								};
							var positionMode = opts.mdMenuCtrl.positionMode();
							if ("target" === positionMode.top || "target" === positionMode.left || "target-right" === positionMode.left)
							{
								alignTarget = firstVisibleChild();
								if (alignTarget)
								{
									alignTarget = alignTarget.firstElementChild || alignTarget;
									alignTarget = alignTarget.querySelector(prefixer.buildSelector("md-menu-align-target")) || alignTarget;
									alignTargetRect = alignTarget.getBoundingClientRect();
									existingOffsets = {
										top: parseFloat(containerNode.style.top || 0),
										left: parseFloat(containerNode.style.left || 0)
									}
								}
							}
							var position = {};
							var transformOrigin = "top ";
							switch (positionMode.top)
							{
							case "target":
								position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
								break;
							case "cascade":
								position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
								break;
							case "bottom":
								position.top = originNodeRect.top + originNodeRect.height;
								break;
							default:
								throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.')
							}
							var rtl = "rtl" === $mdUtil.bidi();
							switch (positionMode.left)
							{
							case "target":
								position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
								transformOrigin += rtl ? "right" : "left";
								break;
							case "target-left":
								position.left = originNodeRect.left;
								transformOrigin += "left";
								break;
							case "target-right":
								position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
								transformOrigin += "right";
								break;
							case "cascade":
								var willFitRight = rtl ? originNodeRect.left - openMenuNodeRect.width < bounds.left : originNodeRect.right + openMenuNodeRect.width < bounds.right;
								position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
								transformOrigin += willFitRight ? "left" : "right";
								break;
							case "right":
								if (rtl)
								{
									position.left = originNodeRect.right - originNodeRect.width;
									transformOrigin += "left"
								}
								else
								{
									position.left = originNodeRect.right - openMenuNodeRect.width;
									transformOrigin += "right"
								}
								break;
							case "left":
								if (rtl)
								{
									position.left = originNodeRect.right - openMenuNodeRect.width;
									transformOrigin += "right"
								}
								else
								{
									position.left = originNodeRect.left;
									transformOrigin += "left"
								}
								break;
							default:
								throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.')
							}
							var offsets = opts.mdMenuCtrl.offsets();
							position.top += offsets.top;
							position.left += offsets.left;
							clamp(position);
							var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1)) / 100;
							var scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1)) / 100;
							return {
								top: Math.round(position.top),
								left: Math.round(position.left),
								transform: opts.alreadyOpen ? undefined : $mdUtil.supplant("scale({0},{1})", [scaleX, scaleY]),
								transformOrigin: transformOrigin
							};

							function clamp(pos)
							{
								pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
								pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left)
							}

							function firstVisibleChild()
							{
								for (var i = 0; i < openMenuNode.children.length; ++i)
									if ("none" != $window.getComputedStyle(openMenuNode.children[i]).display) return openMenuNode.children[i]
							}
						}
					}

					function toNode(el)
					{
						el instanceof angular.element && (el = el[0]);
						return el
					}
				}
			})();
			(function ()
			{
				MenuBarController.$inject = ["$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout"];
				angular.module("material.components.menuBar").controller("MenuBarController", MenuBarController);
				var BOUND_MENU_METHODS = ["handleKeyDown", "handleMenuHover", "scheduleOpenHoveredMenu", "cancelScheduledOpen"];

				function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout)
				{
					this.$element = $element;
					this.$attrs = $attrs;
					this.$mdConstant = $mdConstant;
					this.$mdUtil = $mdUtil;
					this.$document = $document;
					this.$scope = $scope;
					this.$rootScope = $rootScope;
					this.$timeout = $timeout;
					var self = this;
					angular.forEach(BOUND_MENU_METHODS, function (methodName)
					{
						self[methodName] = angular.bind(self, self[methodName])
					})
				}
				MenuBarController.prototype.init = function ()
				{
					var $element = this.$element;
					var $mdUtil = this.$mdUtil;
					var $scope = this.$scope;
					var self = this;
					var deregisterFns = [];
					$element.on("keydown", this.handleKeyDown);
					this.parentToolbar = $mdUtil.getClosest($element, "MD-TOOLBAR");
					deregisterFns.push(this.$rootScope.$on("$mdMenuOpen", function (event, el)
					{
						if (-1 != self.getMenus().indexOf(el[0]))
						{
							$element[0].classList.add("md-open");
							el[0].classList.add("md-open");
							self.currentlyOpenMenu = el.controller("mdMenu");
							self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown);
							self.enableOpenOnHover()
						}
					}));
					deregisterFns.push(this.$rootScope.$on("$mdMenuClose", function (event, el, opts)
					{
						var rootMenus = self.getMenus();
						if (-1 != rootMenus.indexOf(el[0]))
						{
							$element[0].classList.remove("md-open");
							el[0].classList.remove("md-open")
						}
						if ($element[0].contains(el[0]))
						{
							var parentMenu = el[0];
							while (parentMenu && -1 == rootMenus.indexOf(parentMenu)) parentMenu = $mdUtil.getClosest(parentMenu, "MD-MENU", true);
							if (parentMenu)
							{
								opts.skipFocus || parentMenu.querySelector("button:not([disabled])").focus();
								self.currentlyOpenMenu = undefined;
								self.disableOpenOnHover();
								self.setKeyboardMode(true)
							}
						}
					}));
					$scope.$on("$destroy", function ()
					{
						self.disableOpenOnHover();
						while (deregisterFns.length) deregisterFns.shift()()
					});
					this.setKeyboardMode(true)
				};
				MenuBarController.prototype.setKeyboardMode = function (enabled)
				{
					enabled ? this.$element[0].classList.add("md-keyboard-mode") : this.$element[0].classList.remove("md-keyboard-mode")
				};
				MenuBarController.prototype.enableOpenOnHover = function ()
				{
					if (this.openOnHoverEnabled) return;
					var self = this;
					self.openOnHoverEnabled = true;
					if (self.parentToolbar)
					{
						self.parentToolbar.classList.add("md-has-open-menu");
						self.$mdUtil.nextTick(function ()
						{
							angular.element(self.parentToolbar).on("click", self.handleParentClick)
						}, false)
					}
					angular.element(self.getMenus()).on("mouseenter", self.handleMenuHover)
				};
				MenuBarController.prototype.handleMenuHover = function (e)
				{
					this.setKeyboardMode(false);
					this.openOnHoverEnabled && this.scheduleOpenHoveredMenu(e)
				};
				MenuBarController.prototype.disableOpenOnHover = function ()
				{
					if (!this.openOnHoverEnabled) return;
					this.openOnHoverEnabled = false;
					if (this.parentToolbar)
					{
						this.parentToolbar.classList.remove("md-has-open-menu");
						angular.element(this.parentToolbar).off("click", this.handleParentClick)
					}
					angular.element(this.getMenus()).off("mouseenter", this.handleMenuHover)
				};
				MenuBarController.prototype.scheduleOpenHoveredMenu = function (e)
				{
					var menuEl = angular.element(e.currentTarget);
					var menuCtrl = menuEl.controller("mdMenu");
					this.setKeyboardMode(false);
					this.scheduleOpenMenu(menuCtrl)
				};
				MenuBarController.prototype.scheduleOpenMenu = function (menuCtrl)
				{
					var self = this;
					var $timeout = this.$timeout;
					if (menuCtrl != self.currentlyOpenMenu)
					{
						$timeout.cancel(self.pendingMenuOpen);
						self.pendingMenuOpen = $timeout(function ()
						{
							self.pendingMenuOpen = undefined;
							self.currentlyOpenMenu && self.currentlyOpenMenu.close(true,
							{
								closeAll: true
							});
							menuCtrl.open()
						}, 200, false)
					}
				};
				MenuBarController.prototype.handleKeyDown = function (e)
				{
					var keyCodes = this.$mdConstant.KEY_CODE;
					var currentMenu = this.currentlyOpenMenu;
					var wasOpen = currentMenu && currentMenu.isOpen;
					this.setKeyboardMode(true);
					var handled, newMenu, newMenuCtrl;
					switch (e.keyCode)
					{
					case keyCodes.DOWN_ARROW:
						currentMenu ? currentMenu.focusMenuContainer() : this.openFocusedMenu();
						handled = true;
						break;
					case keyCodes.UP_ARROW:
						currentMenu && currentMenu.close();
						handled = true;
						break;
					case keyCodes.LEFT_ARROW:
						newMenu = this.focusMenu(-1);
						if (wasOpen)
						{
							newMenuCtrl = angular.element(newMenu).controller("mdMenu");
							this.scheduleOpenMenu(newMenuCtrl)
						}
						handled = true;
						break;
					case keyCodes.RIGHT_ARROW:
						newMenu = this.focusMenu(1);
						if (wasOpen)
						{
							newMenuCtrl = angular.element(newMenu).controller("mdMenu");
							this.scheduleOpenMenu(newMenuCtrl)
						}
						handled = true
					}
					if (handled)
					{
						e && e.preventDefault && e.preventDefault();
						e && e.stopImmediatePropagation && e.stopImmediatePropagation()
					}
				};
				MenuBarController.prototype.focusMenu = function (direction)
				{
					var menus = this.getMenus();
					var focusedIndex = this.getFocusedMenuIndex(); - 1 == focusedIndex && (focusedIndex = this.getOpenMenuIndex());
					var changed = false;
					if (-1 == focusedIndex)
					{
						focusedIndex = 0;
						changed = true
					}
					else if (direction < 0 && focusedIndex > 0 || direction > 0 && focusedIndex < menus.length - direction)
					{
						focusedIndex += direction;
						changed = true
					}
					if (changed)
					{
						menus[focusedIndex].querySelector("button").focus();
						return menus[focusedIndex]
					}
				};
				MenuBarController.prototype.openFocusedMenu = function ()
				{
					var menu = this.getFocusedMenu();
					menu && angular.element(menu).controller("mdMenu").open()
				};
				MenuBarController.prototype.getMenus = function ()
				{
					var $element = this.$element;
					return this.$mdUtil.nodesToArray($element[0].children).filter(function (el)
					{
						return "MD-MENU" == el.nodeName
					})
				};
				MenuBarController.prototype.getFocusedMenu = function ()
				{
					return this.getMenus()[this.getFocusedMenuIndex()]
				};
				MenuBarController.prototype.getFocusedMenuIndex = function ()
				{
					var $mdUtil = this.$mdUtil;
					var focusedEl = $mdUtil.getClosest(this.$document[0].activeElement, "MD-MENU");
					if (!focusedEl) return -1;
					var focusedIndex = this.getMenus().indexOf(focusedEl);
					return focusedIndex
				};
				MenuBarController.prototype.getOpenMenuIndex = function ()
				{
					var menus = this.getMenus();
					for (var i = 0; i < menus.length; ++i)
						if (menus[i].classList.contains("md-open")) return i;
					return -1
				};
				MenuBarController.prototype.handleParentClick = function (event)
				{
					var openMenu = this.querySelector("md-menu.md-open");
					openMenu && !openMenu.contains(event.target) && angular.element(openMenu).controller("mdMenu").close(true,
					{
						closeAll: true
					})
				}
			})();
			(function ()
			{
				MenuBarDirective.$inject = ["$mdUtil", "$mdTheming"];
				angular.module("material.components.menuBar").directive("mdMenuBar", MenuBarDirective);

				function MenuBarDirective($mdUtil, $mdTheming)
				{
					return {
						restrict: "E",
						require: "mdMenuBar",
						controller: "MenuBarController",
						compile: function compile(templateEl, templateAttrs)
						{
							templateAttrs.ariaRole || templateEl[0].setAttribute("role", "menubar");
							angular.forEach(templateEl[0].children, function (menuEl)
							{
								if ("MD-MENU" == menuEl.nodeName)
								{
									if (!menuEl.hasAttribute("md-position-mode"))
									{
										menuEl.setAttribute("md-position-mode", "left bottom");
										menuEl.querySelector("button, a, md-button").setAttribute("role", "menuitem")
									}
									var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll("md-menu-content"));
									angular.forEach(contentEls, function (contentEl)
									{
										contentEl.classList.add("md-menu-bar-menu");
										contentEl.classList.add("md-dense");
										contentEl.hasAttribute("width") || contentEl.setAttribute("width", 5)
									})
								}
							});
							templateEl.find("md-menu-item").addClass("md-in-menu-bar");
							return function postLink(scope, el, attr, ctrl)
							{
								el.addClass("_md");
								$mdTheming(scope, el);
								ctrl.init()
							}
						}
					}
				}
			})();
			(function ()
			{
				angular.module("material.components.menuBar").directive("mdMenuDivider", MenuDividerDirective);

				function MenuDividerDirective()
				{
					return {
						restrict: "E",
						compile: function (templateEl, templateAttrs)
						{
							templateAttrs.role || templateEl[0].setAttribute("role", "separator")
						}
					}
				}
			})();
			(function ()
			{
				MenuItemController.$inject = ["$scope", "$element", "$attrs"];
				angular.module("material.components.menuBar").controller("MenuItemController", MenuItemController);

				function MenuItemController($scope, $element, $attrs)
				{
					this.$element = $element;
					this.$attrs = $attrs;
					this.$scope = $scope
				}
				MenuItemController.prototype.init = function (ngModel)
				{
					var $element = this.$element;
					var $attrs = this.$attrs;
					this.ngModel = ngModel;
					if ("checkbox" == $attrs.type || "radio" == $attrs.type)
					{
						this.mode = $attrs.type;
						this.iconEl = $element[0].children[0];
						this.buttonEl = $element[0].children[1];
						ngModel && this.initClickListeners()
					}
				};
				MenuItemController.prototype.clearNgAria = function ()
				{
					var el = this.$element[0];
					var clearAttrs = ["role", "tabindex", "aria-invalid", "aria-checked"];
					angular.forEach(clearAttrs, function (attr)
					{
						el.removeAttribute(attr)
					})
				};
				MenuItemController.prototype.initClickListeners = function ()
				{
					var self = this;
					var ngModel = this.ngModel;
					var $scope = this.$scope;
					var $attrs = this.$attrs;
					this.$element;
					var mode = this.mode;
					this.handleClick = angular.bind(this, this.handleClick);
					var icon = this.iconEl;
					var button = angular.element(this.buttonEl);
					var handleClick = this.handleClick;
					$attrs.$observe("disabled", setDisabled);
					setDisabled($attrs.disabled);
					ngModel.$render = function render()
					{
						self.clearNgAria();
						if (isSelected())
						{
							icon.style.display = "";
							button.attr("aria-checked", "true")
						}
						else
						{
							icon.style.display = "none";
							button.attr("aria-checked", "false")
						}
					};
					$scope.$$postDigest(ngModel.$render);

					function isSelected()
					{
						if ("radio" == mode)
						{
							var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
							return ngModel.$modelValue == val
						}
						return ngModel.$modelValue
					}

					function setDisabled(disabled)
					{
						disabled ? button.off("click", handleClick) : button.on("click", handleClick)
					}
				};
				MenuItemController.prototype.handleClick = function (e)
				{
					var mode = this.mode;
					var ngModel = this.ngModel;
					var $attrs = this.$attrs;
					var newVal;
					"checkbox" == mode ? newVal = !ngModel.$modelValue : "radio" == mode && (newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value);
					ngModel.$setViewValue(newVal);
					ngModel.$render()
				}
			})();
			(function ()
			{
				MenuItemDirective.$inject = ["$mdUtil", "$mdConstant", "$$mdSvgRegistry"];
				angular.module("material.components.menuBar").directive("mdMenuItem", MenuItemDirective);

				function MenuItemDirective($mdUtil, $mdConstant, $$mdSvgRegistry)
				{
					return {
						controller: "MenuItemController",
						require: ["mdMenuItem", "?ngModel"],
						priority: $mdConstant.BEFORE_NG_ARIA,
						compile: function (templateEl, templateAttrs)
						{
							var type = templateAttrs.type;
							var inMenuBarClass = "md-in-menu-bar";
							if ("checkbox" != type && "radio" != type || !templateEl.hasClass(inMenuBarClass)) setDefault("role", "menuitem", templateEl[0].querySelector("md-button, button, a"));
							else
							{
								var text = templateEl[0].textContent;
								var buttonEl = angular.element('<md-button type="button"></md-button>');
								var iconTemplate = '<md-icon md-svg-src="' + $$mdSvgRegistry.mdChecked + '"></md-icon>';
								buttonEl.html(text);
								buttonEl.attr("tabindex", "0");
								templateEl.html("");
								templateEl.append(angular.element(iconTemplate));
								templateEl.append(buttonEl);
								templateEl.addClass("md-indent").removeClass(inMenuBarClass);
								setDefault("role", "checkbox" == type ? "menuitemcheckbox" : "menuitemradio", buttonEl);
								moveAttrToButton("ng-disabled")
							}
							return function (scope, el, attrs, ctrls)
							{
								var ctrl = ctrls[0];
								var ngModel = ctrls[1];
								ctrl.init(ngModel)
							};

							function setDefault(attr, val, el)
							{
								el = el || templateEl;
								el instanceof angular.element && (el = el[0]);
								el.hasAttribute(attr) || el.setAttribute(attr, val)
							}

							function moveAttrToButton(attribute)
							{
								var attributes = $mdUtil.prefixer(attribute);
								angular.forEach(attributes, function (attr)
								{
									if (templateEl[0].hasAttribute(attr))
									{
										var val = templateEl[0].getAttribute(attr);
										buttonEl[0].setAttribute(attr, val);
										templateEl[0].removeAttribute(attr)
									}
								})
							}
						}
					}
				}
			})();
			(function ()
			{
				MdProgressCircularDirective.$inject = ["$window", "$mdProgressCircular", "$mdTheming", "$mdUtil", "$interval", "$log"];
				angular.module("material.components.progressCircular").directive("mdProgressCircular", MdProgressCircularDirective);

				function MdProgressCircularDirective($window, $mdProgressCircular, $mdTheming, $mdUtil, $interval, $log)
				{
					var rAF = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || angular.noop;
					var cAF = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame || angular.noop;
					var MODE_DETERMINATE = "determinate";
					var MODE_INDETERMINATE = "indeterminate";
					var DISABLED_CLASS = "_md-progress-circular-disabled";
					var INDETERMINATE_CLASS = "md-mode-indeterminate";
					return {
						restrict: "E",
						scope:
						{
							value: "@",
							mdDiameter: "@",
							mdMode: "@"
						},
						template: '<svg xmlns="http://www.w3.org/2000/svg"><path fill="none"/></svg>',
						compile: function (element, attrs)
						{
							element.attr(
							{
								"aria-valuemin": 0,
								"aria-valuemax": 100,
								role: "progressbar"
							});
							if (angular.isUndefined(attrs.mdMode))
							{
								var mode = attrs.hasOwnProperty("value") ? MODE_DETERMINATE : MODE_INDETERMINATE;
								attrs.$set("mdMode", mode)
							}
							else attrs.$set("mdMode", attrs.mdMode.trim());
							return MdProgressCircularLink
						}
					};

					function MdProgressCircularLink(scope, element, attrs)
					{
						var node = element[0];
						var svg = angular.element(node.querySelector("svg"));
						var path = angular.element(node.querySelector("path"));
						var startIndeterminate = $mdProgressCircular.startIndeterminate;
						var endIndeterminate = $mdProgressCircular.endIndeterminate;
						var iterationCount = 0;
						var lastAnimationId = 0;
						var lastDrawFrame;
						var interval;
						$mdTheming(element);
						element.toggleClass(DISABLED_CLASS, attrs.hasOwnProperty("disabled"));
						scope.mdMode === MODE_INDETERMINATE && startIndeterminateAnimation();
						scope.$on("$destroy", function ()
						{
							cleanupIndeterminateAnimation();
							lastDrawFrame && cAF(lastDrawFrame)
						});
						scope.$watchGroup(["value", "mdMode", function ()
						{
							var isDisabled = node.disabled;
							if (true === isDisabled || false === isDisabled) return isDisabled;
							return angular.isDefined(element.attr("disabled"))
						}], function (newValues, oldValues)
						{
							var mode = newValues[1];
							var isDisabled = newValues[2];
							var wasDisabled = oldValues[2];
							isDisabled !== wasDisabled && element.toggleClass(DISABLED_CLASS, !!isDisabled);
							if (isDisabled) cleanupIndeterminateAnimation();
							else
							{
								if (mode !== MODE_DETERMINATE && mode !== MODE_INDETERMINATE)
								{
									mode = MODE_INDETERMINATE;
									attrs.$set("mdMode", mode)
								}
								if (mode === MODE_INDETERMINATE) startIndeterminateAnimation();
								else
								{
									var newValue = clamp(newValues[0]);
									cleanupIndeterminateAnimation();
									element.attr("aria-valuenow", newValue);
									renderCircle(clamp(oldValues[0]), newValue)
								}
							}
						});
						scope.$watch("mdDiameter", function (newValue)
						{
							var diameter = getSize(newValue);
							var strokeWidth = getStroke(diameter);
							var value = clamp(scope.value);
							var transformOrigin = diameter / 2 + "px";
							var dimensions = {
								width: diameter + "px",
								height: diameter + "px"
							};
							svg[0].setAttribute("viewBox", "0 0 " + diameter + " " + diameter);
							svg.css(dimensions).css("transform-origin", transformOrigin + " " + transformOrigin + " " + transformOrigin);
							element.css(dimensions);
							path.attr("stroke-width", strokeWidth);
							path.attr("stroke-linecap", "square");
							if (scope.mdMode == MODE_INDETERMINATE)
							{
								path.attr("d", getSvgArc(diameter, strokeWidth, true));
								path.attr("stroke-dasharray", (diameter - strokeWidth) * $window.Math.PI * .75);
								path.attr("stroke-dashoffset", getDashLength(diameter, strokeWidth, 1, 75))
							}
							else
							{
								path.attr("d", getSvgArc(diameter, strokeWidth, false));
								path.attr("stroke-dasharray", (diameter - strokeWidth) * $window.Math.PI);
								path.attr("stroke-dashoffset", getDashLength(diameter, strokeWidth, 0, 100));
								renderCircle(value, value)
							}
						});

						function renderCircle(animateFrom, animateTo, easing, duration, iterationCount, maxValue)
						{
							var id = ++lastAnimationId;
							var startTime = $mdUtil.now();
							var changeInValue = animateTo - animateFrom;
							var diameter = getSize(scope.mdDiameter);
							var strokeWidth = getStroke(diameter);
							var ease = easing || $mdProgressCircular.easeFn;
							var animationDuration = duration || $mdProgressCircular.duration;
							var rotation = -90 * (iterationCount || 0);
							var dashLimit = maxValue || 100;
							animateTo === animateFrom ? renderFrame(animateTo) : lastDrawFrame = rAF(function animation()
							{
								var currentTime = $window.Math.max(0, $window.Math.min($mdUtil.now() - startTime, animationDuration));
								renderFrame(ease(currentTime, animateFrom, changeInValue, animationDuration));
								id === lastAnimationId && currentTime < animationDuration && (lastDrawFrame = rAF(animation))
							});

							function renderFrame(value)
							{
								path.attr("stroke-dashoffset", getDashLength(diameter, strokeWidth, value, dashLimit));
								path.attr("transform", "rotate(" + rotation + " " + diameter / 2 + " " + diameter / 2 + ")")
							}
						}

						function animateIndeterminate()
						{
							renderCircle(startIndeterminate, endIndeterminate, $mdProgressCircular.easeFnIndeterminate, $mdProgressCircular.durationIndeterminate, iterationCount, 75);
							iterationCount = ++iterationCount % 4
						}

						function startIndeterminateAnimation()
						{
							if (!interval)
							{
								interval = $interval(animateIndeterminate, $mdProgressCircular.durationIndeterminate, 0, false);
								animateIndeterminate();
								element.addClass(INDETERMINATE_CLASS).removeAttr("aria-valuenow")
							}
						}

						function cleanupIndeterminateAnimation()
						{
							if (interval)
							{
								$interval.cancel(interval);
								interval = null;
								element.removeClass(INDETERMINATE_CLASS)
							}
						}
					}

					function getSvgArc(diameter, strokeWidth, indeterminate)
					{
						var radius = diameter / 2;
						var offset = strokeWidth / 2;
						var start = radius + "," + offset;
						var end = offset + "," + radius;
						var arcRadius = radius - offset;
						return "M" + start + "A" + arcRadius + "," + arcRadius + " 0 1 1 " + end + (indeterminate ? "" : "A" + arcRadius + "," + arcRadius + " 0 0 1 " + start)
					}

					function getDashLength(diameter, strokeWidth, value, limit)
					{
						return (diameter - strokeWidth) * $window.Math.PI * (3 * (limit || 100) / 100 - value / 100)
					}

					function clamp(value)
					{
						return $window.Math.max(0, $window.Math.min(value || 0, 100))
					}

					function getSize(value)
					{
						var defaultValue = $mdProgressCircular.progressSize;
						if (value)
						{
							var parsed = parseFloat(value);
							value.lastIndexOf("%") === value.length - 1 && (parsed = parsed / 100 * defaultValue);
							return parsed
						}
						return defaultValue
					}

					function getStroke(diameter)
					{
						return $mdProgressCircular.strokeWidth / 100 * diameter
					}
				}
			})();
			(function ()
			{
				angular.module("material.components.progressCircular").provider("$mdProgressCircular", MdProgressCircularProvider);

				function MdProgressCircularProvider()
				{
					var progressConfig = {
						progressSize: 50,
						strokeWidth: 10,
						duration: 100,
						easeFn: linearEase,
						durationIndeterminate: 1333,
						startIndeterminate: 1,
						endIndeterminate: 149,
						easeFnIndeterminate: materialEase,
						easingPresets:
						{
							linearEase: linearEase,
							materialEase: materialEase
						}
					};
					return {
						configure: function (options)
						{
							progressConfig = angular.extend(progressConfig, options ||
							{});
							return progressConfig
						},
						$get: function ()
						{
							return progressConfig
						}
					};

					function linearEase(t, b, c, d)
					{
						return c * t / d + b
					}

					function materialEase(t, b, c, d)
					{
						var ts = (t /= d) * t;
						var tc = ts * t;
						return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc)
					}
				}
			})();
			(function ()
			{
				angular.module("material.components.tabs").directive("mdTab", MdTab);

				function MdTab()
				{
					return {
						require: "^?mdTabs",
						terminal: true,
						compile: function (element, attr)
						{
							var label = firstChild(element, "md-tab-label"),
								body = firstChild(element, "md-tab-body");
							if (0 === label.length)
							{
								label = angular.element("<md-tab-label></md-tab-label>");
								attr.label ? label.text(attr.label) : label.append(element.contents());
								if (0 === body.length)
								{
									var contents = element.contents().detach();
									body = angular.element("<md-tab-body></md-tab-body>");
									body.append(contents)
								}
							}
							element.append(label);
							body.html() && element.append(body);
							return postLink
						},
						scope:
						{
							active: "=?mdActive",
							disabled: "=?ngDisabled",
							select: "&?mdOnSelect",
							deselect: "&?mdOnDeselect"
						}
					};

					function postLink(scope, element, attr, ctrl)
					{
						if (!ctrl) return;
						var index = ctrl.getTabElementIndex(element),
							body = firstChild(element, "md-tab-body").remove(),
							label = firstChild(element, "md-tab-label").remove(),
							data = ctrl.insertTab(
							{
								scope: scope,
								parent: scope.$parent,
								index: index,
								element: element,
								template: body.html(),
								label: label.html()
							}, index);
						scope.select = scope.select || angular.noop;
						scope.deselect = scope.deselect || angular.noop;
						scope.$watch("active", function (active)
						{
							active && ctrl.select(data.getIndex(), true)
						});
						scope.$watch("disabled", function ()
						{
							ctrl.refreshIndex()
						});
						scope.$watch(function ()
						{
							return ctrl.getTabElementIndex(element)
						}, function (newIndex)
						{
							data.index = newIndex;
							ctrl.updateTabOrder()
						});
						scope.$on("$destroy", function ()
						{
							ctrl.removeTab(data)
						})
					}

					function firstChild(element, tagName)
					{
						var children = element[0].children;
						for (var i = 0, len = children.length; i < len; i++)
						{
							var child = children[i];
							if (child.tagName === tagName.toUpperCase()) return angular.element(child)
						}
						return angular.element()
					}
				}
			})();
			(function ()
			{
				angular.module("material.components.tabs").directive("mdTabItem", MdTabItem);

				function MdTabItem()
				{
					return {
						require: "^?mdTabs",
						link: function link(scope, element, attr, ctrl)
						{
							if (!ctrl) return;
							ctrl.attachRipple(scope, element)
						}
					}
				}
			})();
			(function ()
			{
				angular.module("material.components.tabs").directive("mdTabLabel", MdTabLabel);

				function MdTabLabel()
				{
					return {
						terminal: true
					}
				}
			})();
			(function ()
			{
				MdTabScroll.$inject = ["$parse"];
				angular.module("material.components.tabs").directive("mdTabScroll", MdTabScroll);

				function MdTabScroll($parse)
				{
					return {
						restrict: "A",
						compile: function ($element, attr)
						{
							var fn = $parse(attr.mdTabScroll, null, true);
							return function ngEventHandler(scope, element)
							{
								element.on("mousewheel", function (event)
								{
									scope.$apply(function ()
									{
										fn(scope,
										{
											$event: event
										})
									})
								})
							}
						}
					}
				}
			})();
			(function ()
			{
				MdTabsController.$inject = ["$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming", "$mdInteraction", "MdTabsPaginationService"];
				angular.module("material.components.tabs").controller("MdTabsController", MdTabsController);

				function MdTabsController($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming, $mdInteraction, MdTabsPaginationService)
				{
					var ctrl = this,
						locked = false,
						queue = (getElements(), []),
						destroyed = false,
						loaded = false;
					ctrl.$onInit = $onInit;
					ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100);
					ctrl.redirectFocus = redirectFocus;
					ctrl.attachRipple = attachRipple;
					ctrl.insertTab = insertTab;
					ctrl.removeTab = removeTab;
					ctrl.select = select;
					ctrl.scroll = scroll;
					ctrl.nextPage = nextPage;
					ctrl.previousPage = previousPage;
					ctrl.keydown = keydown;
					ctrl.canPageForward = canPageForward;
					ctrl.canPageBack = canPageBack;
					ctrl.refreshIndex = refreshIndex;
					ctrl.incrementIndex = incrementIndex;
					ctrl.getTabElementIndex = getTabElementIndex;
					ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);
					ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);
					ctrl.getFocusedTabId = getFocusedTabId;
					1 === angular.version.major && angular.version.minor <= 4 && this.$onInit();

					function $onInit()
					{
						defineOneWayBinding("stretchTabs", handleStretchTabs);
						defineProperty("focusIndex", handleFocusIndexChange, ctrl.selectedIndex || 0);
						defineProperty("offsetLeft", handleOffsetChange, 0);
						defineProperty("hasContent", handleHasContent, false);
						defineProperty("maxTabWidth", handleMaxTabWidth, getMaxTabWidth());
						defineProperty("shouldPaginate", handleShouldPaginate, false);
						defineBooleanAttribute("noInkBar", handleInkBar);
						defineBooleanAttribute("dynamicHeight", handleDynamicHeight);
						defineBooleanAttribute("noPagination");
						defineBooleanAttribute("swipeContent");
						defineBooleanAttribute("noDisconnect");
						defineBooleanAttribute("autoselect");
						defineBooleanAttribute("noSelectClick");
						defineBooleanAttribute("centerTabs", handleCenterTabs, false);
						defineBooleanAttribute("enableDisconnect");
						ctrl.scope = $scope;
						ctrl.parent = $scope.$parent;
						ctrl.tabs = [];
						ctrl.lastSelectedIndex = null;
						ctrl.hasFocus = false;
						ctrl.styleTabItemFocus = false;
						ctrl.shouldCenterTabs = shouldCenterTabs();
						ctrl.tabContentPrefix = "tab-content-";
						setupTabsController()
					}

					function setupTabsController()
					{
						ctrl.selectedIndex = ctrl.selectedIndex || 0;
						compileTemplate();
						configureWatchers();
						bindEvents();
						$mdTheming($element);
						$mdUtil.nextTick(function ()
						{
							getElements();
							updateHeightFromContent();
							adjustOffset();
							updateInkBarStyles();
							ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
							loaded = true;
							updatePagination()
						})
					}

					function compileTemplate()
					{
						var template = $attrs.$mdTabsTemplate,
							element = angular.element($element[0].querySelector("md-tab-data"));
						element.html(template);
						$compile(element.contents())(ctrl.parent);
						delete $attrs.$mdTabsTemplate
					}

					function bindEvents()
					{
						angular.element($window).on("resize", handleWindowResize);
						$scope.$on("$destroy", cleanup)
					}

					function configureWatchers()
					{
						$scope.$watch("$mdTabsCtrl.selectedIndex", handleSelectedIndexChange)
					}

					function defineOneWayBinding(key, handler)
					{
						var attr = $attrs.$normalize("md-" + key);
						handler && defineProperty(key, handler);
						$attrs.$observe(attr, function (newValue)
						{
							ctrl[key] = newValue
						})
					}

					function defineBooleanAttribute(key, handler)
					{
						var attr = $attrs.$normalize("md-" + key);
						handler && defineProperty(key, handler);
						$attrs.hasOwnProperty(attr) && updateValue($attrs[attr]);
						$attrs.$observe(attr, updateValue);

						function updateValue(newValue)
						{
							ctrl[key] = "false" !== newValue
						}
					}

					function cleanup()
					{
						destroyed = true;
						angular.element($window).off("resize", handleWindowResize)
					}

					function handleStretchTabs(stretchTabs)
					{
						var elements = getElements();
						angular.element(elements.wrapper).toggleClass("md-stretch-tabs", shouldStretchTabs());
						updateInkBarStyles()
					}

					function handleCenterTabs(newValue)
					{
						ctrl.shouldCenterTabs = shouldCenterTabs()
					}

					function handleMaxTabWidth(newWidth, oldWidth)
					{
						if (newWidth !== oldWidth)
						{
							var elements = getElements();
							angular.forEach(elements.tabs, function (tab)
							{
								tab.style.maxWidth = newWidth + "px"
							});
							angular.forEach(elements.dummies, function (tab)
							{
								tab.style.maxWidth = newWidth + "px"
							});
							$mdUtil.nextTick(ctrl.updateInkBarStyles)
						}
					}

					function handleShouldPaginate(newValue, oldValue)
					{
						if (newValue !== oldValue)
						{
							ctrl.maxTabWidth = getMaxTabWidth();
							ctrl.shouldCenterTabs = shouldCenterTabs();
							$mdUtil.nextTick(function ()
							{
								ctrl.maxTabWidth = getMaxTabWidth();
								adjustOffset(ctrl.selectedIndex)
							})
						}
					}

					function handleHasContent(hasContent)
					{
						$element[hasContent ? "removeClass" : "addClass"]("md-no-tab-content")
					}

					function handleOffsetChange(left)
					{
						var elements = getElements();
						var newValue = (ctrl.shouldCenterTabs || isRtl() ? "" : "-") + left + "px";
						newValue = newValue.replace("--", "");
						angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, "translate3d(" + newValue + ", 0, 0)");
						$scope.$broadcast("$mdTabsPaginationChanged")
					}

					function handleFocusIndexChange(newIndex, oldIndex)
					{
						if (newIndex === oldIndex) return;
						if (!getElements().tabs[newIndex]) return;
						adjustOffset();
						redirectFocus()
					}

					function handleSelectedIndexChange(newValue, oldValue)
					{
						if (newValue === oldValue) return;
						ctrl.selectedIndex = getNearestSafeIndex(newValue);
						ctrl.lastSelectedIndex = oldValue;
						ctrl.updateInkBarStyles();
						updateHeightFromContent();
						adjustOffset(newValue);
						$scope.$broadcast("$mdTabsChanged");
						ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();
						ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select()
					}

					function getTabElementIndex(tabEl)
					{
						var tabs = $element[0].getElementsByTagName("md-tab");
						return Array.prototype.indexOf.call(tabs, tabEl[0])
					}

					function handleResizeWhenVisible()
					{
						if (handleResizeWhenVisible.watcher) return;
						handleResizeWhenVisible.watcher = $scope.$watch(function ()
						{
							$mdUtil.nextTick(function ()
							{
								if (!handleResizeWhenVisible.watcher) return;
								if ($element.prop("offsetParent"))
								{
									handleResizeWhenVisible.watcher();
									handleResizeWhenVisible.watcher = null;
									handleWindowResize()
								}
							}, false)
						})
					}

					function keydown(event)
					{
						switch (event.keyCode)
						{
						case $mdConstant.KEY_CODE.LEFT_ARROW:
							event.preventDefault();
							incrementIndex(-1, true);
							break;
						case $mdConstant.KEY_CODE.RIGHT_ARROW:
							event.preventDefault();
							incrementIndex(1, true);
							break;
						case $mdConstant.KEY_CODE.SPACE:
						case $mdConstant.KEY_CODE.ENTER:
							event.preventDefault();
							locked || select(ctrl.focusIndex);
							break;
						case $mdConstant.KEY_CODE.TAB:
							ctrl.focusIndex !== ctrl.selectedIndex && (ctrl.focusIndex = ctrl.selectedIndex)
						}
					}

					function select(index, canSkipClick)
					{
						locked || (ctrl.focusIndex = ctrl.selectedIndex = index);
						if (canSkipClick && ctrl.noSelectClick) return;
						$mdUtil.nextTick(function ()
						{
							ctrl.tabs[index].element.triggerHandler("click")
						}, false)
					}

					function scroll(event)
					{
						if (!ctrl.shouldPaginate) return;
						event.preventDefault();
						ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta)
					}

					function nextPage()
					{
						if (!ctrl.canPageForward()) return;
						var newOffset = MdTabsPaginationService.increasePageOffset(getElements(), ctrl.offsetLeft);
						ctrl.offsetLeft = fixOffset(newOffset)
					}

					function previousPage()
					{
						if (!ctrl.canPageBack()) return;
						var newOffset = MdTabsPaginationService.decreasePageOffset(getElements(), ctrl.offsetLeft);
						ctrl.offsetLeft = fixOffset(newOffset)
					}

					function handleWindowResize()
					{
						ctrl.lastSelectedIndex = ctrl.selectedIndex;
						ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
						$mdUtil.nextTick(function ()
						{
							ctrl.updateInkBarStyles();
							updatePagination()
						})
					}

					function handleInkBar(hide)
					{
						angular.element(getElements().inkBar).toggleClass("ng-hide", hide)
					}

					function handleDynamicHeight(value)
					{
						$element.toggleClass("md-dynamic-height", value)
					}

					function removeTab(tabData)
					{
						if (destroyed) return;
						var selectedIndex = ctrl.selectedIndex,
							tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];
						refreshIndex();
						if (ctrl.selectedIndex === selectedIndex)
						{
							tab.scope.deselect();
							ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select()
						}
						$mdUtil.nextTick(function ()
						{
							updatePagination();
							ctrl.offsetLeft = fixOffset(ctrl.offsetLeft)
						})
					}

					function insertTab(tabData, index)
					{
						var hasLoaded = loaded;
						var proto = {
								getIndex: function ()
								{
									return ctrl.tabs.indexOf(tab)
								},
								isActive: function ()
								{
									return this.getIndex() === ctrl.selectedIndex
								},
								isLeft: function ()
								{
									return this.getIndex() < ctrl.selectedIndex
								},
								isRight: function ()
								{
									return this.getIndex() > ctrl.selectedIndex
								},
								shouldRender: function ()
								{
									return !ctrl.noDisconnect || this.isActive()
								},
								hasFocus: function ()
								{
									return ctrl.styleTabItemFocus && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex
								},
								id: $mdUtil.nextUid(),
								hasContent: !!(tabData.template && tabData.template.trim())
							},
							tab = angular.extend(proto, tabData);
						angular.isDefined(index) ? ctrl.tabs.splice(index, 0, tab) : ctrl.tabs.push(tab);
						processQueue();
						updateHasContent();
						$mdUtil.nextTick(function ()
						{
							updatePagination();
							setAriaControls(tab);
							hasLoaded && ctrl.autoselect && $mdUtil.nextTick(function ()
							{
								$mdUtil.nextTick(function ()
								{
									select(ctrl.tabs.indexOf(tab))
								})
							})
						});
						return tab
					}

					function getElements()
					{
						var elements = {};
						var node = $element[0];
						elements.wrapper = node.querySelector("md-tabs-wrapper");
						elements.canvas = elements.wrapper.querySelector("md-tabs-canvas");
						elements.paging = elements.canvas.querySelector("md-pagination-wrapper");
						elements.inkBar = elements.paging.querySelector("md-ink-bar");
						elements.nextButton = node.querySelector("md-next-button");
						elements.prevButton = node.querySelector("md-prev-button");
						elements.contents = node.querySelectorAll("md-tabs-content-wrapper > md-tab-content");
						elements.tabs = elements.paging.querySelectorAll("md-tab-item");
						elements.dummies = elements.canvas.querySelectorAll("md-dummy-tab");
						return elements
					}

					function canPageBack()
					{
						return ctrl.offsetLeft > 0
					}

					function canPageForward()
					{
						var elements = getElements();
						var lastTab = elements.tabs[elements.tabs.length - 1];
						if (isRtl()) return ctrl.offsetLeft < elements.paging.offsetWidth - elements.canvas.offsetWidth;
						return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft
					}

					function getFocusedTabId()
					{
						var focusedTab = ctrl.tabs[ctrl.focusIndex];
						if (!focusedTab || !focusedTab.id) return null;
						return "tab-item-" + focusedTab.id
					}

					function shouldStretchTabs()
					{
						switch (ctrl.stretchTabs)
						{
						case "always":
							return true;
						case "never":
							return false;
						default:
							return !ctrl.shouldPaginate && $window.matchMedia("(max-width: 600px)").matches
						}
					}

					function shouldCenterTabs()
					{
						return ctrl.centerTabs && !ctrl.shouldPaginate
					}

					function shouldPaginate()
					{
						if (ctrl.noPagination || !loaded) return false;
						var canvasWidth = $element.prop("clientWidth");
						angular.forEach(getElements().tabs, function (tab)
						{
							canvasWidth -= tab.offsetWidth
						});
						return canvasWidth < 0
					}

					function getNearestSafeIndex(newIndex)
					{
						if (-1 === newIndex) return -1;
						var i, tab, maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex);
						for (i = 0; i <= maxOffset; i++)
						{
							tab = ctrl.tabs[newIndex + i];
							if (tab && true !== tab.scope.disabled) return tab.getIndex();
							tab = ctrl.tabs[newIndex - i];
							if (tab && true !== tab.scope.disabled) return tab.getIndex()
						}
						return newIndex
					}

					function defineProperty(key, handler, value)
					{
						Object.defineProperty(ctrl, key,
						{
							get: function ()
							{
								return value
							},
							set: function (newValue)
							{
								var oldValue = value;
								value = newValue;
								handler && handler(newValue, oldValue)
							}
						})
					}

					function updatePagination()
					{
						ctrl.maxTabWidth = getMaxTabWidth();
						ctrl.shouldPaginate = shouldPaginate()
					}

					function calcTabsWidth(tabs)
					{
						var width = 0;
						angular.forEach(tabs, function (tab)
						{
							width += Math.max(tab.offsetWidth, tab.getBoundingClientRect().width)
						});
						return Math.ceil(width)
					}

					function getMaxTabWidth()
					{
						var elements = getElements(),
							containerWidth = elements.canvas.clientWidth,
							specMax = 264;
						return Math.max(0, Math.min(containerWidth - 1, specMax))
					}

					function updateTabOrder()
					{
						var selectedItem = ctrl.tabs[ctrl.selectedIndex],
							focusItem = ctrl.tabs[ctrl.focusIndex];
						ctrl.tabs = ctrl.tabs.sort(function (a, b)
						{
							return a.index - b.index
						});
						ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem);
						ctrl.focusIndex = ctrl.tabs.indexOf(focusItem)
					}

					function incrementIndex(inc, focus)
					{
						var newIndex, key = focus ? "focusIndex" : "selectedIndex",
							index = ctrl[key];
						for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc);
						newIndex = (index + inc + ctrl.tabs.length) % ctrl.tabs.length;
						ctrl.tabs[newIndex] && (ctrl[key] = newIndex)
					}

					function redirectFocus()
					{
						ctrl.styleTabItemFocus = "keyboard" === $mdInteraction.getLastInteractionType();
						getElements().tabs[ctrl.focusIndex].focus()
					}

					function adjustOffset(index)
					{
						var elements = getElements();
						angular.isNumber(index) || (index = ctrl.focusIndex);
						if (!elements.tabs[index]) return;
						if (ctrl.shouldCenterTabs) return;
						var tab = elements.tabs[index],
							left = tab.offsetLeft,
							right = tab.offsetWidth + left,
							extraOffset = 32;
						if (0 == index)
						{
							ctrl.offsetLeft = 0;
							return
						}
						if (isRtl())
						{
							var tabWidthsBefore = calcTabsWidth(Array.prototype.slice.call(elements.tabs, 0, index));
							var tabWidthsIncluding = calcTabsWidth(Array.prototype.slice.call(elements.tabs, 0, index + 1));
							ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(tabWidthsBefore));
							ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(tabWidthsIncluding - elements.canvas.clientWidth))
						}
						else
						{
							ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + extraOffset));
							ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left))
						}
					}

					function processQueue()
					{
						queue.forEach(function (func)
						{
							$mdUtil.nextTick(func)
						});
						queue = []
					}

					function updateHasContent()
					{
						var hasContent = false;
						for (var i = 0; i < ctrl.tabs.length; i++)
							if (ctrl.tabs[i].hasContent)
							{
								hasContent = true;
								break
							}
						ctrl.hasContent = hasContent
					}

					function refreshIndex()
					{
						ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex);
						ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex)
					}

					function updateHeightFromContent()
					{
						if (!ctrl.dynamicHeight) return $element.css("height", "");
						if (!ctrl.tabs.length) return queue.push(updateHeightFromContent);
						var elements = getElements();
						var tabContent = elements.contents[ctrl.selectedIndex],
							contentHeight = tabContent ? tabContent.offsetHeight : 0,
							tabsHeight = elements.wrapper.offsetHeight,
							newHeight = contentHeight + tabsHeight,
							currentHeight = $element.prop("clientHeight");
						if (currentHeight === newHeight) return;
						if ("bottom" === $element.attr("md-align-tabs"))
						{
							currentHeight -= tabsHeight;
							newHeight -= tabsHeight;
							$element.attr("md-border-bottom") !== undefined && ++currentHeight
						}
						locked = true;
						var fromHeight = {
								height: currentHeight + "px"
							},
							toHeight = {
								height: newHeight + "px"
							};
						$element.css(fromHeight);
						$animateCss($element,
						{
							from: fromHeight,
							to: toHeight,
							easing: "cubic-bezier(0.35, 0, 0.25, 1)",
							duration: .5
						}).start().done(function ()
						{
							$element.css(
							{
								transition: "none",
								height: ""
							});
							$mdUtil.nextTick(function ()
							{
								$element.css("transition", "")
							});
							locked = false
						})
					}

					function updateInkBarStyles()
					{
						var elements = getElements();
						if (!elements.tabs[ctrl.selectedIndex])
						{
							angular.element(elements.inkBar).css(
							{
								left: "auto",
								right: "auto"
							});
							return
						}
						if (!ctrl.tabs.length) return queue.push(ctrl.updateInkBarStyles);
						if (!$element.prop("offsetParent")) return handleResizeWhenVisible();
						var index = ctrl.selectedIndex,
							totalWidth = elements.paging.offsetWidth,
							tab = elements.tabs[index],
							left = tab.offsetLeft,
							right = totalWidth - left - tab.offsetWidth;
						if (ctrl.shouldCenterTabs)
						{
							var tabWidth = calcTabsWidth(elements.tabs);
							totalWidth > tabWidth && $mdUtil.nextTick(updateInkBarStyles, false)
						}
						updateInkBarClassName();
						angular.element(elements.inkBar).css(
						{
							left: left + "px",
							right: right + "px"
						})
					}

					function updateInkBarClassName()
					{
						var elements = getElements();
						var newIndex = ctrl.selectedIndex,
							oldIndex = ctrl.lastSelectedIndex,
							ink = angular.element(elements.inkBar);
						if (!angular.isNumber(oldIndex)) return;
						ink.toggleClass("md-left", newIndex < oldIndex).toggleClass("md-right", newIndex > oldIndex)
					}

					function fixOffset(value)
					{
						var elements = getElements();
						if (!elements.tabs.length || !ctrl.shouldPaginate) return 0;
						var lastTab = elements.tabs[elements.tabs.length - 1],
							totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
						if (isRtl())
						{
							value = Math.min(elements.paging.offsetWidth - elements.canvas.clientWidth, value);
							value = Math.max(0, value)
						}
						else
						{
							value = Math.max(0, value);
							value = Math.min(totalWidth - elements.canvas.clientWidth, value)
						}
						return value
					}

					function attachRipple(scope, element)
					{
						var elements = getElements();
						var options = {
							colorElement: angular.element(elements.inkBar)
						};
						$mdTabInkRipple.attach(scope, element, options)
					}

					function setAriaControls(tab)
					{
						if (tab.hasContent)
						{
							var nodes = $element[0].querySelectorAll('[md-tab-id="' + tab.id + '"]');
							angular.element(nodes).attr("aria-controls", ctrl.tabContentPrefix + tab.id)
						}
					}

					function isRtl()
					{
						return "rtl" == $mdUtil.bidi()
					}
				}
			})();
			(function ()
			{
				MdTabs.$inject = ["$$mdSvgRegistry"];
				angular.module("material.components.tabs").directive("mdTabs", MdTabs);

				function MdTabs($$mdSvgRegistry)
				{
					return {
						scope:
						{
							selectedIndex: "=?mdSelected"
						},
						template: function (element, attr)
						{
							attr.$mdTabsTemplate = element.html();
							return '<md-tabs-wrapper> <md-tab-data></md-tab-data> <md-prev-button tabindex="-1" role="button" aria-label="Previous Page" aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.previousPage()"> <md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon> </md-prev-button> <md-next-button tabindex="-1" role="button" aria-label="Next Page" aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.nextPage()"> <md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon> </md-next-button> <md-tabs-canvas ng-focus="$mdTabsCtrl.redirectFocus()" ng-class="{ \'md-paginated\': $mdTabsCtrl.shouldPaginate, \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ng-keydown="$mdTabsCtrl.keydown($event)"> <md-pagination-wrapper ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" md-tab-scroll="$mdTabsCtrl.scroll($event)" role="tablist"> <md-tab-item tabindex="{{ tab.isActive() ? 0 : -1 }}" class="md-tab" ng-repeat="tab in $mdTabsCtrl.tabs" role="tab" id="tab-item-{{::tab.id}}" md-tab-id="{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-click="$mdTabsCtrl.select(tab.getIndex())" ng-focus="$mdTabsCtrl.hasFocus = true" ng-blur="$mdTabsCtrl.hasFocus = false" ng-class="{ \'md-active\':    tab.isActive(), \'md-focused\':   tab.hasFocus(), \'md-disabled\':  tab.scope.disabled }" ng-disabled="tab.scope.disabled" md-swipe-left="$mdTabsCtrl.nextPage()" md-swipe-right="$mdTabsCtrl.previousPage()" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-tab-item> <md-ink-bar></md-ink-bar> </md-pagination-wrapper> <md-tabs-dummy-wrapper aria-hidden="true" class="md-visually-hidden md-dummy-wrapper"> <md-dummy-tab class="md-tab" tabindex="-1" ng-repeat="tab in $mdTabsCtrl.tabs" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-dummy-tab> </md-tabs-dummy-wrapper> </md-tabs-canvas> </md-tabs-wrapper> <md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0" class="_md"> <md-tab-content id="{{:: $mdTabsCtrl.tabContentPrefix + tab.id}}" class="_md" role="tabpanel" aria-labelledby="tab-item-{{::tab.id}}" md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ng-if="tab.hasContent" ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ng-class="{ \'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, \'md-active\':        tab.isActive(), \'md-left\':          tab.isLeft(), \'md-right\':         tab.isRight(), \'md-no-scroll\':     $mdTabsCtrl.dynamicHeight }"> <div md-tabs-template="::tab.template" md-connected-if="tab.isActive()" md-scope="::tab.parent" ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> </md-tab-content> </md-tabs-content-wrapper>'
						},
						controller: "MdTabsController",
						controllerAs: "$mdTabsCtrl",
						bindToController: true
					}
				}
			})();
			(function ()
			{
				MdTabsDummyWrapper.$inject = ["$mdUtil", "$window"];
				angular.module("material.components.tabs").directive("mdTabsDummyWrapper", MdTabsDummyWrapper);

				function MdTabsDummyWrapper($mdUtil, $window)
				{
					return {
						require: "^?mdTabs",
						link: function link(scope, element, attr, ctrl)
						{
							if (!ctrl) return;
							var observer;
							var disconnect;
							var mutationCallback = function ()
							{
								ctrl.updatePagination();
								ctrl.updateInkBarStyles()
							};
							if ("MutationObserver" in $window)
							{
								var config = {
									childList: true,
									subtree: true,
									characterData: true
								};
								observer = new MutationObserver(mutationCallback);
								observer.observe(element[0], config);
								disconnect = observer.disconnect.bind(observer)
							}
							else
							{
								var debounced = $mdUtil.debounce(mutationCallback, 15, null, false);
								element.on("DOMSubtreeModified", debounced);
								disconnect = element.off.bind(element, "DOMSubtreeModified", debounced)
							}
							scope.$on("$destroy", function ()
							{
								disconnect()
							})
						}
					}
				}
			})();
			(function ()
			{
				MdTabsTemplate.$inject = ["$compile", "$mdUtil"];
				angular.module("material.components.tabs").directive("mdTabsTemplate", MdTabsTemplate);

				function MdTabsTemplate($compile, $mdUtil)
				{
					return {
						restrict: "A",
						link: link,
						scope:
						{
							template: "=mdTabsTemplate",
							connected: "=?mdConnectedIf",
							compileScope: "=mdScope"
						},
						require: "^?mdTabs"
					};

					function link(scope, element, attr, ctrl)
					{
						if (!ctrl) return;
						var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;
						element.html(scope.template);
						$compile(element.contents())(compileScope);
						return $mdUtil.nextTick(handleScope);

						function handleScope()
						{
							scope.$watch("connected", function (value)
							{
								false === value ? disconnect() : reconnect()
							});
							scope.$on("$destroy", reconnect)
						}

						function disconnect()
						{
							ctrl.enableDisconnect && $mdUtil.disconnectScope(compileScope)
						}

						function reconnect()
						{
							ctrl.enableDisconnect && $mdUtil.reconnectScope(compileScope)
						}
					}
				}
			})();
			void angular.module("material.core").constant("$MD_THEME_CSS", 'md-autocomplete.md-THEME_NAME-theme{background:"{{background-hue-1}}"}md-autocomplete.md-THEME_NAME-theme[disabled]:not([md-floating-label]){background:"{{background-hue-2}}"}md-autocomplete.md-THEME_NAME-theme button md-icon path{fill:"{{background-600}}"}md-autocomplete.md-THEME_NAME-theme button:after{background:"{{background-600-0.3}}"}md-autocomplete.md-THEME_NAME-theme input{color:"{{foreground-1}}"}.md-autocomplete-suggestions-container.md-THEME_NAME-theme{background:"{{background-hue-1}}"}.md-autocomplete-suggestions-container.md-THEME_NAME-theme li{color:"{{foreground-1}}"}.md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected,.md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover{background:"{{background-500-0.18}}"}md-backdrop{background-color:"{{background-900-0.0}}"}md-backdrop.md-opaque.md-THEME_NAME-theme{background-color:"{{background-900-1.0}}"}md-bottom-sheet.md-THEME_NAME-theme{background-color:"{{background-50}}";border-top-color:"{{background-300}}"}md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item{color:"{{foreground-1}}"}md-bottom-sheet.md-THEME_NAME-theme .md-subheader{background-color:"{{background-50}}";color:"{{foreground-1}}"}.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]):hover{background-color:"{{background-500-0.2}}"}.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover{background-color:transparent}.md-button.md-THEME_NAME-theme.md-fab md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab,.md-button.md-THEME_NAME-theme.md-primary.md-raised{color:"{{primary-contrast}}";background-color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon{color:"{{primary-contrast}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover{background-color:"{{primary-600}}"}.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon{color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-fab{background-color:"{{accent-color}}";color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover{background-color:"{{accent-A700}}"}.md-button.md-THEME_NAME-theme.md-raised{color:"{{background-900}}";background-color:"{{background-50}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon{color:"{{background-900}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover{background-color:"{{background-50}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused{background-color:"{{background-200}}"}.md-button.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab,.md-button.md-THEME_NAME-theme.md-warn.md-raised{color:"{{warn-contrast}}";background-color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon{color:"{{warn-contrast}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover{background-color:"{{warn-600}}"}.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon{color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab,.md-button.md-THEME_NAME-theme.md-accent.md-raised{color:"{{accent-contrast}}";background-color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover{background-color:"{{accent-A700}}"}.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon{color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled]{color:"{{foreground-3}}";cursor:default}.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,.md-button.md-THEME_NAME-theme[disabled] md-icon{color:"{{foreground-3}}"}.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled]{background-color:"{{foreground-4}}"}.md-button.md-THEME_NAME-theme[disabled]{background-color:transparent}._md a.md-THEME_NAME-theme:not(.md-button).md-primary{color:"{{primary-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-primary:hover{color:"{{primary-700}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent{color:"{{accent-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent:hover{color:"{{accent-A700}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn{color:"{{warn-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn:hover{color:"{{warn-700}}"}md-card.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-hue-1}}";border-radius:2px}md-card.md-THEME_NAME-theme .md-card-image{border-radius:2px 2px 0 0}md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon{color:"{{background-color}}";background-color:"{{foreground-3}}"}md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead,md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme .md-ripple{color:"{{accent-A700}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple{color:"{{background-600}}"}md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before{background-color:"{{accent-color-0.26}}"}md-checkbox.md-THEME_NAME-theme .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon{background-color:"{{accent-color-0.87}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after{border-color:"{{accent-contrast-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple{color:"{{primary-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple{color:"{{background-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple{color:"{{primary-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon{background-color:"{{primary-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before{background-color:"{{primary-color-0.26}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after{border-color:"{{primary-contrast-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] .md-container{color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple{color:"{{warn-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple{color:"{{warn-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon{background-color:"{{warn-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before{background-color:"{{warn-color-0.26}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after{border-color:"{{background-200}}"}md-checkbox.md-THEME_NAME-theme[disabled]:not(.md-checked) .md-icon{border-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon{background-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after{border-color:"{{background-200}}"}md-checkbox.md-THEME_NAME-theme[disabled] .md-icon:after{border-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled] .md-label{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips{box-shadow:0 1px "{{foreground-4}}"}md-chips.md-THEME_NAME-theme .md-chips.md-focused{box-shadow:0 2px "{{primary-color}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input{color:"{{foreground-1}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-moz-placeholder,md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-moz-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-ms-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-webkit-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme md-chip{background:"{{background-300}}";color:"{{background-800}}"}md-chips.md-THEME_NAME-theme md-chip md-icon{color:"{{background-700}}"}md-chips.md-THEME_NAME-theme md-chip.md-focused{background:"{{primary-color}}";color:"{{primary-contrast}}"}md-chips.md-THEME_NAME-theme md-chip.md-focused md-icon{color:"{{primary-contrast}}"}md-chips.md-THEME_NAME-theme md-chip._md-chip-editing{background:transparent;color:"{{background-800}}"}md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path{fill:"{{background-500}}"}.md-contact-suggestion span.md-contact-email{color:"{{background-400}}"}md-content.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-default}}"}.md-THEME_NAME-theme .md-calendar{background:"{{background-hue-1}}";color:"{{foreground-1-0.87}}"}.md-THEME_NAME-theme .md-calendar tr:last-child td{border-bottom-color:"{{background-hue-2}}"}.md-THEME_NAME-theme .md-calendar-day-header{background:"{{background-500-0.32}}";color:"{{foreground-1-0.87}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator{border:1px solid "{{primary-500}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled{color:"{{primary-500-0.6}}"}.md-calendar-date.md-focus .md-THEME_NAME-theme .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover{background:"{{background-500-0.32}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator{background:"{{primary-500}}";color:"{{primary-500-contrast}}";border-color:transparent}.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-calendar-month-label md-icon,.md-THEME_NAME-theme .md-datepicker-input{color:"{{foreground-1}}"}.md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder,.md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input-container{border-bottom-color:"{{foreground-4}}"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{primary-color}}"}.md-accent .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{accent-color}}"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid,.md-warn .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{warn-A700}}"}.md-THEME_NAME-theme .md-datepicker-calendar-pane{border-color:"{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle{border-top-color:"{{foreground-2}}"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:"{{primary-color}}"}.md-accent .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon,.md-THEME_NAME-theme .md-datepicker-open.md-accent .md-datepicker-calendar-icon{color:"{{accent-color}}"}.md-THEME_NAME-theme .md-datepicker-open.md-warn .md-datepicker-calendar-icon,.md-warn .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:"{{warn-A700}}"}.md-THEME_NAME-theme .md-datepicker-calendar{background:"{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-input-mask-opaque{box-shadow:0 0 0 9999px "{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-input-container{background:"{{background-hue-1}}"}md-dialog.md-THEME_NAME-theme{border-radius:4px;background-color:"{{background-hue-1}}";color:"{{foreground-1}}"}md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions,md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions,md-divider.md-THEME_NAME-theme{border-top-color:"{{foreground-4}}"}.layout-gt-lg-row>md-divider.md-THEME_NAME-theme,.layout-gt-md-row>md-divider.md-THEME_NAME-theme,.layout-gt-sm-row>md-divider.md-THEME_NAME-theme,.layout-gt-xs-row>md-divider.md-THEME_NAME-theme,.layout-lg-row>md-divider.md-THEME_NAME-theme,.layout-md-row>md-divider.md-THEME_NAME-theme,.layout-row>md-divider.md-THEME_NAME-theme,.layout-sm-row>md-divider.md-THEME_NAME-theme,.layout-xl-row>md-divider.md-THEME_NAME-theme,.layout-xs-row>md-divider.md-THEME_NAME-theme{border-right-color:"{{foreground-4}}"}md-icon.md-THEME_NAME-theme{color:"{{foreground-2}}"}md-icon.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}md-icon.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}md-icon.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}md-input-container.md-THEME_NAME-theme .md-input{color:"{{foreground-1}}";border-color:"{{foreground-4}}"}md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder{color:"{{foreground-3}}"}md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder{color:"{{foreground-3}}"}md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder{color:"{{foreground-3}}"}md-input-container.md-THEME_NAME-theme>md-icon{color:"{{foreground-1}}"}md-input-container.md-THEME_NAME-theme .md-placeholder,md-input-container.md-THEME_NAME-theme label{color:"{{foreground-3}}"}md-input-container.md-THEME_NAME-theme label.md-required:after{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-focused):not(.md-input-invalid) label.md-required:after{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme .md-input-message-animation,md-input-container.md-THEME_NAME-theme .md-input-messages-animation{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme .md-input-message-animation .md-char-counter,md-input-container.md-THEME_NAME-theme .md-input-messages-animation .md-char-counter{color:"{{foreground-1}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-moz-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-ms-input-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-webkit-input-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-resized .md-input{border-color:"{{primary-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon{color:"{{primary-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input{border-color:"{{accent-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent md-icon{color:"{{accent-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input{border-color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn md-icon{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input{border-color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter,md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input-message-animation,md-input-container.md-THEME_NAME-theme.md-input-invalid label{color:"{{warn-A700}}"}[disabled] md-input-container.md-THEME_NAME-theme .md-input,md-input-container.md-THEME_NAME-theme .md-input[disabled]{border-bottom-color:transparent;color:"{{foreground-3}}";background-image:linear-gradient(90deg,"{{foreground-3}}" 0,"{{foreground-3}}" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,"{{foreground-3}}" 100%)}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4{color:"{{foreground-1}}"}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p{color:"{{foreground-2}}"}md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style{background-color:"{{background-100}}"}md-list.md-THEME_NAME-theme md-list-item .md-avatar-icon{background-color:"{{foreground-3}}";color:"{{background-color}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon{color:"{{foreground-2}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight{color:"{{primary-color}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight.md-accent{color:"{{accent-color}}"}md-menu-content.md-THEME_NAME-theme{background-color:"{{background-hue-1}}"}md-menu-content.md-THEME_NAME-theme md-menu-item{color:"{{foreground-1}}"}md-menu-content.md-THEME_NAME-theme md-menu-item md-icon{color:"{{foreground-2}}"}md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled],md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] md-icon{color:"{{foreground-3}}"}md-menu-content.md-THEME_NAME-theme md-menu-divider{background-color:"{{foreground-4}}"}md-menu-bar.md-THEME_NAME-theme>button.md-button{color:"{{foreground-1}}";border-radius:2px}md-menu-bar.md-THEME_NAME-theme md-menu>button{color:"{{foreground-1}}"}md-menu-bar.md-THEME_NAME-theme md-menu.md-open>button,md-menu-bar.md-THEME_NAME-theme md-menu>button:focus{outline:none;background-color:"{{ background-500-0.18}}"}md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover>button{background-color:"{{ background-500-0.18}}"}md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover{background:transparent}md-menu-content.md-THEME_NAME-theme .md-menu>.md-button:after{color:"{{foreground-2}}"}md-menu-content.md-THEME_NAME-theme .md-menu.md-open>.md-button{background-color:"{{ background-500-0.18}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar{background-color:"{{background-hue-1}}";color:"{{foreground-1}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler{background-color:"{{primary-color}}";color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon{color:"{{primary-contrast}}"}md-nav-bar.md-THEME_NAME-theme .md-nav-bar{background-color:transparent;border-color:"{{foreground-4}}"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button.md-unselected{color:"{{foreground-2}}"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button[disabled]{color:"{{foreground-3}}"}md-nav-bar.md-THEME_NAME-theme md-nav-ink-bar{color:"{{accent-color}}";background:"{{accent-color}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar{background-color:"{{accent-color}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button{color:"{{accent-A100}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{accent-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{accent-contrast-0.1}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar md-nav-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar{background-color:"{{warn-color}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button{color:"{{warn-100}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{warn-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{warn-contrast-0.1}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar{background-color:"{{primary-color}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button{color:"{{primary-100}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{primary-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{primary-color}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{primary-100}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{primary-contrast}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{accent-color}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{accent-A100}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{accent-contrast}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{accent-contrast-0.1}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar md-nav-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{warn-color}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{warn-100}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{warn-contrast}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{warn-contrast-0.1}}"}._md-panel-backdrop.md-THEME_NAME-theme{background-color:"{{background-900-1.0}}"}md-progress-circular.md-THEME_NAME-theme path{stroke:"{{primary-color}}"}md-progress-circular.md-THEME_NAME-theme.md-warn path{stroke:"{{warn-color}}"}md-progress-circular.md-THEME_NAME-theme.md-accent path{stroke:"{{accent-color}}"}md-progress-linear.md-THEME_NAME-theme .md-container{background-color:"{{primary-100}}"}md-progress-linear.md-THEME_NAME-theme .md-bar{background-color:"{{primary-color}}"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-container{background-color:"{{warn-100}}"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar{background-color:"{{warn-color}}"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-container{background-color:"{{accent-100}}"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar{background-color:"{{accent-color}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-bar1{background-color:"{{primary-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-dashed:before{background:radial-gradient("{{primary-100}}" 0,"{{primary-100}}" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1{background-color:"{{warn-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before{background:radial-gradient("{{warn-100}}" 0,"{{warn-100}}" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1{background-color:"{{accent-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before{background:radial-gradient("{{accent-100}}" 0,"{{accent-100}}" 16%,transparent 42%)}md-radio-button.md-THEME_NAME-theme .md-off{border-color:"{{foreground-2}}"}md-radio-button.md-THEME_NAME-theme .md-on{background-color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme.md-checked .md-off{border-color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme .md-container .md-ripple{color:"{{accent-A700}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on{background-color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off{border-color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple{color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple{color:"{{primary-600}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on{background-color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off{border-color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple{color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple{color:"{{warn-600}}"}md-radio-button.md-THEME_NAME-theme[disabled],md-radio-group.md-THEME_NAME-theme[disabled]{color:"{{foreground-3}}"}md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on{border-color:"{{foreground-3}}"}md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple{color:"{{accent-color-0.26}}"}md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple,md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple{color:"{{primary-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before{background-color:"{{accent-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before{background-color:"{{primary-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before{background-color:"{{warn-color-0.26}}"}md-input-container md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{warn-A700}}"}md-input-container:not(.md-input-focused):not(.md-input-invalid) md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{foreground-3}}"}md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value,md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:"{{primary-color}}"}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme .md-select-value{color:"{{warn-A700}}"!important;border-bottom-color:"{{warn-A700}}"!important}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme[disabled] .md-select-value{border-bottom-color:transparent;background-image:linear-gradient(90deg,"{{foreground-3}}" 0,"{{foreground-3}}" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,"{{foreground-3}}" 100%)}md-select.md-THEME_NAME-theme .md-select-value{border-bottom-color:"{{foreground-4}}"}md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:"{{foreground-3}}"}md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{warn-A700}}"}md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched .md-select-value{color:"{{warn-A700}}"!important;border-bottom-color:"{{warn-A700}}"!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value{border-bottom-color:"{{primary-color}}";color:"{{ foreground-1 }}"}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder{color:"{{ foreground-1 }}"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value{border-bottom-color:"{{accent-color}}"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value{border-bottom-color:"{{warn-color}}"}md-select.md-THEME_NAME-theme[disabled] .md-select-icon,md-select.md-THEME_NAME-theme[disabled] .md-select-value,md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder{color:"{{foreground-3}}"}md-select.md-THEME_NAME-theme .md-select-icon{color:"{{foreground-2}}"}md-select-menu.md-THEME_NAME-theme md-content{background-color:"{{background-hue-1}}"}md-select-menu.md-THEME_NAME-theme md-content md-optgroup{color:"{{foreground-2}}"}md-select-menu.md-THEME_NAME-theme md-content md-option{color:"{{foreground-1}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[disabled] .md-text{color:"{{foreground-3}}"}md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):focus,md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):hover{background-color:"{{background-500-0.18}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]{color:"{{primary-500}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]:focus{color:"{{primary-600}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent{color:"{{accent-color}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent:focus{color:"{{accent-A700}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ripple{color:"{{primary-600}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ripple{color:"{{background-600}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ink-ripple{color:"{{foreground-2}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ink-ripple{color:"{{primary-color-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon{background-color:"{{primary-color-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected].md-focused .md-container:before{background-color:"{{primary-color-0.26}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon:after{border-color:"{{primary-contrast-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-indeterminate[disabled] .md-container{color:"{{foreground-3}}"}.md-checkbox-enabled.md-THEME_NAME-theme md-option .md-text{color:"{{foreground-1}}"}md-sidenav.md-THEME_NAME-theme,md-sidenav.md-THEME_NAME-theme md-content{background-color:"{{background-hue-1}}"}md-slider.md-THEME_NAME-theme .md-track{background-color:"{{foreground-3}}"}md-slider.md-THEME_NAME-theme .md-track-ticks{color:"{{background-contrast}}"}md-slider.md-THEME_NAME-theme .md-focus-ring{background-color:"{{accent-A200-0.2}}"}md-slider.md-THEME_NAME-theme .md-disabled-thumb{border-color:"{{background-color}}";background-color:"{{background-color}}"}md-slider.md-THEME_NAME-theme.md-min .md-thumb:after{background-color:"{{background-color}}";border-color:"{{foreground-3}}"}md-slider.md-THEME_NAME-theme.md-min .md-focus-ring{background-color:"{{foreground-3-0.38}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-thumb:after{background-color:"{{background-contrast}}";border-color:transparent}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign{background-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign:after{border-top-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete][md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme .md-track.md-track-fill{background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-thumb:after{border-color:"{{accent-color}}";background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-sign{background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-sign:after{border-top-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-thumb-text{color:"{{accent-contrast}}"}md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring{background-color:"{{warn-200-0.38}}"}md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill{background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after{border-color:"{{warn-color}}";background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-sign{background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-sign:after{border-top-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text{color:"{{warn-contrast}}"}md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring{background-color:"{{primary-200-0.38}}"}md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill{background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after{border-color:"{{primary-color}}";background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-sign{background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-sign:after{border-top-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text{color:"{{primary-contrast}}"}md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after{border-color:transparent}md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after,md-slider.md-THEME_NAME-theme[disabled][md-discrete] .md-thumb:after{background-color:"{{foreground-3}}";border-color:transparent}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign{background-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign:after{border-top-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly][md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-disabled-thumb{border-color:transparent;background-color:transparent}md-slider-container[disabled]>:first-child:not(md-slider),md-slider-container[disabled]>:last-child:not(md-slider){color:"{{foreground-3}}"}.md-subheader.md-THEME_NAME-theme{color:"{{ foreground-2-0.23 }}";background-color:"{{background-default}}"}.md-subheader.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}.md-subheader.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}.md-subheader.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme .md-ink-ripple{color:"{{background-500}}"}md-switch.md-THEME_NAME-theme .md-thumb{background-color:"{{background-50}}"}md-switch.md-THEME_NAME-theme .md-bar{background-color:"{{background-500}}"}md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color}}"}md-switch.md-THEME_NAME-theme.md-checked .md-thumb{background-color:"{{accent-color}}"}md-switch.md-THEME_NAME-theme.md-checked .md-bar{background-color:"{{accent-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before{background-color:"{{accent-color-0.26}}"}md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple{color:"{{primary-color}}"}md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb{background-color:"{{primary-color}}"}md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar{background-color:"{{primary-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before{background-color:"{{primary-color-0.26}}"}md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple{color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb{background-color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar{background-color:"{{warn-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before{background-color:"{{warn-color-0.26}}"}md-switch.md-THEME_NAME-theme[disabled] .md-thumb{background-color:"{{background-400}}"}md-switch.md-THEME_NAME-theme[disabled] .md-bar{background-color:"{{foreground-4}}"}md-tabs.md-THEME_NAME-theme md-tabs-wrapper{background-color:transparent;border-color:"{{foreground-4}}"}md-tabs.md-THEME_NAME-theme .md-paginator md-icon{color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme md-ink-bar{color:"{{accent-color}}";background:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme .md-tab{color:"{{foreground-2}}"}md-tabs.md-THEME_NAME-theme .md-tab[disabled],md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon{color:"{{foreground-3}}"}md-tabs.md-THEME_NAME-theme .md-tab.md-active,md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon,md-tabs.md-THEME_NAME-theme .md-tab.md-focused,md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon{color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme .md-tab.md-focused{background:"{{primary-color-0.1}}"}md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container{color:"{{accent-A100}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper{background-color:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{accent-A100}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{accent-contrast}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{accent-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper{background-color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{primary-100}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{primary-contrast}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{primary-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper{background-color:"{{warn-color}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{warn-100}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{warn-contrast}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{warn-contrast-0.1}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{primary-color}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{primary-100}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{primary-contrast}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{accent-color}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{accent-A100}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{accent-contrast}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{accent-contrast-0.1}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{warn-color}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{warn-100}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{warn-contrast}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{warn-contrast-0.1}}"}md-toast.md-THEME_NAME-theme .md-toast-content{background-color:#323232;color:"{{background-50}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button{color:"{{background-50}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight{color:"{{accent-color}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-primary{color:"{{primary-color}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn{color:"{{warn-color}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar){background-color:"{{primary-color}}";color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon{color:"{{primary-contrast}}";fill:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button[disabled] md-icon{color:"{{primary-contrast-0.26}}";fill:"{{primary-contrast-0.26}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent{background-color:"{{accent-color}}";color:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-ink-ripple{color:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-icon{color:"{{accent-contrast}}";fill:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-button[disabled] md-icon{color:"{{accent-contrast-0.26}}";fill:"{{accent-contrast-0.26}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn{background-color:"{{warn-color}}";color:"{{warn-contrast}}"}.md-panel.md-tooltip.md-THEME_NAME-theme{color:"{{background-700-contrast}}";background-color:"{{background-700}}"}body.md-THEME_NAME-theme,html.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-color}}"}')
		})(window, window.angular);
		window.ngMaterial = {
			version:
			{
				full: "1.1.10"
			}
		}
	},
	5243: function (module, exports)
	{
		/**
		 * @license AngularJS v1.6.5
		 * (c) 2010-2017 Google, Inc. http://angularjs.org
		 * License: MIT
		 */
		(function (window, angular)
		{
			"use strict";
			angular.module("ngCookies", ["ng"]).info(
			{
				angularVersion: "1.6.5"
			}).provider("$cookies", [function $CookiesProvider()
			{
				var defaults = this.defaults = {};

				function calcOptions(options)
				{
					return options ? angular.extend(
					{}, defaults, options) : defaults
				}
				this.$get = ["$$cookieReader", "$$cookieWriter", function ($$cookieReader, $$cookieWriter)
				{
					return {
						get: function (key)
						{
							return $$cookieReader()[key]
						},
						getObject: function (key)
						{
							var value = this.get(key);
							return value ? angular.fromJson(value) : value
						},
						getAll: function ()
						{
							return $$cookieReader()
						},
						put: function (key, value, options)
						{
							$$cookieWriter(key, value, calcOptions(options))
						},
						putObject: function (key, value, options)
						{
							this.put(key, angular.toJson(value), options)
						},
						remove: function (key, options)
						{
							$$cookieWriter(key, void 0, calcOptions(options))
						}
					}
				}]
			}]);
			angular.module("ngCookies").factory("$cookieStore", ["$cookies", function ($cookies)
			{
				return {
					get: function (key)
					{
						return $cookies.getObject(key)
					},
					put: function (key, value)
					{
						$cookies.putObject(key, value)
					},
					remove: function (key)
					{
						$cookies.remove(key)
					}
				}
			}]);

			function $$CookieWriter($document, $log, $browser)
			{
				var cookiePath = $browser.baseHref();
				var rawDocument = $document[0];

				function buildCookieString(name, value, options)
				{
					var path, expires;
					options = options ||
					{};
					expires = options.expires;
					path = angular.isDefined(options.path) ? options.path : cookiePath;
					if (angular.isUndefined(value))
					{
						expires = "Thu, 01 Jan 1970 00:00:00 GMT";
						value = ""
					}
					angular.isString(expires) && (expires = new Date(expires));
					var str = encodeURIComponent(name) + "=" + encodeURIComponent(value);
					str += path ? ";path=" + path : "";
					str += options.domain ? ";domain=" + options.domain : "";
					str += expires ? ";expires=" + expires.toUTCString() : "";
					str += options.secure ? ";secure" : "";
					var cookieLength = str.length + 1;
					cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
					return str
				}
				return function (name, value, options)
				{
					rawDocument.cookie = buildCookieString(name, value, options)
				}
			}
			$$CookieWriter.$inject = ["$document", "$log", "$browser"];
			angular.module("ngCookies").provider("$$cookieWriter", function $$CookieWriterProvider()
			{
				this.$get = $$CookieWriter
			})
		})(window, window.angular)
	},
	5244: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(5245);
		__webpack_require__(5251);
		__webpack_require__(5254);
		__webpack_require__(5269);
		__webpack_require__(5271);
		__webpack_require__(5277)
	},
	5245: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _jquery = __webpack_require__(16);
		var _jquery2 = _interopRequireDefault(_jquery);
		var _modules = __webpack_require__(2);
		var _loader = __webpack_require__(5246);
		var _timefilter = __webpack_require__(27);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _toConsumableArray(arr)
		{
			if (Array.isArray(arr))
			{
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2
			}
			return Array.from(arr)
		}
		var app = _modules.uiModules.get("apps/webinar_app", []);
		app.directive("kbnVis", function ()
		{
			return {
				restrict: "E",
				scope:
				{
					visID: "=visId",
					specificTimeRange: "=specificTimeRange"
				},
				controller: function controller($scope, $rootScope, wzsavedVisualizations, errorHandler, rawVisualizations, loadedVisualizations, tabVisualizations, discoverPendingUpdates, visHandlers)
				{
					var _this = this;
					var implicitFilter = "";
					var rawFilters = [];
					var rendered = false;
					var visualization = null;
					var visHandler = null;
					var renderInProgress = false;
					var setSearchSource = function setSearchSource(discoverList)
					{
						try
						{
							if ("Wazuh-App-Overview-General-Agents-status" === $scope.visID || $scope.visID.includes("Cluster"))
							{
								var monitoringFilter = discoverList[1].filter(function (item)
								{
									return item && item.meta && item.meta.key && (item.meta.key.includes("cluster.name") || item.meta.key.includes("cluster.node"))
								});
								Array.isArray(monitoringFilter) && monitoringFilter.length && visualization.searchSource.setField("filter", monitoringFilter)
							}
							else visualization.searchSource.setField("query",
							{
								language: discoverList[0].language || "lucene",
								query: implicitFilter
							}).setField("filter", discoverList.length > 1 ? [].concat(_toConsumableArray(discoverList[1]), _toConsumableArray(rawFilters)) : rawFilters)
						}
						catch (error)
						{
							errorHandler.handle(error, "Visualize - setSearchSource")
						}
					};
					var myRender = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(raw)
					{
						var discoverList, rawVis;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								if (loader)
								{
									_context.next = 5;
									break
								}
								_context.next = 4;
								return (0, _loader.getVisualizeLoader)();
							case 4:
								loader = _context.sent;
							case 5:
								discoverList = discoverPendingUpdates.getList();
								if (!(raw && discoverList.length))
								{
									_context.next = 23;
									break
								}
								if (!(!visualization && !rendered && !renderInProgress))
								{
									_context.next = 22;
									break
								}
								renderInProgress = true;
								rawVis = raw.filter(function (item)
								{
									return item && item.id === $scope.visID
								});
								_context.next = 12;
								return wzsavedVisualizations.get($scope.visID, rawVis[0]);
							case 12:
								visualization = _context.sent;
								rawFilters = visualization.searchSource.getField("filter");
								implicitFilter = discoverList ? discoverList[0].query : "";
								setSearchSource(discoverList);
								visHandler = loader.embedVisualizationWithSavedObject((0, _jquery2.default)("[vis-id=\"'" + $scope.visID + "'\"]")[0], visualization,
								{});
								visHandler.update(
								{
									timeRange: _timefilter.timefilter.getTime()
								});
								visHandlers.addItem(visHandler);
								visHandler.addRenderCompleteListener(renderComplete);
								_context.next = 23;
								break;
							case 22:
								if (rendered)
								{
									implicitFilter = discoverList ? discoverList[0].query : "";
									visHandler.update(
									{
										timeRange: _timefilter.timefilter.getTime()
									});
									setSearchSource(discoverList)
								}
							case 23:
								_context.next = 28;
								break;
							case 25:
								_context.prev = 25;
								_context.t0 = _context["catch"](0);
							//	_context.t0 && _context.t0.message && _context.t0.message.includes("not locate that index-pattern-field") ? errorHandler.handle(_context.t0.message + ", please restart Kibana and refresh this page once done", "Visualize") : errorHandler.handle(_context.t0, "Visualize");
							case 28:
								return _context.abrupt("return");
							case 29:
							case "end":
								return _context.stop()
							}
						}, _callee, _this, [
							[0, 25]
						])
					})), function myRender(_x)
					{
						return _ref.apply(this, arguments)
					});
					var _ref;
					var updateVisWatcher = $rootScope.$on("updateVis", function ()
					{
						$rootScope.$$phase || $rootScope.$digest();
						var rawVis = rawVisualizations.getList();
						Array.isArray(rawVis) && rawVis.length && myRender(rawVis)
					});
					$scope.$on("$destroy", function ()
					{
						updateVisWatcher();
						try
						{
							visualization.destroy()
						}
						catch (error)
						{}
						try
						{
							visHandler.destroy()
						}
						catch (error)
						{}
					});
					var renderComplete = function renderComplete()
					{
						rendered = true;
						loadedVisualizations.addItem(true);
						var currentCompleted = Math.round(loadedVisualizations.getList().length / tabVisualizations.getItem(tabVisualizations.getTab()) * 100);
						$rootScope.loadingStatus = "Rendering visualizations... " + (currentCompleted > 100 ? 100 : currentCompleted) + " %";
						currentCompleted >= 100 ? $rootScope.rendered = true : "Wazuh-App-Overview-General-Agents-status" !== $scope.visID && ($rootScope.rendered = false);
						$rootScope.$$phase || $rootScope.$digest()
					};
					var loader = null
				}
			}
		})
	},
	5246: function (module, exports, __webpack_require__)
	{
		"use strict";

		function __export(m)
		{
			for (var p in m) exports.hasOwnProperty(p) || (exports[p] = m[p])
		}
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		__export(__webpack_require__(5247))
	},
	5247: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _extends = Object.assign || function (target)
		{
			for (var i = 1; i < arguments.length; i++)
			{
				var source = arguments[i];
				for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key])
			}
			return target
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		var __importDefault = (void 0, function (mod)
		{
			return mod && mod.__esModule ? mod :
			{
				default: mod
			}
		});
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var chrome_1 = __importDefault(__webpack_require__(9));
		var query_filter_1 = __webpack_require__(117);
		var embedded_visualize_handler_1 = __webpack_require__(5248);
		var VisualizeLoader = function ()
		{
			function VisualizeLoader(savedVisualizations, Private)
			{
				_classCallCheck(this, VisualizeLoader);
				this.savedVisualizations = savedVisualizations;
				this.Private = Private
			}
			_createClass(VisualizeLoader, [
			{
				key: "embedVisualizationWithId",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(element, savedVisualizationId, params)
					{
						var _this = this;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								return _context.abrupt("return", new Promise(function (resolve, reject)
								{
									_this.savedVisualizations.get(savedVisualizationId).then(function (savedObj)
									{
										var handler = _this.renderVis(element, savedObj, params);
										resolve(handler)
									}, reject)
								}));
							case 1:
							case "end":
								return _context.stop()
							}
						}, _callee, this)
					}));

					function embedVisualizationWithId(_x, _x2, _x3)
					{
						return _ref.apply(this, arguments)
					}
					return embedVisualizationWithId
				}()
			},
			{
				key: "embedVisualizationWithSavedObject",
				value: function embedVisualizationWithSavedObject(el, savedObj, params)
				{
					return this.renderVis(el, savedObj, params)
				}
			},
			{
				key: "getVisualizationList",
				value: function getVisualizationList()
				{
					return this.savedVisualizations.find().then(function (result)
					{
						return result.hits
					})
				}
			},
			{
				key: "renderVis",
				value: function renderVis(container, savedObj, params)
				{
					var vis = savedObj.vis,
						description = savedObj.description,
						searchSource = savedObj.searchSource;
					vis.description = description;
					vis.searchSource = searchSource;
					params.append || (container.innerHTML = "");
					var element = document.createElement("div");
					element.className = "visualize";
					element.setAttribute("data-test-subj", "visualizationLoader");
					container.appendChild(element);
					container.style.display = "flex";
					params.cssClass && params.cssClass.split(" ").forEach(function (cssClass)
					{
						element.classList.add(cssClass)
					});
					var dataAttrs = params.dataAttrs;
					dataAttrs && Object.keys(dataAttrs).forEach(function (key)
					{
						element.setAttribute("data-" + key, dataAttrs[key])
					});
					var handlerParams = _extends(
					{}, params,
					{
						queryFilter: this.Private(query_filter_1.FilterBarQueryFilterProvider),
						Private: this.Private
					});
					return new embedded_visualize_handler_1.EmbeddedVisualizeHandler(element, savedObj, handlerParams)
				}
			}]);
			return VisualizeLoader
		}();

		function VisualizeLoaderProvider(savedVisualizations, Private)
		{
			return new VisualizeLoader(savedVisualizations, Private)
		}
		exports.VisualizeLoaderProvider = VisualizeLoaderProvider;

		function getVisualizeLoader()
		{
			return chrome_1.default.dangerouslyGetActiveInjector().then(function ($injector)
			{
				var Private = $injector.get("Private");
				return Private(VisualizeLoaderProvider)
			})
		}
		exports.getVisualizeLoader = getVisualizeLoader
	},
	5248: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		var __importStar = (void 0, function (mod)
		{
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (null != mod)
				for (var k in mod) Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
			result["default"] = mod;
			return result
		});
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var events_1 = __webpack_require__(74);
		var lodash_1 = __webpack_require__(291);
		var Rx = __importStar(__webpack_require__(60));
		var operators_1 = __webpack_require__(105);
		var render_complete_1 = __webpack_require__(272);
		var timefilter_1 = __webpack_require__(27);
		var visualization_loader_1 = __webpack_require__(5249);
		var visualize_data_loader_1 = __webpack_require__(5250);
		var RENDER_COMPLETE_EVENT = "render_complete";
		var LOADING_ATTRIBUTE = "data-loading";
		var EmbeddedVisualizeHandler = function ()
		{
			function EmbeddedVisualizeHandler(element, savedObject, params)
			{
				var _this = this;
				_classCallCheck(this, EmbeddedVisualizeHandler);
				this.element = element;
				this.loaded = false;
				this.destroyed = false;
				this.listeners = new events_1.EventEmitter;
				this.shouldForceNextFetch = false;
				this.debouncedFetchAndRender = lodash_1.debounce(function ()
				{
					if (_this.destroyed) return;
					var forceFetch = _this.shouldForceNextFetch;
					_this.shouldForceNextFetch = false;
					_this.fetch(forceFetch).then(_this.render)
				}, 100);
				this.onRenderCompleteListener = function ()
				{
					_this.listeners.emit(RENDER_COMPLETE_EVENT);
					_this.element.removeAttribute(LOADING_ATTRIBUTE)
				};
				this.onUiStateChange = function ()
				{
					_this.fetchAndRender()
				};
				this.fetchAndRender = function ()
				{
					var forceFetch = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
					_this.shouldForceNextFetch = forceFetch || _this.shouldForceNextFetch;
					_this.element.setAttribute(LOADING_ATTRIBUTE, "");
					_this.debouncedFetchAndRender()
				};
				this.handleVisUpdate = function ()
				{
					if (_this.appState)
					{
						_this.appState.vis = _this.vis.getState();
						_this.appState.save()
					}
					_this.fetchAndRender()
				};
				this.reload = function ()
				{
					_this.fetchAndRender(true)
				};
				this.fetch = function ()
				{
					var forceFetch = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
					_this.dataLoaderParams.aggs = _this.vis.getAggConfig();
					_this.dataLoaderParams.forceFetch = forceFetch;
					return _this.dataLoader.fetch(_this.dataLoaderParams).then(function (data)
					{
						_this.dataSubject.next(data);
						return data
					})
				};
				this.render = function ()
				{
					var visData = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
					return visualization_loader_1.visualizationLoader.render(_this.element, _this.vis, visData, _this.uiState,
					{
						listenOnChange: false
					}).then(function ()
					{
						if (!_this.loaded)
						{
							_this.loaded = true;
							_this.fetchAndRender()
						}
					})
				};
				var searchSource = savedObject.searchSource,
					vis = savedObject.vis;
				var appState = params.appState,
					uiState = params.uiState,
					queryFilter = params.queryFilter,
					timeRange = params.timeRange,
					filters = params.filters,
					query = params.query,
					Private = params.Private;
				this.dataLoaderParams = {
					searchSource: searchSource,
					timeRange: timeRange,
					query: query,
					queryFilter: queryFilter,
					filters: filters,
					uiState: uiState,
					aggs: vis.getAggConfig(),
					forceFetch: false
				};
				this.firstRenderComplete = new Promise(function (resolve)
				{
					_this.listeners.once(RENDER_COMPLETE_EVENT, resolve)
				});
				element.setAttribute(LOADING_ATTRIBUTE, "");
				element.addEventListener("renderComplete", this.onRenderCompleteListener);
				this.appState = appState;
				this.vis = vis;
				uiState && vis._setUiState(uiState);
				this.uiState = this.vis.getUiState();
				this.vis.on("update", this.handleVisUpdate);
				this.vis.on("reload", this.reload);
				this.uiState.on("change", this.onUiStateChange);
				timefilter_1.timefilter.on("autoRefreshFetch", this.reload);
				this.dataLoader = new visualize_data_loader_1.VisualizeDataLoader(vis, Private);
				this.renderCompleteHelper = new render_complete_1.RenderCompleteHelper(element);
				this.dataSubject = new Rx.Subject;
				this.data$ = this.dataSubject.asObservable().pipe(operators_1.share());
				this.render()
			}
			_createClass(EmbeddedVisualizeHandler, [
			{
				key: "update",
				value: function update()
				{
					var _this2 = this;
					var params = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
					{};
					var dataAttrs = params.dataAttrs;
					dataAttrs && Object.keys(dataAttrs).forEach(function (key)
					{
						if (null === dataAttrs[key])
						{
							_this2.element.removeAttribute("data-" + key);
							return
						}
						_this2.element.setAttribute("data-" + key, dataAttrs[key])
					});
					var fetchRequired = false;
					if (params.hasOwnProperty("timeRange"))
					{
						fetchRequired = true;
						this.dataLoaderParams.timeRange = params.timeRange
					}
					if (params.hasOwnProperty("filters"))
					{
						fetchRequired = true;
						this.dataLoaderParams.filters = params.filters
					}
					if (params.hasOwnProperty("query"))
					{
						fetchRequired = true;
						this.dataLoaderParams.query = params.query
					}
					fetchRequired && this.fetchAndRender()
				}
			},
			{
				key: "destroy",
				value: function destroy()
				{
					this.destroyed = true;
					this.debouncedFetchAndRender.cancel();
					timefilter_1.timefilter.off("autoRefreshFetch", this.reload);
					this.vis.removeListener("reload", this.reload);
					this.vis.removeListener("update", this.handleVisUpdate);
					this.element.removeEventListener("renderComplete", this.onRenderCompleteListener);
					this.uiState.off("change", this.onUiStateChange);
					visualization_loader_1.visualizationLoader.destroy(this.element);
					this.renderCompleteHelper.destroy()
				}
			},
			{
				key: "getElement",
				value: function getElement()
				{
					return this.element
				}
			},
			{
				key: "openInspector",
				value: function openInspector()
				{
					return this.vis.openInspector()
				}
			},
			{
				key: "whenFirstRenderComplete",
				value: function whenFirstRenderComplete()
				{
					return this.firstRenderComplete
				}
			},
			{
				key: "addRenderCompleteListener",
				value: function addRenderCompleteListener(listener)
				{
					this.listeners.addListener(RENDER_COMPLETE_EVENT, listener)
				}
			},
			{
				key: "removeRenderCompleteListener",
				value: function removeRenderCompleteListener(listener)
				{
					this.listeners.removeListener(RENDER_COMPLETE_EVENT, listener)
				}
			}]);
			return EmbeddedVisualizeHandler
		}();
		exports.EmbeddedVisualizeHandler = EmbeddedVisualizeHandler
	},
	5249: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __importDefault = (void 0, function (mod)
		{
			return mod && mod.__esModule ? mod :
			{
				default: mod
			}
		});
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var lodash_1 = __importDefault(__webpack_require__(291));
		var react_1 = __importDefault(__webpack_require__(0));
		var react_dom_1 = __webpack_require__(17);
		var visualization_1 = __webpack_require__(1381);

		function renderVisualization(element, vis, visData, uiState, params)
		{
			return new Promise(function (resolve)
			{
				var listenOnChange = lodash_1.default.get(params, "listenOnChange", false);
				react_dom_1.render(react_1.default.createElement(visualization_1.Visualization,
				{
					vis: vis,
					visData: visData,
					uiState: uiState,
					listenOnChange: listenOnChange,
					onInit: resolve
				}), element)
			})
		}

		function destroy(element)
		{
			element && react_dom_1.unmountComponentAtNode(element)
		}
		exports.visualizationLoader = {
			render: renderVisualization,
			destroy: destroy
		}
	},
	5250: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _extends = Object.assign || function (target)
		{
			for (var i = 1; i < arguments.length; i++)
			{
				var source = arguments[i];
				for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key])
			}
			return target
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var lodash_1 = __webpack_require__(291);
		var vis_request_handlers_1 = __webpack_require__(595);
		var vis_response_handlers_1 = __webpack_require__(449);
		var elasticsearch_errors_1 = __webpack_require__(1382);
		var notify_1 = __webpack_require__(10);

		function getHandler(from, type)
		{
			if ("function" === typeof type) return type;
			var handlerDesc = from.find(function (handler)
			{
				return handler.name === type
			});
			if (!handlerDesc) throw new Error('Could not find handler "' + type + '".');
			return handlerDesc.handler
		}
		var VisualizeDataLoader = function ()
		{
			function VisualizeDataLoader(vis, Private)
			{
				_classCallCheck(this, VisualizeDataLoader);
				this.vis = vis;
				var _vis$type = vis.type,
					requestHandler = _vis$type.requestHandler,
					responseHandler = _vis$type.responseHandler;
				var requestHandlers = Private(vis_request_handlers_1.VisRequestHandlersRegistryProvider);
				var responseHandlers = Private(vis_response_handlers_1.VisResponseHandlersRegistryProvider);
				this.requestHandler = getHandler(requestHandlers, requestHandler);
				this.responseHandler = getHandler(responseHandlers, responseHandler)
			}
			_createClass(VisualizeDataLoader, [
			{
				key: "fetch",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(params)
					{
						var requestHandlerResponse, canSkipResponseHandler;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								this.vis.filters = {
									timeRange: params.timeRange
								};
								this.vis.requestError = void 0;
								this.vis.showRequestError = false;
								_context.prev = 3;
								_context.next = 6;
								return this.requestHandler(this.vis, _extends(
								{
									partialRows: this.vis.params.partialRows || this.vis.type.requiresPartialRows
								}, params));
							case 6:
								requestHandlerResponse = _context.sent;
								canSkipResponseHandler = this.previousRequestHandlerResponse && this.previousRequestHandlerResponse === requestHandlerResponse && this.previousVisState && lodash_1.isEqual(this.previousVisState, this.vis.getState());
								this.previousVisState = this.vis.getState();
								this.previousRequestHandlerResponse = requestHandlerResponse;
								if (canSkipResponseHandler)
								{
									_context.next = 14;
									break
								}
								_context.next = 13;
								return Promise.resolve(this.responseHandler(requestHandlerResponse));
							case 13:
								this.visData = _context.sent;
							case 14:
								return _context.abrupt("return", this.visData);
							case 17:
								_context.prev = 17;
								_context.t0 = _context["catch"](3);
								params.searchSource.cancelQueued();
								this.vis.requestError = _context.t0;
								this.vis.showRequestError = _context.t0.type && ["NO_OP_SEARCH_STRATEGY", "UNSUPPORTED_QUERY"].includes(_context.t0.type);
								console.error(_context.t0);
								if (!elasticsearch_errors_1.isTermSizeZeroError(_context.t0))
								{
									_context.next = 25;
									break
								}
								return _context.abrupt("return", notify_1.toastNotifications.addDanger("Your visualization ('" + this.vis.title + "') has an error: it has a term aggregation with a size of 0. Please set it to a number greater than 0 to resolve the error."));
							case 25:
								notify_1.toastNotifications.addDanger(
								{
									title: "Error in visualization",
									text: _context.t0.message
								});
							case 26:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[3, 17]
						])
					}));

					function fetch(_x)
					{
						return _ref.apply(this, arguments)
					}
					return fetch
				}()
			}]);
			return VisualizeDataLoader
		}();
		exports.VisualizeDataLoader = VisualizeDataLoader
	},
	5251: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.toggleFilterDisabled = exports.enableFilter = exports.disableFilter = void 0;
		var _disable_filter = __webpack_require__(885);
		Object.defineProperty(exports, "disableFilter",
		{
			enumerable: true,
			get: function get()
			{
				return _disable_filter.disableFilter
			}
		});
		Object.defineProperty(exports, "enableFilter",
		{
			enumerable: true,
			get: function get()
			{
				return _disable_filter.enableFilter
			}
		});
		Object.defineProperty(exports, "toggleFilterDisabled",
		{
			enumerable: true,
			get: function get()
			{
				return _disable_filter.toggleFilterDisabled
			}
		});
		var _lodash = __webpack_require__(291);
		var _lodash2 = _interopRequireDefault(_lodash);
		var _kibanaFilterbarTemplate = __webpack_require__(5252);
		var _kibanaFilterbarTemplate2 = _interopRequireDefault(_kibanaFilterbarTemplate);
		var _kibanaFilterpillTemplate = __webpack_require__(5253);
		var _kibanaFilterpillTemplate2 = _interopRequireDefault(_kibanaFilterpillTemplate);
		__webpack_require__(886);
		__webpack_require__(1496);
		__webpack_require__(1502);
		var _filter_applied_and_unwrap = __webpack_require__(1503);
		var _map_and_flatten_filters = __webpack_require__(590);
		var _map_flatten_and_wrap_filters = __webpack_require__(1504);
		var _extract_time_filter = __webpack_require__(1505);
		var _filter_out_time_based_filter = __webpack_require__(1506);
		var _change_time_filter = __webpack_require__(1507);
		var _query_filter = __webpack_require__(117);
		var _compare_filters = __webpack_require__(444);
		var _modules = __webpack_require__(2);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _toConsumableArray(arr)
		{
			if (Array.isArray(arr))
			{
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2
			}
			return Array.from(arr)
		}
		var _module = _modules.uiModules.get("kibana");
		_module.directive("filterBarW", function (Private, Promise, getAppState)
		{
			var mapAndFlattenFilters = Private(_map_and_flatten_filters.FilterBarLibMapAndFlattenFiltersProvider);
			var mapFlattenAndWrapFilters = Private(_map_flatten_and_wrap_filters.FilterBarLibMapFlattenAndWrapFiltersProvider);
			var extractTimeFilter = Private(_extract_time_filter.FilterBarLibExtractTimeFilterProvider);
			var filterOutTimeBasedFilter = Private(_filter_out_time_based_filter.FilterBarLibFilterOutTimeBasedFilterProvider);
			var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);
			return {
				template: _kibanaFilterbarTemplate2.default,
				restrict: "E",
				scope:
				{
					indexPatterns: "=",
					tooltipContent: "="
				},
				link: function link($scope, $elem)
				{
					["addFilters", "toggleFilter", "toggleAll", "pinFilter", "pinAll", "invertFilter", "invertAll", "removeFilter", "removeAll"].forEach(function (method)
					{
						$scope[method] = queryFilter[method]
					});
					$scope.state = getAppState();
					$scope.showCollapseLink = function ()
					{
						var pill = $elem.find("filter-pill-w");
						return pill[pill.length - 1].offsetTop > 10
					};
					$scope.filterNavToggle = {
						isOpen: true,
						tooltipContent: "Collapse to hide filters"
					};
					$scope.toggleFilterShown = function ()
					{
						var collapser = $elem.find(".filter-nav-link__collapser");
						var filterPanelPill = $elem.find(".filter-panel__pill");
						if ($scope.filterNavToggle.isOpen)
						{
							$scope.filterNavToggle.tooltipContent = "Expand to show filters";
							collapser.attr("aria-expanded", "false");
							filterPanelPill.attr("style", "width: calc(100% - 80px)")
						}
						else
						{
							$scope.filterNavToggle.tooltipContent = "Collapse to hide filters";
							collapser.attr("aria-expanded", "true");
							filterPanelPill.attr("style", "width: auto")
						}
						$scope.filterNavToggle.isOpen = !$scope.filterNavToggle.isOpen
					};
					$scope.applyFilters = function (filters)
					{
						addAndInvertFilters((0, _filter_applied_and_unwrap.filterAppliedAndUnwrap)(filters));
						$scope.newFilters = [];
						$scope.changeTimeFilter && $scope.changeTimeFilter.meta && $scope.changeTimeFilter.meta.apply && (0, _change_time_filter.changeTimeFilter)($scope.changeTimeFilter)
					};
					$scope.addFilter = function ()
					{
						$scope.editingFilter = {
							meta:
							{
								isNew: true
							}
						}
					};
					$scope.deleteFilter = function (filter)
					{
						$scope.removeFilter(filter);
						filter === $scope.editingFilter && $scope.cancelEdit()
					};
					$scope.editFilter = function (filter)
					{
						$scope.editingFilter = filter
					};
					$scope.cancelEdit = function ()
					{
						delete $scope.editingFilter
					};
					$scope.saveEdit = function (filter, newFilter, isPinned)
					{
						filter.meta.isNew || $scope.removeFilter(filter);
						delete $scope.editingFilter;
						$scope.addFilters([newFilter], isPinned)
					};
					$scope.clearFilterBar = function ()
					{
						$scope.newFilters = [];
						$scope.changeTimeFilter = null
					};
					$scope.$listen(queryFilter, "update", function ()
					{
						updateFilters()
					});
					$scope.$watch(getAppState, function (appState)
					{
						$scope.state = appState
					});
					$scope.$watch("state.$newFilters", function (filters)
					{
						if (!filters) return;
						if (filters.length > 1) return mapFlattenAndWrapFilters(filters).then(function (results)
						{
							extractTimeFilter(results).then(function (filter)
							{
								$scope.changeTimeFilter = filter
							});
							return results
						}).then(filterOutTimeBasedFilter).then(function (results)
						{
							$scope.newFilters = results
						});
						1 === filters.length && Promise.resolve(filters).then(function (filters)
						{
							extractTimeFilter(filters).then(function (timeFilter)
							{
								timeFilter && (0, _change_time_filter.changeTimeFilter)(timeFilter)
							});
							return filters
						}).then(filterOutTimeBasedFilter).then(addAndInvertFilters)
					});

					function addAndInvertFilters(filters)
					{
						var existingFilters = queryFilter.getFilters();
						var inversionFilters = _lodash2.default.filter(existingFilters, function (existingFilter)
						{
							var newMatchingFilter = _lodash2.default.find(filters, _lodash2.default.partial(_compare_filters.compareFilters, existingFilter));
							return newMatchingFilter && newMatchingFilter.meta && existingFilter.meta && existingFilter.meta.negate !== newMatchingFilter.meta.negate
						});
						var newFilters = _lodash2.default.reject(filters, function (filter)
						{
							return _lodash2.default.find(inversionFilters, _lodash2.default.partial(_compare_filters.compareFilters, filter))
						});
						_lodash2.default.forEach(inversionFilters, $scope.invertFilter);
						$scope.addFilters(newFilters)
					}

					function updateFilters()
					{
						var filters = queryFilter.getFilters();
						if (filters && Array.isArray(filters))
						{
							var nonRemovable = filters.filter(function (item)
							{
								return item && item.meta && "undefined" !== typeof item.meta.removable && !item.meta.removable
							});
							var globalState = filters.filter(function (item)
							{
								return item && item.$state && "globalState" === item.$state.store
							});
							var other = filters.filter(function (item)
							{
								return item && !(item.meta && "undefined" !== typeof item.meta.removable && !item.meta.removable) && !(item.$state && "globalState" === item.$state.store)
							});
							var newFilters = [];
							nonRemovable.length && newFilters.push.apply(newFilters, _toConsumableArray(nonRemovable));
							globalState.length && newFilters.push.apply(newFilters, _toConsumableArray(globalState));
							other.length && newFilters.push.apply(newFilters, _toConsumableArray(other));
							filters = newFilters
						}
						mapAndFlattenFilters(filters).then(function (results)
						{
							$scope.filters = _lodash2.default.sortBy(results, function (filter)
							{
								return !filter.meta.pinned
							});
							$scope.$emit("filterbar:updated")
						})
					}
					updateFilters()
				}
			}
		}).directive("filterPillW", function ()
		{
			return {
				template: _kibanaFilterpillTemplate2.default,
				restrict: "E",
				scope:
				{
					filter: "=",
					onToggleFilter: "=",
					onPinFilter: "=",
					onInvertFilter: "=",
					onDeleteFilter: "=",
					onEditFilter: "="
				},
				bindToController: true,
				controllerAs: "pill",
				controller: function filterPillController()
				{
					var _this = this;
					this.activateActions = function ()
					{
						_this.areActionsActivated = true
					};
					this.deactivateActions = function ()
					{
						_this.areActionsActivated = false
					};
					this.isControlledByPanel = function ()
					{
						return _lodash2.default.has(_this.filter, "meta.controlledBy")
					}
				}
			}
		})
	},
	5252: function (module, exports)
	{
		module.exports = '<section aria-label="Filters">\r\n  <div class="filter-bar-confirm" ng-show="newFilters.length">\r\n    <form ng-submit="applyFilters(newFilters)">\r\n    <ul class="list-unstyled">\r\n      <li>Apply these filters?</li>\r\n      <li ng-repeat="filter in newFilters track by $index" class="filter" ng-click="filter.meta.apply = !filter.meta.apply"><input type="checkbox" ng-checked="filter.meta.apply"/>\r\n        <span ng-if="filter.meta.negate">NOT </span> {{ filter.meta.key }}: {{ filter.meta.value }}\r\n      </li>\r\n      <li ng-if="changeTimeFilter" class="changeTimeFilter filter" ng-click="changeTimeFilter.meta.apply = !changeTimeFilter.meta.apply"><input type="checkbox" ng-checked="changeTimeFilter.meta.apply"/> <strong>Change time to:</strong> {{changeTimeFilter.meta.value}} </li>\r\n      <li>\r\n        <div class="kuiButtonGroup">\r\n          <button class="kuiButton kuiButton--primary kuiButton--small">\r\n            Apply Now\r\n          </button>\r\n\r\n          <button\r\n            class="kuiButton kuiButton--hollow"\r\n            ng-click="clearFilterBar();"\r\n          >\r\n            Cancel\r\n          </button>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    </form>\r\n  </div>\r\n\r\n  <div\r\n    class="filter-bar wz-background-transparent wz-border-0"\r\n    ng-class="filterNavToggle.isOpen == true || !showCollapseLink() ? \'\' : \'filter-panel--close\'"\r\n  >\r\n    <div class="filter-panel__pill wz-inline-block">\r\n      <filter-pill-w\r\n        ng-repeat="filter in filters track by $index"\r\n        filter="filter"\r\n        on-toggle-filter="toggleFilter"\r\n        on-pin-filter="pinFilter"\r\n        on-invert-filter="invertFilter"\r\n        on-delete-filter="deleteFilter"\r\n        on-edit-filter="editFilter"\r\n      ></filter-pill-w>\r\n    </div>\r\n\r\n    <div\r\n      class="filter-link"\r\n    >\r\n      <div class="filter-description small">\r\n        <button\r\n          ng-click="addFilter()"\r\n          class="euiLink euiLink--primary"\r\n          data-test-subj="addFilter"\r\n        >\r\n          Add a filter\r\n          <span class="fa fa-plus"></span>\r\n        </button>\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      class="filter-nav-link__icon"\r\n      tooltip="{{ filterNavToggle.tooltipContent }}"\r\n      tooltip-placement="left"\r\n      tooltip-popup-delay="0"\r\n      tooltip-append-to-body="1"\r\n      ng-show="filters.length && showCollapseLink()"\r\n      aria-hidden="!filters.length || !showCollapseLink()"\r\n    >\r\n      <button\r\n        class="filter-nav-link__collapser"\r\n        ng-click="toggleFilterShown($event)"\r\n        aria-expanded="true"\r\n        aria-label="Toggle filterbar"\r\n      >\r\n        <span class="kuiIcon" ng-class="filterNavToggle.isOpen == true ? \'fa-chevron-circle-up\' : \'fa-chevron-circle-down\'"></span>\r\n      </button>\r\n    </div>\r\n\r\n    <div\r\n      class="filter-edit-container"\r\n      ng-if="editingFilter"\r\n    >\r\n      <filter-editor\r\n        filter="editingFilter"\r\n        index-patterns="indexPatterns"\r\n        on-delete="deleteFilter(editingFilter)"\r\n        on-save="saveEdit(filter, newFilter, isPinned)"\r\n        on-cancel="cancelEdit()"\r\n      ></filter-editor>\r\n    </div>\r\n  </div>\r\n\r\n  <div\r\n    class="filter-bar filter-bar-condensed"\r\n    ng-show="filters.length && showFilterActions"\r\n    id="filterActionsAllContainer"\r\n  >\r\n  \r\n    <!--\r\n    <div class="filter-actions-all">\r\n      <div class="filter-link">\r\n        <div class="filter-description"><strong>All filters:</strong></div>\r\n      </div>\r\n        <div class="filter-link">\r\n          <div class="filter-description"><a ng-click="toggleAll(false)" kbn-accessible-click>Enable</a></div>\r\n        </div>\r\n      <div class="filter-link">\r\n        <div class="filter-description"><a ng-click="toggleAll(true)" kbn-accessible-click>Disable</a></div>\r\n      </div>\r\n      <div class="filter-link">\r\n        <div class="filter-description"><a ng-click="pinAll(true)" kbn-accessible-click>Pin</a></div>\r\n      </div>\r\n      <div class="filter-link">\r\n        <div class="filter-description"><a ng-click="pinAll(false)" kbn-accessible-click>Unpin</a></div>\r\n      </div>\r\n      <div class="filter-link">\r\n        <div class="filter-description"><a ng-click="invertAll()" kbn-accessible-click>Invert</a></div>\r\n      </div>\r\n      <div class="filter-link">\r\n        <div class="filter-description"><a ng-click="toggleAll()" kbn-accessible-click>Toggle</a></div>\r\n      </div>\r\n      <div class="filter-link">\r\n        <div class="filter-description"><a ng-click="removeAll()" data-test-subj="removeAllFilters" kbn-accessible-click>Remove</a></div>\r\n      </div>\r\n      -->\r\n    </div>\r\n  </div>\r\n</section>\r\n'
	},
	5253: function (module, exports)
	{
		module.exports = '<div\r\n  class="filter"\r\n  ng-class="{ negate: pill.filter.meta.negate, disabled: pill.filter.meta.disabled }"\r\n  data-test-subj="filter filter-{{ pill.filter.meta.disabled ? \'disabled\' : \'enabled\' }} {{ pill.filter.meta.key ? \'filter-key-\' + pill.filter.meta.key : \'\' }} {{ pill.filter.meta.value ? \'filter-value-\' + pill.filter.meta.value : \'\' }}"\r\n  ng-mouseover="pill.activateActions()"\r\n  ng-mouseleave="pill.deactivateActions()"\r\n>\r\n\r\n  <div\r\n    class="filter-description"\r\n    ng-class="{\'filter-description-deactivated\': pill.areActionsActivated && pill.filter.meta.removable !== false}"\r\n    tabindex="0"\r\n    aria-disabled="{{pill.filter.meta.disabled}}"\r\n  >\r\n    <span ng-if="pill.filter.$state.store == \'globalState\'"><span class="fa fa-fw fa-thumb-tack pinned"></span></span>\r\n    <span ng-if="pill.filter.meta.negate">NOT</span>\r\n    <span ng-if="pill.filter.meta.alias">{{ pill.filter.meta.alias }}</span>\r\n    <span ng-if="!pill.filter.meta.alias">{{ pill.filter.meta.key }}:</span>\r\n    <span ng-if="!pill.filter.meta.alias">"{{ pill.filter.meta.value }}"</span>\r\n  </div>\r\n\r\n  <div class="filter-actions" ng-show="pill.filter.meta.removable !== false" ng-class="{\'filter-actions-activated\': pill.areActionsActivated}">\r\n    <button\r\n      class="action filter-toggle"\r\n      ng-click="pill.onToggleFilter(pill.filter)"\r\n      data-test-subj="disableFilter-{{ pill.filter.meta.key }}"\r\n      ng-focus="pill.activateActions()"\r\n      ng-blur="pill.deactivateActions()"\r\n      aria-label="{{pill.filter.meta.disabled ? \'Enable filter\' : \'Disable filter\'}}"\r\n      tooltip="{{pill.filter.meta.disabled ? \'Enable filter\' : \'Disable filter\'}}"\r\n      tooltip-append-to-body="true"\r\n    >\r\n      <span ng-show="pill.filter.meta.disabled" class="fa fa-fw fa-square-o disabled"></span>\r\n      <span ng-hide="pill.filter.meta.disabled" class="fa fa-fw fa-check-square-o enabled"></span>\r\n    </button>\r\n\r\n    <button\r\n      class="action filter-pin"\r\n      ng-click="pill.onPinFilter(pill.filter)"\r\n      data-test-subj="pinFilter-{{ pill.filter.meta.key }}"\r\n      ng-focus="pill.activateActions()"\r\n      ng-blur="pill.deactivateActions()"\r\n      aria-label="{{pill.filter.$state.store == \'globalState\' ? \'Unpin filter\' : \'Pin filter\'}}"\r\n      tooltip="{{pill.filter.$state.store == \'globalState\' ? \'Unpin filter\' : \'Pin filter\'}}"\r\n      tooltip-append-to-body="true"\r\n    >\r\n      <span ng-show="pill.filter.$state.store == \'globalState\'" class="fa fa-fw fa-thumb-tack pinned"></span>\r\n      <span ng-hide="pill.filter.$state.store == \'globalState\'" class="fa fa-fw fa-thumb-tack fa-rotate-270 unpinned"></span>\r\n    </button>\r\n\r\n    <button\r\n      class="action filter-invert"\r\n      ng-click="pill.onInvertFilter(pill.filter)"\r\n      data-test-subj="invertFilter-{{ pill.filter.meta.key }}"\r\n      ng-focus="pill.activateActions()"\r\n      ng-blur="pill.deactivateActions()"\r\n      aria-label="{{pill.filter.meta.negate ? \'Include matches\' : \'Exclude matches\'}}"\r\n      tooltip="{{pill.filter.meta.negate ? \'Include matches\' : \'Exclude matches\'}}"\r\n      tooltip-append-to-body="true"\r\n    >\r\n      <span ng-show="pill.filter.meta.negate" class="fa fa-fw fa-search-plus negative"></span>\r\n      <span ng-hide="pill.filter.meta.negate" class="fa fa-fw fa-search-minus positive"></span>\r\n    </button>\r\n\r\n    <button\r\n      class="action filter-remove"\r\n      ng-click="pill.onDeleteFilter(pill.filter)"\r\n      ng-focus="pill.activateActions()"\r\n      ng-blur="pill.deactivateActions()"\r\n      aria-label="Remove filter"\r\n      tooltip="Remove filter"\r\n      tooltip-append-to-body="true"\r\n    >\r\n      <span class="fa fa-fw fa-trash" data-test-subj="removeFilter-{{ pill.filter.meta.key }}"></span>\r\n    </button>\r\n\r\n    <button\r\n      class="action filter-edit"\r\n      ng-click="pill.onEditFilter(pill.filter)"\r\n      ng-disabled="pill.isControlledByPanel()"\r\n      ng-focus="pill.activateActions()"\r\n      ng-blur="pill.deactivateActions()"\r\n      aria-label="Edit filter"\r\n      tooltip="Edit filter"\r\n      tooltip-append-to-body="true"\r\n      data-test-subj="editFilter"\r\n    >\r\n      <span\r\n        ng-show="pill.isControlledByPanel()"\r\n        tooltip="Edit disabled because filter is controlled by Kibana"\r\n        class="fa fa-fw fa-edit fa-disabled"\r\n      ></span>\r\n      <span ng-hide="pill.isControlledByPanel()" class="fa fa-fw fa-edit"></span>\r\n    </button>\r\n\r\n  </div>\r\n</div>\r\n'
	},
	5254: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var _kibanaDiscoverTemplate = __webpack_require__(5255);
		var _kibanaDiscoverTemplate2 = _interopRequireDefault(_kibanaDiscoverTemplate);
		__webpack_require__(386);
		__webpack_require__(884);
		__webpack_require__(792);
		__webpack_require__(617);
		__webpack_require__(1679);
		__webpack_require__(1680);
		__webpack_require__(952);
		__webpack_require__(1681);
		__webpack_require__(1682);
		__webpack_require__(883);
		__webpack_require__(1490);
		__webpack_require__(1318);
		__webpack_require__(1319);
		__webpack_require__(1492);
		__webpack_require__(899);
		__webpack_require__(1525);
		__webpack_require__(620);
		__webpack_require__(1508);
		__webpack_require__(1528);
		__webpack_require__(472);
		var _lodash = __webpack_require__(291);
		var _lodash2 = _interopRequireDefault(_lodash);
		var _angular = __webpack_require__(22);
		var _angular2 = _interopRequireDefault(_angular);
		var _get_sort = __webpack_require__(882);
		var _columns = __webpack_require__(890);
		var columnActions = _interopRequireWildcard(_columns);
		var _filter = __webpack_require__(919);
		var filterActions = _interopRequireWildcard(_filter);
		var _datemath = __webpack_require__(83);
		var _datemath2 = _interopRequireDefault(_datemath);
		__webpack_require__(881);
		__webpack_require__(953);
		__webpack_require__(1683);
		__webpack_require__(906);
		__webpack_require__(382);
		__webpack_require__(151);
		__webpack_require__(366);
		var _timefilter = __webpack_require__(27);
		var _share = __webpack_require__(627);
		__webpack_require__(623);
		var _courier = __webpack_require__(95);
		var _notify = __webpack_require__(10);
		var _vis = __webpack_require__(879);
		var _vislib = __webpack_require__(866);
		var _doc_title = __webpack_require__(381);
		var _hit_sort_fn = __webpack_require__(1684);
		var _hit_sort_fn2 = _interopRequireDefault(_hit_sort_fn);
		var _query_filter = __webpack_require__(117);
		var _state_monitor_factory = __webpack_require__(626);
		var _migrateLegacyQuery = __webpack_require__(448);
		var _filter_manager = __webpack_require__(468);
		var _visualization_loader = __webpack_require__(1380);
		var _documentation_links = __webpack_require__(119);
		var _state_hashing = __webpack_require__(270);
		var _adapters = __webpack_require__(326);
		var _courier_inspector_utils = __webpack_require__(461);
		var _tabify = __webpack_require__(1685);
		__webpack_require__(1511);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _toConsumableArray(arr)
		{
			if (Array.isArray(arr))
			{
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2
			}
			return Array.from(arr)
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
		_modules.uiModules.get("app/wazuh", ["kibana/courier"]).directive("kbnDis", [function ()
		{
			return {
				restrict: "E",
				scope:
				{},
				template: _kibanaDiscoverTemplate2.default
			}
		}]);
		var app = _modules.uiModules.get("apps/discover", ["kibana/notify", "kibana/courier", "kibana/url", "kibana/index_patterns", "app/wazuh"]);
		app.directive("discoverAppW", function ()
		{
			return {
				restrict: "E",
				controllerAs: "discoverApp",
				controller: discoverController
			}
		});

		function discoverController($element, $route, $scope, $timeout, $window, AppState, Notifier, Private, Promise, config, courier, $rootScope, $location, kbnUrl, localStorage, breadcrumbState, getAppState, globalState, loadedVisualizations, discoverPendingUpdates)
		{
			var _this = this;
			_ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(saveOptions)
			{
				var id;
				return regeneratorRuntime.wrap(function _callee4$(_context4)
				{
					while (1) switch (_context4.prev = _context4.next)
					{
					case 0:
						_context4.next = 2;
						return $scope.updateDataSource();
					case 2:
						savedSearch.columns = $scope.state.columns;
						savedSearch.sort = $scope.state.sort;
						_context4.prev = 4;
						_context4.next = 7;
						return savedSearch.save(saveOptions);
					case 7:
						id = _context4.sent;
						$scope.$evalAsync(function ()
						{
							stateMonitor.setInitialState($state.toJSON());
							if (id)
							{
								_notify.toastNotifications.addSuccess(
								{
									title: "Search '" + savedSearch.title + "' was saved",
									"data-test-subj": "saveSearchSuccess"
								});
								if (savedSearch.id !== $route.current.params.id) kbnUrl.change("/discover/{{id}}",
								{
									id: savedSearch.id
								});
								else
								{
									$state.setDefaults(getStateDefaults());
									docTitle.change(savedSearch.lastSavedTitle)
								}
							}
						});
						return _context4.abrupt("return",
						{
							id: id
						});
					case 12:
						_context4.prev = 12;
						_context4.t0 = _context4["catch"](4);
						_notify.toastNotifications.addDanger(
						{
							title: "Search '" + savedSearch.title + "' was not saved.",
							text: _context4.t0.message
						});
						return _context4.abrupt("return",
						{
							error: _context4.t0
						});
					case 16:
					case "end":
						return _context4.stop()
					}
				}, _callee4, this, [
					[4, 12]
				])
			}));
			var _ref5;
			var Vis = Private(_vis.VisProvider);
			var docTitle = Private(_doc_title.DocTitleProvider);
			var HitSortFn = Private(_hit_sort_fn2.default);
			var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);
			var responseHandler = Private(_vislib.VislibSeriesResponseHandlerProvider).handler;
			var filterManager = Private(_filter_manager.FilterManagerProvider);
			var notify = new Notifier(
			{
				location: "Discover"
			});
			Private(_state_hashing.getUnhashableStatesProvider);
			Private(_share.ShareContextMenuExtensionsRegistryProvider);
			var inspectorAdapters = {
				requests: new _adapters.RequestAdapter
			};
			var calcWzInterval = function calcWzInterval()
			{
				var wzInterval = false;
				try
				{
					var from = _datemath2.default.parse(_timefilter.timefilter.getTime().from);
					var to = _datemath2.default.parse(_timefilter.timefilter.getTime().to);
					var totalSeconds = (to - from) / 1e3;
					wzInterval = totalSeconds <= 3600 ? "m" : totalSeconds > 3600 && totalSeconds <= 86400 ? "h" : totalSeconds > 86400 && totalSeconds <= 604800 ? "d" : totalSeconds > 604800 && totalSeconds <= 2419200 ? "w" : "M"
				}
				catch (error)
				{}
				return wzInterval
			};
			$scope.getDocLink = _documentation_links.getDocLink;
			$scope.intervalOptions = [
			{
				display: "Minute",
				val: "m"
			},
			{
				display: "Hourly",
				val: "h"
			},
			{
				display: "Daily",
				val: "d"
			},
			{
				display: "Weekly",
				val: "w"
			},
			{
				display: "Monthly",
				val: "M"
			},
			{
				display: "Yearly",
				val: "y"
			},
			{
				display: "Custom",
				val: "custom"
			}];
			$scope.showInterval = false;
			$scope.minimumVisibleRows = 50;
			$scope.intervalEnabled = function (interval)
			{
				return "custom" !== interval.val
			};
			var savedSearch = $route.current.locals.savedSearch;
			$scope.$on("$destroy", savedSearch.destroy);
			var $appStatus = $scope.appStatus = this.appStatus = {
				dirty: !savedSearch.id
			};
			$scope.topNavMenu = [];
			$scope.toggleRefresh = function ()
			{
				$scope.timefilter.refreshInterval.pause = !$scope.timefilter.refreshInterval.pause
			};
			$scope.searchSource = savedSearch.searchSource;
			$scope.indexPattern = resolveIndexPatternLoading();
			$scope.searchSource.setField("index", $scope.indexPattern).setField("highlightAll", true).setField("version", true);
			$scope.searchSource.setPreferredSearchStrategyId("default");
			var timeRangeSearchSource = savedSearch.searchSource.create();
			(0, _courier.isDefaultTypeIndexPattern)($scope.indexPattern) && timeRangeSearchSource.setField("filter", function ()
			{
				return _timefilter.timefilter.createFilter($scope.indexPattern)
			});
			$scope.searchSource.setParent(timeRangeSearchSource);
			var pageTitleSuffix = savedSearch.id && savedSearch.title ? ": " + savedSearch.title : "";
			docTitle.change("Discover" + pageTitleSuffix);
			savedSearch.id && savedSearch.title ? breadcrumbState.set([
			{
				text: "Discover",
				href: "#/discover"
			},
			{
				text: savedSearch.title
			}]) : breadcrumbState.set([
			{
				text: "Discover"
			}]);
			var stateMonitor = void 0;
			var $state = $scope.state = new AppState(getStateDefaults());
			var getFieldCounts = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
			{
				return regeneratorRuntime.wrap(function _callee$(_context)
				{
					while (1) switch (_context.prev = _context.next)
					{
					case 0:
						if ($scope.fetchStatus)
						{
							_context.next = 2;
							break
						}
						return _context.abrupt("return", $scope.fieldCounts);
					case 2:
						_context.next = 4;
						return new Promise(function (resolve)
						{
							var unwatch = $scope.$watch("fetchStatus", function (newValue)
							{
								if (newValue) return;
								unwatch();
								resolve($scope.fieldCounts)
							})
						});
					case 4:
						return _context.abrupt("return", _context.sent);
					case 5:
					case "end":
						return _context.stop()
					}
				}, _callee, _this)
			})), function getFieldCounts()
			{
				return _ref.apply(this, arguments)
			});
			var _ref;
			var getSharingDataFields = (_ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2()
			{
				var selectedFields, fieldCounts, timeFieldName, fields;
				return regeneratorRuntime.wrap(function _callee2$(_context2)
				{
					while (1) switch (_context2.prev = _context2.next)
					{
					case 0:
						selectedFields = $state.columns;
						if (!(1 === selectedFields.length && "_source" === selectedFields[0]))
						{
							_context2.next = 6;
							break
						}
						_context2.next = 4;
						return getFieldCounts();
					case 4:
						fieldCounts = _context2.sent;
						return _context2.abrupt("return",
						{
							searchFields: null,
							selectFields: _lodash2.default.keys(fieldCounts).sort()
						});
					case 6:
						timeFieldName = $scope.indexPattern.timeFieldName;
						fields = timeFieldName ? [timeFieldName].concat(_toConsumableArray(selectedFields)) : selectedFields;
						return _context2.abrupt("return",
						{
							searchFields: fields,
							selectFields: fields
						});
					case 9:
					case "end":
						return _context2.stop()
					}
				}, _callee2, _this)
			})), function getSharingDataFields()
			{
				return _ref2.apply(this, arguments)
			});
			var _ref2;
			this.getSharingData = _asyncToGenerator(regeneratorRuntime.mark(function _callee3()
			{
				var searchSource, _ref4, searchFields, selectFields, body;
				return regeneratorRuntime.wrap(function _callee3$(_context3)
				{
					while (1) switch (_context3.prev = _context3.next)
					{
					case 0:
						searchSource = $scope.searchSource.createCopy();
						_context3.next = 3;
						return getSharingDataFields();
					case 3:
						_ref4 = _context3.sent;
						searchFields = _ref4.searchFields;
						selectFields = _ref4.selectFields;
						searchSource.setField("fields", searchFields);
						searchSource.setField("sort", (0, _get_sort.getSort)($state.sort, $scope.indexPattern));
						searchSource.setField("highlight", null);
						searchSource.setField("highlightAll", null);
						searchSource.setField("aggs", null);
						searchSource.setField("size", null);
						_context3.next = 14;
						return searchSource.getSearchRequestBody();
					case 14:
						body = _context3.sent;
						return _context3.abrupt("return",
						{
							searchRequest:
							{
								index: searchSource.getField("index").title,
								body: body
							},
							fields: selectFields,
							metaFields: $scope.indexPattern.metaFields,
							conflictedTypesFields: $scope.indexPattern.fields.filter(function (f)
							{
								return "conflict" === f.type
							}).map(function (f)
							{
								return f.name
							}),
							indexPatternId: searchSource.getField("index").id
						});
					case 16:
					case "end":
						return _context3.stop()
					}
				}, _callee3, _this)
			}));
			$scope.uiState = $state.makeStateful("uiState");

			function getStateDefaults()
			{
				var wzInterval = calcWzInterval();
				return {
					query: $scope.searchSource.getField("query") ||
					{
						query: "",
						language: localStorage.get("kibana.userQueryLanguage") || config.get("search:queryLanguage")
					},
					sort: _get_sort.getSort.array(savedSearch.sort, $scope.indexPattern, config.get("discover:sort:defaultOrder")),
					columns: savedSearch.columns.length > 0 ? savedSearch.columns : config.get("defaultColumns").slice(),
					index: $scope.indexPattern.id,
					interval: wzInterval || "h",
					filters: _lodash2.default.cloneDeep($scope.searchSource.getOwnField("filter"))
				}
			}
			$state.index = $scope.indexPattern.id;
			$state.sort = _get_sort.getSort.array($state.sort, $scope.indexPattern);
			$scope.getBucketIntervalToolTipText = function ()
			{
				return "This interval creates " + ($scope.bucketInterval.scale > 1 ? "buckets that are too large" : "too many buckets") + "\n      to show in the selected time range, so it has been scaled to " + $scope.bucketInterval.description
			};
			$scope.$watchCollection("state.columns", function ()
			{
				$state.save()
			});
			$scope.opts = {
				sampleSize: config.get("discover:sampleSize"),
				timefield: (0, _courier.isDefaultTypeIndexPattern)($scope.indexPattern) && $scope.indexPattern.timeFieldName,
				savedSearch: savedSearch,
				indexPatternList: $route.current.locals.ip.list
			};
			var init = _lodash2.default.once(function ()
			{
				stateMonitor = _state_monitor_factory.stateMonitorFactory.create($state, getStateDefaults());
				stateMonitor.onChange(function (status)
				{
					$appStatus.dirty = status.dirty || !savedSearch.id
				});
				$scope.$on("$destroy", function ()
				{
					return stateMonitor.destroy()
				});
				$scope.updateDataSource().then(function ()
				{
					$scope.$listen(_timefilter.timefilter, "fetch", function ()
					{
						$state.interval = calcWzInterval() || "d";
						$scope.fetch()
					});
					$scope.$watchCollection("state.sort", function (sort)
					{
						if (!sort) return;
						var currentSort = Object.entries($scope.searchSource.getField("sort")).pop();
						_angular2.default.equals(sort, currentSort) || $scope.fetch()
					});
					$scope.$listen(queryFilter, "update", function ()
					{
						return $scope.updateDataSource().then(function ()
						{
							discoverPendingUpdates.removeAll();
							discoverPendingUpdates.addItem($state.query, queryFilter.getFilters());
							$rootScope.$broadcast("updateVis");
							$rootScope.$broadcast("fetch");
							if ("configuration" != $location.search().tab)
							{
								loadedVisualizations.removeAll();
								$rootScope.rendered = false;
								$rootScope.loadingStatus = "Fetching data..."
							}
							$state.save()
						}).catch(console.error)
					});
					$scope.$listen($state, "fetch_with_changes", function (diff)
					{
						diff.indexOf("query") >= 0 && $scope.fetch()
					});
					$scope.$listen(queryFilter, "fetch", $scope.fetch);
					_timefilter.timefilter.enableAutoRefreshSelector();
					$scope.$watch("opts.timefield", function (timefield)
					{
						timefield ? _timefilter.timefilter.enableTimeRangeSelector() : _timefilter.timefilter.disableTimeRangeSelector()
					});
					$scope.$watch("state.interval", function ()
					{
						$scope.fetch()
					});
					$scope.$watch("vis.aggs", function ()
					{
						if (!$scope.opts.timefield) return;
						var buckets = $scope.vis.getAggConfig().bySchemaGroup.buckets;
						buckets && 1 === buckets.length && ($scope.bucketInterval = buckets[0].buckets.getInterval())
					});
					$scope.$watch("state.query", $scope.updateQueryAndFetch);
					$scope.$watchMulti(["rows", "fetchStatus"], function updateResultState()
					{
						var prev = {};
						var status = {
							LOADING: "loading",
							READY: "ready",
							NO_RESULTS: "none"
						};

						function pick(rows, oldRows, fetchStatus)
						{
							if (null == rows && null == oldRows) return status.LOADING;
							var rowsEmpty = _lodash2.default.isEmpty(rows);
							var preparingForFetch = _lodash2.default.isUndefined(fetchStatus);
							return preparingForFetch ? status.LOADING : rowsEmpty && fetchStatus ? status.LOADING : rowsEmpty ? status.NO_RESULTS : status.READY
						}
						return function ()
						{
							var current = {
								rows: $scope.rows,
								fetchStatus: $scope.fetchStatus
							};
							$scope.resultState = pick(current.rows, prev.rows, current.fetchStatus, prev.fetchStatus);
							$rootScope.resultState = $scope.resultState;
							prev = current
						}
					}());
					if ($scope.opts.timefield)
					{
						setupVisualization();
						$scope.updateTime()
					}
					init.complete = true;
					$state.replace()
				})
			});
			var filtersAreReady = function filtersAreReady()
			{
				var currentUrlPath = $location.path();
				if (currentUrlPath && !currentUrlPath.includes("wazuh-discover"))
				{
					var filters = queryFilter.getFilters();
					filters = Array.isArray(filters) ? filters.filter(function (item)
					{
						return item && item.$state && item.$state.store && "appState" === item.$state.store
					}) : [];
					if (!filters || !filters.length) return false
				}
				return true
			};
			$scope.opts.fetch = $scope.fetch = function ()
			{
				if (!filtersAreReady()) return;
				if (!init.complete) return;
				$scope.fetchError = void 0;
				$scope.updateTime();
				$scope.updateDataSource().then(setupVisualization).then(function ()
				{
					$state.save();
					return courier.fetch()
				}).catch(notify.error)
			};
			$scope.updateQueryAndFetch = function (query)
			{
				if (!filtersAreReady()) return;
				discoverPendingUpdates.removeAll();
				discoverPendingUpdates.addItem($state.query, queryFilter.getFilters());
				$rootScope.$broadcast("updateVis");
				$rootScope.$broadcast("fetch");
				$state.query = (0, _migrateLegacyQuery.migrateLegacyQuery)(query);
				$scope.fetch()
			};

			function handleSegmentedFetch(segmented)
			{
				function flushResponseData()
				{
					$scope.fetchError = void 0;
					$scope.hits = 0;
					$scope.failures = [];
					$scope.rows = [];
					$scope.fieldCounts = {}
				}
				$scope.rows || flushResponseData();
				var sort = $state.sort;
				var timeField = $scope.indexPattern.timeFieldName;
				var sortBy = Array.isArray(sort) ? "_score" === sort[0] ? "implicit" : sort[0] === timeField ? "time" : "non-time" : "implicit";
				var sortFn = null;
				"implicit" !== sortBy && (sortFn = new HitSortFn(sort[1]));
				"_score" === sort[0] && segmented.setMaxSegments(1);
				segmented.setDirection("time" === sortBy && sort[1] || "desc");
				segmented.setSortFn(sortFn);
				segmented.setSize($scope.opts.sampleSize);
				var inspectorRequests = [];

				function logResponseInInspector(resp)
				{
					if (inspectorRequests.length > 0)
					{
						var inspectorRequest = inspectorRequests.shift();
						inspectorRequest.stats((0, _courier_inspector_utils.getResponseInspectorStats)($scope.searchSource, resp)).ok(
						{
							json: resp
						})
					}
				}
				segmented.on("status", function (status)
				{
					$scope.fetchStatus = status;
					if (0 === status.complete)
					{
						inspectorAdapters.requests.reset();
						inspectorRequests = []
					}
					if (status.remaining > 0)
					{
						var inspectorRequest = inspectorAdapters.requests.start("Segment " + $scope.fetchStatus.complete,
						{
							description: "This request queries Elasticsearch to fetch the data for the search."
						});
						inspectorRequest.stats((0, _courier_inspector_utils.getRequestInspectorStats)($scope.searchSource));
						$scope.searchSource.getSearchRequestBody().then(function (body)
						{
							inspectorRequest.json(body)
						});
						inspectorRequests.push(inspectorRequest)
					}
				});
				segmented.on("first", function ()
				{
					flushResponseData()
				});
				segmented.on("segment", function (resp)
				{
					logResponseInInspector(resp);
					if (resp._shards.failed > 0)
					{
						$scope.failures = _lodash2.default.union($scope.failures, resp._shards.failures);
						$scope.failures = _lodash2.default.uniq($scope.failures, false, function (failure)
						{
							return failure.index + failure.shard + failure.reason
						})
					}
				});
				segmented.on("emptySegment", function (resp)
				{
					logResponseInInspector(resp)
				});
				segmented.on("mergedSegment", function (merged)
				{
					$scope.mergedEsResp = merged;
					if ($scope.opts.timefield)
					{
						var tabifiedData = (0, _tabify.tabifyAggResponse)($scope.vis.aggs, merged);
						$scope.searchSource.rawResponse = merged;
						Promise.resolve(responseHandler(tabifiedData)).then(function (resp)
						{
							$scope.visData = resp;
							if (("panels" !== $scope.tabView || $location.path().includes("wazuh-discover")) && "cluster-monitoring" !== $scope.tabView)
							{
								var visEl = $element.find("#discoverHistogram")[0];
								_visualization_loader.visualizationLoader.render(visEl, $scope.vis, $scope.visData, $scope.uiState,
								{
									listenOnChange: true
								})
							}
						})
					}
					$scope.hits = merged.hits.total;
					var indexPattern = $scope.searchSource.getField("index");
					$scope.rows = merged.hits.hits.slice();
					var counts = $scope.fieldCounts;
					counts && !sortFn || (counts = $scope.fieldCounts = {});
					$scope.rows.forEach(function (hit)
					{
						if (hit.$$_counted) return;
						sortFn || (hit.$$_counted = true);
						var fields = _lodash2.default.keys(indexPattern.flattenHit(hit));
						var n = fields.length;
						var field = void 0;
						while (field = fields[--n]) counts[field] ? counts[field] += 1 : counts[field] = 1
					})
				});
				segmented.on("complete", function ()
				{
					0 === $scope.fetchStatus.hitCount && flushResponseData();
					$scope.fetchStatus = null
				})
			}

			function beginSegmentedFetch()
			{
				$scope.searchSource.onBeginSegmentedFetch(handleSegmentedFetch).catch(function (error)
				{
					var fetchError = (0, _notify.getPainlessError)(error);
					fetchError ? $scope.fetchError = fetchError : notify.error(error);
					beginSegmentedFetch()
				})
			}
			beginSegmentedFetch();
			$scope.updateTime = function ()
			{
				if ("configuration" != $location.search().tab)
				{
					loadedVisualizations.removeAll();
					$rootScope.rendered = false;
					$rootScope.loadingStatus = "Fetching data..."
				}
				$scope.timeRange = {
					from: _datemath2.default.parse(_timefilter.timefilter.getTime().from),
					to: _datemath2.default.parse(_timefilter.timefilter.getTime().to,
					{
						roundUp: true
					})
				}
			};
			$scope.resetQuery = function ()
			{
				kbnUrl.change("/discover/{{id}}",
				{
					id: $route.current.params.id
				})
			};
			$scope.newQuery = function ()
			{
				kbnUrl.change("/discover")
			};
			$scope.updateDataSource = Promise.method(function updateDataSource()
			{
				$scope.searchSource.setField("size", $scope.opts.sampleSize).setField("sort", (0, _get_sort.getSort)($state.sort, $scope.indexPattern)).setField("query", $state.query ? $state.query : null).setField("filter", queryFilter.getFilters())
			});
			$scope.setSortOrder = function setSortOrder(columnName, direction)
			{
				$scope.state.sort = [columnName, direction]
			};
			$scope.filterQuery = function (field, values, operation)
			{
				filterActions.addFilter(field, values, operation, $scope.indexPattern.id, $scope.state, filterManager)
			};
			$scope.addColumn = function addColumn(columnName)
			{
				columnActions.addColumn($scope.state.columns, columnName)
			};
			$scope.removeColumn = function removeColumn(columnName)
			{
				columnActions.removeColumn($scope.state.columns, columnName)
			};
			$scope.moveColumn = function moveColumn(columnName, newIndex)
			{
				columnActions.moveColumn($scope.state.columns, columnName, newIndex)
			};
			$scope.scrollToTop = function ()
			{
				$window.scrollTo(0, 0)
			};
			$scope.scrollToBottom = function ()
			{
				$timeout(function ()
				{
					$element.find("#discoverBottomMarker").focus()
				}, 0)
			};
			$scope.showAllRows = function ()
			{
				$scope.minimumVisibleRows = $scope.hits
			};

			function setupVisualization()
			{
				if (!$scope.opts.timefield) return;
				var visStateAggs = [
				{
					type: "count",
					schema: "metric"
				},
				{
					type: "date_histogram",
					schema: "segment",
					params:
					{
						field: $scope.opts.timefield,
						interval: $state.interval,
						timeRange: _timefilter.timefilter.getTime()
					}
				}];
				if ($scope.vis)
				{
					var visState = $scope.vis.getEnabledState();
					visState.aggs = visStateAggs;
					$scope.vis.setState(visState)
				}
				else
				{
					$scope.vis = new Vis($scope.indexPattern,
					{
						title: savedSearch.title,
						type: "histogram",
						params:
						{
							addLegend: false,
							addTimeMarker: true
						},
						aggs: visStateAggs
					});
					$scope.searchSource.onRequestStart(function (searchSource, searchRequest)
					{
						return $scope.vis.getAggConfig().onSearchRequestStart(searchSource, searchRequest)
					});
					$scope.searchSource.setField("aggs", function ()
					{
						var result = $scope.vis.getAggConfig().toDsl();
						result[2] && result[2].date_histogram && "0ms" === result[2].date_histogram.interval && (result[2].date_histogram.interval = "1d");
						return result
					})
				}
				$scope.vis.filters = {
					timeRange: _timefilter.timefilter.getTime()
				}
			}

			function resolveIndexPatternLoading()
			{
				var _$route$current$local = $route.current.locals.ip,
					loadedIndexPattern = _$route$current$local.loaded,
					stateVal = _$route$current$local.stateVal,
					stateValFound = _$route$current$local.stateValFound;
				var ownIndexPattern = $scope.searchSource.getOwnField("index");
				if (ownIndexPattern && !stateVal) return ownIndexPattern;
				if (stateVal && !stateValFound)
				{
					var warningTitle = '"' + stateVal + '" is not a configured index pattern ID';
					if (ownIndexPattern)
					{
						_notify.toastNotifications.addWarning(
						{
							title: warningTitle,
							text: 'Showing the saved index pattern: "' + ownIndexPattern.title + '" (' + ownIndexPattern.id + ")"
						});
						return ownIndexPattern
					}
					_notify.toastNotifications.addWarning(
					{
						title: warningTitle,
						text: 'Showing the default index pattern: "' + loadedIndexPattern.title + '" (' + loadedIndexPattern.id + ")"
					})
				}
				return loadedIndexPattern
			}
			$scope.isUnsupportedIndexPattern = !(0, _courier.isDefaultTypeIndexPattern)($route.current.locals.ip.loaded) && !(0, _courier.hasSearchStategyForIndexPattern)($route.current.locals.ip.loaded);
			if ($scope.isUnsupportedIndexPattern)
			{
				$scope.unsupportedIndexPatternType = $route.current.locals.ip.loaded.type;
				return
			}
			var loadFilters = function loadFilters(wzCurrentFilters, localChange)
			{
				var appState = getAppState();
				if (appState && globalState)
				{
					$state.filters = localChange ? $state.filters : [];
					queryFilter.addFilters(wzCurrentFilters).then(function () {}).catch(function (error)
					{
						return console.log(error.message || error)
					})
				}
				else $timeout(100).then(function ()
				{
					return loadFilters(wzCurrentFilters)
				})
			};
			var wzEventFiltersListener = $rootScope.$on("wzEventFilters", function (evt, parameters)
			{
				loadFilters(parameters.filters, parameters.localChange)
			});
			$scope.tabView = $location.search().tabView || "panels";
			var changeTabViewListener = $rootScope.$on("changeTabView", function (evt, parameters)
			{
				$scope.tabView = parameters.tabView || "panels";
				$scope.updateQueryAndFetch($state.query)
			});
			$scope.$on("$destroy", function ()
			{
				wzEventFiltersListener();
				changeTabViewListener()
			});
			init()
		}
	},
	5255: function (module, exports)
	{
		module.exports = '<discover-app-w class="app-container">\r\n  <!-- Local nav. -->\r\n  <wz-kbn-top-nav name="discover" config="topNavMenu">\r\n    <!-- Transcluded elements. -->\r\n    <div data-transclude-slots>\r\n      <!-- Breadcrumbs. -->\r\n      <div data-transclude-slot="topLeftCorner" class="kuiLocalBreadcrumbs">\r\n        <h1 tabindex="0" id="kui_local_breadcrumb" class="kuiLocalBreadcrumb" ng-show="tabView === \'discover\'">\r\n          <span ng-show="opts.savedSearch.id" class="kuiLocalBreadcrumb__emphasis">\r\n            <span data-test-subj="discoverCurrentQuery" ng-bind="opts.savedSearch.lastSavedTitle"></span>\r\n            <span\r\n              id="reload_saved_search"\r\n              aria-label="Reload Saved Search"\r\n              tooltip="Reload Saved Search"\r\n              ng-click="resetQuery()"\r\n              kbn-accessible-click\r\n              class="kuiIcon fa-undo small"\r\n            ></span>&nbsp;\r\n          </span>\r\n          <span data-test-subj="discoverQueryHits" class="kuiLocalBreadcrumb__emphasis">{{(hits || 0) | number:0}}</span>\r\n          <ng-pluralize count="hits" when="{\'1\':\'hit\', \'other\':\'hits\'}"></ng-pluralize>\r\n        </h1>\r\n      </div>\r\n\r\n      <!-- Search. -->\r\n      <div data-transclude-slot="bottomRow" class="fullWidth" ng-show="tabView !== \'cluster-monitoring\'">\r\n        <query-bar\r\n          query="state.query"\r\n          on-submit="updateQueryAndFetch"\r\n          app-name="\'discover\'"\r\n          index-patterns="[indexPattern]"\r\n        ></query-bar>\r\n      </div>\r\n    </div>\r\n  </wz-kbn-top-nav>\r\n\r\n  <main class="container-fluid" ng-show="tabView !== \'cluster-monitoring\'">\r\n    <div class="row">\r\n      <filter-bar-w\r\n        state="state"\r\n        index-patterns="[indexPattern]"\r\n      ></filter-bar-w>\r\n    </div>\r\n    <div class="row" ng-if="tabView === \'discover\'">\r\n      <div class="col-md-2 sidebar-container collapsible-sidebar" id="discover-sidebar">\r\n        <disc-field-chooser\r\n          class="dscFieldChooser"\r\n          columns="state.columns"\r\n          hits="rows"\r\n          field-counts="fieldCounts"\r\n          index-pattern="searchSource.getField(\'index\')"\r\n          index-pattern-list="opts.indexPatternList"\r\n          state="state"\r\n          on-add-field="addColumn"\r\n          on-add-filter="filterQuery"\r\n          on-remove-field="removeColumn"\r\n        >\r\n        </disc-field-chooser>\r\n      </div>\r\n\r\n      <div class="dscWrapper col-md-10">\r\n        <div class="dscWrapper__content">\r\n          <div layout="row" class="wz-margin-top-10" ng-if="isUnsupportedIndexPattern">\r\n            <div flex class="euiCallOut euiCallOut--warning" data-test-subj="discoverNoResults">\r\n                <div class="euiCallOutHeader">\r\n                    <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path></defs><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use></svg>\r\n                    <span class="euiCallOutHeader__title">Unsupported index pattern.</span>\r\n                </div>\r\n            </div>\r\n          </div>\r\n          <div layout="row" class="wz-margin-top-10" ng-if="resultState === \'none\'">\r\n            <div flex class="euiCallOut euiCallOut--warning" data-test-subj="discoverNoResults">\r\n                <div class="euiCallOutHeader">\r\n                    <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path></defs><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use></svg>\r\n                    <span class="euiCallOutHeader__title">No results match your search criteria</span>\r\n                </div>\r\n            </div>\r\n          </div>\r\n\r\n          <!-- loading -->\r\n          <div ng-show="resultState === \'loading\'">\r\n            <discover-fetch-error\r\n              ng-show="fetchError"\r\n              fetch-error="fetchError"\r\n            ></discover-fetch-error>\r\n\r\n            <div\r\n              ng-hide="fetchError"\r\n              class="dscOverlay"\r\n            >\r\n              <div class="euiTitle" >\r\n                <h2>Searching</h2>\r\n              </div>\r\n              <div class="euiSpacer euiSpacer--m"></div>\r\n              <div ng-show="fetchStatus">{{fetchStatus.complete}}/{{fetchStatus.total}}</div>\r\n            </div>\r\n          </div>\r\n\r\n          <!-- result -->\r\n          <div class="dscResults" ng-show="resultState === \'ready\'">\r\n            <button\r\n              class="kuiButton kuiButton--basic kuiButton--iconText dscSkipButton"\r\n              ng-click="showAllRows(); scrollToBottom()"\r\n            >\r\n              <span class="kuiButton__inner">\r\n                <span aria-hidden="true" class="kuiButton__icon kuiIcon fa-chevron-down"></span>\r\n                <span>Skip to bottom</span>\r\n              </span>\r\n            </button>\r\n\r\n            <section aria-label="Histogram of found documents" class="dscTimechart" ng-if="opts.timefield">\r\n              <header class="dscTimechart__header">\r\n                <div class="small">\r\n                  <span tooltip="To change the time, click the clock icon in the navigation bar">{{timeRange.from | moment}} - {{timeRange.to | moment}}</span>\r\n\r\n                  &mdash;\r\n\r\n                  <span class="form-inline">\r\n                    <select\r\n                      class="dscResults__interval form-control"\r\n                      ng-model="state.interval"\r\n                      ng-options="interval.val as interval.display for interval in intervalOptions | filter: intervalEnabled"\r\n                      ng-blur="toggleInterval()"\r\n                      data-test-subj="discoverIntervalSelect"\r\n                      >\r\n                    </select>\r\n                    <span ng-if="bucketInterval.scaled">\r\n                      <icon-tip\r\n                        content="getBucketIntervalToolTipText()"\r\n                        position="\'top\'"\r\n                      ></icon-tip>\r\n                      Scaled to {{ bucketInterval.description }}\r\n                    </span>\r\n                  </span>\r\n                </div>\r\n\r\n              </header>\r\n\r\n              <div id="discoverHistogram"\r\n                 ng-if="vis && rows.length !== 0"\r\n                 style="display: flex; height: 200px"\r\n                >\r\n              </div>\r\n            </section>\r\n\r\n            <section class="dscTable" fixed-scroll aria-label="Documents">\r\n              <doc-table\r\n                hits="rows"\r\n                index-pattern="indexPattern"\r\n                sorting="state.sort"\r\n                columns="state.columns"\r\n                infinite-scroll="true"\r\n                filter="filterQuery"\r\n                filters="state.filters"\r\n                data-shared-item\r\n                data-title="{{opts.savedSearch.lastSavedTitle}}"\r\n                data-description="{{opts.savedSearch.description}}"\r\n                minimum-visible-rows="minimumVisibleRows"\r\n                render-complete\r\n                on-add-column="addColumn"\r\n                on-change-sort-order="setSortOrder"\r\n                on-move-column="moveColumn"\r\n                on-remove-column="removeColumn"\r\n              ></doc-table>\r\n\r\n              <a tabindex="0" id="discoverBottomMarker"></a>\r\n\r\n              <div ng-if="rows.length == opts.sampleSize" class="dscTable__footer">\r\n                These are the first {{opts.sampleSize}} documents matching\r\n                your search, refine your search to see others.\r\n                <a kbn-accessible-click ng-click="scrollToTop()">Back to top.</a>\r\n              </div>\r\n            </section>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </main>\r\n</discover-app-w>'
	},
	5269: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(878);
		var _vis_types = __webpack_require__(76);
		var _modules = __webpack_require__(2);
		var _savedObjectLoader = __webpack_require__(5270);
		var _saved_object_registry = __webpack_require__(327);
		var _saved_objects = __webpack_require__(54);
		var app = _modules.uiModules.get("app/visualize");
		_saved_object_registry.savedObjectManagementRegistry.register(
		{
			service: "wzsavedVisualizations",
			title: "visualizations"
		});
		app.service("wzsavedVisualizations", function (Promise, kbnIndex, SavedVis, Private, kbnUrl, $http, chrome)
		{
			var visTypes = Private(_vis_types.VisTypesRegistryProvider);
			var savedObjectClient = Private(_saved_objects.SavedObjectsClientProvider);
			var saveVisualizationLoader = new _savedObjectLoader.SavedObjectLoader(SavedVis, kbnIndex, kbnUrl, $http, chrome, savedObjectClient);
			saveVisualizationLoader.mapHitSource = function (source, id)
			{
				source.id = id;
				source.url = this.urlFor(id);
				var typeName = source.typeName;
				if (source.visState) try
				{
					typeName = JSON.parse(source.visState).type
				}
				catch (e)
				{}
				if (!typeName || !visTypes.byName[typeName])
				{
					source.error = "Unknown visualization type";
					return source
				}
				source.type = visTypes.byName[typeName];
				source.icon = source.type.icon;
				return source
			};
			saveVisualizationLoader.urlFor = function (id)
			{
				return kbnUrl.eval("#/visualize/edit/{{id}}",
				{
					id: id
				})
			};
			return saveVisualizationLoader
		})
	},
	5270: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.SavedObjectLoader = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _lodash = __webpack_require__(291);
		var _lodash2 = _interopRequireDefault(_lodash);
		var _scanner = __webpack_require__(1489);
		var _string_utils = __webpack_require__(811);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.SavedObjectLoader = function ()
		{
			function SavedObjectLoader(SavedObjectClass, kbnIndex, kbnUrl, $http, chrome, savedObjectsClient)
			{
				_classCallCheck(this, SavedObjectLoader);
				this.type = SavedObjectClass.type;
				this.Class = SavedObjectClass;
				this.lowercaseType = this.type.toLowerCase();
				this.kbnIndex = kbnIndex;
				this.kbnUrl = kbnUrl;
				this.chrome = chrome;
				this.scanner = new _scanner.Scanner($http,
				{
					index: kbnIndex,
					type: this.lowercaseType
				});
				this.loaderProperties = {
					name: this.lowercaseType + "s",
					noun: _string_utils.StringUtils.upperFirst(this.type),
					nouns: this.lowercaseType + "s"
				};
				this.savedObjectsClient = savedObjectsClient
			}
			_createClass(SavedObjectLoader, [
			{
				key: "processFunc",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								return _context.abrupt("return");
							case 1:
							case "end":
								return _context.stop()
							}
						}, _callee, this)
					}));

					function processFunc()
					{
						return _ref.apply(this, arguments)
					}
					return processFunc
				}()
			},
			{
				key: "get",
				value: function get(id, raw)
				{
					var _this = this;
					var instance = new this.Class(id);
					instance.init = _lodash2.default.once(function ()
					{
						return Promise.resolve().then(function ()
						{
							if (!instance.id)
							{
								_lodash2.default.assign(instance, instance.defaults);
								return instance.hydrateIndexPattern().then(function ()
								{
									return afterESResp.call(instance)
								})
							}
							return _this.processFunc().then(function ()
							{
								return {
									_id: raw.id,
									_type: raw.type,
									_source: _lodash2.default.cloneDeep(raw.attributes),
									found: !!raw._version
								}
							}).then(instance.applyESResp).catch(instance.applyEsResp)
						}).then(function ()
						{
							return instance
						})
					});
					var object = instance.init();
					return object
				}
			},
			{
				key: "urlFor",
				value: function urlFor(id)
				{
					return this.kbnUrl.eval("#/" + this.lowercaseType + "/{{id}}",
					{
						id: id
					})
				}
			},
			{
				key: "delete",
				value: function _delete(ids)
				{
					var _this2 = this;
					ids = Array.isArray(ids) ? ids : [ids];
					var deletions = ids.map(function (id)
					{
						var savedObject = new _this2.Class(id);
						return savedObject.delete()
					});
					return Promise.all(deletions).then(function ()
					{
						_this2.chrome && _this2.chrome.untrackNavLinksForDeletedSavedObjects(ids)
					})
				}
			},
			{
				key: "mapHitSource",
				value: function mapHitSource(source, id)
				{
					source.id = id;
					source.url = this.urlFor(id);
					return source
				}
			},
			{
				key: "scanAll",
				value: function scanAll(queryString)
				{
					var pageSize = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e3;
					return this.scanner.scanAndMap(queryString,
					{
						pageSize: pageSize,
						docCount: Infinity
					})
				}
			},
			{
				key: "mapSavedObjectApiHits",
				value: function mapSavedObjectApiHits(hit)
				{
					return this.mapHitSource(hit.attributes, hit.id)
				}
			},
			{
				key: "findAll",
				value: function findAll()
				{
					var search = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
					var _this3 = this;
					var size = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100;
					var fields = arguments[2];
					return this.savedObjectsClient.find(
					{
						type: this.lowercaseType,
						search: search ? search + "*" : void 0,
						perPage: size,
						page: 1,
						searchFields: ["title^3", "description"],
						fields: fields
					}).then(function (resp)
					{
						return {
							total: resp.total,
							hits: resp.savedObjects.map(function (savedObject)
							{
								return _this3.mapSavedObjectApiHits(savedObject)
							})
						}
					})
				}
			},
			{
				key: "find",
				value: function find()
				{
					var search = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
					var size = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100;
					return this.findAll(search, size).then(function (resp)
					{
						return {
							total: resp.total,
							hits: resp.hits.filter(function (savedObject)
							{
								return !savedObject.error
							})
						}
					})
				}
			}]);
			return SavedObjectLoader
		}()
	},
	5271: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(5272)
	},
	5272: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _lodash = __webpack_require__(291);
		var _lodash2 = _interopRequireDefault(_lodash);
		var _angular = __webpack_require__(22);
		var _angular2 = _interopRequireDefault(_angular);
		__webpack_require__(578);
		__webpack_require__(380);
		var _modules = __webpack_require__(2);
		var _kbn_top_nav = __webpack_require__(5273);
		var _kbn_top_nav2 = _interopRequireDefault(_kbn_top_nav);
		var _kbn_top_nav_controller = __webpack_require__(5274);
		var _navbar_extensions = __webpack_require__(1519);
		__webpack_require__(5275);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		var _module = _modules.uiModules.get("kibana");
		_module.directive("wzKbnTopNav", function (Private)
		{
			var KbnTopNavController = Private(_kbn_top_nav_controller.KbnTopNavControllerProvider);
			var navbarExtensions = Private(_navbar_extensions.NavBarExtensionsRegistryProvider);
			var getNavbarExtensions = _lodash2.default.memoize(function (name)
			{
				if (!name) throw new Error("navbar directive requires a name attribute");
				return _lodash2.default.sortBy(navbarExtensions.byAppName[name], "order")
			});
			return {
				restrict: "E",
				transclude: true,
				template: _kbn_top_nav2.default,
				controller: function controller($scope, $attrs, $element, $transclude)
				{
					$scope.transcludes = {};
					$transclude(function (clone)
					{
						var transcludedContentContainer = _lodash2.default.find(clone, function (item)
						{
							if (item.attributes) return _lodash2.default.find(item.attributes, function (attr)
							{
								return -1 !== attr.name.indexOf("data-transclude-slots")
							})
						});
						if (!transcludedContentContainer) return;
						var transcludedContent = transcludedContentContainer.children;
						_lodash2.default.forEach(transcludedContent, function (transcludedItem)
						{
							var transclusionSlot = transcludedItem.getAttribute("data-transclude-slot");
							$scope.transcludes[transclusionSlot] = transcludedItem
						})
					});
					var extensions = getNavbarExtensions($attrs.name);

					function initTopNav(newConfig, oldConfig)
					{
						if (_lodash2.default.isEqual(oldConfig, newConfig)) return;
						if (newConfig instanceof KbnTopNavController)
						{
							newConfig.addItems(extensions);
							$scope.wzKbnTopNav = new KbnTopNavController(newConfig)
						}
						else
						{
							newConfig = newConfig.concat(extensions);
							$scope.wzKbnTopNav = new KbnTopNavController(newConfig)
						}
						$scope.wzKbnTopNav._link($scope, $element)
					}
					var getTopNavConfig = function getTopNavConfig()
					{
						return _lodash2.default.get($scope, $attrs.config, [])
					};
					var topNavConfig = getTopNavConfig();
					topNavConfig instanceof KbnTopNavController || $scope.$watch(getTopNavConfig, initTopNav, true);
					initTopNav(topNavConfig, null);
					return $scope.wzKbnTopNav
				},
				link: function link(scope)
				{
					var transclusionSlotNames = ["topLeftCorner", "bottomRow"];
					transclusionSlotNames.forEach(function (name)
					{
						var transcludedItem = scope.transcludes[name];
						if (transcludedItem)
						{
							var transclusionSlot = document.querySelector('[data-transclude-slot="' + name + '"]');
							_angular2.default.element(transclusionSlot).replaceWith(transcludedItem)
						}
					})
				}
			}
		})
	},
	5273: function (module, exports)
	{
		module.exports = '<div\n  class="kuiLocalNav"\n  ng-show="wzKbnTopNav.isVisible()"\n  data-test-subj="top-nav"\n>\n  <!-- Top row -->\n  <div class="kuiLocalNavRow">\n    <!-- Top left corner slot, e.g. breadcrumbs, title. -->\n    <div\n      class="kuiLocalNavRow__section"\n      data-transclude-slot="topLeftCorner"\n    ></div>\n\n    <!-- Right-side: menu -->\n    <div class="kuiLocalNavRow__section">\n      <div class="kuiLocalMenu">\n\n        <!-- Time-picker "menu item" -->\n        <wz-kbn-global-timepicker></wz-kbn-global-timepicker>\n      </div>\n    </div>\n  </div>\n\n  <!-- Dropdown content, e.g. time-picker. -->\n  <div\n    class="kuiLocalDropdown"\n    ng-show="wzKbnTopNav.rendered"\n  >\n    <button class="kuiLocalDropdownCloseButton" ng-click="wzKbnTopNav.close()" aria-label="Close">\n      <span class="kuiIcon fa-chevron-circle-up"></span>\n    </button>\n    <div id="template_wrapper">\n      <!-- Content gets dynamically inserted here. -->\n    </div>\n  </div>\n\n  <div class="kuiLocalNavRow kuiLocalNavRow--secondary">\n    <!-- Bottom row slot, e.g. tabs. -->\n    <div data-transclude-slot="bottomRow"></div>\n  </div>\n</div>\n'
	},
	5274: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _extends = Object.assign || function (target)
		{
			for (var i = 1; i < arguments.length; i++)
			{
				var source = arguments[i];
				for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key])
			}
			return target
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		exports.KbnTopNavControllerProvider = KbnTopNavControllerProvider;
		var _lodash = __webpack_require__(291);
		var _chrome = __webpack_require__(9);
		var _chrome2 = _interopRequireDefault(_chrome);
		var _filter = __webpack_require__(1517);
		var _filter2 = _interopRequireDefault(_filter);
		var _interval = __webpack_require__(1518);
		var _interval2 = _interopRequireDefault(_interval);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}

		function KbnTopNavControllerProvider($compile)
		{
			return function ()
			{
				function KbnTopNavController()
				{
					var _this = this;
					var opts = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
					_classCallCheck(this, KbnTopNavController);
					this.setCurrent = function (key)
					{
						if (key && !_this.templates.hasOwnProperty(key)) throw new TypeError('KbnTopNav: unknown template key "' + key + '"');
						_this.currentKey = key || null;
						_this._render()
					};
					this.getCurrent = function ()
					{
						return _this.currentKey
					};
					this.isCurrent = function (key)
					{
						return _this.getCurrent() === key
					};
					this.open = function (key)
					{
						_this.setCurrent(key)
					};
					this.close = function (key)
					{
						(!key || _this.isCurrent(key)) && _this.setCurrent(null)
					};
					this.toggle = function (key)
					{
						_this.setCurrent(_this.isCurrent(key) ? null : key)
					};
					this.click = function (key)
					{
						_this.handleClick(_this.getItem(key))
					};
					this.getItem = function (key)
					{
						return _this.menuItems.find(function (i)
						{
							return i.key === key
						})
					};
					this.handleClick = function (menuItem)
					{
						if (menuItem.disableButton()) return false;
						menuItem.run(menuItem, _this)
					};
					if (opts instanceof KbnTopNavController) return opts;
					this.opts = [];
					this.menuItems = [];
					this.currentKey = null;
					this.templates = {
						interval: _interval2.default,
						filter: _filter2.default
					};
					this.locals = new Map;
					this.addItems(opts)
				}
				_createClass(KbnTopNavController, [
				{
					key: "isVisible",
					value: function isVisible()
					{
						return _chrome2.default.getVisible()
					}
				},
				{
					key: "addItems",
					value: function addItems(rawOpts)
					{
						var _this2 = this;
						(0, _lodash.isArray)(rawOpts) || (rawOpts = [rawOpts]);
						rawOpts.forEach(function (rawOpt)
						{
							var opt = _this2._applyOptDefault(rawOpt);
							if (!opt.key) throw new TypeError("KbnTopNav: menu items must have a key");
							_this2.opts.push(opt);
							opt.hideButton() || _this2.menuItems.push(opt);
							opt.template && (_this2.templates[opt.key] = opt.template);
							opt.locals && _this2.locals.set(opt.key, opt.locals)
						})
					}
				},
				{
					key: "_applyOptDefault",
					value: function _applyOptDefault()
					{
						var _this3 = this;
						var opt = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
						{};
						var defaultedOpt = _extends(
						{
							label: (0, _lodash.capitalize)(opt.key),
							hasFunction: !!opt.run,
							description: opt.run ? opt.key : "Toggle " + opt.key + " view",
							run: function run(item)
							{
								return _this3.toggle(item.key)
							}
						}, opt);
						defaultedOpt.hideButton = (0, _lodash.isFunction)(opt.hideButton) ? opt.hideButton : function ()
						{
							return !!opt.hideButton
						};
						defaultedOpt.disableButton = (0, _lodash.isFunction)(opt.disableButton) ? opt.disableButton : function ()
						{
							return !!opt.disableButton
						};
						defaultedOpt.tooltip = (0, _lodash.isFunction)(opt.tooltip) ? opt.tooltip : function ()
						{
							return opt.tooltip
						};
						return defaultedOpt
					}
				},
				{
					key: "_link",
					value: function _link($scope, $element)
					{
						this.$scope = $scope;
						this.$element = $element;
						this._render()
					}
				},
				{
					key: "_render",
					value: function _render()
					{
						var $scope = this.$scope,
							$element = this.$element,
							rendered = this.rendered,
							currentKey = this.currentKey;
						var templateToRender = currentKey && this.templates[currentKey];
						if (rendered)
						{
							if (rendered.key === currentKey) return;
							rendered.$childScope.$destroy();
							rendered.$el.remove();
							this.rendered = null
						}
						if (!templateToRender || !$scope || !$element) return;
						var $childScope = $scope.$new();
						this.locals.has(currentKey) && Object.assign($childScope, this.locals.get(currentKey));
						var $el = $element.find("#template_wrapper").html(templateToRender).contents();
						$compile($el)($childScope);
						this.rendered = {
							$childScope: $childScope,
							$el: $el,
							key: currentKey
						}
					}
				}]);
				return KbnTopNavController
			}()
		}
	},
	5275: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _bread_crumbs = __webpack_require__(5276);
		var _bread_crumbs2 = _interopRequireDefault(_bread_crumbs);
		var _modules = __webpack_require__(2);
		var _routes = __webpack_require__(19);
		var _routes2 = _interopRequireDefault(_routes);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		var _module = _modules.uiModules.get("kibana");
		_module.directive("wzBreadCrumbs", function ()
		{
			return {
				restrict: "E",
				replace: true,
				scope:
				{
					omitCurrentPage: "=",
					omitPages: "=",
					pageTitle: "=",
					useLinks: "="
				},
				template: _bread_crumbs2.default,
				controller: function controller($scope)
				{
					function omitPagesFilter(crumb)
					{
						return !$scope.omitPages || !$scope.omitPages.includes(crumb.id)
					}

					function omitCurrentPageFilter(crumb)
					{
						return !($scope.omitCurrentPage && crumb.current)
					}
					$scope.$watchMulti(["[]omitPages", "omitCurrentPage"], function getBreadcrumbs()
					{
						$scope.breadcrumbs = _routes2.default.getBreadcrumbs().filter(omitPagesFilter).filter(omitCurrentPageFilter)
					})
				}
			}
		})
	},
	5276: function (module, exports)
	{
		module.exports = '<div\n  class="kuiLocalBreadcrumbs"\n  data-test-subj="breadcrumbs"\n  role="heading"\n  aria-level="1"\n>\n  <div\n    class="kuiLocalBreadcrumb"\n    ng-if="useLinks"\n    ng-repeat="breadcrumb in breadcrumbs"\n  >\n    <a\n      class="kuiLocalBreadcrumb__link"\n      href="{{ breadcrumb.href }}"\n      data-test-subj="lnkBreadcrumb{{$index}}"\n    >\n      {{ breadcrumb.display}}\n    </a>\n  </div>\n\n  <div\n    class="kuiLocalBreadcrumb"\n    ng-if="!useLinks"\n    ng-repeat="breadcrumb in breadcrumbs"\n  >\n    {{ breadcrumb.display }}\n  </div>\n\n  <div\n    class="kuiLocalBreadcrumb"\n    ng-if="pageTitle"\n    data-test-subj="breadcrumbPageTitle"\n  >\n    {{ pageTitle }}\n  </div>\n</div>\n'
	},
	5277: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var _kbn_global_timepicker = __webpack_require__(5278);
		var _kbn_global_timepicker2 = _interopRequireDefault(_kbn_global_timepicker);
		var _time_navigation = __webpack_require__(5279);
		var _timefilter = __webpack_require__(27);
		var _pretty_duration = __webpack_require__(902);
		var _pretty_interval = __webpack_require__(903);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		_modules.uiModules.get("kibana").directive("wzKbnGlobalTimepicker", function (globalState, config, $rootScope)
		{
			var getConfig = function getConfig()
			{
				return config.get.apply(config, arguments)
			};
			var listenForUpdates = function listenForUpdates($scope)
			{
				$scope.$listenAndDigestAsync(_timefilter.timefilter, "refreshIntervalUpdate", function ()
				{
					setTimefilterValues($scope)
				});
				$scope.$listenAndDigestAsync(_timefilter.timefilter, "timeUpdate", function ()
				{
					setTimefilterValues($scope)
				});
				$scope.$listenAndDigestAsync(_timefilter.timefilter, "enabledUpdated", function ()
				{
					setTimefilterValues($scope)
				})
			};

			function setTimefilterValues($scope)
			{
				$rootScope.$broadcast("updateVis");
				var time = _timefilter.timefilter.getTime();
				var refreshInterval = _timefilter.timefilter.getRefreshInterval();
				$scope.timefilterValues = {
					refreshInterval: refreshInterval,
					time: time,
					display:
					{
						time: (0, _pretty_duration.prettyDuration)(time.from, time.to, getConfig),
						refreshInterval: (0, _pretty_interval.prettyInterval)(refreshInterval.value)
					},
					isAutoRefreshSelectorEnabled: _timefilter.timefilter.isAutoRefreshSelectorEnabled,
					isTimeRangeSelectorEnabled: _timefilter.timefilter.isTimeRangeSelectorEnabled
				}
			}
			return {
				template: _kbn_global_timepicker2.default,
				replace: true,
				require: "^wzKbnTopNav",
				link: function link($scope, element, attributes, wzKbnTopNav)
				{
					listenForUpdates($scope);
					setTimefilterValues($scope);
					$scope.toggleRefresh = function ()
					{
						_timefilter.timefilter.toggleRefresh()
					};
					$scope.forward = function ()
					{
						_timefilter.timefilter.setTime(_time_navigation.timeNavigation.stepForward(_timefilter.timefilter.getBounds()))
					};
					$scope.back = function ()
					{
						_timefilter.timefilter.setTime(_time_navigation.timeNavigation.stepBackward(_timefilter.timefilter.getBounds()))
					};
					$scope.updateFilter = function (from, to, mode)
					{
						_timefilter.timefilter.setTime(
						{
							from: from,
							to: to,
							mode: mode
						});
						wzKbnTopNav.close("filter")
					};
					$scope.updateInterval = function (interval)
					{
						_timefilter.timefilter.setRefreshInterval(interval);
						wzKbnTopNav.close("interval")
					};
					$scope.getSharedTimeFilterFromDate = function ()
					{
						return _timefilter.timefilter.isAutoRefreshSelectorEnabled || _timefilter.timefilter.isTimeRangeSelectorEnabled ? _timefilter.timefilter.getBounds().min.clone().utc().format() : null
					};
					$scope.getSharedTimeFilterToDate = function ()
					{
						return _timefilter.timefilter.isAutoRefreshSelectorEnabled || _timefilter.timefilter.isTimeRangeSelectorEnabled ? _timefilter.timefilter.getBounds().max.clone().utc().format() : null
					}
				}
			}
		})
	},
	5278: function (module, exports)
	{
		module.exports = '<div\n  ng-show="timefilterValues.isAutoRefreshSelectorEnabled || timefilterValues.isTimeRangeSelectorEnabled"\n  data-shared-timefilter-from="{{ getSharedTimeFilterFromDate() }}"\n  data-shared-timefilter-to="{{ getSharedTimeFilterToDate() }}"\n  class="kuiLocalMenu"\n  data-test-subj="globalTimepicker"\n>\n  <button\n    class="kuiLocalMenuItem"\n    aria-label="{{ timefilterValues.refreshInterval.pause ? \'Resume refreshing data\' : \'Pause refreshing data\' }}"\n    ng-click="toggleRefresh()"\n    ng-show="timefilterValues.isAutoRefreshSelectorEnabled && (timefilterValues.refreshInterval.value > 0)"\n    data-test-subj="globalTimepickerAutoRefreshButton"\n    data-test-subj-state="{{ timefilterValues.refreshInterval.pause ? \'inactive\' : \'active\' }}"\n  >\n    <span\n      class="kuiIcon"\n      aria-hidden="true"\n      ng-class="timefilterValues.refreshInterval.pause ? \'fa-play\' : \'fa-pause\'"\n    ></span>\n  </button>\n\n  <button\n    class="kuiLocalMenuItem navbar-timepicker-auto-refresh-desc"\n    ng-class="{\'kuiLocalMenuItem-isSelected\': wzKbnTopNav.isCurrent(\'interval\') }"\n    ng-show="timefilterValues.isAutoRefreshSelectorEnabled"\n    ng-click="wzKbnTopNav.toggle(\'interval\')"\n  >\n    <span ng-show="timefilterValues.refreshInterval.value === 0">\n      <span aria-hidden="true" class="kuiIcon fa-repeat"></span> Auto-refresh\n    </span>\n\n    <span\n      ng-show="timefilterValues.refreshInterval.value > 0"\n      aria-label="Data will refresh every {{timefilterValues.display.refreshInterval}}"\n    >\n      {{ timefilterValues.display.refreshInterval }}\n    </span>\n  </button>\n\n  <button\n    ng-show="timefilterValues.isTimeRangeSelectorEnabled"\n    class="kuiLocalMenuItem"\n    ng-click="back()"\n    aria-label="Move backward in time"\n  >\n    <span\n      class="kuiIcon fa-chevron-left"\n      aria-hidden="true"\n      tooltip="Move backward in time"\n    ></span>\n  </button>\n\n  <button\n    ng-show="timefilterValues.isTimeRangeSelectorEnabled"\n    data-test-subj="globalTimepickerButton"\n    class="kuiLocalMenuItem navbar-timepicker-time-desc"\n    ng-class="{\'kuiLocalMenuItem-isSelected\': wzKbnTopNav.isCurrent(\'filter\')}"\n    ng-click="wzKbnTopNav.toggle(\'filter\')"\n    aria-label="Open time range picker"\n    aria-haspopup="true"\n  >\n    <span aria-hidden="true" class="kuiIcon fa-clock-o"></span>\n    <span\n      aria-label="Current time range is {{timefilterValues.display.time}}"\n      data-test-subj="globalTimepickerRange"\n    >\n      {{timefilterValues.display.time}}\n    </span>\n  </button>\n\n  <button\n    ng-show="timefilterValues.isTimeRangeSelectorEnabled"\n    class="kuiLocalMenuItem"\n    ng-click="forward()"\n    aria-label="Move forward in time"\n  >\n    <span\n      aria-hidden="true"\n      class="kuiIcon fa-chevron-right"\n      tooltip="Move forward in time"\n    ></span>\n  </button>\n</div>\n'
	},
	5279: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.timeNavigation = void 0;
		var _moment = __webpack_require__(15);
		var _moment2 = _interopRequireDefault(_moment);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		exports.timeNavigation = {
			stepForward: function stepForward(_ref)
			{
				var min = _ref.min,
					max = _ref.max;
				var diff = max.diff(min);
				return {
					from: (0, _moment2.default)(max).add(1, "ms").toISOString(),
					to: (0, _moment2.default)(max).add(diff + 1, "ms").toISOString(),
					mode: "absolute"
				}
			},
			stepBackward: function stepBackward(_ref2)
			{
				var min = _ref2.min,
					max = _ref2.max;
				var diff = max.diff(min);
				return {
					from: (0, _moment2.default)(min).subtract(diff + 1, "ms").toISOString(),
					to: (0, _moment2.default)(min).subtract(1, "ms").toISOString(),
					mode: "absolute"
				}
			},
			zoomOut: function zoomOut(_ref3)
			{
				var min = _ref3.min,
					max = _ref3.max;
				var diff = max.diff(min);
				return {
					from: (0, _moment2.default)(min).subtract(diff / 2, "ms").toISOString(),
					to: (0, _moment2.default)(max).add(diff / 2, "ms").toISOString(),
					mode: "absolute"
				}
			},
			zoomIn: function zoomIn(_ref4)
			{
				var min = _ref4.min,
					max = _ref4.max;
				var diff = max.diff(min);
				return {
					from: (0, _moment2.default)(min).add(diff / 4, "ms").toISOString(),
					to: (0, _moment2.default)(max).subtract(diff / 4, "ms").toISOString(),
					mode: "absolute"
				}
			}
		}
	},
	5280: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _errorHandler = __webpack_require__(5281);
		__webpack_require__(5282);
		var _apiRequest = __webpack_require__(5283);
		var _genericRequest = __webpack_require__(5284);
		var _appState = __webpack_require__(5285);
		var _apiTester = __webpack_require__(5286);
		var _patternHandler = __webpack_require__(5287);
		__webpack_require__(5288);
		var _csvRequest = __webpack_require__(5315);
		var _commonData = __webpack_require__(5316);
		var _reporting = __webpack_require__(5317);
		var _visFactoryHandler = __webpack_require__(5318);
		__webpack_require__(5319);
		__webpack_require__(5320);
		var _modules = __webpack_require__(2);
		var _groupHandler = __webpack_require__(5321);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.service("errorHandler", _errorHandler.ErrorHandler).service("apiReq", _apiRequest.ApiRequest).service("genericReq", _genericRequest.GenericRequest).service("appState", _appState.AppState).service("testAPI", _apiTester.ApiTester).service("patternHandler", _patternHandler.PatternHandler).service("csvReq", _csvRequest.CSVRequest).service("commonData", _commonData.CommonData).service("reportingService", _reporting.ReportingService).service("visFactoryService", _visFactoryHandler.VisFactoryService).service("groupHandler", _groupHandler.GroupHandler)
	},
	5281: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.ErrorHandler = void 0;
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _notify = __webpack_require__(10);

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ErrorHandler = function ()
		{
			function ErrorHandler()
			{
				_classCallCheck(this, ErrorHandler)
			}
			_createClass(ErrorHandler, [
			{
				key: "extractMessage",
				value: function extractMessage(error)
				{
					if (-1 === (error ||
						{}).status)
					{
						var isFromAPI = "/api/request" === ((error ||
						{}).config ||
						{}).url;
						return isFromAPI ? "Wazuh API don't reachable. Reason: timeout." : "Server did not respond"
					}
					if ((((error ||
						{}).data ||
						{}).errorData ||
						{}).message) return error.data.errorData.message;
					if (((error ||
						{}).errorData ||
						{}).message) return error.errorData.message;
					if ("string" === typeof (error ||
						{}).data) return error.data;
					if ("string" === typeof ((error ||
						{}).data ||
						{}).error) return error.data.error;
					if ("string" === typeof ((error ||
						{}).data ||
						{}).message) return error.data.message;
					if ("string" === typeof (((error ||
						{}).data ||
						{}).message ||
						{}).msg) return error.data.message.msg;
					if ("string" === typeof ((error ||
						{}).data ||
						{}).data) return error.data.data;
					if ("string" === typeof error.message) return error.message;
					if (((error ||
						{}).message ||
						{}).msg) return error.message.msg;
					if ("string" === typeof error) return error;
					if ("object" === ("undefined" === typeof error ? "undefined" : _typeof(error))) return JSON.stringify(error);
					return error || "Unexpected error"
				}
			},
			{
				key: "info",
				value: function info(message, location)
				{
					if ("string" === typeof message)
					{
						message = location ? location + ". " + message : message;
						_notify.toastNotifications.addSuccess(message)
					}
					return
				}
			},
			{
				key: "handle",
				value: function handle(error, location, isWarning, silent)
				{
					var message = this.extractMessage(error);
					var text = message;
					error.extraMessage && (text = error.extraMessage);
					text = location ? location + ". " + text : text;
					silent || (isWarning || text && "string" === typeof text && text.toLowerCase().includes("no results") ? _notify.toastNotifications.addWarning(text) : _notify.toastNotifications.addDanger(text));
					return text
				}
			}]);
			return ErrorHandler
		}()
	},
	5282: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		_modules.uiModules.get("app/wazuh", []).config(function ($mdThemingProvider)
		{
			var kibanaWhiteBlack = {
				50: "#ffffff",
				100: "#ffffff",
				200: "#ffffff",
				300: "#ffffff",
				400: "#fafafa",
				500: "#ecf0f1",
				600: "#dde4e6",
				700: "#cfd9db",
				800: "#c0cdd1",
				900: "#000000",
				A100: "#ffffff",
				A200: "#ffffff",
				A400: "#ffffff",
				A700: "#a3b6bb"
			};
			$mdThemingProvider.definePalette("kibanaWhiteBlack", kibanaWhiteBlack);
			var kibanaBlue = {
				50: "#a4d9ea",
				100: "#8fd0e5",
				200: "#7ac8e0",
				300: "#65bfdc",
				400: "#51b7d7",
				500: "#3caed2",
				600: "#2ea2c7",
				700: "#2991b2",
				800: "#24809d",
				900: "#206f88",
				A100: "#b8e2ef",
				A200: "#cdeaf3",
				A400: "#e2f3f8",
				A700: "#1b5e74",
				contrastDefaultColor: "dark"
			};
			$mdThemingProvider.definePalette("kibanaBlue", kibanaBlue);
			$mdThemingProvider.theme("default").primaryPalette("blue-grey",
			{
				default: "100",
				"hue-1": "300",
				"hue-2": "500",
				"hue-3": "700"
			}).accentPalette("kibanaBlue",
			{
				default: "500",
				"hue-1": "800",
				"hue-2": "300",
				"hue-3": "100"
			}).warnPalette("amber",
			{
				default: "300",
				"hue-1": "500",
				"hue-2": "700",
				"hue-3": "900"
			}).backgroundPalette("kibanaWhiteBlack",
			{
				default: "50",
				"hue-1": "50",
				"hue-2": "600",
				"hue-3": "900"
			})
		})
	},
	5283: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ApiRequest = function ()
		{
			function ApiRequest($q, genericReq, appState)
			{
				_classCallCheck(this, ApiRequest);
				this.$q = $q;
				this.genericReq = genericReq;
				this.appState = appState
			}
			_createClass(ApiRequest, [
			{
				key: "request",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(method, path, body)
					{
						var _JSON$parse, id, requestData, data;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								if (!(!method || !path || !body))
								{
									_context.next = 3;
									break
								}
								throw new Error("Missing parameters");
							case 3:
								if (this.appState.getCurrentAPI())
								{
									_context.next = 5;
									break
								}
								throw new Error("No API selected.");
							case 5:
								_JSON$parse = JSON.parse(this.appState.getCurrentAPI()), id = _JSON$parse.id;
								requestData = {
									method: method,
									path: path,
									body: body,
									id: id
								};
								_context.next = 9;
								return this.genericReq.request("POST", "/api/request", requestData);
							case 9:
								data = _context.sent;
								if (!data.error)
								{
									_context.next = 12;
									break
								}
								throw new Error(data.error);
							case 12:
								return _context.abrupt("return", this.$q.resolve(data));
							case 15:
								_context.prev = 15;
								_context.t0 = _context["catch"](0);
								return _context.abrupt("return", ((_context.t0 ||
								{}).data ||
								{}).message || false ? this.$q.reject(_context.t0.data.message) : this.$q.reject(_context.t0.message || _context.t0));
							case 18:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 15]
						])
					}));

					function request(_x, _x2, _x3)
					{
						return _ref.apply(this, arguments)
					}
					return request
				}()
			}]);
			return ApiRequest
		}()
	},
	5284: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.GenericRequest = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _chrome = __webpack_require__(9);
		var _chrome2 = _interopRequireDefault(_chrome);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.GenericRequest = function ()
		{
			function GenericRequest($q, $http, appState, wazuhConfig)
			{
				_classCallCheck(this, GenericRequest);
				this.$q = $q;
				this.$http = $http;
				this.appState = appState;
				this.wazuhConfig = wazuhConfig
			}
			_createClass(GenericRequest, [
			{
				key: "request",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(method, path)
					{
						var payload = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
						var _wazuhConfig$getConfi, timeout, requestHeaders, tmpUrl, data;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								if (!(!method || !path))
								{
									_context.next = 3;
									break
								}
								throw new Error("Missing parameters");
							case 3:
								_wazuhConfig$getConfi = this.wazuhConfig.getConfig(), timeout = _wazuhConfig$getConfi.timeout;
								requestHeaders = {
									headers:
									{
										"Content-Type": "application/json"
									},
									timeout: timeout || 8e3
								};
								tmpUrl = _chrome2.default.addBasePath(path);
								requestHeaders.headers.pattern = this.appState.getCurrentPattern();
								try
								{
									requestHeaders.headers.id = JSON.parse(this.appState.getCurrentAPI()).id
								}
								catch (error)
								{}
								data = {};
								if (!("GET" === method))
								{
									_context.next = 16;
									break
								}
								_context.t0 = Object;
								_context.t1 = data;
								_context.next = 14;
								return this.$http.get(tmpUrl, requestHeaders);
							case 14:
								_context.t2 = _context.sent;
								_context.t0.assign.call(_context.t0, _context.t1, _context.t2);
							case 16:
								if (!("PUT" === method))
								{
									_context.next = 23;
									break
								}
								_context.t3 = Object;
								_context.t4 = data;
								_context.next = 21;
								return this.$http.put(tmpUrl, payload, requestHeaders);
							case 21:
								_context.t5 = _context.sent;
								_context.t3.assign.call(_context.t3, _context.t4, _context.t5);
							case 23:
								if (!("POST" === method))
								{
									_context.next = 30;
									break
								}
								_context.t6 = Object;
								_context.t7 = data;
								_context.next = 28;
								return this.$http.post(tmpUrl, payload, requestHeaders);
							case 28:
								_context.t8 = _context.sent;
								_context.t6.assign.call(_context.t6, _context.t7, _context.t8);
							case 30:
								if (!("DELETE" === method))
								{
									_context.next = 37;
									break
								}
								_context.t9 = Object;
								_context.t10 = data;
								_context.next = 35;
								return this.$http.delete(tmpUrl);
							case 35:
								_context.t11 = _context.sent;
								_context.t9.assign.call(_context.t9, _context.t10, _context.t11);
							case 37:
								if (data)
								{
									_context.next = 39;
									break
								}
								throw new Error("Error doing a request to " + tmpUrl + ", method: " + method + ".");
							case 39:
								if (!(data.error && "0" !== data.error))
								{
									_context.next = 41;
									break
								}
								throw new Error(data.error);
							case 41:
								return _context.abrupt("return", this.$q.resolve(data));
							case 44:
								_context.prev = 44;
								_context.t12 = _context["catch"](0);
								return _context.abrupt("return", this.$q.reject(_context.t12));
							case 47:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 44]
						])
					}));

					function request(_x2, _x3)
					{
						return _ref.apply(this, arguments)
					}
					return request
				}()
			}]);
			return GenericRequest
		}()
	},
	5285: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.AppState = function ()
		{
			function AppState($cookies, $window)
			{
				_classCallCheck(this, AppState);
				this.$cookies = $cookies;
				this.$window = $window
			}
			_createClass(AppState, [
			{
				key: "getExtensions",
				value: function getExtensions(id)
				{
					var current = this.$cookies.getObject("extensions");
					return !!current && current[id]
				}
			},
			{
				key: "setExtensions",
				value: function setExtensions(id, extensions)
				{
					var current = this.$cookies.getObject("extensions") ||
					{};
					current[id] = extensions;
					var exp = new Date;
					exp.setDate(exp.getDate() + 365);
					extensions && this.$cookies.putObject("extensions", current,
					{
						expires: exp
					})
				}
			},
			{
				key: "getClusterInfo",
				value: function getClusterInfo()
				{
					return this.$cookies.getObject("_clusterInfo")
				}
			},
			{
				key: "removeClusterInfo",
				value: function removeClusterInfo()
				{
					return this.$cookies.remove("_clusterInfo")
				}
			},
			{
				key: "setClusterInfo",
				value: function setClusterInfo(cluster_info)
				{
					var exp = new Date;
					exp.setDate(exp.getDate() + 365);
					cluster_info && this.$cookies.putObject("_clusterInfo", cluster_info,
					{
						expires: exp
					})
				}
			},
			{
				key: "setCreatedAt",
				value: function setCreatedAt(date)
				{
					var exp = new Date;
					exp.setDate(exp.getDate() + 365);
					this.$cookies.putObject("_createdAt", date,
					{
						expires: exp
					})
				}
			},
			{
				key: "getCreatedAt",
				value: function getCreatedAt()
				{
					return this.$cookies.getObject("_createdAt")
				}
			},
			{
				key: "removeCreatedAt",
				value: function removeCreatedAt()
				{
					return this.$cookies.remove("_createdAt")
				}
			},
			{
				key: "getCurrentAPI",
				value: function getCurrentAPI()
				{
					return this.$cookies.getObject("API")
				}
			},
			{
				key: "removeCurrentAPI",
				value: function removeCurrentAPI()
				{
					return this.$cookies.remove("API")
				}
			},
			{
				key: "setCurrentAPI",
				value: function setCurrentAPI(API)
				{
					var exp = new Date;
					exp.setDate(exp.getDate() + 365);
					API && this.$cookies.putObject("API", API,
					{
						expires: exp
					})
				}
			},
			{
				key: "getPatternSelector",
				value: function getPatternSelector()
				{
					return this.$cookies.getObject("patternSelector")
				}
			},
			{
				key: "setPatternSelector",
				value: function setPatternSelector(value)
				{
					this.$cookies.putObject("patternSelector", value)
				}
			},
			{
				key: "setCurrentPattern",
				value: function setCurrentPattern(newPattern)
				{
					var exp = new Date;
					exp.setDate(exp.getDate() + 365);
					newPattern && this.$cookies.putObject("_currentPattern", newPattern,
					{
						expires: exp
					})
				}
			},
			{
				key: "getCurrentPattern",
				value: function getCurrentPattern()
				{
					return this.$cookies.getObject("_currentPattern")
				}
			},
			{
				key: "removeCurrentPattern",
				value: function removeCurrentPattern()
				{
					return this.$cookies.remove("_currentPattern")
				}
			},
			{
				key: "setCurrentDevTools",
				value: function setCurrentDevTools(current)
				{
					this.$window.localStorage.setItem("currentDevTools", current)
				}
			},
			{
				key: "getCurrentDevTools",
				value: function getCurrentDevTools()
				{
					return this.$window.localStorage.getItem("currentDevTools")
				}
			},
			{
				key: "setSessionStorageItem",
				value: function setSessionStorageItem(key, value)
				{
					this.$window.sessionStorage.setItem(key, value)
				}
			},
			{
				key: "getSessionStorageItem",
				value: function getSessionStorageItem(key)
				{
					return this.$window.sessionStorage.getItem(key)
				}
			},
			{
				key: "removeSessionStorageItem",
				value: function removeSessionStorageItem(key)
				{
					this.$window.sessionStorage.removeItem(key)
				}
			}]);
			return AppState
		}()
	},
	5286: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.ApiTester = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _chrome = __webpack_require__(9);
		var _chrome2 = _interopRequireDefault(_chrome);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ApiTester = function ()
		{
			function ApiTester($http, appState, wzMisc, wazuhConfig)
			{
				_classCallCheck(this, ApiTester);
				this.$http = $http;
				this.appState = appState;
				this.wzMisc = wzMisc;
				this.wazuhConfig = wazuhConfig
			}
			_createClass(ApiTester, [
			{
				key: "checkStored",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(data)
					{
						var configuration, timeout, headers, current, lastRestart, result;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								configuration = this.wazuhConfig.getConfig();
								timeout = configuration ? configuration.timeout : 8e3;
								headers = {
									headers:
									{
										"Content-Type": "application/json"
									},
									timeout: timeout || 8e3
								};
								current = this.appState.getCreatedAt();
								lastRestart = this.wzMisc.getLastRestart();
								if (!(current && lastRestart && lastRestart > current))
								{
									_context.next = 16;
									break
								}
								this.appState.removeCurrentPattern();
								this.appState.removeCurrentAPI();
								this.appState.removeClusterInfo();
								this.appState.removeCreatedAt();
								this.wzMisc.setLastRestart(null);
								this.appState.setPatternSelector(configuration["ip.selector"]);
								return _context.abrupt("return", "cookies_outdated");
							case 16:
								_context.next = 18;
								return this.$http.post(_chrome2.default.addBasePath("/api/check-stored-api"), data, headers);
							case 18:
								result = _context.sent;
								this.appState.setPatternSelector(configuration["ip.selector"]);
								if (!result.error)
								{
									_context.next = 22;
									break
								}
								return _context.abrupt("return", Promise.reject(result));
							case 22:
								return _context.abrupt("return", result);
							case 23:
								_context.next = 29;
								break;
							case 25:
								_context.prev = 25;
								_context.t0 = _context["catch"](0);
								_context.t0.status && -1 === _context.t0.status && this.wzMisc.setApiIsDown(true);
								return _context.abrupt("return", Promise.reject(_context.t0));
							case 29:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 25]
						])
					}));

					function checkStored(_x)
					{
						return _ref.apply(this, arguments)
					}
					return checkStored
				}()
			},
			{
				key: "check",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(data)
					{
						var _wazuhConfig$getConfi, timeout, headers, url, response;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								_wazuhConfig$getConfi = this.wazuhConfig.getConfig(), timeout = _wazuhConfig$getConfi.timeout;
								headers = {
									headers:
									{
										"Content-Type": "application/json"
									},
									timeout: timeout || 8e3
								};
								url = _chrome2.default.addBasePath("/api/check-api");
								_context2.next = 6;
								return this.$http.post(url, data, headers);
							case 6:
								response = _context2.sent;
								if (!response.error)
								{
									_context2.next = 9;
									break
								}
								return _context2.abrupt("return", Promise.reject(response));
							case 9:
								return _context2.abrupt("return", response);
							case 12:
								_context2.prev = 12;
								_context2.t0 = _context2["catch"](0);
								return _context2.abrupt("return", Promise.reject(_context2.t0));
							case 15:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 12]
						])
					}));

					function check(_x2)
					{
						return _ref2.apply(this, arguments)
					}
					return check
				}()
			}]);
			return ApiTester
		}()
	},
	5287: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.PatternHandler = function ()
		{
			function PatternHandler($location, genericReq, appState, errorHandler, wzMisc)
			{
				_classCallCheck(this, PatternHandler);
				this.$location = $location;
				this.genericReq = genericReq;
				this.appState = appState;
				this.errorHandler = errorHandler;
				this.wzMisc = wzMisc
			}
			_createClass(PatternHandler, [
			{
				key: "getPatternList",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var _this = this;
						var patternList, filtered;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return this.genericReq.request("GET", "/elastic/index-patterns",
								{});
							case 3:
								patternList = _context.sent;
								if (patternList.data.data.length)
								{
									_context.next = 9;
									break
								}
								this.wzMisc.setBlankScr("Sorry but no valid index patterns were found");
								this.$location.search("tab", null);
								this.$location.path("/blank-screen");
								return _context.abrupt("return");
							case 9:
								if (this.appState.getCurrentPattern())
								{
									filtered = patternList.data.data.filter(function (item)
									{
										return item.id.includes(_this.appState.getCurrentPattern())
									});
									filtered.length || this.appState.setCurrentPattern(patternList.data.data[0].id)
								}
								return _context.abrupt("return", patternList.data.data);
							case 13:
								_context.prev = 13;
								_context.t0 = _context["catch"](0);
								this.errorHandler.handle(_context.t0, "Pattern Handler (getPatternList)");
							case 16:
								return _context.abrupt("return");
							case 17:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 13]
						])
					}));

					function getPatternList()
					{
						return _ref.apply(this, arguments)
					}
					return getPatternList
				}()
			},
			{
				key: "changePattern",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(selectedPattern)
					{
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								this.appState.setCurrentPattern(selectedPattern);
								_context2.next = 4;
								return this.genericReq.request("GET", "/elastic/known-fields/" + selectedPattern,
								{});
							case 4:
								return _context2.abrupt("return", this.appState.getCurrentPattern());
							case 7:
								_context2.prev = 7;
								_context2.t0 = _context2["catch"](0);
								this.errorHandler.handle(_context2.t0, "Pattern Handler (changePattern)");
							case 10:
								return _context2.abrupt("return");
							case 11:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 7]
						])
					}));

					function changePattern(_x)
					{
						return _ref2.apply(this, arguments)
					}
					return changePattern
				}()
			}]);
			return PatternHandler
		}()
	},
	5288: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _routes = __webpack_require__(19);
		var _routes2 = _interopRequireDefault(_routes);
		var _resolves = __webpack_require__(5289);
		var _healthCheck = __webpack_require__(5295);
		var _healthCheck2 = _interopRequireDefault(_healthCheck);
		var _agents = __webpack_require__(5296);
		var _agents2 = _interopRequireDefault(_agents);
		var _agentsPrev = __webpack_require__(5300);
		var _agentsPrev2 = _interopRequireDefault(_agentsPrev);
		var _management = __webpack_require__(5301);
		var _management2 = _interopRequireDefault(_management);
		var _overview = __webpack_require__(5310);
		var _overview2 = _interopRequireDefault(_overview);
		var _discover = __webpack_require__(5311);
		var _discover2 = _interopRequireDefault(_discover);
		var _settings = __webpack_require__(5312);
		var _settings2 = _interopRequireDefault(_settings);
		var _blankScreen = __webpack_require__(5313);
		var _blankScreen2 = _interopRequireDefault(_blankScreen);
		var _devTools = __webpack_require__(5314);
		var _devTools2 = _interopRequireDefault(_devTools);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		var assignPreviousLocation = function assignPreviousLocation($rootScope, $location)
		{
			var path = $location.path();
			path.includes("/health-check") || ($rootScope.previousLocation = path)
		};

		function ip(indexPatterns, $q, $rootScope, $window, $location, Private, appState, genericReq, errorHandler, wzMisc)
		{
			assignPreviousLocation($rootScope, $location);
			return (0, _resolves.getIp)(indexPatterns, $q, $window, $location, Private, appState, genericReq, errorHandler, wzMisc)
		}

		function nestedResolve($q, genericReq, errorHandler, wazuhConfig, $rootScope, $location, $window, testAPI, appState, wzMisc)
		{
			assignPreviousLocation($rootScope, $location);
			var location = $location.path();
			return (0, _resolves.getWzConfig)($q, genericReq, errorHandler, wazuhConfig).then(function ()
			{
				return (0, _resolves.settingsWizard)($location, $q, $window, testAPI, appState, genericReq, errorHandler, wzMisc, wazuhConfig, location && location.includes("/health-check"))
			})
		}

		function savedSearch(redirectWhenMissing, $location, $window, $rootScope, savedSearches, $route)
		{
			assignPreviousLocation($rootScope, $location);
			return (0, _resolves.getSavedSearch)(redirectWhenMissing, $location, $window, savedSearches, $route)
		}

		function wzConfig($q, genericReq, errorHandler, wazuhConfig, $rootScope, $location)
		{
			assignPreviousLocation($rootScope, $location);
			return (0, _resolves.getWzConfig)($q, genericReq, errorHandler, wazuhConfig)
		}

		function wzKibana($location, $window, $rootScope)
		{
			assignPreviousLocation($rootScope, $location);
			return (0, _resolves.goToKibana)($location, $window)
		}

		function clearRuleId(commonData)
		{
			commonData.removeRuleId();
			return Promise.resolve()
		}
		_routes2.default.enable();
		_routes2.default.when("/health-check",
		{
			template: _healthCheck2.default,
			resolve:
			{
				nestedResolve: nestedResolve,
				ip: ip
			}
		}).when("/agents/:id?/:tab?/:view?",
		{
			template: _agents2.default,
			resolve:
			{
				nestedResolve: nestedResolve,
				ip: ip,
				savedSearch: savedSearch
			}
		}).when("/agents-preview/:tab?/",
		{
			template: _agentsPrev2.default,
			resolve:
			{
				nestedResolve: nestedResolve
			}
		}).when("/manager/:tab?/",
		{
			template: _management2.default,
			resolve:
			{
				nestedResolve: nestedResolve,
				ip: ip,
				savedSearch: savedSearch,
				clearRuleId: clearRuleId
			}
		}).when("/overview/",
		{
			template: _overview2.default,
			resolve:
			{
				nestedResolve: nestedResolve,
				ip: ip,
				savedSearch: savedSearch
			}
		}).when("/wazuh-discover/",
		{
			template: _discover2.default,
			resolve:
			{
				nestedResolve: nestedResolve,
				ip: ip,
				savedSearch: savedSearch
			}
		}).when("/settings/:tab?/",
		{
			template: _settings2.default,
			resolve:
			{
				wzConfig: wzConfig
			}
		}).when("/visualize/create?",
		{
			redirectTo: function redirectTo()
			{},
			resolve:
			{
				wzConfig: wzConfig,
				wzKibana: wzKibana
			}
		}).when("/context/:pattern?/:type?/:id?",
		{
			redirectTo: function redirectTo()
			{},
			resolve:
			{
				wzKibana: wzKibana
			}
		}).when("/doc/:pattern?/:index?/:type?/:id?",
		{
			redirectTo: function redirectTo()
			{},
			resolve:
			{
				wzKibana: wzKibana
			}
		}).when("/wazuh-dev",
		{
			template: _devTools2.default,
			resolve:
			{
				nestedResolve: nestedResolve
			}
		}).when("/blank-screen",
		{
			template: _blankScreen2.default,
			resolve:
			{
				wzConfig: wzConfig
			}
		}).when("/",
		{
			redirectTo: "/overview/"
		}).when("",
		{
			redirectTo: "/overview/"
		}).otherwise(
		{
			redirectTo: "/overview/"
		})
	},
	5289: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.getWzConfig = exports.totalRAM = exports.getIp = exports.goToKibana = exports.getSavedSearch = exports.settingsWizard = exports.healthCheck = exports.checkTimestamp = void 0;
		var _checkTimestamp = __webpack_require__(1686);
		var _healthCheck = __webpack_require__(645);
		var _settingsWizard = __webpack_require__(5290);
		var _getSavedSearch = __webpack_require__(5291);
		var _goToKibana = __webpack_require__(5292);
		var _getIp = __webpack_require__(5293);
		var _checkRam = __webpack_require__(1687);
		var _getConfig = __webpack_require__(5294);
		exports.checkTimestamp = _checkTimestamp.checkTimestamp;
		exports.healthCheck = _healthCheck.healthCheck;
		exports.settingsWizard = _settingsWizard.settingsWizard;
		exports.getSavedSearch = _getSavedSearch.getSavedSearch;
		exports.goToKibana = _goToKibana.goToKibana;
		exports.getIp = _getIp.getIp;
		exports.totalRAM = _checkRam.totalRAM;
		exports.getWzConfig = _getConfig.getWzConfig
	},
	5290: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.settingsWizard = settingsWizard;
		var _checkTimestamp = __webpack_require__(1686);
		var _healthCheck = __webpack_require__(645);
		var _checkRam = __webpack_require__(1687);

		function settingsWizard($location, $q, $window, testAPI, appState, genericReq, errorHandler, wzMisc, wazuhConfig)
		{
			var disableErrors = arguments.length > 9 && void 0 !== arguments[9] && arguments[9];
			try
			{
				var deferred = $q.defer();
				!disableErrors && (0, _checkRam.totalRAM)(genericReq, errorHandler);
				var checkResponse = function checkResponse(data)
				{
					var fromElastic = false;
					if (2 === parseInt(data.data.error)) !disableErrors && errorHandler.handle("Wazuh App: Please set up Wazuh API credentials.", "Routes", true);
					else if (JSON.stringify(data).includes("socket hang up") || ((data ||
						{}).data ||
						{}).apiIsDown || (((data ||
						{}).data ||
						{}).data ||
						{}).apiIsDown)
					{
						wzMisc.setApiIsDown(true);
						!disableErrors && errorHandler.handle("Wazuh RESTful API seems to be down.", "Routes")
					}
					else
					{
						fromElastic = true;
						wzMisc.setBlankScr(errorHandler.handle(data, "Routes"));
						appState.removeCurrentAPI()
					}
					if (fromElastic)
						if (500 === parseInt(((data ||
							{}).data ||
							{}).statusCode) && 7 === parseInt(((data ||
							{}).data ||
							{}).error) && "401 Unauthorized" === ((data ||
							{}).data ||
							{}).message)
						{
							!disableErrors && errorHandler.handle("Wrong Wazuh API credentials, please add a new API and/or modify the existing one.", "Routes");
							$location.search("_a", null);
							$location.search("tab", "api");
							$location.path("/settings")
						}
					else $location.path("/blank-screen");
					else
					{
						wzMisc.setWizard(true);
						if (!$location.path().includes("/settings"))
						{
							$location.search("_a", null);
							$location.search("tab", "api");
							$location.path("/settings")
						}
					}
					deferred.reject()
				};
				var changeCurrentApi = function changeCurrentApi(data)
				{
					var currentApi = false;
					try
					{
						currentApi = JSON.parse(appState.getCurrentAPI()).id
					}
					catch (error)
					{
						console.log("Error parsing JSON (settingsWizards.changeCurrentApi)")
					}
					var clusterInfo = data.data.data.cluster_info;
					var str = "disabled" === clusterInfo.status ? JSON.stringify(
					{
						name: clusterInfo.manager,
						id: currentApi
					}) : JSON.stringify(
					{
						name: clusterInfo.cluster,
						id: currentApi
					});
					appState.setCurrentAPI(str);
					appState.setClusterInfo(clusterInfo)
				};
				var callCheckStored = function callCheckStored()
				{
					var config = wazuhConfig.getConfig();
					var currentApi = false;
					try
					{
						currentApi = JSON.parse(appState.getCurrentAPI()).id
					}
					catch (error)
					{
						console.log("Error parsing JSON (settingsWizards.callCheckStored 1)")
					}
					if (currentApi && !appState.getExtensions(currentApi))
					{
						var extensions = {
							audit: config["extensions.audit"],
							pci: config["extensions.pci"],
							gdpr: config["extensions.gdpr"],
							oscap: config["extensions.oscap"],
							ciscat: config["extensions.ciscat"],
							aws: config["extensions.aws"],
							virustotal: config["extensions.virustotal"],
							osquery: config["extensions.osquery"]
						};
						appState.setExtensions(currentApi, extensions)
					}(0, _checkTimestamp.checkTimestamp)(appState, genericReq, $location, wzMisc).then(function ()
					{
						return testAPI.checkStored(currentApi)
					}).then(function (data)
					{
						if (data && "cookies_outdated" === data)
						{
							$location.search("tab", "welcome");
							$location.path("/overview")
						}
						else if (data.data.error || data.data.data.apiIsDown) checkResponse(data);
						else
						{
							if (((data ||
								{}).data ||
								{}).idChanged)
							{
								var apiRaw = false;
								try
								{
									apiRaw = JSON.parse(appState.getCurrentAPI())
								}
								catch (error)
								{
									console.log("Error parsing JSON (settingsWizards.callCheckStored 2)")
								}
								appState.setCurrentAPI(JSON.stringify(
								{
									name: apiRaw.name,
									id: data.data.idChanged
								}))
							}
							wzMisc.setApiIsDown(false);
							changeCurrentApi(data);
							deferred.resolve()
						}
					}).catch(function (error)
					{
						appState.removeCurrentAPI();
						!disableErrors && errorHandler.handle(error, "Routes");
						!disableErrors && errorHandler.handle("Please insert a new Wazuh API or select an existing valid one.", "Routes", true);
						$location.search("_a", null);
						$location.search("tab", "api");
						$location.path("/settings")
					})
				};
				var currentParams = $location.search();
				var targetedAgent = currentParams && (currentParams.agent || "000" === currentParams.agent);
				var targetedRule = currentParams && "ruleset" === currentParams.tab && currentParams.ruleid;
				if (targetedAgent || targetedRule || disableErrors || !(0, _healthCheck.healthCheck)($window)) appState.getCurrentAPI() ? callCheckStored() : genericReq.request("GET", "/elastic/apis").then(function (data)
				{
					if (data.data.length > 0)
					{
						var apiEntries = data.data;
						appState.setCurrentAPI(JSON.stringify(
						{
							name: apiEntries[0]._source.cluster_info.manager,
							id: apiEntries[0]._id
						}));
						callCheckStored()
					}
					else
					{
						var comeFromWizard = wzMisc.getWizard();
						!comeFromWizard && errorHandler.handle("Wazuh App: Please set up Wazuh API credentials.", "Routes", true);
						wzMisc.setWizard(true);
						if (!$location.path().includes("/settings"))
						{
							$location.search("_a", null);
							$location.search("tab", "api");
							$location.path("/settings")
						}
						deferred.reject()
					}
				}).catch(function (error)
				{
					!disableErrors && errorHandler.handle(error, "Routes");
					wzMisc.setWizard(true);
					if (!$location.path().includes("/settings"))
					{
						$location.search("_a", null);
						$location.search("tab", "api");
						$location.path("/settings")
					}
					deferred.reject()
				});
				else
				{
					$location.path("/health-check");
					deferred.reject()
				}
				return deferred.promise
			}
			catch (error)
			{
				!disableErrors && errorHandler.handle(error, "Routes")
			}
		}
	},
	5291: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.getSavedSearch = getSavedSearch;
		var _healthCheck = __webpack_require__(645);
		var _persisted_log = __webpack_require__(132);

		function getSavedSearch(redirectWhenMissing, $location, $window, savedSearches, $route)
		{
			var currentParams = $location.search();
			var targetedAgent = currentParams && (currentParams.agent || "000" === currentParams.agent);
			var targetedRule = currentParams && "ruleset" === currentParams.tab && currentParams.ruleid;
			if (targetedAgent || targetedRule || !(0, _healthCheck.healthCheck)($window))
			{
				var savedSearchId = $route.current.params.id;
				return savedSearches.get(savedSearchId).then(function (savedSearch)
				{
					savedSearchId && _persisted_log.recentlyAccessed.add(savedSearch.getFullPath(), savedSearch.title, savedSearchId);
					return savedSearch
				}).catch(redirectWhenMissing(
				{
					search: "/discover",
					"index-pattern": "/management/kibana/objects/savedSearches/" + $route.current.params.id
				}))
			}
			$location.path("/health-check");
			return Promise.reject()
		}
	},
	5292: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.goToKibana = goToKibana;

		function goToKibana($location, $window)
		{
			var url = $location.$$absUrl.substring(0, $location.$$absUrl.indexOf("#"));
			($window.sessionStorage.getItem("lastSubUrl:" + url).includes("/wazuh#/visualize") || $window.sessionStorage.getItem("lastSubUrl:" + url).includes("/wazuh#/doc") || $window.sessionStorage.getItem("lastSubUrl:" + url).includes("/wazuh#/context")) && $window.sessionStorage.setItem("lastSubUrl:" + url, url);
			$window.location.href = $location.absUrl().replace("/wazuh#", "/kibana#")
		}
	},
	5293: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.getIp = getIp;
		var _saved_objects = __webpack_require__(54);
		var _healthCheck = __webpack_require__(645);

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function getIp(indexPatterns, $q, $window, $location, Private, appState, genericReq, errorHandler, wzMisc)
		{
			var _this = this;
			var deferred = $q.defer();
			var buildSavedObjectsClient = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
			{
				var savedObjectsClient, savedObjectsData, savedObjects, currentPattern, data, onlyWazuhAlerts, courierData;
				return regeneratorRuntime.wrap(function _callee$(_context)
				{
					while (1) switch (_context.prev = _context.next)
					{
					case 0:
						_context.prev = 0;
						savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);
						_context.next = 4;
						return savedObjectsClient.find(
						{
							type: "index-pattern",
							fields: ["title"],
							perPage: 1e4
						});
					case 4:
						savedObjectsData = _context.sent;
						savedObjects = savedObjectsData.savedObjects;
						currentPattern = "";
						if (!appState.getCurrentPattern())
						{
							_context.next = 11;
							break
						}
						currentPattern = appState.getCurrentPattern();
						_context.next = 21;
						break;
					case 11:
						_context.next = 13;
						return genericReq.request("GET", "/elastic/index-patterns");
					case 13:
						data = _context.sent;
						if (!(!data || !data.data || !data.data.data || !data.data.data.length))
						{
							_context.next = 19;
							break
						}
						wzMisc.setBlankScr("Sorry but no valid index patterns were found");
						$location.search("tab", null);
						$location.path("/blank-screen");
						return _context.abrupt("return");
					case 19:
						currentPattern = data.data.data[0].id;
						appState.setCurrentPattern(currentPattern);
					case 21:
						onlyWazuhAlerts = savedObjects.filter(function (element)
						{
							return element.id === currentPattern
						});
						if (!(!onlyWazuhAlerts || !onlyWazuhAlerts.length))
						{
							_context.next = 25;
							break
						}
						deferred.resolve("No ip");
						return _context.abrupt("return");
					case 25:
						_context.next = 27;
						return indexPatterns.get(currentPattern);
					case 27:
						courierData = _context.sent;
						deferred.resolve(
						{
							list: onlyWazuhAlerts,
							loaded: courierData,
							stateVal: null,
							stateValFound: false
						});
						_context.next = 36;
						break;
					case 31:
						_context.prev = 31;
						_context.t0 = _context["catch"](0);
						deferred.reject(_context.t0);
						wzMisc.setBlankScr(errorHandler.handle(_context.t0, "Elasticsearch", false, true));
						$location.path("/blank-screen");
					case 36:
					case "end":
						return _context.stop()
					}
				}, _callee, _this, [
					[0, 31]
				])
			})), function buildSavedObjectsClient()
			{
				return _ref.apply(this, arguments)
			});
			var _ref;
			var currentParams = $location.search();
			var targetedAgent = currentParams && (currentParams.agent || "000" === currentParams.agent);
			var targetedRule = currentParams && "ruleset" === currentParams.tab && currentParams.ruleid;
			if (targetedAgent || targetedRule || !(0, _healthCheck.healthCheck)($window)) buildSavedObjectsClient();
			else
			{
				deferred.reject();
				$location.path("/health-check")
			}
			return deferred.promise
		}
	},
	5294: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		exports.getWzConfig = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee($q, genericReq, errorHandler, wazuhConfig)
		{
			var defaultConfig, config, ymlContent, key;
			return regeneratorRuntime.wrap(function _callee$(_context)
			{
				while (1) switch (_context.prev = _context.next)
				{
				case 0:
					defaultConfig = {
						pattern: "wazuh-alerts-3.x-*",
						"checks.pattern": true,
						"checks.template": true,
						"checks.api": true,
						"checks.setup": true,
						"extensions.pci": true,
						"extensions.gdpr": true,
						"extensions.audit": true,
						"extensions.oscap": true,
						"extensions.ciscat": false,
						"extensions.aws": false,
						"extensions.virustotal": false,
						"extensions.osquery": false,
						timeout: 8e3,
						"threat-analytics.shards": 1,
						"threat-analytics.replicas": 0,
						"threat-analytics-version.shards": 1,
						"threat-analytics-version.replicas": 0,
						"ip.selector": true,
						"ip.ignore": [],
						"xpack.rbac.enabled": true,
						"threat-analytics.monitoring.enabled": true,
						"threat-analytics.monitoring.frequency": 3600,
						"threat-analytics.monitoring.shards": 2,
						"threat-analytics.monitoring.replicas": 0,
						"threat-analytics.monitoring.pattern": "threat-analytics-monitoring-3.x-*",
						admin: true
					};
					_context.prev = 1;
					_context.next = 4;
					return genericReq.request("GET", "/utils/configuration",
					{});
				case 4:
					config = _context.sent;
					if (!(!config || !config.data || !config.data.data))
					{
						_context.next = 7;
						break
					}
					throw new Error("No config available");
				case 7:
					ymlContent = config.data.data;
					if ("object" === ("undefined" === typeof ymlContent ? "undefined" : _typeof(ymlContent)))
						for (key in ymlContent) defaultConfig[key] = ymlContent[key];
					wazuhConfig.setConfig(defaultConfig);
					_context.next = 16;
					break;
				case 12:
					_context.prev = 12;
					_context.t0 = _context["catch"](1);
					wazuhConfig.setConfig(defaultConfig);
					errorHandler.handle("Error parsing config.yml, using default values.", "Config", true);
				case 16:
					return _context.abrupt("return", $q.resolve());
				case 17:
				case "end":
					return _context.stop()
				}
			}, _callee, this, [
				[1, 12]
			])
		})), function getWzConfig(_x, _x2, _x3, _x4)
		{
			return _ref.apply(this, arguments)
		});
		var _ref;

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
	},
	5295: function (module, exports)
	{
		module.exports = '<md-content flex="auto" layout="column" layout-align="center" ng-controller="healthCheck as ctrl">\n    <div class="height-150" layout="row" layout-align="center">\n  </div>\n    <div layout="row" class="layout-align-center margin-top-30">\n        <table flex="50" class="table">\n            <thead class="kuiTableHeaderCell">\n                <th>Description</th>\n                <th>Status</th>\n            </thead>\n            <tbody>\n                <tr ng-repeat="result in ctrl.results">\n                    <td>{{result.description}}</td>\n                    <td ng-if="result.status === \'disabled\'" class="discover-field-details">\n                        Disabled\n                    </td>\n                    <td ng-if="result.status === \'Ready\' || result.status === \'Error\'">\n                        <i ng-if="result.status === \'Ready\'" class="fa fa-fw fa-check wz-text-teal"></i>\n                        <i ng-if="result.status === \'Error\'" class="fa fa-fw fa-warning wz-text-red"></i>\n                        {{result.status}}</td>\n                    <td ng-if="result.status !== \'Ready\' && result.status !== \'Error\' && result.status !== \'disabled\'">\n                            <i class="fa fa-fw fa-spin fa-spinner"></i>\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n    <div layout="row" ng-if="ctrl.errors.length" class="layout-align-center margin-top-30">\n        <ul>\n            <li class="wz-text-red" ng-repeat=\'error in ctrl.errors\'>{{error}}</li>\n        </ul>\n    </div>\n    <div ng-if="ctrl.errors.length" layout="row" class="layout-align-center margin-top-30">\n        <md-button class="wz-button md-raised md-primary" ng-click="ctrl.goApp()" aria-label="Go app">\n            <i class="fa fa-fw fa-sign-out"></i> Open the app\n        </md-button>\n    </div>\n\n</md-content>\n'
	},
	5296: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_interp, pug_html = "";
			pug_html = pug_html + '<div flex="auto" layout="column" ng-cloak ng-controller="agentsController">\n\n    <!-- Top navbar section -->\n    <wz-menu ng-init="menuNavItem = \'agents\'"></wz-menu>\n    <!-- End top navbar section -->\n\n    <!-- Navigation section -->\n    <div layout="row" layout-align="start center">\n        <!-- Breadcrumbs -->\n        <div layout="row" layout-padding ng-if="agent">\n            <!-- If you\'re not on the Welcome tab, show a functional breadcrumb -->\n            <div ng-if="tab !== \'welcome\' && tab !== \'configuration\'">\n                <a class="wz-text-link cursor-pointer" href="#/agents-preview">Agents</a>\n                <span> / </span>\n                <span class="wz-text-link cursor-pointer" ng-click="switchTab(\'welcome\')">{{agent.name}} ({{agent.id}})</span>\n                <span> / </span>\n                <span>{{ tabNames[tab] }}</span>\n            </div>\n\n            <!-- If you\'re on the Welcome tab, show a blank, simple breadcrumb -->\n            <div ng-if="tab === \'welcome\'">\n                <a class="wz-text-link cursor-pointer" href="#/agents-preview">Agents</a>\n                <span> / </span>\n                <span>{{agent.name}} ({{agent.id}})</span>\n                <span> / </span>\n                <span>Welcome</span>\n            </div>\n\n            <div ng-if="tab === \'configuration\' && configurationTab === \'welcome\'">\n                <a class="wz-text-link cursor-pointer" href="#/agents-preview">Agents</a>\n                <span> / </span>\n                <span class="wz-text-link cursor-pointer" ng-click="switchTab(\'welcome\')">{{agent.name}} ({{agent.id}})</span>\n                <span> / </span>\n                <span>{{ tabNames[tab] }}</span>\n            </div>\n\n            <div ng-if="tab === \'configuration\' && configurationTab !== \'welcome\'">\n                <a class="wz-text-link cursor-pointer" href="#/agents-preview">Agents</a>\n                <span> / </span>\n                <span class="wz-text-link cursor-pointer" ng-click="switchTab(\'welcome\')">{{agent.name}} ({{agent.id}})</span>\n                <span> / </span>\n                <span class="wz-text-link cursor-pointer" ng-click="switchConfigurationTab(\'welcome\', true)">{{ tabNames[tab] }}</span>\n                <span> / </span>\n                <span>{{ tabNames[configurationTab] === \'Alerts\' ? \'Labels\' : tabNames[configurationTab] }}</span>\n            </div>\n        </div>\n        <!-- End breadcrumbs -->\n\n        <!-- Agent status section -->\n        <div ng-if="agent.status">\n            <span class="wz-agent-status-indicator small" ng-class="getAgentStatusClass(agent.status)" aria-label="Agent status indicator">{{formatAgentStatus(agent.status)}}</span>\n        </div>\n        <!-- End agent status section -->\n\n        <!-- Separator -->\n        <span flex></span>\n        <!-- End separator -->\n\n        <!-- Reporting button section -->\n        <div ng-show="tab !== \'welcome\' && tab !== \'configuration\' && tabView === \'panels\'">\n            <!-- Report button -->\n         <!--   <md-button md-no-ink class="md-icon-button small wz-no-margin-padding" tooltip="Generate report" tooltip-placement="bottom" ng-disabled="(!rendered || loading || resultState !== \'ready\') && tab !== \'syscollector\'" ng-click="startVis2Png()" aria-label="Generate report button">\n                 <i class="fa fa-fw fa-print" aria-hidden="true"></i>\n            </md-button>-->\n      </div>\n        <!-- End Reporting buttons section -->\n\n        <!-- Discover/Dashboard buttons section -->\n        <div ng-show="tab !== \'welcome\' && tab !== \'configuration\' && tab !== \'syscollector\'">\n            <!-- Dashboard button -->\n            <md-button ng-if="tabView === \'discover\'" class="wz-button-flat small" ng-click="switchSubtab(\'panels\')" aria-label="Dashboard button">\n                <i class="fa fa-fw fa-th" aria-hidden="true"></i> Dashboard\n            </md-button>\n\n            <!-- Discover button -->\n            <md-button ng-if="tabView === \'panels\'" class="wz-button-flat small" ng-click="switchSubtab(\'discover\')" aria-label="Discover button">\n                <i class="fa fa-fw fa-compass" aria-hidden="true"></i> Discover\n            </md-button>\n        </div>\n        <!-- End Discover/Dashboard buttons section -->\n\n        <!-- Agent autocomplete selector section -->\n        <div flex="30" class="wz-margin-8-no-left">\n            <md-autocomplete flex class="wz-autocomplete wz-select-input"\n            md-no-cache="true"\n            md-select-on-match="false"\n            md-selected-item="_swpagent"\n            md-selected-item-change="getAgent(_swpagent.id,true)"\n            md-search-text="searchTerm"\n            md-items="agentAutoComplete in analyzeAgents(searchTerm)"\n            md-item-text="agentAutoComplete.name"\n            md-min-length="0"\n            md-clear-button="true"\n            md-no-asterisk="false"\n            placeholder="Search by name, ID or IP address">\n                <md-item-template>\n                    <span class="item-title">\n                        <span><strong md-highlight-text="search" md-highlight-flags="i"> {{agentAutoComplete.name}} ({{agentAutoComplete.id}}) </strong></span>\n                    </span>\n                    <span class="item-metadata">\n                        <span class="item-metastat" md-highlight-text="searchTerm" md-highlight-flags="i"> {{agentAutoComplete.ip}} ({{agentAutoComplete.status}}) </span>\n                    </span>\n                </md-item-template>\n                <md-not-found>\n                    No agents matching "{{searchTerm}}" were found.\n                </md-not-found>\n            </md-autocomplete>\n        </div>\n        <!-- End agent autocomplete selector section -->\n\n        <!-- Help button -->\n        <!--md-button md-no-ink class="md-icon-button small" tooltip="testing" tooltip-placement="left" ng-href="#/settings/about" aria-label="Link to open app about section"-->\n            <i class="" aria-hidden="true"></i>\n        </md-button>\n        <!-- End help button -->\n\n    </div>\n    <!-- End navigation section -->\n\n    <!-- Host monitoring navigation bar -->\n    <md-nav-bar\n        ng-if="inArray(tab, hostMonitoringTabs)"\n        class="wz-nav-bar"\n        ng-show="tab !== \'welcome\'"\n        md-selected-nav-item="tab"\n        nav-bar-aria-label="Host monitoring navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchTab(\'general\')" name="general">{{ tabNames[\'general\'] }}</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchTab(\'fim\')" name="fim">{{ tabNames[\'fim\'] }}</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchTab(\'syscollector\')" name="syscollector">{{ tabNames[\'syscollector\'] }}</md-nav-item>\n    </md-nav-bar>\n    <!-- End Host monitoring navigation bar -->\n\n    <!-- System audit navigation bar -->\n    <md-nav-bar\n        ng-if="inArray(tab, systemAuditTabs) && (extensions.audit || extensions.oscap || extensions.ciscat)"\n        class="wz-nav-bar"\n        ng-show="tab !== \'welcome\'"\n        md-selected-nav-item="tab"\n        nav-bar-aria-label="System audit navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchTab(\'pm\')" name="pm">{{ tabNames[\'pm\'] }}</md-nav-item>\n        <md-nav-item ng-show="extensions.audit" class="wz-nav-item" md-nav-click="switchTab(\'audit\')" name="audit">{{ tabNames[\'audit\'] }}</md-nav-item>\n        <md-nav-item ng-show="extensions.oscap" class="wz-nav-item" md-nav-click="switchTab(\'oscap\')" name="oscap">{{ tabNames[\'oscap\'] }}</md-nav-item>\n        <md-nav-item ng-show="extensions.ciscat" class="wz-nav-item" md-nav-click="switchTab(\'ciscat\')" name="ciscat">{{ tabNames[\'ciscat\'] }}</md-nav-item>\n      </md-nav-bar>\n    <!-- End System audit navigation bar -->\n\n    <!-- Security navigation bar -->\n    <md-nav-bar\n        ng-if="inArray(tab, securityTabs) && (extensions.virustotal || extensions.osquery)"\n        class="wz-nav-bar"\n        ng-show="tab !== \'welcome\'"\n        md-selected-nav-item="tab"\n        nav-bar-aria-label="Security navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchTab(\'vuls\')" name="vuls">{{ tabNames[\'vuls\'] }}</md-nav-item>\n        <md-nav-item ng-show="extensions.virustotal" class="wz-nav-item" md-nav-click="switchTab(\'virustotal\')" name="virustotal">{{ tabNames[\'virustotal\'] }}</md-nav-item>\n        <md-nav-item ng-show="extensions.osquery" class="wz-nav-item" md-nav-click="switchTab(\'osquery\')" name="osquery">{{ tabNames[\'osquery\'] }}</md-nav-item>\n    </md-nav-bar>\n    <!-- End Security navigation bar -->\n\n    <!-- Compliance navigation bar -->\n    <md-nav-bar\n        ng-if="inArray(tab, complianceTabs) && extensions.pci && extensions.gdpr"\n        class="wz-nav-bar"\n        ng-show="tab !== \'welcome\'"\n        md-selected-nav-item="tab"\n        nav-bar-aria-label="Compliance navigation links">\n        <md-nav-item ng-show="extensions.pci" class="wz-nav-item" md-nav-click="switchTab(\'pci\')" name="pci">{{ tabNames[\'pci\'] }}</md-nav-item>\n        <md-nav-item ng-show="extensions.gdpr" class="wz-nav-item" md-nav-click="switchTab(\'gdpr\')" name="gdpr">{{ tabNames[\'gdpr\'] }}</md-nav-item>\n    </md-nav-bar>\n    <!-- End Compliance navigation bar -->\n\n    <!-- Discover search bar section -->\n    <kbn-dis ng-show="(tab !== \'welcome\') && (tab !== \'configuration\') && tab !== \'syscollector\'"></kbn-dis>\n    <!-- End Discover search bar section -->\n\n    <!-- Loading status section -->\n    <div layout="column" layout-align="center center" ng-if="tab !== \'welcome\' && tab !== \'configuration\' && tab !== \'syscollector\'" ng-show="resultState === \'ready\' && tabView === \'panels\' && !rendered">\n        <div class="percentage"><i class="fa fa-fw fa-spin fa-spinner" aria-hidden="true"></i></div>\n        <div class="percentage">{{loadingStatus}}</div>\n    </div>\n    <!-- End loading status section -->\n\n    <!-- Report status section -->\n    <div layout="column" layout-align="center center" class="wz-margin-top-8" ng-if="(tab !== \'welcome\') && (tab !== \'configuration\')" ng-show="reportBusy && reportStatus">\n        <div class="percentage"><i class="fa fa-fw fa-spin fa-spinner" aria-hidden="true"></i></div>\n        <div class="percentage">{{reportStatus}}</div>\n    </div>\n    <!-- End report status section -->\n\n    <!-- No results section -->\n    <div layout="row" ng-if="!showSyscheckFiles && tab === \'fim\' && resultState === \'none\' && tabView === \'panels\'" layout-padding class="wz-padding-top-0">\n        <span flex></span>\n        <span ng-click="switchSyscheckFiles()" class="btn pull-right btn-primary">Show files</span>\n    </div> \n    <div layout="row" class="wz-margin-top-10 wz-margin-right-8 wz-margin-left-8" ng-if="!showSyscheckFiles && tab !== \'welcome\' && tab !== \'configuration\' && tab !== \'syscollector\'" ng-show="resultState === \'none\' && tabView === \'panels\'">\n        <div flex class="euiCallOut euiCallOut--warning">\n            <div class="euiCallOutHeader">\n                <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path></defs><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use></svg>\n                <span class="euiCallOutHeader__title">There are no results for selected time range. Try another one.</span>\n            </div>\n        </div>\n    </div>\n    <!-- No results section -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load && tab !== \'configuration\' && tabView === \'panels\'">\n        <div></div>\n    </div>\n<div layout="column" layout-align="start stretch" ng-if="tab === \'welcome\'" ng-show="!load">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-tv" aria-hidden="true"></i> Agent overview</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Agent information section -->\n    <div layout="row" layout-padding class="wz-padding-top-0 wz-padding-bottom-0">\n        <md-card flex class="wz-metric-color wz-md-card wz-no-padding">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>\n                    Name: <span class="wz-text-bold">{{ agent.name }}</span>\n                    <md-tooltip ng-if="agent.name.length > 25" md-direction="bottom" class="wz-tooltip">\n                        Full name: {{ agent.name }}\n                    </md-tooltip>\n                </div>\n                <div class="wz-text-truncatable" flex>\n                    IP: <span class="wz-text-bold">{{ agent.ip }}</span>\n                </div>\n                <div class="wz-text-truncatable" flex ng-if="agent.version">\n                    Version: <span class="wz-text-bold">{{ agent.version }}</span>\n                </div>\n                <div class="wz-text-truncatable" flex>\n                    OS: <span class="wz-text-bold">{{ agentOS }}</span>\n                    <md-tooltip ng-if="agentOS.length > 25" md-direction="bottom" class="wz-tooltip">\n                        Full OS name: {{ agentOS }}\n                    </md-tooltip>\n                </div>\n                <div class="wz-text-truncatable" flex>\n                    <span class="wz-text-bold wz-text-link" ng-click="goDiscover()"><i class="fa fa-fw fa-compass" aria-hidden="true"></i> Discover</span>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" layout-padding class="wz-padding-top-0 wz-padding-bottom-0" ng-if="agent.group">\n        <md-card flex class="wz-metric-color wz-md-card wz-no-padding">\n            <md-card-content class="wz-padding-metric">\n                <div class="layout-row wz-word-break">\n                    <span class="wz-text-link" ng-if=\'adminMode\' ng-click="switchGroupEdit()"><i class="fa fa-fw fa-plus-circle"></i>&nbsp;</span>Groups:&nbsp;                    \n                    <span ng-repeat="group in agent.group" class="wz-text-bold">{{ group }}&nbsp;</span>                   \n                </div>\n                <div layout="row" class="wz-margin-top-10" ng-if="editGroup && !addingGroupToAgent">\n                    <div class="wz-word-break" flex ng-if="groups && groups.length">\n                        Available groups:\n                    </div>\n                    <div class="wz-word-break" flex ng-if="!groups || !groups.length">\n                        There are no more groups available.\n                    </div>\n                </div>\n                <div ng-if="editGroup && !addingGroupToAgent" class="wz-margin-top-4" ng-if="groups && groups.length">\n                    <span ng-repeat="group in groups" class="wz-text-bold wz-text-link" ng-click="showConfirmAddGroup(group)">{{\n                        group }}&nbsp;</span>\n                </div>\n\n                <div class="wz-margin-top-10" ng-if="editGroup && addingGroupToAgent">\n                    <div layout="row">\n                   <!--     <span class="euiToastHeader__title font-size-12">Group {{addingGroupToAgent}} will be added to agent {{agent.id}}</span>\n        -->            </div>\n                    <div layout="row">\n                        <md-button class="cancelBtnAgents" type="button" ng-click="cancelAddGroup()"><i aria-hidden=\'true\' class=\'fa fa-fw fa-close\'></i> Cancel</md-button>\n                        <md-button class="agreeBtnAgents" type="button" ng-click="confirmAddGroup(addingGroupToAgent)"><i aria-hidden=\'true\' class=\'fa fa-fw fa-check\'></i> Confirm</md-button>  \n                    </div>                          \n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" layout-padding class="wz-padding-top-0 wz-padding-bottom-0">\n        <md-card flex class="wz-metric-color wz-md-card wz-no-padding">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Last keep alive:<span class="wz-text-bold"> {{agent.lastKeepAlive || \'Unknown\' }}</span></div>\n                <div class="wz-text-truncatable" flex>Registration date:<span class="wz-text-bold"> {{agent.dateAdd}}</span></div>\n                <div class="wz-text-truncatable" flex ng-if="agent.syscheck.inProgress">Last syscheck scan:<span class="wz-text-bold"> Scan in progress</span></div>\n                <div class="wz-text-truncatable" flex ng-if="!agent.syscheck.inProgress">Last syscheck scan:<span class="wz-text-bold"> {{agent.syscheck.end || \'Unknown\'}}</span>\n                    <md-tooltip ng-if="!agent.syscheck.inProgress && agent.syscheck.start && agent.syscheck.end" md-direction="bottom" class="wz-tooltip">\n                        Start time: {{ agent.syscheck.start || \'Unknown\'}} <br>\n                        End time: {{ agent.syscheck.end || \'Unknown\'}} <br>\n                        Duration time: {{ agent.syscheck.duration +\' minutes\' || \'Unknown\'}}\n                    </md-tooltip>\n                </div>\n                <div class="wz-text-truncatable" flex ng-if="agent.rootcheck.inProgress">Last rootcheck scan:<span class="wz-text-bold"> Scan in progress</span></div>\n                <div class="wz-text-truncatable" flex ng-if="!agent.rootcheck.inProgress">Last rootcheck scan:<span class="wz-text-bold"> {{agent.rootcheck.end || \'Unknown\'}}</span>\n                    <md-tooltip ng-if="!agent.rootcheck.inProgress && agent.rootcheck.start && agent.rootcheck.end" md-direction="bottom" class="wz-tooltip">\n                        Start time: {{ agent.rootcheck.start || \'Unknown\'}} <br>\n                        End time: {{ agent.rootcheck.end || \'Unknown\'}} <br>\n                        Duration time: {{ agent.rootcheck.duration +\' minutes\' || \'Unknown\'}}\n                    </md-tooltip>\n                </div>\n                <div class="wz-text-truncatable" flex></div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End agent information section -->\n\n\n    <div layout="row" layout-padding>\n        <div class="euiFlexGroup euiFlexGroup--gutterLarge euiFlexGroup--responsive">\n            <div class="euiFlexItem">\n                <div class="euiPanel euiPanel--paddingLarge">\n                    <h3 class="euiTitle wzEuiTitle">Security Information Management</h3>\n                    <div class="euiSpacer euiSpacer--m"></div>\n                    <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_dashboard.svg\'" title="\'Security events\'"\n                            switch-tab="switchTab(\'general\')" current-tab="\'general\'"\n                            description="TabDescription.general.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_logging.svg\'" title="\'Integrity monitoring\'"\n                            switch-tab="switchTab(\'fim\')" current-tab="\'fim\'"\n                            description="TabDescription.fim.description"\n                        ></wz-welcome-card>\n                        <!--wz-welcome-card\n                            class="" logo=""\n                            title="\'js_Configuration\'" switch-tab="switchTab(\'configuration\')" current-tab="\'configuration\'"\n                            description="TabDescription.configuration.description"\n                        ></wz-welcome-card-->\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_index_pattern.svg\'"\n                            title="\'Inventory data\'" switch-tab="switchTab(\'syscollector\')" current-tab="\'syscollector\'"\n                            description="TabDescription.syscollector.description"\n                        ></wz-welcome-card>\n                    </div>\n                </div>\n            </div>\n            <div class="euiFlexItem">\n                <div class="euiPanel euiPanel--paddingLarge">\n                    <h3 class="euiTitle wzEuiTitle">Auditing and Policy Monitoring</h3>\n                    <div class="euiSpacer euiSpacer--m"></div>\n                    <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_advanced_settings.svg\'"\n                            title="\'Policy monitoring\'" switch-tab="switchTab(\'pm\')" current-tab="\'pm\'"\n                            description="TabDescription.pm.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="extensions.audit && agent.isLinuxOS" class="euiFlexItem" logo="\'icons/app_monitoring.svg\'"\n                            title="\'System auditing\'" switch-tab="switchTab(\'audit\')" current-tab="\'audit\'"\n                            description="TabDescription.audit.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="extensions.oscap && agent.isLinuxOS" class="euiFlexItem" logo="\'icons/app_discover.svg\'"\n                            title="\'OpenSCAP\'" switch-tab="switchTab(\'oscap\')" current-tab="\'oscap\'"\n                            description="TabDescription.oscap.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="extensions.ciscat" class="euiFlexItem" logo="\'icons/app_management.svg\'"\n                            title="\'CIS-CAT\'" switch-tab="switchTab(\'ciscat\')" current-tab="\'ciscat\'"\n                            description="TabDescription.ciscat.description"\n                        ></wz-welcome-card>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <div layout="row" layout-padding>\n        <div class="euiFlexGroup euiFlexGroup--gutterLarge euiFlexGroup--responsive">\n            <div class="euiFlexItem">\n                <div class="euiFlexItem">\n                    <div class="euiPanel euiPanel--paddingLarge">\n                        <h3 class="euiTitle wzEuiTitle">Threat Detection and Response</h3>\n                        <div class="euiSpacer euiSpacer--m"></div>\n                        <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                            <wz-welcome-card\n                                class="euiFlexItem" logo="\'icons/app_security.svg\'"\n                                title="\'Vulnerabilities\'" switch-tab="switchTab(\'vuls\')" current-tab="\'vuls\'"\n                                description="TabDescription.vuls.description"\n                            ></wz-welcome-card>\n                            <wz-welcome-card\n                                ng-if="extensions.virustotal" class="euiFlexItem" logo="\'icons/app_saved_objects.svg\'"\n                                title="\'VirusTotal\'" switch-tab="switchTab(\'virustotal\')" current-tab="\'virustotal\'"\n                                description="TabDescription.virustotal.description"\n                            --!></wz-welcome-card>\n                            <wz-welcome-card\n                                ng-if="extensions.osquery" class="euiFlexItem" logo="\'icons/osquery.svg\'"\n                                title="\'Osquery\'" switch-tab="switchTab(\'osquery\')" current-tab="\'osquery\'"\n                                description="TabDescription.osquery.description"\n                            ></wz-welcome-card>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <div class="euiFlexItem" ng-if="extensions && (extensions.pci || extensions.gdpr)">\n                <div class="euiPanel euiPanel--paddingLarge">\n                    <h3 class="euiTitle wzEuiTitle">Regulatory Compliance</h3>\n                    <div class="euiSpacer euiSpacer--m"></div>\n                    <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                        <wz-welcome-card\n                            ng-if="extensions.pci" class="euiFlexItem" logo="\'icons/app_apm.svg\'"\n                            title="\'PCI DSS\'" switch-tab="switchTab(\'pci\')" current-tab="\'pci\'"\n                            description="TabDescription.pci.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="extensions.gdpr" class="euiFlexItem" logo="\'icons/app_visualize.svg\'"\n                            title="\'GDPR\'" switch-tab="switchTab(\'gdpr\')" current-tab="\'gdpr\'"\n                            description="TabDescription.gdpr.description"\n                        ></wz-welcome-card>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n</div>\n<md-content flex layout="column" ng-if="tab === \'general\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- Agent information section -->\n    <div layout="row" layout-align="start center">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>\n                    Name: <span class="wz-text-bold">{{ agent.name }}</span>\n                    <md-tooltip ng-if="agent.name.length > 25" md-direction="bottom" class="wz-tooltip">\n                        Full name: {{ agent.name }}\n                    </md-tooltip>\n                </div>\n                <div class="wz-text-truncatable" flex>\n                    IP: <span class="wz-text-bold">{{ agent.ip }}</span>\n                </div>\n                <div class="wz-text-truncatable" flex ng-if="agent.version">\n                    Version: <span class="wz-text-bold">{{ agent.version }}</span>\n                </div>\n                <div class="wz-text-truncatable" flex>\n                    OS: <span class="wz-text-bold">{{ agentOS }}</span>\n                    <md-tooltip ng-if="agentOS.length > 25" md-direction="bottom" class="wz-tooltip">\n                        Full OS name: {{ agentOS }}\n                    </md-tooltip>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" layout-align="start center">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-word-break" flex ng-if="agent.group">\n                    Groups: <span ng-repeat="group in agent.group" class="wz-text-bold wz-text-link" ng-click="goGroups(agent,$index)">{{ group }}&nbsp;</span>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" layout-align="start center">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Last keep alive:<span class="wz-text-bold"> {{agent.lastKeepAlive || \'Unknown\' }}</span></div>\n                <div class="wz-text-truncatable" flex>Registration date:<span class="wz-text-bold"> {{agent.dateAdd}}</span></div>\n                <div class="wz-text-truncatable" flex ng-if="agent.syscheck.inProgress">Last syscheck scan:<span class="wz-text-bold"> Scan in progress</span></div>\n                <div class="wz-text-truncatable" flex ng-if="!agent.syscheck.inProgress">Last syscheck scan:<span class="wz-text-bold"> {{agent.syscheck.end || \'Unknown\'}}</span>\n                    <md-tooltip ng-if="!agent.syscheck.inProgress && agent.syscheck.start && agent.syscheck.end" md-direction="bottom" class="wz-tooltip">\n                        Start time: {{ agent.syscheck.start || \'Unknown\'}} <br>\n                        End time: {{ agent.syscheck.end || \'Unknown\'}} <br>\n                        Duration time: {{ agent.syscheck.duration +\' minutes\' || \'Unknown\'}}\n                    </md-tooltip>\n                </div>\n                <div class="wz-text-truncatable" flex ng-if="agent.rootcheck.inProgress">Last rootcheck scan:<span class="wz-text-bold"> Scan in progress</span></div>\n                <div class="wz-text-truncatable" flex ng-if="!agent.rootcheck.inProgress">Last rootcheck scan:<span class="wz-text-bold"> {{agent.rootcheck.end || \'Unknown\'}}</span>\n                    <md-tooltip ng-if="!agent.rootcheck.inProgress && agent.rootcheck.start && agent.rootcheck.end" md-direction="bottom" class="wz-tooltip">\n                        Start time: {{ agent.rootcheck.start || \'Unknown\'}} <br>\n                        End time: {{ agent.rootcheck.end || \'Unknown\'}} <br>\n                        Duration time: {{ agent.rootcheck.duration +\' minutes\' || \'Unknown\'}}\n                    </md-tooltip>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End agent information section -->\n\n    <!-- View: Panels -->\n        <div layout="row" class="height-230">\n            <md-card flex="33" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 alerts</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Overview-Top-5-alerts" vis-id="\'Wazuh-App-Agents-Overview-Top-5-alerts\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="33" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 groups</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Overview-Top-5-groups" vis-id="\'Wazuh-App-Agents-Overview-Top-5-groups\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="33" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 PCI DSS Requirements</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Overview-Top-5-PCI-DSS-Requirements" vis-id="\'Wazuh-App-Agents-Overview-Top-5-PCI-DSS-Requirements\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="start stretch" class="height-230">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alert level evolution</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Overview-Alert-level-evolution" vis-id="\'Wazuh-App-Agents-Overview-Alert-level-evolution\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="60" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Overview-Alerts" vis-id="\'Wazuh-App-Agents-Overview-Alerts\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" class="height-570">\n            <md-card  flex="60" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts summary</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis vis-id="\'Wazuh-App-Agents-Overview-Alerts-summary\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="40" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Groups summary</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis vis-id="\'Wazuh-App-Agents-Overview-Groups-summary\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="tab === \'fim\' && tabView === \'panels\'" ng-show="!showSyscheckFiles" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n    <div layout="row" layout-padding class="wz-padding-top-0">\n        <span flex></span>\n        <span ng-click="switchSyscheckFiles()" class="btn pull-right btn-primary">Show files</span>\n    </div>\n    <!-- View: Panels -->\n    <div layout="row" class="height-230">\n        <div layout="column" flex>\n            <div layout="row" class="height-230">\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column">\n                        <span class="wz-headline-title">Users</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Agents-FIM-Users" vis-id="\'Wazuh-App-Agents-FIM-Users\'">\n                    </md-card-content>\n                </md-card>\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column">\n                        <span class="wz-headline-title">Permissions</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Agents-FIM-Permissions" vis-id="\'Wazuh-App-Agents-FIM-Permissions\'">\n                    </md-card-content>\n                </md-card>\n            </div>\n        </div>\n        <div layout="column" flex>\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Events</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-FIM-Events" vis-id="\'Wazuh-App-Agents-FIM-Events\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n    </div>\n\n    <div layout="row" class="height-230">\n        <md-card flex="33" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Files added</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-FIM-Files-added" vis-id="\'Wazuh-App-Agents-FIM-Files-added\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="33" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Files modified</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-FIM-Files-modified" vis-id="\'Wazuh-App-Agents-FIM-Files-modified\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="33" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Files deleted</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-FIM-Files-deleted" vis-id="\'Wazuh-App-Agents-FIM-Files-deleted\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="space-between stretch" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Agents-FIM-Alerts-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n</md-content>\n\n<md-content flex layout="column" ng-if="tab === \'fim\' && tabView === \'panels\' && showSyscheckFiles" layout-align="start">\n    <div layout="row" layout-padding class="wz-padding-top-0">\n        <span flex></span>\n        <span ng-click="switchSyscheckFiles()" class="btn pull-right btn-primary">Show alerts</span>\n    </div>\n\n    <div layout="row" class="wz-margin-top-10 wz-margin-right-8 wz-margin-left-8" ng-if="showSyscheckFiles && (!agent || !agent.os)">\n        <div flex class="euiCallOut euiCallOut--warning">\n            <div class="euiCallOutHeader">\n                <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path></defs><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use></svg>\n                <span class="euiCallOutHeader__title">This agent is never connected.</span>\n            </div>\n        </div>\n    </div>\n\n    <div layout="row" class="wz-padding-top-0" ng-if="agent && agent.os && agent.os.platform === \'windows\'">\n        <md-card flex="" class="wz-md-card _md flex">\n            <md-card-content>\n                <span class="wz-headline-title"><i class="fa fa-fw fa-windows"></i> Windows registry</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-margin-top-10">\n                    <input placeholder="Filter registry..." ng-model="registrySearch" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid height-30"\n                        aria-invalid="false" wz-enter="searchSyscheckFile(registrySearch,{name:\'type\',value:\'registry\'})">\n                    <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-30" ng-click="searchSyscheckFile(registrySearch,{name:\'type\',value:\'registry\'})">\n                        <span class="fa fa-search" aria-hidden="true"></span>\n                    </button>\n                </div>\n                <div layout="row" ng-if="agent && !load" class="wz-margin-top-10 wz-margin-bottom-40-inv">\n                    <wz-table flex path="\'/syscheck/\' + agent.id" implicit-filter="[{name:\'type\',value:\'registry\'}]" row-sizes="[6,6,6]" extra-limit="true" keys="[\'file\',\'sha1\',\'md5\']">\n                    </wz-table>\n                </div>\n                <div layout="row" layout-padding>\n                    <span flex></span>\n                    <a class="small" id="btnDownload" ng-click="downloadCsv(\'/syscheck/\' + agent.id, \'fim-registry.csv\', [{name:\'type\',value:\'registry\'}])">Formatted <i aria-hidden="true" class="fa fa-fw fa-download"></i></a>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="wz-padding-top-0" ng-if="agent && agent.os && agent.os.platform === \'windows\'">\n        <md-card flex="" class="wz-md-card _md flex">\n            <md-card-content>\n                <span class="wz-headline-title"><i class="fa fa-fw fa-file-o"></i> Files</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-margin-top-10">\n                    <input placeholder="Filter files..." ng-model="filesSearch" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid height-30"\n                        aria-invalid="false" wz-enter="searchSyscheckFile(filesSearch,{name:\'type\',value:\'file\'})">\n                    <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-30" ng-click="searchSyscheckFile(filesSearch,{name:\'type\',value:\'file\'})">\n                        <span class="fa fa-search" aria-hidden="true"></span>\n                    </button>\n                </div>\n                <div layout="row" ng-if="agent && !load" class="wz-margin-top-10 wz-margin-bottom-40-inv">\n                    <wz-table flex path="\'/syscheck/\' + agent.id" implicit-filter="[{name:\'type\',value:\'file\'}]" row-sizes="[6,6,6]" extra-limit="true" keys="[\'file\',\'size\',\'uname\',\'perm\',\'sha1\',\'sha256\',\'uid\',\'mtime\',\'md5\']">\n                    </wz-table>\n                </div>\n                <div layout="row" layout-padding>\n                    <span flex></span>\n                    <a class="small" id="btnDownload" ng-click="downloadCsv(\'/syscheck/\' + agent.id, \'fim-files.csv\', [{name:\'type\',value:\'file\'}])">Formatted <i aria-hidden="true" class="fa fa-fw fa-download"></i></a>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="wz-padding-top-0" ng-if="agent && agent.os && agent.os.platform !== \'windows\'">\n        <md-card flex="" class="wz-md-card _md flex">\n            <md-card-content>\n                <span class="wz-headline-title"><i class="fa fa-fw fa-file-o"></i> Files</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-margin-top-10">\n                    <input placeholder="Filter files..." ng-model="filesSearch" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid height-30"\n                        aria-invalid="false" wz-enter="searchSyscheckFile(filesSearch)">\n                    <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-30" ng-click="searchSyscheckFile(filesSearch)">\n                        <span class="fa fa-search" aria-hidden="true"></span>\n                    </button>\n                </div>\n                <div layout="row" ng-if="agent && !load" class="wz-margin-top-10 wz-margin-bottom-40-inv">\n                    <wz-table flex path="\'/syscheck/\' + agent.id" row-sizes="[12,10,8]" extra-limit="true" keys="[\'file\',\'size\',\'inode\',\'gname\',\'uname\',\'perm\',\'sha1\',\'sha256\',\'uid\',\'gid\',\'mtime\',\'md5\']">\n                    </wz-table>\n                </div>\n                <div layout="row" layout-padding>\n                    <span flex></span>\n                    <a class="small" id="btnDownload" ng-click="downloadCsv(\'/syscheck/\' + agent.id, \'fim-files.csv\')">Formatted <i aria-hidden="true" class="fa fa-fw fa-download"></i></a>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n</md-content><md-content flex layout="column" ng-if="tab === \'pm\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- View: Panels -->\n\n\n        <div layout="row" class="height-240">\n            <md-card flex="50" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts over time</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-PM-Alerts-over-time" vis-id="\'Wazuh-App-Agents-PM-Alerts-over-time\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="25" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 CIS Requirements</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-PM-Top-5-CIS-Requirements" vis-id="\'Wazuh-App-Agents-PM-Top-5-CIS-Requirements\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="25" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 PCI DSS Requirements</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-PM-Top-5-PCI-DSS-Requirements" vis-id="\'Wazuh-App-Agents-PM-Top-5-PCI-DSS-Requirements\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="space-between stretch" class="height-570">\n            <md-card flex="100" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts summary</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis vis-id="\'Wazuh-App-Agents-PM-Alerts-summary\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n       </div>\n\n\n\n</md-content>\n<md-content flex layout="column" ng-if="tab === \'vuls\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}"\n    layout-align="start">\n\n    <!-- View: Panels -->\n\n\n    <div layout="row">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div flex>Critical severity alerts: <span class="wz-text-bold" ng-bind="vulnCritical()"></span></div>\n                <div flex>High severity alerts: <span class="wz-text-bold" ng-bind="vulnHigh()"></span></div>\n                <div flex>Medium severity alerts: <span class="wz-text-bold" ng-bind="vulnMedium()"></span></div>\n                <div flex>Low severity alerts: <span class="wz-text-bold" ng-bind="vulnLow()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-App-Agents-vulnerability-Metric-Critical-severity\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Agents-vulnerability-Metric-High-severity\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Agents-vulnerability-Metric-Medium-severity\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Agents-vulnerability-Metric-Low-severity\'"></kbn-vis>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-300">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts severity over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-vulnerability-Alerts-severity-over-time" vis-id="\'Wazuh-App-Agents-vulnerability-Alerts-severity-over-time\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Most common rules</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Agents-vulnerability-Most-common-rules\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" layout-align="center stretch" class="height-270">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Most common CVEs</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-vulnerability-Vulnerability-Most-common-CVEs" vis-id="\'Wazuh-App-Agents-vulnerability-Vulnerability-Most-common-CVEs\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Severity distribution</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-vulnerability-Vulnerability-severity-distribution" vis-id="\'Wazuh-App-Agents-vulnerability-Vulnerability-severity-distribution\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Commonly affected packages</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-vulnerability-Commonly-affected-packages" vis-id="\'Wazuh-App-Agents-vulnerability-Commonly-affected-packages\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alert summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Agents-vulnerability-Alert-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n</md-content><md-content flex layout="column" ng-if="tab === \'oscap\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- View: Panels -->\n\n        <div layout="row">\n            <md-card flex class="wz-metric-color wz-md-card">\n                <md-card-content layout="row" class="wz-padding-metric">\n                    <div flex>Last score: <span class="wz-text-bold" ng-bind="scapLastScore()"></span></div>\n                    <div flex>Highest score: <span class="wz-text-bold" ng-bind="scapHighestScore()"></span></div>\n                    <div flex>Lowest score: <span class="wz-text-bold" ng-bind="scapLowestScore()"></span></div>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div class="wz-no-display">\n            <kbn-vis vis-id="\'Wazuh-App-Agents-OSCAP-Last-score\'"></kbn-vis>\n            <kbn-vis vis-id="\'Wazuh-App-Agents-OSCAP-Higher-score-metric\'"></kbn-vis>\n            <kbn-vis vis-id="\'Wazuh-App-Agents-OSCAP-Lower-score-metric\'"></kbn-vis>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-230">\n            <md-card flex="25" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 Scans</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-OSCAP-Scans" vis-id="\'Wazuh-App-Agents-OSCAP-Scans\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="25" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 Profiles</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-OSCAP-Profiles" vis-id="\'Wazuh-App-Agents-OSCAP-Profiles\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="25" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 Content</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-OSCAP-Content" vis-id="\'Wazuh-App-Agents-OSCAP-Content\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="25" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 Severity</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-OSCAP-Severity" vis-id="\'Wazuh-App-Agents-OSCAP-Severity\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="start stretch" class="height-230">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Daily scans evolution</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-OSCAP-Daily-scans-evolution" vis-id="\'Wazuh-App-Agents-OSCAP-Daily-scans-evolution\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-250">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 - Alerts</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-OSCAP-Top-5-Alerts" vis-id="\'Wazuh-App-Agents-OSCAP-Top-5-Alerts\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Top 5 - High risk alerts</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-OSCAP-Top-5-High-risk-alerts" vis-id="\'Wazuh-App-Agents-OSCAP-Top-5-High-risk-alerts\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-570">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts summary</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis vis-id="\'Wazuh-App-Agents-OSCAP-Last-alerts\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n\n\n</md-content>\n<md-content flex layout="column" ng-if="tab === \'audit\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- View: Panels -->\n\n        <div layout="row">\n            <md-card flex class="wz-metric-color wz-md-card">\n                <md-card-content layout="row" class="wz-padding-metric">\n                    <div class="wz-text-truncatable" flex>New files: <span class="wz-text-bold" ng-bind="auditNewFiles()"></span></div>\n                    <div class="wz-text-truncatable" flex>Read files: <span class="wz-text-bold" ng-bind="auditReadFiles()"></span></div>\n                    <div class="wz-text-truncatable" flex>Modified files: <span class="wz-text-bold" ng-bind="auditModifiedFiles()"></span></div>\n                    <div class="wz-text-truncatable" flex>Removed files: <span class="wz-text-bold" ng-bind="auditRemovedFiles()"></span></div>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div class="wz-no-display">\n            <kbn-vis vis-id="\'Wazuh-App-Agents-Audit-New-files-metric\'"></kbn-vis>\n            <kbn-vis vis-id="\'Wazuh-App-Agents-Audit-Read-files-metric\'"></kbn-vis>\n            <kbn-vis vis-id="\'Wazuh-App-Agents-Audit-Modified-files-metric\'"></kbn-vis>\n            <kbn-vis vis-id="\'Wazuh-App-Agents-Audit-Removed-files-metric\'"></kbn-vis>\n            <kbn-vis vis-id="\'Wazuh-App-Agents-Audit-Latest-alert\'"></kbn-vis>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-230">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Groups</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Audit-Groups" vis-id="\'Wazuh-App-Agents-Audit-Groups\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Directories</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Audit-Directories" vis-id="\'Wazuh-App-Agents-Audit-Directories\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Files</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Audit-Files" vis-id="\'Wazuh-App-Agents-Audit-Files\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-230">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts over time</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Audit-Alerts-over-time" vis-id="\'Wazuh-App-Agents-Audit-Alerts-over-time\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div class="height-448" layout="row" layout-align="center stretch">\n            <div flex="20" layout="column" layout-align="center stretch">\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column">\n                        <span class="wz-headline-title">File read access</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Agents-Audit-File-read-access" vis-id="\'Wazuh-App-Agents-Audit-File-read-access\'"></kbn-vis>\n                    </md-card-content>\n                </md-card>\n\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column">\n                        <span class="wz-headline-title">File write access</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Agents-Audit-File-write-access" vis-id="\'Wazuh-App-Agents-Audit-File-write-access\'"></kbn-vis>\n                    </md-card-content>\n                </md-card>\n            </div>\n\n            <div flex="60" layout="column" layout-align="center stretch">\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column">\n                        <span class="wz-headline-title">Commands</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Agents-Audit-Commands" vis-id="\'Wazuh-App-Agents-Audit-Commands\'"></kbn-vis>\n                    </md-card-content>\n                </md-card>\n            </div>\n\n            <div flex="20" layout="column" layout-align="center stretch">\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column">\n                        <span class="wz-headline-title">Created files</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Agents-Audit-Created-files" vis-id="\'Wazuh-App-Agents-Audit-Created-files\'"></kbn-vis>\n                    </md-card-content>\n                </md-card>\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column">\n                        <span class="wz-headline-title">Removed files</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Agents-Audit-Removed-files" vis-id="\'Wazuh-App-Agents-Audit-Removed-files\'"></kbn-vis>\n                    </md-card-content>\n                </md-card>\n            </div>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-570">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts summary</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis vis-id="\'Wazuh-App-Agents-Audit-Last-alerts\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="tab === \'ciscat\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- Metric bar section -->\n    <div layout="row" layout-align="start center">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Last not checked: <span class="wz-text-bold" ng-bind="ciscatScanNotChecked()"></span></div>\n                <div class="wz-text-truncatable" flex>Last pass: <span class="wz-text-bold" ng-bind="ciscatScanPass()"></span></div>\n                <div class="wz-text-truncatable" flex>Last scan score: <span class="wz-text-bold" ng-bind="ciscatScanScore()"></span></div>\n                <div class="wz-text-truncatable">Last scan date: <span class="wz-text-bold" ng-bind="ciscatScanTimestamp()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End metric bar section -->\n\n    <!-- Metric bar section -->\n    <div layout="row" layout-align="start center">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Last errors: <span class="wz-text-bold" ng-bind="ciscatScanError()"></span></div>\n                <div class="wz-text-truncatable" flex>Last fails: <span class="wz-text-bold" ng-bind="ciscatScanFail()"></span></div>\n                <div class="wz-text-truncatable" flex>Last unknown: <span class="wz-text-bold" ng-bind="ciscatScanUnknown()"></span></div>\n                <div class="wz-text-truncatable">Last scan benchmark: <span class="wz-text-bold" ng-bind="ciscatScanBenchmark()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End metric bar section -->\n\n    <!-- Hidden metric visualizations section -->\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-last-scan-error\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-last-scan-fail\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-last-scan-not-checked\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-last-scan-pass\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-last-scan-score\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-last-scan-timestamp\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-last-scan-benchmark\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-last-scan-unknown\'"></kbn-vis>\n    </div>\n    <!-- End hidden metric visualizations section -->\n\n    <!-- Top groups and result evolution section -->\n    <div layout="row" layout-align="start stretch" class="height-320">\n        <md-card flex="60" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 CIS-CAT groups</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-top-5-groups\'" id="Wazuh-app-Agents-CISCAT-top-5-groups"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Scan result evolution</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-scan-result-evolution\'" id="Wazuh-app-Agents-CISCAT-scan-result-evolution"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End top groups and result evolution section -->\n\n    <!-- Alerts summary table section -->\n    <div layout="row" layout-align="start stretch" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-app-Agents-CISCAT-alerts-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End alerts summary table section -->\n\n</md-content>\n<md-content flex layout="column" ng-if="tab === \'pci\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- View: Panels -->\n\n\n        <div layout="row" layout-align="center stretch">\n            <md-card flex class="wz-md-card">\n                <md-tabs md-selected="selectedPciIndex" class="wz-md-tab" md-border-bottom md-dynamic-height id="pciReq_tab">\n                    <md-tab ng-repeat="tab in pciTabs" ng-disabled="tab.disabled" label="{{tab.title}}">\n                        <div class="md-padding">\n                            <span class="wz-headline-title">PCI DSS Requirement: {{tab.title}}</span>\n                            <md-divider class="wz-margin-top-10"></md-divider>\n                            <div layout="row" class="wz-padding-top-10 wz-line-height">\n                                <div ng-bind-html="tab.content"></div>\n                            </div>\n                        </div>\n                    </md-tab>\n                </md-tabs>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-225">\n            <md-card flex="70" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">PCI Requirements</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-PCI-Requirements" vis-id="\'Wazuh-App-Agents-PCI-Requirements\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="30" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Groups</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-PCI-Groups" vis-id="\'Wazuh-App-Agents-PCI-Groups\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-570">\n            <md-card class="wz-md-card" flex>\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts summary</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis vis-id="\'Wazuh-App-Agents-PCI-Last-alerts\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n\n\n</md-content>\n<md-content flex layout="column" ng-if="tab === \'gdpr\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- View: Panels -->\n\n        <div layout="row" layout-align="center stretch">\n            <md-card flex class="wz-md-card">\n                <md-tabs md-selected="selectedGdprIndex" class="wz-md-tab" md-border-bottom md-dynamic-height id="gdprReq_tab">\n                    <md-tab ng-repeat="tab in gdprTabs" ng-disabled="tab.disabled" label="{{tab.title}}">\n                        <div class="md-padding">\n                            <span class="wz-headline-title">GDPR Requirement: {{tab.title}}</span>\n                            <md-divider class="wz-margin-top-10"></md-divider>\n                            <div layout="row" class="wz-padding-top-10 wz-line-height">\n                                <div ng-bind-html="tab.content"></div>\n                            </div>\n                        </div>\n                    </md-tab>\n                </md-tabs>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-225">\n            <md-card flex="30" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Groups</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-GDPR-Groups" vis-id="\'Wazuh-App-Agents-GDPR-Groups\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="70" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">GDPR Requirements</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-GDPR-Requirements" vis-id="\'Wazuh-App-Agents-GDPR-Requirements\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div layout="row" layout-align="center stretch" class="height-570">\n            <md-card class="wz-md-card" flex>\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Alerts summary</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis vis-id="\'Wazuh-App-Agents-GDPR-Last-alerts\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="tab === \'virustotal\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- View: Panels -->\n\n\n        <div layout="row">\n            <md-card flex class="wz-metric-color wz-md-card">\n                <md-card-content layout="row" class="wz-padding-metric">\n                    <div flex>Total malicious: <span class="wz-text-bold" ng-bind="virusMalicious()"></span></div>\n                    <div flex>Total positives: <span class="wz-text-bold" ng-bind="virusPositives()"></span></div>\n                    <div flex>Total: <span class="wz-text-bold" ng-bind="virusTotal()"></span></div>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div class="wz-no-display">\n            <kbn-vis vis-id="\'Wazuh-App-Agents-Virustotal-Total-Malicious\'"></kbn-vis>\n            <kbn-vis vis-id="\'Wazuh-App-Agents-Virustotal-Total-Positives\'"></kbn-vis>\n            <kbn-vis vis-id="\'Wazuh-App-Agents-Virustotal-Total\'"></kbn-vis>\n        </div>\n\n        <div layout="row" class="height-250">\n            <md-card flex="33" class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Last scanned files</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Virustotal-Last-Files-Pie" vis-id="\'Wazuh-App-Agents-Virustotal-Last-Files-Pie\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Malicious files alerts Evolution</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Virustotal-Malicious-Evolution" vis-id="\'Wazuh-App-Agents-Virustotal-Malicious-Evolution\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n        <div layout="row" class="height-570">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column">\n                    <span class="wz-headline-title">Last files</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Agents-Virustotal-Files-Table" vis-id="\'Wazuh-App-Agents-Virustotal-Files-Table\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n\n\n</md-content>\n<md-content layout="column" ng-if="tab === \'syscollector\'" ng-show="!load">\n\n    <div layout="row" class="layout-padding" ng-if="agent && agent.status !== \'Active\'">\n        <md-card flex class="wz-md-card" flex>\n            <md-card-content class="wz-text-center">\n                <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">Agent is not connected.</span>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="layout-padding" ng-if="agent && agent.status === \'Active\' && !hasSize(syscollector)">\n        <md-card flex class="wz-md-card" flex>\n            <md-card-content class="wz-text-center">\n                <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">Could not fetch inventory for this agent.</span>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="layout-padding wz-padding-bottom-0" ng-if="agent && agent.status === \'Active\' && hasSize(syscollector) && (!hasSize(syscollector.hardware) || !hasSize(syscollector.os))">\n        <md-card flex class="wz-md-card" flex>\n            <md-card-content class="wz-text-center">\n                <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">Not enough hardware or operating system information</span>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="inventory-metrics" ng-if="agent && agent.status === \'Active\' && hasSize(syscollector) && hasSize(syscollector.hardware) && hasSize(syscollector.os)">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div flex="10">Cores: <span class="wz-text-bold">{{ syscollector.hardware.cpu.cores }}</span></div>\n                <div flex="15">Memory: <span class="wz-text-bold">{{ (syscollector.hardware.ram.total / 1024) | number: 2 }} MB</span></div>\n                <div flex="10">Arch: <span class="wz-text-bold">{{ syscollector.os.architecture }}</span></div>\n                <div flex>OS: <span class="wz-text-bold">{{ syscollector.os.os.name }} {{ syscollector.os.os.version }}</span></div>\n                <div flex>CPU: <span class="wz-text-bold">{{ syscollector.hardware.cpu.name }}</span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n   \n    <div layout="row" class="layout-padding wz-padding-top-0" ng-if="agent && agent.status === \'Active\' && hasSize(syscollector)">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <span class="wz-headline-title"><i class="fa fa-fw fa-cubes"></i> Packages</span>\n                <span class="color-grey pull-right">Last scan: {{syscollector.packagesDate}}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-margin-top-10">\n                    <input placeholder="Filter packages..." ng-model="packageSearch" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid height-30"\n                        aria-invalid="false" wz-enter="search(packageSearch,\'packages\')">\n                    <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-30" ng-click="search(packageSearch,\'packages\')">\n                        <span class="fa fa-search" aria-hidden="true"></span>\n                    </button>\n                </div>\n\n                <div layout="row" ng-if="agent && syscollector && !load" class="wz-margin-top-10 wz-margin-bottom-40-inv">\n                    <wz-table flex \n                        ng-if="agent && agent.os && agent.os.platform !== \'windows\'"\n                        path="\'/syscollector/\' + agent.id + \'/packages\'" \n                        row-sizes="[10,8,6]" \n                        extra-limit="true" \n                        keys="[{value:\'name\',size:2},\'architecture\',\'version\',{value:\'vendor\',size:2},{value:\'description\',size:3}]"\n                    />\n                    <wz-table flex \n                        ng-if="agent && agent.os && agent.os.platform === \'windows\'"\n                        path="\'/syscollector/\' + agent.id + \'/packages\'" \n                        row-sizes="[10,8,6]" \n                        extra-limit="true" \n                        keys="[{value:\'name\',size:3},\'architecture\',\'version\',{value:\'vendor\',size:2}]"\n                    />\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="layout-padding wz-padding-top-0" ng-if="agent && agent.status === \'Active\' && hasSize(syscollector)">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <span class="wz-headline-title"><i class="fa fa-fw fa-terminal"></i> Processes</span>\n                <span class="color-grey pull-right">Last scan: {{syscollector.processesDate}}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-margin-top-10">\n                    <input placeholder="Filter processes..." ng-model="processSearch" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid height-30"\n                        aria-invalid="false" wz-enter="search(processSearch,\'processes\')">\n                    <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-30" ng-click="search(processSearch,\'processes\')">\n                        <span class="fa fa-search" aria-hidden="true"></span>\n                    </button>\n                </div>\n                <div layout="row" ng-if="agent && syscollector && !load" class="wz-margin-top-10 wz-margin-bottom-40-inv">\n                    <wz-table flex \n                        ng-if="agent && agent.os && agent.os.platform === \'windows\'"\n                        path="\'/syscollector/\' + agent.id + \'/processes\'" \n                        row-sizes="[10,8,6]" \n                        extra-limit="true" \n                        keys="[\'name\',\'cmd\',\'priority\',\'nlwp\']"\n                        />\n                    <wz-table flex \n                        ng-if="agent && agent.os && agent.os.platform !== \'windows\'"\n                        path="\'/syscollector/\' + agent.id + \'/processes\'" \n                        row-sizes="[10,8,6]" \n                        extra-limit="true" \n                        keys="[\'name\',\'euser\',\'nice\',\'state\']"\n                        />\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="layout-padding wz-padding-bottom-0" ng-if="agent && agent.status === \'Active\' && hasSize(syscollector)">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wz-text-center" ng-if="!syscollector.netiface || !syscollector.netiface.items || !syscollector.netiface.items.length">\n                <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">No interfaces scan available</span>\n             </md-card-content>\n            <md-card-content ng-if="syscollector.netiface && syscollector.netiface.items.length">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-sitemap"></i> Network interfaces</span>\n                <span class="color-grey pull-right">Last scan: {{syscollector.netiface.items[0].scan.time}}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <table class="table table-striped table-condensed table-layout-fixed">\n                    <thead class="wz-text-bold">\n                        <th class="wz-text-left">Name</th>\n                        <th class="wz-text-left">Mac</th>\n                        <th class="wz-text-left">State</th>\n                        <th class="wz-text-left">MTU</th>\n                        <th class="wz-text-left">Type</th>\n                    </thead>\n                    <tbody>\n                        <tr class="wz-word-wrap" ng-repeat="interface in syscollector.netiface.items">\n                            <td>{{interface.name}}</td>\n                            <td>{{interface.mac}}</td>\n                            <td>\n                                <svg ng-if="interface.state !== \'up\'" class="euiIcon euiIcon--medium euiIcon--warning" focusable="false" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><circle id="dot-a" cx="8" cy="8" r="4"></circle></defs><use xlink:href="#dot-a"></use></svg>\n                                <svg ng-if="interface.state === \'up\'" class="euiIcon euiIcon--medium euiIcon--success" focusable="false" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><circle id="dot-a" cx="8" cy="8" r="4"></circle></defs><use xlink:href="#dot-a"></use></svg>\n                                 {{interface.state}}\n                            </td>\n                            <td>{{interface.mtu}}</td>\n                            <td>{{interface.type}}</td>\n                        </tr>\n                    </tbody>\n                </table>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wz-text-center wz-margin-bottom-40-inv" ng-if="syscollector.ports && !syscollector.ports.items.length">\n                <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">No ports scan available</span>\n            </md-card-content>\n            <md-card-content class="wz-margin-bottom-40-inv" ng-if="syscollector.ports && syscollector.ports.items.length">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-exchange"></i> Network ports</span>\n                <span class="color-grey pull-right">Last scan: {{syscollector.ports.items[0].scan.time}}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <wz-table flex ng-if="agent && agent.os && agent.os.platform === \'windows\'" path="\'/syscollector/\' + agent.id + \'/ports\'" row-sizes="[4]" keys="[{value:\'process\',nosortable:true},{value:\'local.ip\',nosortable:true}, {value:\'local.port\',nosortable:true},\'state\',\'protocol\']">\n                </wz-table>\n                <wz-table flex ng-if="agent && agent.os && agent.os.platform !== \'windows\'" path="\'/syscollector/\' + agent.id + \'/ports\'" row-sizes="[4]" keys="[{value:\'local.ip\',nosortable:true}, {value:\'local.port\',nosortable:true},\'state\',\'protocol\']">\n                </wz-table>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="layout-padding wz-padding-bottom-0" ng-if="agent && agent.status === \'Active\' && hasSize(syscollector)">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wz-text-center" ng-if="!syscollector.netaddr || !syscollector.netaddr.items || !syscollector.netaddr.items.length">\n                <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">No network addresses scan available</span>\n             </md-card-content>\n            <md-card-content class="wz-margin-bottom-40-inv" ng-if="syscollector.netaddr && syscollector.netaddr.items.length">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-exchange"></i> Network addresses</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <wz-table flex path="\'/syscollector/\' + agent.id + \'/netaddr\'" row-sizes="[4]" keys="[\'iface\', \'address\', \'netmask\', \'proto\', \'broadcast\']">\n                </wz-table>\n            </md-card-content>\n        </md-card>\n    </div>\n</md-content>\n<md-content flex layout="column" ng-if="tab === \'osquery\' && tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n    <div layout="row" class="height-300">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Most common Osquery packs being used</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-Osquery-top-5-packs-being-used" vis-id="\'Wazuh-App-Agents-Osquery-top-5-packs-being-used\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="70" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Evolution of Osquery events per pack over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-Osquery-events-per-pack-over-time" vis-id="\'Wazuh-App-Agents-Osquery-events-per-pack-over-time\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="height-300">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Most common Osquery actions</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-Osquery-most-common-osquery-actions" vis-id="\'Wazuh-App-Agents-Osquery-most-common-osquery-actions\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n\n        <md-card flex="70" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Most common rules</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-Osquery-monst-common-rules-being-fired" vis-id="\'Wazuh-App-Agents-Osquery-monst-common-rules-being-fired\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="height-300">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Evolution of Osquery events over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Agents-Osquery-events-over-time" vis-id="\'Wazuh-App-Agents-Osquery-events-over-time\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n</md-content>' + (null == (pug_interp = __webpack_require__(5298).call(this, locals)) ? "" : pug_interp) + "</div>";
			return pug_html
		}
		module.exports = template
	},
	5297: function (module, exports) {},
	5298: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_interp, pug_html = "";
			pug_html = pug_html + '<div flex="auto" layout="column" ng-if="tab === \'configuration\' && load">\n    <div layout="row" class="md-padding">\n        <div class=\'uil-ring-css\'><div></div></div>\n    </div>\n</div>\n\n<div flex="auto" layout="column" ng-show="tab === \'configuration\' && !load">\n\n    <div layout="row" class="wz-padding-top-0 wz-padding-bottom-0" ng-if="agent && agent.group">\n        <md-card flex class="wz-metric-color wz-md-card wz-no-padding">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-word-break" flex ng-if="agent.group">\n                    Groups: <span ng-repeat="group in agent.group" class="wz-text-bold wz-text-link" ng-click="goGroups(agent,$index)">{{ group }}&nbsp;</span>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div><div flex="auto" layout="column" ng-if="configurationTab === \'welcome\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div ng-show="agent && agent.id !== \'000\'">\n            <span class="font-size-18"> <i class="fa fa-fw fa-cog" aria-hidden="true"></i> Configuration</span>\n            <span ng-if="isSynchronized" class="wz-agent-status-indicator small teal">SYNCHRONIZED</span>\n            <span ng-if="!isSynchronized" class="wz-agent-status-indicator small red">NOT SYNCHRONIZED</span>\n        </div>\n        <span class="font-size-18" ng-show="!agent || agent.id === \'000\'">\n                <i class="fa fa-fw fa-cog" aria-hidden="true"></i> Configuration</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Configuration section cards and right sidenav -->\n    <div flex="auto" layout="row">\n\n        <!-- This section has the configuration cards -->\n        <div flex layout="column">\n\n            <!-- Main configurations card -->\n            <md-card class="wz-md-card">\n                <md-card-content>\n                    <span class="font-size-16">Main configurations</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <!-- Manager sections -->\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'global-configuration\', [{component:\'analysis\',configuration:\'global\'},{component:\'request\',configuration:\'remote\'},{component:\'com\',configuration:\'logging\'}])">Global configuration</h3>\n                                <p>Global and remote settings</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'cluster\', [{component:\'com\',configuration:\'cluster\'}])">Cluster</h3>\n                                <p>Master node configuration</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'registration-service\', [{component:\'auth\',configuration:\'auth\'}])">Registration service</h3>\n                                <p>Automatic agent registration service</p>\n                            </div>\n                        </md-list-item>\n                        <!-- <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'ruleset\')">Ruleset</h3>\n                                <p>Current rules, decoders and CDB lists loaded in the cluster</p>\n                            </div>\n                        </md-list-item> -->\n                        <!-- End manager sections -->\n                        <!-- Agent sections -->\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'global-configuration\', [{component:\'com\',configuration:\'logging\'}])">Global configuration</h3>\n                                <p>Logging settings that apply to the agent</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'client\', [{component:\'agent\',configuration:\'client\'}])">Communication</h3>\n                                <p>Settings related to the connection with the manager</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'client-buffer\', [{component:\'agent\',configuration:\'buffer\'}])">Anti-flooding settings</h3>\n                                <p>Agent bucket parameters to avoid event flooding</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'alerts\',[{component:\'agent\',configuration:\'labels\'}])">Labels</h3>\n                                <p>User-defined information about the agent included in alerts</p>\n                            </div>\n                        </md-list-item>\n                        <!-- End agent sections -->\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End main configurations card -->\n\n            <!-- Alerts and output management card -->\n            <md-card class="wz-md-card" ng-if="!agent || agent.id === \'000\'">\n                <md-card-content>\n                    <span class="font-size-16" ng-if="!agent || agent.id === \'000\'">Alerts and output management</span>\n                      <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'alerts\',[{component:\'analysis\',configuration:\'alerts\'},{component:\'analysis\',configuration:\'labels\'},{component:\'mail\',configuration:\'alerts\'},{component:\'monitor\',configuration:\'reports\'}, {component:\'csyslog\',configuration:\'csyslog\'}])">Alerts</h3>\n                                <p>Settings related to the alerts and their format</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'integrations\',[{component:\'integrator\',configuration:\'integration\'}])">Integrations</h3>\n                                <p>Slack, VirusTotal and PagerDuty integrations with external APIs</p>\n                            </div>\n                        </md-list-item>\n                        <!-- <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'database-output\')">Database output</h3>\n                                <p>MySQL and PostgreSQL database output configuration</p>\n                            </div>\n                        </md-list-item> -->\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End alerts and output management card -->\n\n            <!-- Auditing and policy monitoring card -->\n            <md-card class="wz-md-card">\n                <md-card-content>\n                    <span class="font-size-16">Auditing and policy monitoring</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'policy-monitoring\', [{component:\'syscheck\',configuration:\'rootcheck\'}])">Policy monitoring</h3>\n                                <p>Configuration to ensure compliance with security policies, standards and hardening guides</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'open-scap\')">OpenSCAP</h3>\n                                <p>Configuration assessment and automation of compliance monitoring using SCAP checks</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'cis-cat\')">CIS-CAT</h3>\n                                <p>Configuration assessment using CIS scanner and SCAP checks</p>\n                            </div>\n                        </md-list-item>\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End auditing and policy monitoring card -->\n\n            <!-- System, threats and incident response card -->\n            <md-card class="wz-md-card">\n                <md-card-content>\n                    <span class="font-size-16">System threats and incident response</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'vulnerability-detector\')">Vulnerabilities</h3>\n                                <p>Discover what applications are affected by well-known vulnerabilities</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'osquery\')">Osquery</h3>\n                                <p>Expose an operating system as a high-performance relational database</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'syscollector\')">Inventory data</h3>\n                                <p>Gather relevant information about system OS, hardware, networking and packages</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'active-response\',[{component:\'analysis\',configuration:\'command\'},{component:\'analysis\',configuration:\'active_response\'}])">Active response</h3>\n                                <p>Active threat addressing by inmmediate response</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'active-response\',[{component:\'com\',configuration:\'active-response\'}])">Active response</h3>\n                                <p>Active threat addressing by inmmediate response</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'command\')">Commands</h3>\n                                <p>Configuration options of the Command wodle</p>\n                            </div>\n                        </md-list-item>\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End system, threats and incident response card -->\n\n            <!-- Log data analysis card -->\n            <md-card class="wz-md-card">\n                <md-card-content>\n                    <span class="font-size-16">Log data analysis</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'log-collection\',[{component:\'logcollector\',configuration:\'localfile\'},{component:\'logcollector\',configuration:\'socket\'}])">Log collection</h3>\n                                <p>Log analysis from text files, Windows events or syslog outputs</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'integrity-monitoring\',[{component:\'syscheck\',configuration:\'syscheck\'}])">Integrity monitoring</h3>\n                                <p>Identify changes in content, permissions, ownership, and attributes of files</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'agentless\',[{component:\'agentless\',configuration:\'agentless\'}])">Agentless</h3>\n                                <p>Run integrity checks on devices such as routers, firewalls and switches</p>\n                            </div>\n                        </md-list-item>\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End log data analysis card -->\n\n            <!-- Cloud security monitoring card -->\n            <md-card class="wz-md-card" ng-if="!agent || agent.id === \'000\'">\n                <md-card-content>\n                    <span class="font-size-16">Cloud security monitoring</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'aws-s3\')">Amazon S3</h3>\n                                <p>Security events related to Amazon AWS services, collected directly via AWS API</p>\n                            </div>\n                        </md-list-item>\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End cloud security monitoring card -->\n\n        </div>\n        <!-- End configuration cards section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <!--md-subheader>More info about this section</md-subheader--!>\n                <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/manager/index.html">Wazuh administration documentation</md-list-item--!>\n                <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/index.html">Wazuh capabilities documentation</md-list-item--!>\n                <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/index.html">Local configuration reference</md-list-item--!>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End configuration section cards and right sidenav -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(1688).call(this, locals)) ? "" : pug_interp) + '<div flex="auto" layout="column" ng-if="configurationTab === \'client\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Communication</span>\n        </div>\n        <span class="md-subheader">Settings related to the connection with the manager</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'agent-client\']"\n          ng-if="currentConfig[\'agent-client\'] && isString(currentConfig[\'agent-client\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig[\'agent-client\'] && !isString(currentConfig[\'agent-client\'])">\n\n            <!-- The main card will all the settings -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Main settings</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">Basic manager-agent communication settings</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Method used to encrypt communications"\n                            value="currentConfig[\'agent-client\'].client.crypto_method || \'aes\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Auto-restart the agent when receiving valid configuration from manager"\n                            value="currentConfig[\'agent-client\'].client.auto_restart || \'yes\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Time (in seconds) between agent checkings to the manager"\n                            value="currentConfig[\'agent-client\'].client.notify_time || \'60\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Time (in seconds) before attempting to reconnect"\n                            value="currentConfig[\'agent-client\'].client[\'time-reconnect\'] || \'300\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Configuration profiles"\n                            value="currentConfig[\'agent-client\'].client[\'config-profile\'] || \'-\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            ng-if="currentConfig[\'agent-client\'].client.local_ip"\n                            label="IP address used when the agent has multiple network interfaces"\n                            value="currentConfig[\'agent-client\'].client.local_ip">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                    <div ng-if="currentConfig[\'agent-client\'].client.server.length" class="wz-margin-top-10">\n                        <span class="font-size-16">Server settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">List of managers to connect</span>\n                        </div>\n                    </div>\n                    <md-divider ng-if="currentConfig[\'agent-client\'].client.server.length" class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div ng-if="currentConfig[\'agent-client\'].client.server.length" class="wz-padding-top-10">\n\n                        <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                            <thead class="wz-text-bold">\n                                <th class="wz-text-left">Address</th>\n                                <th class="wz-text-left">Port</th>\n                                <th class="wz-text-left">Protocol</th>\n                            </thead>\n                            <tbody class="wz-word-wrap">\n                                <tr ng-repeat="item in currentConfig[\'agent-client\'].client.server">\n                                    <td>{{ item.address || \'-\' }}</td>\n                                    <td>{{ item.port || \'1514\' }}</td>\n                                    <td>{{ item.protocol || \'udp\' }}</td>\n                                </tr>\n                            </tbody>\n                        </table>\n\n                    </div>\n                    <!-- End configuration block -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <!--md-subheader>More info about this section</md-subheader--!>\n                <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/agents/agent-connection.html">Checking connection with manager</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/client.html">Client reference</md-list-item--!>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n<div flex="auto" layout="column" ng-if="configurationTab === \'client-buffer\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Anti-flooding settings</span>\n            <span ng-if="(currentConfig[\'agent-buffer\'] && currentConfig[\'agent-buffer\'].buffer && currentConfig[\'agent-buffer\'].buffer.disabled === \'no\') || (currentConfig[\'agent-buffer\'] && currentConfig[\'agent-buffer\'].buffer && !currentConfig[\'agent-buffer\'].buffer.disabled)" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="currentConfig[\'agent-buffer\'] && currentConfig[\'agent-buffer\'].buffer && currentConfig[\'agent-buffer\'].buffer.disabled === \'yes\'" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Agent bucket parameters to avoid event flooding</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'agent-buffer\']"\n          ng-if="currentConfig[\'agent-buffer\'] && isString(currentConfig[\'agent-buffer\'])"></wz-no-config>\n        <wz-no-config\n          flex\n          error="\'not-present\'"\n          ng-if="currentConfig[\'agent-buffer\'] && !isString(currentConfig[\'agent-buffer\']) && !currentConfig[\'agent-buffer\'].buffer"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig[\'agent-buffer\'] && !isString(currentConfig[\'agent-buffer\']) && currentConfig[\'agent-buffer\'].buffer">\n\n            <!-- The main card will all the settings -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Main settings</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">These settings determine the event processing rate for the agent</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Buffer status"\n                            value="currentConfig[\'agent-buffer\'].buffer.disabled === \'yes\'? \'disabled\' : \'enabled\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Queue size"\n                            value="currentConfig[\'agent-buffer\'].buffer.queue_size || \'5000\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Events per second"\n                            value="currentConfig[\'agent-buffer\'].buffer.events_per_second || \'500\'">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <!--md-subheader>More info about this section</md-subheader--!>\n                <!--md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/antiflooding.html">Anti-flooding mechanism</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/agent_buffer.html">Client buffer reference</md-list-item--!>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(1689).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(1690).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(1691).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(1692).call(this, locals)) ? "" : pug_interp) + '<div flex="auto" layout="column" ng-if="configurationTab === \'osquery\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Osquery</span>\n            <span ng-if="currentConfig && currentConfig.osquery && currentConfig.osquery.disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="(currentConfig && currentConfig.osquery && currentConfig.osquery.disabled === \'yes\') || (currentConfig && !currentConfig.osquery)" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Expose an operating system as a high-performance relational database</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n      <!-- No configuration section -->\n      <wz-no-config\n        flex\n        error="currentConfig[\'wmodules-wmodules\']"\n        ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n      <wz-no-config\n        flex\n        error="\'not-present\'"\n        ng-if="currentConfig && !currentConfig.osquery && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n      <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig.osquery">\n\n            <!-- The main card will all the settings -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Main settings</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">General Osquery integration settings</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Osquery integration status"\n                            value="currentConfig.osquery.disabled === \'yes\' ? \'disabled\' : \'enabled\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Auto-run the Osquery daemon"\n                            value="currentConfig.osquery.run_daemon">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Path to the Osquery executable"\n                            value="currentConfig.osquery.bin_path">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Path to the Osquery results log file"\n                            value="currentConfig.osquery.log_path">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Path to the Osquery configuration file"\n                            value="currentConfig.osquery.config_path">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Use defined labels as decorators"\n                            value="currentConfig.osquery.add_labels">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                    <div ng-if="currentConfig.osquery.packs && isArray(currentConfig.osquery.packs) && currentConfig.osquery.packs.length" class="wz-margin-top-10">\n                        <span class="font-size-16">Osquery packs</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">A pack contains multiple queries to quickly retrieve system information</span>\n                        </div>\n                    </div>\n                    <md-divider ng-if="currentConfig.osquery.packs && isArray(currentConfig.osquery.packs) && currentConfig.osquery.packs.length" class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div ng-if="currentConfig.osquery.packs && isArray(currentConfig.osquery.packs) && currentConfig.osquery.packs.length" class="wz-padding-top-10">\n\n                        <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                            <thead class="wz-text-bold">\n                                <th class="wz-text-left col-lg-4">Name</th>\n                                <th class="wz-text-left col-lg-8">Path</th>\n                            </thead>\n                            <tbody class="wz-word-wrap">\n                                <tr ng-repeat="item in currentConfig.osquery.packs">\n                                    <td>{{ item.name }}</td>\n                                    <td>{{ item.path }}</td>\n                                </tr>\n                            </tbody>\n                        </table>\n\n                    </div>\n                    <!-- End configuration block -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <!--md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/osquery.html">Osquery module documentation</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-osquery.html">Osquery module reference</md-list-item--!>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n<div flex="auto" layout="column" ng-if="configurationTab === \'syscollector\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Inventory data</span>\n            <span ng-if="currentConfig && currentConfig.syscollector && currentConfig.syscollector.disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="(currentConfig && currentConfig.syscollector && currentConfig.syscollector.disabled === \'yes\') || (currentConfig && !currentConfig.syscollector)" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Gather relevant information about system OS, hardware, networking and packages</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n      <!-- No configuration section -->\n      <wz-no-config\n        flex\n        error="currentConfig[\'wmodules-wmodules\']"\n        ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n      <wz-no-config\n        flex\n        error="\'not-present\'"\n        ng-if="currentConfig && !currentConfig.syscollector && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n      <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig.syscollector">\n\n            <!-- The main card will all the settings -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Main settings</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">General settings applied to all the scans</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Syscollector integration status"\n                            value="currentConfig.syscollector.disabled === \'yes\' ? \'disabled\' : \'enabled\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Interval between system scans"\n                            value="currentConfig.syscollector.interval">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan on start"\n                            value="currentConfig.syscollector[\'scan-on-start\']">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                    <div class="wz-margin-top-10">\n                        <span class="font-size-16">Scan settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Specific inventory scans to collect</span>\n                        </div>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Scan hardware info"\n                            value="currentConfig.syscollector.hardware">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan current processes"\n                            value="currentConfig.syscollector.processes">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan operating system info"\n                            value="currentConfig.syscollector.os">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan installed packages"\n                            value="currentConfig.syscollector.packages">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan network interfaces"\n                            value="currentConfig.syscollector.network">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan listening network ports"\n                            value="currentConfig.syscollector.ports">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan all network ports"\n                            value="currentConfig.syscollector.ports_all">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <!--md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/syscollector.html">Syscollector module documentation</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-syscollector.html">Syscollector module reference</md-list-item--!>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(5299).call(this, locals)) ? "" : pug_interp) + '<div flex="auto" layout="column" ng-if="configurationTab === \'command\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Commands</span>\n        </div>\n        <span class="md-subheader">Configuration options of the Command wodle</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'wmodules-wmodules\']"\n          ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <wz-no-config\n          flex\n          error="\'not-present\'"\n          ng-if="currentConfig && !currentConfig.commands && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig.commands && !isString(currentConfig[\'wmodules-wmodules\']) && currentConfig.commands.length">\n\n            <!-- The main card will all the settings -->\n            <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content flex layout="column">\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Command definitions</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">Find here all the currently defined commands</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- The container for both list and detail -->\n                    <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                        <!-- List container -->\n                        <div flex="30" layout="column">\n\n                            <md-list flex="auto" class="wz-item-list">\n                                <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig.commands">{{item.tag}}</md-list-item>\n                            </md-list>\n\n                        </div>\n                        <!-- End list container -->\n\n                        <!-- Detail container -->\n                        <div flex layout="column">\n\n                            <div flex="auto" class="wz-item-detail">\n                                <wz-config-item\n                                    label="Command status"\n                                    value="currentConfig.commands[selectedItem].disabled === \'no\' ? \'enabled\' : \'disabled\'">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Command name"\n                                    value="currentConfig.commands[selectedItem].tag">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Command to execute"\n                                    value="currentConfig.commands[selectedItem].command">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Interval between executions"\n                                    value="currentConfig.commands[selectedItem].interval">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Run on start"\n                                    value="currentConfig.commands[selectedItem].run_on_start">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Ignore command output"\n                                    value="currentConfig.commands[selectedItem].ignore_output">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Timeout (in seconds) to wait for execution"\n                                    value="currentConfig.commands[selectedItem].timeout">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Verify MD5 sum"\n                                    value="currentConfig.commands[selectedItem].verify_md5">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Verify SHA1 sum"\n                                    value="currentConfig.commands[selectedItem].verify_sha1">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Verify SHA256 sum"\n                                    value="currentConfig.commands[selectedItem].verify_sha256">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Ignore checksum verification"\n                                    value="currentConfig.commands[selectedItem].skip_verification">\n                                </wz-config-item>\n                            </div>\n\n                        </div>\n                        <!-- End detail container -->\n                    </div>\n                    <!-- End container for both list and detail -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <!--md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-command.html">Command module reference</md-list-item--!>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(1693).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(1694).call(this, locals)) ? "" : pug_interp) + "</div>";
			return pug_html
		}
		module.exports = template
	},
	5299: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'active-response\'" ng-init="switchConfigurationSubTab(\'active-response\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Active response</span>\n        </div>\n        <span class="md-subheader">Active threat addressing by inmmediate response</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Commands & Active response navigation bar -->\n    <md-nav-bar\n        ng-if="!agent || agent.id === \'000\'"\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Active response navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'active-response\')" name="active-response">Active response</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'commands\')" name="commands">Commands</md-nav-item>\n    </md-nav-bar>\n    <!-- End Commands & Active response navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'active-response\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'com-active-response\']"\n      ng-if="currentConfig[\'com-active-response\'] && isString(currentConfig[\'com-active-response\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'com-active-response\'] && !isString(currentConfig[\'com-active-response\']) && !currentConfig[\'com-active-response\'][\'active-response\']"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'com-active-response\'] && !isString(currentConfig[\'com-active-response\']) && currentConfig[\'com-active-response\'][\'active-response\']">\n\n        <!-- The main card will all the settings -->\n        <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content>\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Active response settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Find here all the Active response settings for this agent</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- Configuration block -->\n                <div class="wz-padding-top-10">\n\n                    <wz-config-item\n                        label="Active response status"\n                        value="currentConfig[\'com-active-response\'][\'active-response\'] === \'yes\' ? \'disabled\' : \'enabled\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="List of timeouts (in minutes) for repeated offenders"\n                        value="currentConfig[\'com-active-response\'][\'active-response\'].repeated_offenders">\n                    </wz-config-item>\n                    <wz-config-item\n                        is-array="true"\n                        label="Use the following list of root CA certificates"\n                        value="currentConfig[\'com-active-response\'][\'active-response\'].ca_store">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Validate WPKs using root CA certificate"\n                        value="currentConfig[\'com-active-response\'][\'active-response\'].ca_verification">\n                    </wz-config-item>\n\n                </div>\n                <!-- End configuration block -->\n\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <!--md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/active-response/index.html">Active response documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/active-response.html">Active response reference</md-list-item--!>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'commands\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'analysis-command\']"\n      ng-if="currentConfig[\'analysis-command\'] && isString(currentConfig[\'analysis-command\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'analysis-command\'] && !isString(currentConfig[\'analysis-command\']) && currentConfig[\'analysis-command\'].command && !currentConfig[\'analysis-command\'].command.length"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'analysis-command\'] && !isString(currentConfig[\'analysis-command\']) && currentConfig[\'analysis-command\'].command && currentConfig[\'analysis-command\'].command.length">\n\n        <!-- The main card will all the settings -->\n        <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content flex layout="column">\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Command definitions</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Find here all the currently defined commands used for Active response</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- The container for both list and detail -->\n                <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                    <!-- List container -->\n                    <div flex="30" layout="column">\n\n                        <md-list flex="auto" class="wz-item-list">\n                            <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'analysis-command\'].command">{{item.name}}</md-list-item>\n                        </md-list>\n\n                    </div>\n                    <!-- End list container -->\n\n                    <!-- Detail container -->\n                    <div flex layout="column" ng-if="currentConfig[\'analysis-command\'].command.length">\n\n                        <div flex="auto" class="wz-item-detail">\n                            <wz-config-item\n                                label="Command name"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].name">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Name of executable file"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].executable">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="List of expected fields"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].expect">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Extra arguments"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].extra_args">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Allow this command to be reverted"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].timeout_allowed ? \'yes\' : \'no\'">\n                            </wz-config-item>\n                        </div>\n\n                    </div>\n                    <!-- End detail container -->\n                </div>\n                <!-- End container for both list and detail -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/active-response/index.html">Active response documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/commands.html">Commands reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	5300: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div ng-cloak flex="auto" ng-controller="agentsPreviewController as ctrl" layout="column" class="mozilla-table-size-99">\n\n    <wz-menu ng-init="menuNavItem = \'agents\'"></wz-menu>\n\n    <div class=\'uil-ring-css\' ng-show="ctrl.init || ctrl.loading">\n        <div></div>\n    </div>\n<div ng-if="!ctrl.init && !ctrl.loading" class="md-padding" layout="column" layout-align="start space-around">\n    <div layout="row" layout-align="space-between stretch">\n        <md-card flex class="no-margin-left wz-md-card">\n            <md-card-content>\n                <span class="wz-headline-title">Status</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row">\n                    <div flex layout="column">\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50">Active</p>\n                            <p class="wz-text-right color-grey">{{ctrl.agentsCountActive}}</p>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50">Disconnected</p>\n                            <p class="wz-text-right color-grey">{{ctrl.agentsCountDisconnected}}</p>\n                        </div>\n                    </div>\n                    <div flex layout="column">\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50">Never connected</p>\n                            <p class="wz-text-right color-grey">{{ctrl.agentsCountNeverConnected}}</p>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50">Agents coverage</p>\n                            <p class="wz-text-right color-grey">{{(ctrl.agentsCoverity | number:2)}}%</p>\n                        </div>\n                    </div>\n                </div>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="no-margin-right wz-md-card">\n            <md-card-content>\n                <span class="wz-headline-title">Top</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-padding-top-10">\n                    <p flex="35" class="manager-status-subtitle">Last registered agent</p>\n                    <p ng-if="ctrl.lastAgent.id !== \'000\'" class="wz-text-right wz-text-link" tooltip="Click to open this agent"\n                        tooltip-placement="right" ng-click="ctrl.showAgent(ctrl.lastAgent)">{{ctrl.lastAgent.name}}</p>\n                    <p ng-if="ctrl.lastAgent.id === \'000\'" class="wz-text-right" tooltip-placement="right">{{ctrl.lastAgent.name}}\n                        (manager)</p>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <p flex="35" class="manager-status-subtitle">Higher activity</p>\n                    <p ng-show="ctrl.mostActiveAgent.id !== \'000\'" class="wz-text-right wz-text-link" tooltip="Click to open this agent"\n                        tooltip-placement="right" ng-click="ctrl.showAgent(ctrl.mostActiveAgent)">{{ctrl.mostActiveAgent.name}}</p>\n                    <p ng-show="ctrl.mostActiveAgent.id === \'000\'" class="wz-text-right" tooltip-placement="right">{{ctrl.mostActiveAgent.name}}</p>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <wz-tag-filter path="\'/agents\'" query-fn="ctrl.query(q, search)" fields-model="ctrl.searchBarModel"></wz-tag-filter>\n\n    <div layout="row" class="margin-top-30">\n        <wz-table flex path="\'/agents\'" keys="[\'id\',\'name\',\'ip\',\'status\',\'group\',\'os.name\',\'os.version\',\'version\', \'dateAdd\', \'lastKeepAlive\']"\n            allow-click="true" row-sizes="[17,15,13]">\n        </wz-table>\n    </div>\n\n    <div layout="row" class="wz-margin-top-10">\n        <span flex></span>\n        <a class="small" id="btnDownload" ng-click="ctrl.downloadCsv()">Formatted\n            <i aria-hidden="true" class="fa fa-download"></i>\n        </a>\n    </div>\n</div></div>';
			return pug_html
		}
		module.exports = template
	},
	5301: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_interp, pug_html = "";
			pug_html = pug_html + '<div flex="auto" layout="column" ng-cloak ng-controller="managementController as mctrl">\n\n    <!-- Top navbar section -->\n    <wz-menu ng-init="menuNavItem = \'manager\'"></wz-menu>\n    <!-- End top navbar section -->\n\n    <!-- Navigation section -->\n    <div layout="row" layout-align="start center" ng-if="mctrl.tab !== \'monitoring\' && mctrl.tab !== \'configuration\'">\n        <!-- Breadcrumbs -->\n        <div layout="row" layout-padding>\n            <!-- If you\'re not on the Welcome tab, show a functional breadcrumb -->\n          <!--  <div ng-if="mctrl.tab !== \'welcome\' && !mctrl.currentGroup">\n              <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n                <span> / {{ mctrl.tabNames[mctrl.tab] }}</span>\n         </div>\n    -->        <div ng-if="mctrl.tab === \'groups\' && mctrl.currentGroup && mctrl.currentGroup.name">\n          <!--      <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n     -->     <!--      <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'groups\')"> / {{ mctrl.tabNames[mctrl.tab] }}</span>\n  -->        <!--      <span> / {{ mctrl.currentGroup.name }} </span>\n        -->    </div>\n            <!-- If you\'re on the Welcome tab, show a blank, simple breadcrumb -->\n            <div ng-if="mctrl.tab === \'welcome\'">\n                <span>Management / Welcome</span>\n            </div>\n        </div>\n        <!-- End breadcrumbs -->\n    </div>\n    <!-- End navigation section -->\n\n    <!-- Wazuh management navigation bar -->\n    <md-nav-bar\n        ng-if="!mctrl.load && mctrl.inArray(mctrl.tab, mctrl.wazuhManagementTabs)"\n        class="wz-nav-bar"\n        ng-show="mctrl.tab !== \'welcome\'"\n        md-selected-nav-item="mctrl.tab"\n        nav-bar-aria-label="Wazuh management navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'ruleset\')" name="ruleset">Ruleset</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'groups\')" name="groups">Groups</md-nav-item>\n    </md-nav-bar>\n    <!-- End Wazuh management navigation bar -->\n\n    <!-- Status and reports navigation bar -->\n    <md-nav-bar\n        ng-if="!mctrl.load && mctrl.inArray(mctrl.tab, mctrl.statusReportsTabs) && mctrl.tab !== \'monitoring\'"\n        class="wz-nav-bar"\n        ng-show="mctrl.tab !== \'welcome\'"\n        md-selected-nav-item="mctrl.tab"\n        nav-bar-aria-label="Status and reports navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'status\')" name="status">Status</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'logs\')" name="logs">Logs</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'monitoring\')" name="monitoring">Cluster</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'reporting\')" name="reporting">Reporting</md-nav-item>\n    </md-nav-bar>\n    <!-- End Status and reports navigation bar -->\n<div layout="column" layout-align="start stretch" ng-if="mctrl.tab === \'welcome\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-server" aria-hidden="true"></i> Management</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Wazuh management card -->\n\n    <div layout="row" layout-padding>\n        <div class="euiFlexGroup euiFlexGroup--gutterLarge euiFlexGroup--responsive">\n            <div class="euiFlexItem">\n                <div class="euiPanel euiPanel--paddingLarge">\n                    <h3 class="euiTitle wzEuiTitle">Administration</h3>\n                    <div class="euiSpacer euiSpacer--m"></div>\n                    <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/ruleset.png\'" title="\'Ruleset\'"\n                            switch-tab="mctrl.switchTab(\'ruleset\')" current-tab="\'rules\'"\n                            description="\'Explore your Wazuh cluster ruleset.\'"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/groups.png\'"\n                            title="\'Groups\'" switch-tab="mctrl.switchTab(\'groups\')" current-tab="\'groups\'"\n                            description="\'Check your agent groups.\'"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_devtools.svg\'"\n                            title="\'Configuration\'" switch-tab="mctrl.switchTab(\'configuration\')" current-tab="\'configuration\'"\n                            description="\'Check your Wazuh cluster configuration.\'"\n                        ></wz-welcome-card>\n                    </div>\n                </div>\n            </div>\n            <div class="euiFlexItem">\n                <div class="euiPanel euiPanel--paddingLarge">\n                    <h3 class="euiTitle wzEuiTitle">Status and reports</h3>\n                    <div class="euiSpacer euiSpacer--m"></div>\n                    <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_monitoring.svg\'" title="\'Status\'"\n                            switch-tab="mctrl.switchTab(\'status\')" current-tab="\'status\'"\n                            description="\'Check your Wazuh cluster status.\'"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_logging.svg\'" title="\'Logs\'"\n                            switch-tab="mctrl.switchTab(\'logs\')" current-tab="\'logs\'"\n                            description="\'Logs from your Wazuh cluster.\'"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_index_pattern.svg\'" title="\'Cluster\'"\n                            switch-tab="mctrl.switchTab(\'monitoring\')" current-tab="\'monitoring\'"\n                            description="\'Visualize your Wazuh cluster.\'"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/reporting.png\'" title="\'2_Reporting\'"\n                            switch-tab="mctrl.switchTab(\'reporting\')" current-tab="\'reporting\'"\n                            description="\'Check your stored Wazuh reports.\'"\n                        ></wz-welcome-card>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n<div layout="column" layout-align="start stretch" ng-controller="managerStatusController as ctrl" ng-if="mctrl.tab === \'status\'">\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="ctrl.load">\n        <div></div>\n    </div>\n\n    <!-- Headline -->\n    <div ng-show="!ctrl.load" layout="row" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-heartbeat" aria-hidden="true"></i> Status</span>\n    </div>\n    <div ng-show="!ctrl.load" layout="row" layout-padding>\n        <div flex layout="column" layout-align="center" class="height-40 wz-margin-right-15">\n            <span class="md-subheader">Check the status of all Wazuh manager daemons <span ng-show="ctrl.selectedNode">({{ctrl.selectedNode}})</span></span>\n        </div>\n        <div ng-show="ctrl.selectedNode" layout="column" layout-align="center" class="height-40 wz-select-input">\n            <select class="kuiSelect wz-border-none cursor-pointer max-height-35" id="categoryBox" ng-model="ctrl.selectedNode"\n                ng-change="ctrl.changeNode(ctrl.selectedNode)" aria-label="Select node">\n                <option ng-repeat="node in ctrl.nodes" value="{{node.name}}">{{node.name}}</option>\n            </select>\n        </div>\n    </div>\n    <!-- End headline -->\n\n    <div layout="row" class="wz-margin-top-10 wz-margin-right-8 wz-margin-left-8" ng-show="ctrl.clusterError && !ctrl.load">\n        <div flex class="euiCallOut euiCallOut--warning">\n            <div class="euiCallOutHeader">\n                <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"\n                    xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16">\n                    <defs>\n                        <path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path>\n                    </defs>\n                    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use>\n                </svg>\n                <span class="euiCallOutHeader__title">{{ctrl.clusterError}}</span>\n            </div>\n        </div>\n    </div>\n\n    <!-- Daemons status section -->\n    <div layout="row" layout-align="start stretch" ng-show="!ctrl.load && !ctrl.clusterError">\n        <md-card flex class="wz-md-card" ng-repeat="(k,v) in ctrl.daemons">\n            <md-card-content>\n                <center>\n                    <p ng-class="ctrl.getDaemonStatusClass(v)" class="round"></p>\n                    <p class="wz-padding-top-10">{{k}}</p>\n                </center>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End daemons status section -->\n\n    <!-- Agents status section -->\n    <div layout="row" layout-align="start center" ng-show="!ctrl.load && !ctrl.clusterError">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div flex class="wz-text-truncatable">Total agents:\n                    <span class="wz-text-bold">{{ctrl.agentsCountTotal}}</span>\n                </div>\n                <div flex class="wz-text-truncatable">Active:\n                    <span class="wz-text-bold">{{ctrl.agentsCountActive}}</span>\n                </div>\n                <div flex class="wz-text-truncatable">Disconnected:\n                    <span class="wz-text-bold">{{ctrl.agentsCountDisconnected}}</span>\n                </div>\n                <div flex class="wz-text-truncatable">Never connected: <span class="wz-text-bold">{{ctrl.agentsCountNeverConnected}}</span>\n                </div>\n                <div flex class="wz-text-truncatable">Agents coverage:\n                    <span class="wz-text-bold">{{(ctrl.agentsCoverity | number:2)}}%</span>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End agents status section -->\n\n    <div layout="row" layout-align="start stretch" layout-wrap ng-if="!ctrl.load && !ctrl.clusterError">\n        <!-- Manager information section -->\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <i class="fa fa-fw fa-server" aria-hidden="true"></i> <span ng-if="ctrl.selectedNode" class="wz-headline-title">{{ctrl.selectedNode}}\n                    information</span> <span ng-if="!ctrl.selectedNode" class="wz-headline-title">Manager information</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Version</span>\n                    <span class="wz-text-right color-grey">{{ctrl.managerInfo.version ? ctrl.managerInfo.version : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Compilation date</span>\n                    <span class="wz-text-right color-grey">{{ctrl.managerInfo.compilation_date ?\n                        ctrl.managerInfo.compilation_date : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Installation path</span>\n                    <span class="wz-text-right color-grey">{{ctrl.managerInfo.path ? ctrl.managerInfo.path : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Installation type</span>\n                    <span class="wz-text-right color-grey">{{ctrl.managerInfo.type ? ctrl.managerInfo.type : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Agents limit</span>\n                    <span class="wz-text-right color-grey">{{ctrl.managerInfo.max_agents ? ctrl.managerInfo.max_agents : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">OpenSSL Support</span>\n                    <span class="wz-text-right color-grey">{{ctrl.managerInfo.openssl_support ? ctrl.managerInfo.openssl_support\n                        : \'-\'}}</span>\n                </div>\n            </md-card-content>\n        </md-card>\n        <!-- End manager information section -->\n\n        <!-- Last registered agent section -->\n        <md-card flex class="wz-md-card" ng-show="ctrl.agentInfo && ctrl.agentInfo.id !== \'000\'">\n            <md-card-content>\n                <i class="fa fa-fw fa-tv" aria-hidden="true"></i> <span class="wz-headline-title">Last registered agent</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Name</span>\n                    <span class="wz-text-right color-grey">{{ctrl.agentInfo.name ? ctrl.agentInfo.name : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">ID</span>\n                    <span class="wz-text-right color-grey">{{ctrl.agentInfo.id ? ctrl.agentInfo.id : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Status</span>\n                    <span class="wz-text-right color-grey">{{ctrl.agentInfo.status ? ctrl.agentInfo.status : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">IP Address</span>\n                    <span class="wz-text-right color-grey">{{ctrl.agentInfo.ip ? ctrl.agentInfo.ip : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Date add</span>\n                    <span class="wz-text-right color-grey">{{ctrl.agentInfo.dateAdd ? ctrl.agentInfo.dateAdd : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Version</span>\n                    <span class="wz-text-right color-grey">{{ctrl.agentInfo.version ? ctrl.agentInfo.version : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10" ng-if="ctrl.agentInfo.id !== \'000\'">\n                    <span flex="25">Last keep alive</span>\n                    <span class="wz-text-right color-grey">{{ctrl.agentInfo.lastKeepAlive ? ctrl.agentInfo.lastKeepAlive : \'-\'}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="25">Operating system</span>\n                    <span class="wz-text-right color-grey">{{ctrl.agentInfo.os.name ? ctrl.agentInfo.os.name +\n                        ctrl.agentInfo.os.version : ctrl.agentInfo.os.uname ? ctrl.agentInfo.os.uname : \'-\'}}</span>\n                </div>\n            </md-card-content>\n        </md-card>\n        <!-- End last registered agent section -->\n    </div>\n</div>' + (null == (pug_interp = __webpack_require__(5302).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(5306).call(this, locals)) ? "" : pug_interp) + '<div layout="column" class="mozilla-table-size-85" ng-controller="managerLogController as ctrl" ng-if="!ctrl.loading && mctrl.tab == \'logs\'">\n\n    <!-- Headline -->\n    <div ng-show="!ctrl.loading" layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-pencil-square-o" aria-hidden="true"></i> Logs</span>\n        <span class="md-subheader">Review the logs of all Wazuh manager daemons</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Filters and Realtime button section -->\n    <div ng-show="!ctrl.loading" layout="row" layout-align="start center" class="md-padding">\n        <!-- Daemon selector -->\n        <div flex="20" layout="column"  layout-align="center" class="height-40 wz-margin-right-15 wz-select-input">\n            <select flex class="kuiSelect wz-border-none cursor-pointer max-height-35" ng-disabled="ctrl.realtime || !ctrl.daemons.length" id="categoryBox" ng-model="ctrl.category" ng-change="ctrl.filter({name:\'category\',value:ctrl.category})"\n            aria-label="Logs category">\n                <option value="all">All daemons</option>\n                <option ng-repeat="daemon in ctrl.daemons | orderObjectBy: \'title\'" value="{{daemon.title}}">{{daemon.title}}</option>\n            </select>\n        </div>\n        <!-- End daemon selector -->\n\n        <!-- Level selector -->\n        <div flex="20" layout="column" layout-align="center" class="height-40 wz-select-input wz-margin-right-15">\n            <select flex class="kuiSelect wz-border-none cursor-pointer max-height-35" ng-disabled="ctrl.realtime" id="levelBox" ng-model="ctrl.type_log" ng-change="ctrl.filter({name:\'type_log\',value:ctrl.type_log})"\n            aria-label="Logs level">\n                <option value="all">All log levels</option>\n                <option value="info">Info</option>\n                <option value="error">Error</option>\n                <option value="warning">Warning</option>\n                <option value="critical">Critical</option>\n                <option value="debug">Debug</option>\n            </select>\n        </div>\n\n        <div flex="20" layout="column" ng-show="ctrl.nodeList" layout-align="center" class="height-40 wz-select-input">\n            <select flex class="kuiSelect wz-border-none cursor-pointer max-height-35" ng-disabled="ctrl.realtime" id="categoryBox" ng-model="ctrl.selectedNode" ng-change="ctrl.changeNode(ctrl.selectedNode)"\n            aria-label="Logs category">\n                <option ng-repeat="node in ctrl.nodeList" value="{{node}}">{{node}}</option>\n            </select>\n        </div>\n        <!-- End Level selector -->\n\n        <!-- White space between filters and Realtime button -->\n        <span flex></span>\n\n        <md-button ng-if="!ctrl.realtime" class="wz-button md-raised md-primary no-margin-right" ng-click="ctrl.playRealtime()" aria-label="Play realtime button">\n            <i class="fa fa-play fa-fw" aria-hidden="true"></i>\n            Play realtime\n        </md-button>\n        <md-button ng-if="ctrl.realtime" class="wz-button md-raised md-primary no-margin-right" ng-click="ctrl.stopRealtime()" aria-label="Stop realtime button">\n            <i class="fa fa-stop fa-fw" aria-hidden="true"></i>\n            Stop realtime\n        </md-button>\n    </div>\n    <!-- End Filters and Realtime button section -->\n\n    <div layout="row" flex class="md-padding" ng-if="ctrl.logsPath">\n        <input placeholder="Filter logs..." ng-model="ctrl.custom_search" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid"\n            aria-invalid="false" wz-enter="ctrl.search(ctrl.custom_search)">\n        <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-40" ng-click="ctrl.search(ctrl.custom_search)">\n            <span class="fa fa-search" aria-hidden="true"></span>\n        </button>\n    </div>\n\n    <!-- Logs table section -->\n    <div layout="row" layout-padding ng-if="ctrl.logsPath">\n        <wz-table\n            flex\n            extra-limit="true"\n            path="ctrl.logsPath"\n            keys="[\'timestamp\',{value:\'tag\',size:2},\'level\',{value:\'description\',size:4,nosortable:true}]"\n            row-sizes="[12,10,7]">\n        </wz-table>\n    </div>\n    <!-- End Logs table section -->\n\n    <div layout="row" layout-padding>\n        <span flex></span>\n        <a class="small" id="btnDownload" ng-click="ctrl.downloadCsv()">Formatted <i aria-hidden="true" class="fa fa-fw fa-download"></i></a>\n    </div>\n</div>\n<div layout="column" layout-align="start stretch" ng-controller="reportingController as ctrl" ng-if="mctrl.tab === \'reporting\'">\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="ctrl.loading">\n        <div></div>\n    </div>\n    <!-- End loading ring -->\n\n    <!-- Headline -->\n    <div ng-show="!ctrl.loading" layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-file-text" aria-hidden="true"></i> Reporting</span>\n        <span class="md-subheader">List and download all the threatanalytics app reports</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- No reports section -->\n    <div layout="row" layout-align="start start" ng-show="!ctrl.loading && (!ctrl.pagedItems || !ctrl.pagedItems.length)">\n        <md-card flex class="wz-md-card" flex>\n            <md-card-content class="wz-text-center">\n                <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">No reports available</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column" class="wz-padding-top-10">\n                    <p>There are no reports yet. Go to the Overview or Agents tabs and click on the <i class="fa fa-fw fa-print" aria-hidden="true"></i> icon to create one.</p>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End no reports section -->\n\n    <div layout="row" ng-show="!ctrl.loading && ctrl.pagedItems && ctrl.pagedItems.length">\n        <md-button class="wz-report-refresh-btn" ng-click="ctrl.load()"><i class="fa fa-fw fa-refresh"></i> Refresh</md-button>\n    </div>\n    <div layout="row" ng-show="!ctrl.loading && ctrl.pagedItems && ctrl.pagedItems.length">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <div layout="row" class="wz-padding-top-10">\n                    <table class="table table-striped table-condensed" id="wz_table">\n                        <thead class="wz-text-bold">\n                            <th class="wz-text-left">File</th>\n                            <th class="wz-text-left">Size</th>\n                            <th class="wz-text-left">Created</th>\n                            <th class="wz-text-left">Options</th>\n                        </thead>\n                        <tbody>\n                            <tr ng-repeat="item in ctrl.pagedItems[ctrl.currentPage]">\n                                <td>{{item.name}}</td>\n                                <td>{{item.size / 1024 | number: 2}}KB</td>\n                                <td>{{item.date.split(\'T\')[0]}} {{item.date.split(\'T\')[1].split(\'.\')[0]}}</td>\n                                <td>\n                                    <a ng-href="/reports/{{item.name}}" flex class="wz-text-right" target="_blank">\n                                        <i class="fa fa-fw fa-download"></i>\n                                    </a>\n                                    <a flex class="wz-text-right cursor-pointer" ng-click="ctrl.deleteReport(item.name)">\n                                        <i class="fa fa-fw fa-trash"></i>\n                                    </a>\n                                </td>\n                            </tr>\n                        </tbody>\n                        <tfoot>\n                            <td colspan="6">\n                                <div class="pagination pull-right">\n                                    <ul layout="row">\n                                        <li ng-class="{disabled: ctrl.currentPage == 0}" class="md-padding">\n                                            <a href ng-click="ctrl.prevPage()"> Prev</a>\n                                        </li>\n\n                                        <li ng-repeat="n in ctrl.range(ctrl.pagedItems.length, ctrl.currentPage, ctrl.currentPage + ctrl.gap) "\n                                            ng-class="{active: n == ctrl.currentPage}"\n                                        ng-click="ctrl.setPage(n)" class="md-padding">\n                                            <a href ng-bind="n + 1">1</a>\n                                        </li>\n\n                                        <li ng-class="{disabled: (ctrl.currentPage) == ctrl.pagedItems.length - 1}" class="md-padding">\n                                            <a href ng-click="ctrl.nextPage()">Next </a>\n                                        </li>\n                                    </ul>\n                                </div>\n                            </td>\n                        </tfoot>\n                    </table>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</div>\n<div flex layout="column" class="mozilla-table-size-85" ng-class="{\'cursor-wait\': multipleSelectorLoading}"\n    ng-controller="groupsPreviewController" ng-if="mctrl.tab == \'groups\'">\n    <md-content flex layout="column" class="overflow-hidden" ng-init="lookingGroup=false">\n\n        <!-- Loading ring -->\n        <div class=\'uil-ring-css\' ng-show="load">\n            <div></div>\n        </div>\n\n        <!-- Headline -->\n        <div ng-show="!load" layout="column" layout-padding ng-if="!currentGroup || !currentGroup.name">\n            <div layout="row">\n                <span class="font-size-18">\n                    <i class="fa fa-fw fa-object-group" aria-hidden="true"></i> Groups</span>\n                <span ng-if=\'adminMode\' class="font-size-18 wz-text-link" ng-click="switchAddingGroup()"><i class="fa fa-fw fa-plus-circle"></i></span>\n            </div>\n            <div layout="row" ng-if="addingGroup" ng-if=\'adminMode\'>\n                <input placeholder="Group name..." ng-model="groupToBeAdded" type="text" class="kuiLocalSearchInput addGroupInput ng-empty ng-pristine ng-scope ng-touched ng-valid"\n                    aria-invalid="false">\n                <button type="submit" aria-label="Search" class="kuiLocalSearchButton addGroupBtn" ng-click="createGroup(groupToBeAdded)">\n                    <span class="fa fa-save fa-fw" aria-hidden="true"></span>\n                </button>\n            </div>\n            <div layout="row" ng-if="!addingGroup">\n                <span class="md-subheader">List and check your groups, its agents and files</span>\n            </div>\n\n\n        </div>\n        <!-- End headline -->\n\n        <div flex layout="column" layout-align="start stretch" ng-show="!load" ng-init="groupsSelectedTab=\'agents\'">\n            <!-- MD5 Sums and Details cards -->\n            <div layout="row" class="md-padding-h" ng-if="lookingGroup">\n                <!-- Group MD5 sums section -->\n                <md-card flex class="no-margin-left wz-md-card">\n                    <md-card-content>\n                        <div layout="row">\n                            <span class="font-size-18">\n                                <i class="fa fa-fw fa-object-group" aria-hidden="true"></i> {{currentGroup.name}}</span>\n\n                        </div>\n\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <div layout="row" class="wz-padding-top-10">\n                            <span flex="15">Agents</span>\n                            <span class="wz-text-right color-grey">{{ currentGroup.count }}</span>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <span flex="15">Content</span>\n                            <span class="wz-text-right color-grey">{{ totalFiles }} files</span>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <span flex="15">Configuration sum</span>\n                            <span class="wz-text-right color-grey">{{ currentGroup.configSum }}</span>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <span flex="15">Merged sum</span>\n                            <span class="wz-text-right color-grey">{{ currentGroup.mergedSum }}</span>\n                        </div>\n                    </md-card-content>\n                </md-card>\n            </div>\n\n            <!-- End group actions -->\n            <md-nav-bar ng-if="lookingGroup && currentGroup && !addingAgents && !editingFile" class="wz-nav-bar wz-margin-left-16 wz-margin-right-16"\n                md-selected-nav-item="groupsSelectedTab">\n                <md-nav-item class="wz-nav-item" md-nav-click="goBackToAgents()" name="agents">Agents</md-nav-item>\n                <md-nav-item class="wz-nav-item" md-nav-click="goBackFiles()" name="files">Content</md-nav-item>\n            </md-nav-bar>\n\n            <!-- XML editor for group agents -->\n            <div ng-show="editingFile">\n                <div layout="row" class="md-padding">\n                    <span ng-click=\'closeEditingFile()\' class=\'btn btn-info\'>Cancel</span>\n                    <button ng-disabled=\'xmlHasErrors\' ng-click=\'doSaveGroupAgentConfig()\' class=\'btn btn-primary pull-right wz-margin-left-8\'>\n                        <span ng-show=\'!xmlHasErrors\'><i aria-hidden=\'true\' class=\'fa fa-fw fa-save\'></i>Save file</span>\n                        <span ng-show=\'xmlHasErrors\' class=\'btn-danger\'><i aria-hidden=\'true\' class=\'fa fa-fw fa-exclamation-triangle\'></i>\n                            XML format error</span>\n                    </button>\n                </div>\n                <div class="md-padding md-padding-top-10" ng-if="fetchedXML">\n                    <wz-xml-file-editor file-name=\'agent.conf\' data="fetchedXML" target-name="currentGroup.name"\n                        valid-fn=\'xmlIsValid(valid)\'>\n                    </wz-xml-file-editor>\n                </div>\n            </div>\n            <!-- XML editor for group agents -->\n\n            <div ng-if="!editingFile">\n                <div layout="row" class="md-padding" ng-if="lookingGroup && currentGroup && addingAgents">\n                    <span ng-click=\'addMultipleAgents(false)\' class=\'btn btn-info\'>\n                        Cancel</span>\n                    <span ng-hide=\'moreThan500\' ng-click=\'saveAddAgents()\' class=\'btn btn-primary wz-margin-left-8\'><i\n                            aria-hidden=\'true\' class=\'fa fa-fw fa-save\'></i>\n                        Apply changes</span>\n                    <span class=\'error-msg\' ng-show=\'moreThan500\'><i class="fa fa-exclamation-triangle"></i> It is not\n                        possible to apply changes of more than 500 additions or deletions</span>\n                </div>\n\n                <!-- Search bar -->\n                <div layout="row" class="md-padding" ng-if="!addingAgents && !file">\n                    <input placeholder="{{groupsSelectedTab===\'files\' ? \'Filter files...\' : lookingGroup ? \'Filter agents...\' : \'Filter groups...\'}}"\n                        ng-model="custom_search" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid"\n                        aria-invalid="false" wz-enter="search(custom_search)">\n                    <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-40" ng-click="search(custom_search)">\n                        <span class="fa fa-search" aria-hidden="true"></span>\n                    </button>\n                </div>\n                <!-- End search bar -->\n\n                <div layout="row" class="wz-margin-left-16" ng-if="lookingGroup && currentGroup && !addingAgents && !editingFile && !file && adminMode">\n                    <button ng-if="lookingGroup && groupsSelectedTab===\'files\'" ng-click=\'editGroupAgentConfig(currentGroup)\'\n                        class=\'btn btn-primary\'><i aria-hidden=\'true\' class=\'fa fa-fw fa-pencil\'></i>\n                        Edit group configuration\n                    </button>\n                    <button ng-if="lookingGroup && groupsSelectedTab===\'agents\'" ng-disabled="currentGroup.name === \'default\'"\n                        ng-click=\'addMultipleAgents(true)\' class=\'btn btn-primary\'><i aria-hidden=\'true\' class=\'fa fa-fw fa-tv\'></i>\n                        Add or remove agents\n                    </button>\n                </div>\n\n                <!-- Groups table -->\n                <div layout="row" ng-if="!lookingGroup" class="md-padding">\n                    <wz-table flex extra-limit="true" path="\'/agents/groups\'" keys="[\'name\',\'count\',\'mergedSum\']"\n                        allow-click="true" row-sizes="[14,12,10]">\n                    </wz-table>\n                </div>\n                <!-- End groups table -->\n\n                <!-- CSV Download button section for groups -->\n                <div layout="row" class="md-padding" ng-if="!lookingGroup">\n                    <span flex></span>\n                    <a class="small" id="btnDownload" ng-click="downloadCsv(\'/agents/groups\')">Formatted\n                        <i aria-hidden="true" class="fa fa-fw fa-download"></i>\n                    </a>\n                </div>\n                <!-- End CSV Download button section for groups -->\n\n                <div ng-if=\'!addingAgents\'>\n                    <!-- Group agents table -->\n                    <div layout="row" ng-if="lookingGroup && groupsSelectedTab===\'agents\' && currentGroup" class="md-padding">\n                        <wz-table flex path="\'/agents/groups/\' + currentGroup.name" keys="[\'id\',\'name\',\'ip\',\'status\',\'os.name\',\'os.version\',\'version\']"\n                            allow-click="true" row-sizes="[14,12,10]" />\n                    </div>\n                    <!-- End Group agents table -->\n\n                    <!-- CSV Download button section for group agents -->\n                    <div layout="row" class="md-padding" ng-if="lookingGroup && groupsSelectedTab===\'agents\'">\n                        <span flex></span>\n                        <a class="small" id="btnDownload" ng-click="downloadCsv(\'/agents/groups/\' + currentGroup.name)">Formatted\n                            <i aria-hidden="true" class="fa fa-fw fa-download"></i>\n                        </a>\n                    </div>\n                    <!-- End CSV Download button section for group agents -->\n\n                    <!-- Group files table -->\n                    <div layout="row" ng-if="lookingGroup && groupsSelectedTab===\'files\' && !fileViewer && currentGroup"\n                        class="md-padding">\n                        <wz-table extra-limit="true" flex path="\'/agents/groups/\' + currentGroup.name + \'/files\'" keys="[{value:\'filename\',size:2},{value:\'hash\',size:6}]"\n                            allow-click="true" row-sizes="[10,8,6,4]">\n                        </wz-table>\n                    </div>\n                    <!-- End Group files table -->\n\n                    <!-- CSV Download button section for group files-->\n                    <div layout="row" class="md-padding" ng-if="lookingGroup && groupsSelectedTab===\'files\' && !file">\n                        <span flex></span>\n                        <a class="small" id="btnDownload" ng-click="downloadCsv(\'/agents/groups/\' + currentGroup.name + \'/files\')">Formatted\n                            <i aria-hidden="true" class="fa fa-fw fa-download"></i>\n                        </a>\n                    </div>\n                    <!-- End CSV Download button section for group files -->\n\n                    <!-- File JSON viewer section -->\n                    <div flex layout="column" class="md-padding" ng-if="lookingGroup && groupsSelectedTab===\'files\' && file">\n                        <div flex layout="column">\n                            <div layout="row" class="wz-padding-bottom-14">\n                                <span flex class="wz-headline-title">{{ filename }}</span>\n                                <button class="md-icon-button" ng-if="lookingGroup" aria-label="Back" tooltip="Close file"\n                                    tooltip-placement="left" ng-click="goBackFiles()"><i class="fa fa-fw fa-close"\n                                        aria-hidden="true"></i></button>\n                                <!--<span flex class="wz-text-right cursor-pointer color-grey" ng-click="goBackFiles()">close</span>-->\n                            </div>\n                            <div flex layout="column">\n                                <pre flex class="wz-pre groupContentViewer wzXmlEditor wz-overflow-y-auto"><code wz-dynamic="file"></code></pre>\n                            </div>\n                        </div>\n                    </div>\n                    <!-- End File JSON viewer section -->\n                </div>\n\n                <div layout="row" class="md-padding" ng-if="addingAgents">\n                    <span ng-show=\'!multipleSelectorLoading\' class="wzMultipleSelectorCounter"><span style=\'color:green\'>+{{currentAdding}}</span>&nbsp;<span\n                            style=\'color:red\'>-{{currentDeleting}}</span></span>\n                    <wz-multiple-selector class=\'wzMultipleSelector\' available-items="availableAgents.data"\n                        selected-items="selectedAgents.data" title-available-items="Available agents"\n                        title-selected-items="Current agents in the group" total-selected-items="totalSelectedAgents"\n                        reload-scroll=\'reload(element, searchTerm, 499, start)\' limit="checkLimit()">\n                    </wz-multiple-selector>\n                </div>\n            </div>\n        </div>\n    </md-content>\n</div>' + (null == (pug_interp = __webpack_require__(5307).call(this, locals)) ? "" : pug_interp) + "</div>";
			return pug_html
		}
		module.exports = template
	},
	5302: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_interp, pug_html = "";
			pug_html = pug_html + '<div flex="auto" layout="column" ng-controller="managementConfigurationController" ng-if="mctrl.tab === \'configuration\'" ng-init="switchConfigurationTab(\'welcome\', false)">\n\n    <!-- Navigation section -->\n    <div layout="row" layout-align="start center">\n        <!-- Breadcrumbs -->\n        <div layout="row" layout-padding>\n            <!-- Welcome section -->\n            <div ng-if="configurationTab === \'welcome\'">\n                <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n                <span> / </span>\n                <span>{{ mctrl.tabNames[mctrl.tab] }}</span>\n            </div>\n            <!-- First-level section -->\n            <div ng-if="configurationTab !== \'welcome\'">\n                <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n                <span> / </span>\n                <span class="wz-text-link cursor-pointer" ng-click="switchConfigurationTab(\'welcome\', true)">{{ mctrl.tabNames[mctrl.tab] }}</span>\n                <span> / </span>\n                <span>{{ mctrl.tabNames[configurationTab] }}</span>\n            </div>\n        </div>\n        <!-- End breadcrumbs -->\n\n        <!-- Separator -->\n        <span flex></span>\n        <!-- End separator -->\n\n        <!-- Help button -->\n        <md-button md-no-ink class="md-icon-button small" tooltip="About and help" tooltip-placement="left" ng-href="#/settings/about" aria-label="Link to open app about section">\n            <i class="fa fa-fw fa-question-circle-o" aria-hidden="true"></i>\n        </md-button>\n        <!-- End help button -->\n    </div>\n    <!-- End navigation section -->\n<div flex="auto" layout="column" ng-if="configurationTab === \'welcome\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div ng-show="agent && agent.id !== \'000\'">\n            <span class="font-size-18"> <i class="fa fa-fw fa-cog" aria-hidden="true"></i> Configuration</span>\n            <span ng-if="isSynchronized" class="wz-agent-status-indicator small teal">SYNCHRONIZED</span>\n            <span ng-if="!isSynchronized" class="wz-agent-status-indicator small red">NOT SYNCHRONIZED</span>\n        </div>\n        <span class="font-size-18" ng-show="!agent || agent.id === \'000\'">\n                <i class="fa fa-fw fa-cog" aria-hidden="true"></i> Configuration</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Configuration section cards and right sidenav -->\n    <div flex="auto" layout="row">\n\n        <!-- This section has the configuration cards -->\n        <div flex layout="column">\n\n            <!-- Main configurations card -->\n            <md-card class="wz-md-card">\n                <md-card-content>\n                    <span class="font-size-16">Main configurations</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <!-- Manager sections -->\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'global-configuration\', [{component:\'analysis\',configuration:\'global\'},{component:\'request\',configuration:\'remote\'},{component:\'com\',configuration:\'logging\'}])">Global configuration</h3>\n                                <p>Global and remote settings</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'cluster\', [{component:\'com\',configuration:\'cluster\'}])">Cluster</h3>\n                                <p>Master node configuration</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'registration-service\', [{component:\'auth\',configuration:\'auth\'}])">Registration service</h3>\n                                <p>Automatic agent registration service</p>\n                            </div>\n                        </md-list-item>\n                        <!-- <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'ruleset\')">Ruleset</h3>\n                                <p>Current rules, decoders and CDB lists loaded in the cluster</p>\n                            </div>\n                        </md-list-item> -->\n                        <!-- End manager sections -->\n                        <!-- Agent sections -->\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'global-configuration\', [{component:\'com\',configuration:\'logging\'}])">Global configuration</h3>\n                                <p>Logging settings that apply to the agent</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'client\', [{component:\'agent\',configuration:\'client\'}])">Communication</h3>\n                                <p>Settings related to the connection with the manager</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'client-buffer\', [{component:\'agent\',configuration:\'buffer\'}])">Anti-flooding settings</h3>\n                                <p>Agent bucket parameters to avoid event flooding</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'alerts\',[{component:\'agent\',configuration:\'labels\'}])">Labels</h3>\n                                <p>User-defined information about the agent included in alerts</p>\n                            </div>\n                        </md-list-item>\n                        <!-- End agent sections -->\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End main configurations card -->\n\n            <!-- Alerts and output management card -->\n            <md-card class="wz-md-card" ng-if="!agent || agent.id === \'000\'">\n                <md-card-content>\n                    <span class="font-size-16" ng-if="!agent || agent.id === \'000\'">Alerts and output management</span>\n                      <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'alerts\',[{component:\'analysis\',configuration:\'alerts\'},{component:\'analysis\',configuration:\'labels\'},{component:\'mail\',configuration:\'alerts\'},{component:\'monitor\',configuration:\'reports\'}, {component:\'csyslog\',configuration:\'csyslog\'}])">Alerts</h3>\n                                <p>Settings related to the alerts and their format</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'integrations\',[{component:\'integrator\',configuration:\'integration\'}])">Integrations</h3>\n                                <p>Slack, VirusTotal and PagerDuty integrations with external APIs</p>\n                            </div>\n                        </md-list-item>\n                        <!-- <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'database-output\')">Database output</h3>\n                                <p>MySQL and PostgreSQL database output configuration</p>\n                            </div>\n                        </md-list-item> -->\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End alerts and output management card -->\n\n            <!-- Auditing and policy monitoring card -->\n            <md-card class="wz-md-card">\n                <md-card-content>\n                    <span class="font-size-16">Auditing and policy monitoring</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'policy-monitoring\', [{component:\'syscheck\',configuration:\'rootcheck\'}])">Policy monitoring</h3>\n                                <p>Configuration to ensure compliance with security policies, standards and hardening guides</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'open-scap\')">OpenSCAP</h3>\n                                <p>Configuration assessment and automation of compliance monitoring using SCAP checks</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'cis-cat\')">CIS-CAT</h3>\n                                <p>Configuration assessment using CIS scanner and SCAP checks</p>\n                            </div>\n                        </md-list-item>\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End auditing and policy monitoring card -->\n\n            <!-- System, threats and incident response card -->\n            <md-card class="wz-md-card">\n                <md-card-content>\n                    <span class="font-size-16">System threats and incident response</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'vulnerability-detector\')">Vulnerabilities</h3>\n                                <p>Discover what applications are affected by well-known vulnerabilities</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'osquery\')">Osquery</h3>\n                                <p>Expose an operating system as a high-performance relational database</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'syscollector\')">Inventory data</h3>\n                                <p>Gather relevant information about system OS, hardware, networking and packages</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'active-response\',[{component:\'analysis\',configuration:\'command\'},{component:\'analysis\',configuration:\'active_response\'}])">Active response</h3>\n                                <p>Active threat addressing by inmmediate response</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="agent && agent.id !== \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'active-response\',[{component:\'com\',configuration:\'active-response\'}])">Active response</h3>\n                                <p>Active threat addressing by inmmediate response</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'command\')">Commands</h3>\n                                <p>Configuration options of the Command wodle</p>\n                            </div>\n                        </md-list-item>\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End system, threats and incident response card -->\n\n            <!-- Log data analysis card -->\n            <md-card class="wz-md-card">\n                <md-card-content>\n                    <span class="font-size-16">Log data analysis</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'log-collection\',[{component:\'logcollector\',configuration:\'localfile\'},{component:\'logcollector\',configuration:\'socket\'}])">Log collection</h3>\n                                <p>Log analysis from text files, Windows events or syslog outputs</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'integrity-monitoring\',[{component:\'syscheck\',configuration:\'syscheck\'}])">Integrity monitoring</h3>\n                                <p>Identify changes in content, permissions, ownership, and attributes of files</p>\n                            </div>\n                        </md-list-item>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line" ng-if="!agent || agent.id === \'000\'">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchConfigTab(\'agentless\',[{component:\'agentless\',configuration:\'agentless\'}])">Agentless</h3>\n                                <p>Run integrity checks on devices such as routers, firewalls and switches</p>\n                            </div>\n                        </md-list-item>\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End log data analysis card -->\n\n            <!-- Cloud security monitoring card -->\n            <md-card class="wz-md-card" ng-if="!agent || agent.id === \'000\'">\n                <md-card-content>\n                    <span class="font-size-16">Cloud security monitoring</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <md-list layout="row" layout-wrap>\n                        <md-list-item flex="100" flex-gt-md="50" flex-gt-lg="33" class="md-2-line">\n                            <div class="md-list-item-text">\n                                <h3 class="wz-text-link" ng-click="switchWodle(\'aws-s3\')">Amazon S3</h3>\n                                <p>Security events related to Amazon AWS services, collected directly via AWS API</p>\n                            </div>\n                        </md-list-item>\n                    </md-list>\n\n                </md-card-content>\n            </md-card>\n            <!-- End cloud security monitoring card -->\n\n        </div>\n        <!-- End configuration cards section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/manager/index.html">Wazuh administration documentation</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/index.html">Wazuh capabilities documentation</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/index.html">Local configuration reference</md-list-item>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End configuration section cards and right sidenav -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(1688).call(this, locals)) ? "" : pug_interp) + '<div flex="auto" layout="column" ng-if="configurationTab === \'cluster\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Cluster</span>\n            <span ng-if="currentConfig[\'com-cluster\'] && currentConfig[\'com-cluster\'].disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="currentConfig[\'com-cluster\'] && isString(currentConfig[\'com-cluster\'])" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'com-cluster\']"\n          ng-if="currentConfig[\'com-cluster\'] && isString(currentConfig[\'com-cluster\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig[\'com-cluster\'] && !isString(currentConfig[\'com-cluster\'])">\n\n            <!-- The main card will all the settings -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Master node settings</span>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Cluster status"\n                            value="currentConfig[\'com-cluster\'].disabled === \'yes\'? \'disabled\' : \'enabled\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Cluster name"\n                            value="currentConfig[\'com-cluster\'].name">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Node name"\n                            value="currentConfig[\'com-cluster\'].node_name">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Node type"\n                            value="currentConfig[\'com-cluster\'].node_type">\n                        </wz-config-item>\n                        <wz-config-item\n                            is-array="true"\n                            label="Master node IP address"\n                            value="currentConfig[\'com-cluster\'].nodes">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Port to listen to cluster communications"\n                            value="currentConfig[\'com-cluster\'].port">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="IP address to listen to cluster communications"\n                            value="currentConfig[\'com-cluster\'].bind_addr">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Hide cluster information in alerts"\n                            value="currentConfig[\'com-cluster\'].hidden">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/manager/wazuh-cluster.html">How to configure the Wazuh cluster</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/cluster.html">Wazuh cluster reference</md-list-item>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n<div flex="auto" layout="column" ng-if="configurationTab === \'registration-service\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Registration service</span>\n            <span ng-if="currentConfig[\'auth-auth\'] && currentConfig[\'auth-auth\'].auth && currentConfig[\'auth-auth\'].auth.disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="currentConfig[\'auth-auth\'] && isString(currentConfig[\'auth-auth\'])" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Automatic agent registration service</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'auth-auth\']"\n          ng-if="currentConfig[\'auth-auth\'] && isString(currentConfig[\'auth-auth\']) && !currentConfig[\'auth-auth\'].auth"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig[\'auth-auth\'] && currentConfig[\'auth-auth\'].auth && !isString(currentConfig[\'auth-auth\'].auth)">\n\n            <!-- The main card will all the settings -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Main settings</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">General settings applied to the registration service</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Service status"\n                            value="currentConfig[\'auth-auth\'].auth.disabled === \'yes\'? \'disabled\' : \'enabled\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Listen to connections at port"\n                            value="currentConfig[\'auth-auth\'].auth.port">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Use client\'s source IP address"\n                            value="currentConfig[\'auth-auth\'].auth.use_source_ip">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Use a password to register agents"\n                            value="currentConfig[\'auth-auth\'].auth.use_password">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Purge agents list when removing agents"\n                            value="currentConfig[\'auth-auth\'].auth.purge">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Limit registration to maximum number of agents"\n                            value="currentConfig[\'auth-auth\'].auth.limit_maxagents">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Force registration when using an existing IP address"\n                            value="currentConfig[\'auth-auth\'].auth.force_insert">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                    <div class="wz-margin-top-10">\n                        <span class="font-size-16">SSL settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Applied when the registration service uses SSL certificates</span>\n                        </div>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Verify agents using a CA certificate"\n                            value="currentConfig[\'auth-auth\'].auth.ssl_verify_host">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Auto-select the SSL negotiation method"\n                            value="currentConfig[\'auth-auth\'].auth.ssl_auto_negotiate">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="CA certificate location"\n                            value="currentConfig[\'auth-auth\'].auth.ssl_agent_ca">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Server SSL certificate location"\n                            value="currentConfig[\'auth-auth\'].auth.ssl_manager_cert">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Server SSL key location"\n                            value="currentConfig[\'auth-auth\'].auth.ssl_manager_key">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Use the following SSL ciphers"\n                            value="currentConfig[\'auth-auth\'].auth.ciphers">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/registering/use-registration-service.html">How to use the registration service</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/auth.html">Registration service reference</md-list-item>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(1689).call(this, locals)) ? "" : pug_interp) + '<div flex="auto" layout="column" ng-if="configurationTab === \'integrations\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Integrations</span>\n        </div>\n        <span class="md-subheader">Slack, VirusTotal and PagerDuty integrations with external APIs</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n      <!-- No configuration section -->\n      <wz-no-config\n        flex\n        error="currentConfig[\'integrator-integration\']"\n        ng-if="currentConfig[\'integrator-integration\'] && isString(currentConfig[\'integrator-integration\'])"></wz-no-config>\n      <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig[\'integrator-integration\'] && !isString(currentConfig[\'integrator-integration\'])">\n\n            <!-- VirusTotal integration card -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div ng-if="integrations[\'virustotal\']">\n                            <span class="font-size-16">VirusTotal</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">Get notified when malicious software is found</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10" ng-if="integrations[\'virustotal\']">\n                        <wz-config-item\n                            label="Filter alerts by this level or above"\n                            value="integrations[\'virustotal\'].level">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by this rule IDs"\n                            value="integrations[\'virustotal\'].rule_id">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by this rule groups"\n                            value="integrations[\'virustotal\'].group">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by location (agent, IP or file)"\n                            value="integrations[\'virustotal\'].event_location">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Used format to write alerts"\n                            value="integrations[\'virustotal\'].alert_format">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                    <div class="wz-margin-top-10" ng-if="integrations[\'slack\']">\n                        <span class="font-size-16">Slack</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Get alerts directly on Slack</span>\n                        </div>\n                    </div>\n                    <md-divider class="wz-margin-top-10" ng-if="integrations[\'slack\']"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10" ng-if="integrations[\'slack\']">\n\n                        <wz-config-item\n                            label="Hook URL"\n                            value="integrations[\'slack\'].hook_url">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by this level or above"\n                            value="integrations[\'slack\'].level">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by this rule IDs"\n                            value="integrations[\'slack\'].rule_id">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by this rule groups"\n                            value="integrations[\'slack\'].group">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by location (agent, IP or file)"\n                            value="integrations[\'slack\'].event_location">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Used format to write alerts"\n                            value="integrations[\'slack\'].alert_format">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                    <div class="wz-margin-top-10" ng-if="integrations[\'pagerduty\']">\n                        <span class="font-size-16">PagerDuty</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Get alerts on this streamlined incident resolution software</span>\n                        </div>\n                    </div>\n                    <md-divider class="wz-margin-top-10" ng-if="integrations[\'pagerduty\']"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10" ng-if="integrations[\'pagerduty\']">\n\n                        <wz-config-item\n                            label="Filter alerts by this level or above"\n                            value="integrations[\'pagerduty\'].level">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by this rule IDs"\n                            value="integrations[\'pagerduty\'].rule_id">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by this rule groups"\n                            value="integrations[\'pagerduty\'].group">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Filter alerts by location (agent, IP or file)"\n                            value="integrations[\'pagerduty\'].event_location">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Used format to write alerts"\n                            value="integrations[\'pagerduty\'].alert_format">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n                </md-card-content>\n            </md-card>\n            <!-- End VirusTotal integration card -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/manager/manual-integration.html">How to integrate Wazuh with external APIs</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/virustotal-scan/index.html">VirusTotal integration documentation</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/integration.html">Integration reference</md-list-item>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(1690).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(1691).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(1692).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(5303).call(this, locals)) ? "" : pug_interp) + '<div flex="auto" layout="column" ng-if="configurationTab === \'osquery\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Osquery</span>\n            <span ng-if="currentConfig && currentConfig.osquery && currentConfig.osquery.disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="(currentConfig && currentConfig.osquery && currentConfig.osquery.disabled === \'yes\') || (currentConfig && !currentConfig.osquery)" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Expose an operating system as a high-performance relational database</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n      <!-- No configuration section -->\n      <wz-no-config\n        flex\n        error="currentConfig[\'wmodules-wmodules\']"\n        ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n      <wz-no-config\n        flex\n        error="\'not-present\'"\n        ng-if="currentConfig && !currentConfig.osquery && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n      <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig.osquery">\n\n            <!-- The main card will all the settings -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Main settings</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">General Osquery integration settings</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Osquery integration status"\n                            value="currentConfig.osquery.disabled === \'yes\' ? \'disabled\' : \'enabled\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Auto-run the Osquery daemon"\n                            value="currentConfig.osquery.run_daemon">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Path to the Osquery executable"\n                            value="currentConfig.osquery.bin_path">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Path to the Osquery results log file"\n                            value="currentConfig.osquery.log_path">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Path to the Osquery configuration file"\n                            value="currentConfig.osquery.config_path">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Use defined labels as decorators"\n                            value="currentConfig.osquery.add_labels">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                    <div ng-if="currentConfig.osquery.packs && isArray(currentConfig.osquery.packs) && currentConfig.osquery.packs.length" class="wz-margin-top-10">\n                        <span class="font-size-16">Osquery packs</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">A pack contains multiple queries to quickly retrieve system information</span>\n                        </div>\n                    </div>\n                    <md-divider ng-if="currentConfig.osquery.packs && isArray(currentConfig.osquery.packs) && currentConfig.osquery.packs.length" class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div ng-if="currentConfig.osquery.packs && isArray(currentConfig.osquery.packs) && currentConfig.osquery.packs.length" class="wz-padding-top-10">\n\n                        <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                            <thead class="wz-text-bold">\n                                <th class="wz-text-left col-lg-4">Name</th>\n                                <th class="wz-text-left col-lg-8">Path</th>\n                            </thead>\n                            <tbody class="wz-word-wrap">\n                                <tr ng-repeat="item in currentConfig.osquery.packs">\n                                    <td>{{ item.name }}</td>\n                                    <td>{{ item.path }}</td>\n                                </tr>\n                            </tbody>\n                        </table>\n\n                    </div>\n                    <!-- End configuration block -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/osquery.html">Osquery module documentation</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-osquery.html">Osquery module reference</md-list-item>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n<div flex="auto" layout="column" ng-if="configurationTab === \'syscollector\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Inventory data</span>\n            <span ng-if="currentConfig && currentConfig.syscollector && currentConfig.syscollector.disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="(currentConfig && currentConfig.syscollector && currentConfig.syscollector.disabled === \'yes\') || (currentConfig && !currentConfig.syscollector)" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Gather relevant information about system OS, hardware, networking and packages</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n      <!-- No configuration section -->\n      <wz-no-config\n        flex\n        error="currentConfig[\'wmodules-wmodules\']"\n        ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n      <wz-no-config\n        flex\n        error="\'not-present\'"\n        ng-if="currentConfig && !currentConfig.syscollector && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n      <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig.syscollector">\n\n            <!-- The main card will all the settings -->\n            <md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content>\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Main settings</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">General settings applied to all the scans</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Syscollector integration status"\n                            value="currentConfig.syscollector.disabled === \'yes\' ? \'disabled\' : \'enabled\'">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Interval between system scans"\n                            value="currentConfig.syscollector.interval">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan on start"\n                            value="currentConfig.syscollector[\'scan-on-start\']">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                    <div class="wz-margin-top-10">\n                        <span class="font-size-16">Scan settings</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Specific inventory scans to collect</span>\n                        </div>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- Configuration block -->\n                    <div class="wz-padding-top-10">\n\n                        <wz-config-item\n                            label="Scan hardware info"\n                            value="currentConfig.syscollector.hardware">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan current processes"\n                            value="currentConfig.syscollector.processes">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan operating system info"\n                            value="currentConfig.syscollector.os">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan installed packages"\n                            value="currentConfig.syscollector.packages">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan network interfaces"\n                            value="currentConfig.syscollector.network">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan listening network ports"\n                            value="currentConfig.syscollector.ports">\n                        </wz-config-item>\n                        <wz-config-item\n                            label="Scan all network ports"\n                            value="currentConfig.syscollector.ports_all">\n                        </wz-config-item>\n\n                    </div>\n                    <!-- End configuration block -->\n\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/syscollector.html">Syscollector module documentation</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-syscollector.html">Syscollector module reference</md-list-item>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(5304).call(this, locals)) ? "" : pug_interp) + '<div flex="auto" layout="column" ng-if="configurationTab === \'command\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Commands</span>\n        </div>\n        <span class="md-subheader">Configuration options of the Command wodle</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'wmodules-wmodules\']"\n          ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <wz-no-config\n          flex\n          error="\'not-present\'"\n          ng-if="currentConfig && !currentConfig.commands && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig.commands && !isString(currentConfig[\'wmodules-wmodules\']) && currentConfig.commands.length">\n\n            <!-- The main card will all the settings -->\n            <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content flex layout="column">\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Command definitions</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">Find here all the currently defined commands</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- The container for both list and detail -->\n                    <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                        <!-- List container -->\n                        <div flex="30" layout="column">\n\n                            <md-list flex="auto" class="wz-item-list">\n                                <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig.commands">{{item.tag}}</md-list-item>\n                            </md-list>\n\n                        </div>\n                        <!-- End list container -->\n\n                        <!-- Detail container -->\n                        <div flex layout="column">\n\n                            <div flex="auto" class="wz-item-detail">\n                                <wz-config-item\n                                    label="Command status"\n                                    value="currentConfig.commands[selectedItem].disabled === \'no\' ? \'enabled\' : \'disabled\'">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Command name"\n                                    value="currentConfig.commands[selectedItem].tag">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Command to execute"\n                                    value="currentConfig.commands[selectedItem].command">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Interval between executions"\n                                    value="currentConfig.commands[selectedItem].interval">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Run on start"\n                                    value="currentConfig.commands[selectedItem].run_on_start">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Ignore command output"\n                                    value="currentConfig.commands[selectedItem].ignore_output">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Timeout (in seconds) to wait for execution"\n                                    value="currentConfig.commands[selectedItem].timeout">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Verify MD5 sum"\n                                    value="currentConfig.commands[selectedItem].verify_md5">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Verify SHA1 sum"\n                                    value="currentConfig.commands[selectedItem].verify_sha1">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Verify SHA256 sum"\n                                    value="currentConfig.commands[selectedItem].verify_sha256">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Ignore checksum verification"\n                                    value="currentConfig.commands[selectedItem].skip_verification">\n                                </wz-config-item>\n                            </div>\n\n                        </div>\n                        <!-- End detail container -->\n                    </div>\n                    <!-- End container for both list and detail -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-command.html">Command module reference</md-list-item>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(1694).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(1693).call(this, locals)) ? "" : pug_interp) + '<div flex="auto" layout="column" ng-if="configurationTab === \'agentless\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Agentless</span>\n        </div>\n        <span class="md-subheader">Run integrity checks on devices such as routers, firewalls and switches.</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'agentless-agentless\']"\n          ng-if="currentConfig[\'agentless-agentless\'] && isString(currentConfig[\'agentless-agentless\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig[\'agentless-agentless\'] && !isString(currentConfig[\'agentless-agentless\'])">\n\n            <!-- The main card will all the settings -->\n            <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n                <md-card-content flex layout="column">\n                    <div layout="row" layout-align="start center">\n                        <div>\n                            <span class="font-size-16">Devices list</span>\n                            <div class="wz-margin-top-10">\n                                <span class="md-subheader small">List of monitored devices that don\'t use the agent</span>\n                            </div>\n                        </div>\n                        <span flex></span>\n                        <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                        <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                        <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                    </div>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n\n                    <!-- The container for both list and detail -->\n                    <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                        <!-- List container -->\n                        <div flex="30" layout="column">\n\n                            <md-list flex="auto" class="wz-item-list">\n                                <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'agentless-agentless\'].agentless">{{ item.type }} ({{ item.state }})</md-list-item>\n                            </md-list>\n\n                        </div>\n                        <!-- End list container -->\n\n                        <!-- Detail container -->\n                        <div flex layout="column" ng-if="currentConfig[\'agentless-agentless\'].agentless.length">\n\n                            <div flex="auto" class="wz-item-detail">\n                                <wz-config-item\n                                    label="Agentless monitoring type"\n                                    value="currentConfig[\'agentless-agentless\'].agentless[selectedItem].type">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Interval (in seconds) between checks"\n                                    value="currentConfig[\'agentless-agentless\'].agentless[selectedItem].frequency">\n                                </wz-config-item>\n                                <wz-config-item\n                                    is-array="true"\n                                    label="Device username and hostname"\n                                    value="currentConfig[\'agentless-agentless\'].agentless[selectedItem].host">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Device check type"\n                                    value="currentConfig[\'agentless-agentless\'].agentless[selectedItem].state">\n                                </wz-config-item>\n                                <wz-config-item\n                                    label="Pass these arguments to check"\n                                    value="currentConfig[\'agentless-agentless\'].agentless[selectedItem].arguments">\n                                </wz-config-item>\n                            </div>\n\n                        </div>\n                        <!-- End detail container -->\n                    </div>\n                    <!-- End container for both list and detail -->\n                </md-card-content>\n            </md-card>\n            <!-- End main card with all the settings -->\n\n            <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n        </div>\n        <!-- End main content section -->\n\n        <!-- This section is the right sidenav content -->\n        <md-sidenav\n            class="md-sidenav-right"\n            md-is-locked-open="true">\n            <md-list>\n                <md-subheader>More info about this section</md-subheader>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/agentless-monitoring/index.html">How to monitor agentless devices</md-list-item>\n                <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/agentless.html">Agentless reference</md-list-item>\n            </md-list>\n        </md-sidenav>\n        <!-- End right sidenav section -->\n\n    </div>\n    <!-- End main content and right sidenav section -->\n\n</div>\n' + (null == (pug_interp = __webpack_require__(5305).call(this, locals)) ? "" : pug_interp) + "</div>";
			return pug_html
		}
		module.exports = template
	},
	5303: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'vulnerability-detector\'" ng-init="switchConfigurationSubTab(\'vulnerabilities-general\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Vulnerabilities</span>\n            <span ng-if="currentConfig && currentConfig[\'vulnerability-detector\'] && currentConfig[\'vulnerability-detector\'].disabled === \'no\'" class="wz-agent-status-indicator small teal">Enabled</span>\n            <span ng-if="(currentConfig && currentConfig[\'vulnerability-detector\'] && currentConfig[\'vulnerability-detector\'].disabled === \'yes\') || (currentConfig && !currentConfig[\'vulnerability-detector\'])" class="wz-agent-status-indicator small red">Disabled</span>\n        </div>\n        <span class="md-subheader">Discover what applications are affected by well-known vulnerabilities</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Vulnerabilities navigation bar -->\n    <md-nav-bar\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Vulnerabilities navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'vulnerabilities-general\')" name="vulnerabilities-general">General</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'vulnerabilities-feeds\')" name="vulnerabilities-feeds">Feeds</md-nav-item>\n    </md-nav-bar>\n    <!-- End Vulnerabilities navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'wmodules-wmodules\']"\n          ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <wz-no-config\n          flex\n          error="\'not-present\'"\n          ng-if="currentConfig && !currentConfig[\'vulnerability-detector\'] && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig[\'vulnerability-detector\']">\n<!-- General card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'vulnerabilities-general\'">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Main settings</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">General settings applied to the vulnerability detector and its feeds</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <wz-config-item\n                label="Vulnerability detector status"\n                value="currentConfig[\'vulnerability-detector\'].disabled === \'yes\' ? \'disabled\' : \'enabled\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Interval between scan executions"\n                value="currentConfig[\'vulnerability-detector\'].interval">\n            </wz-config-item>\n            <wz-config-item\n                label="Scan on start"\n                value="currentConfig[\'vulnerability-detector\'].run_on_start">\n            </wz-config-item>\n            <wz-config-item\n                label="Time to ignore already detected vulerabilities"\n                value="currentConfig[\'vulnerability-detector\'].ignore_time">\n            </wz-config-item>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End general card -->\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="configurationSubTab === \'vulnerabilities-feeds\' && currentConfig && currentConfig[\'vulnerability-detector\'] && !currentConfig[\'vulnerability-detector\'].feeds"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- Feeds card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'vulnerabilities-feeds\' && currentConfig && currentConfig[\'vulnerability-detector\'] && currentConfig[\'vulnerability-detector\'].feeds">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Feeds</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">List of OVAL databases to check for vulnerability scans</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <table class="table table-striped table-condensed" style="table-layout: fixed !important;">\n                <thead class="wz-text-bold">\n                    <th class="wz-text-left">Name</th>\n                    <th class="wz-text-left">Version</th>\n                    <th class="wz-text-left col-lg-2">Update interval</th>\n                    <th class="wz-text-left col-lg-3">Alt. path</th>\n                    <th class="wz-text-left col-lg-3">Alt. URL</th>\n                    <th class="wz-text-left">Alt. port</th>\n                </thead>\n                <tbody class="wz-word-wrap">\n                    <tr ng-repeat="item in currentConfig[\'vulnerability-detector\'].feeds">\n                        <td>{{ item.name || \'-\' }}</td>\n                        <td>{{ item.version || \'-\' }}</td>\n                        <td>{{ item.interval || \'-\' }}</td>\n                        <td>{{ item.path || \'-\' }}</td>\n                        <td>{{ item.alternative.url || \'-\' }}</td>\n                        <td>{{ item.alternative.port || \'-\' }}</td>\n                    </tr>\n                </tbody>\n            </table>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End feeds card -->\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/vulnerability-detection.html">Vulnerability detector documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-vuln-detector.html">Vulnerability detector reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	5304: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'active-response\'" ng-init="switchConfigurationSubTab(\'active-response\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Active response</span>\n        </div>\n        <span class="md-subheader">Active threat addressing by inmmediate response</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Commands & Active response navigation bar -->\n    <md-nav-bar\n        ng-if="!agent || agent.id === \'000\'"\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Active response navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'active-response\')" name="active-response">Active response</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'commands\')" name="commands">Commands</md-nav-item>\n    </md-nav-bar>\n    <!-- End Commands & Active response navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'active-response\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'analysis-active_response\']"\n      ng-if="currentConfig[\'analysis-active_response\'] && isString(currentConfig[\'analysis-active_response\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'analysis-active_response\'] && !isString(currentConfig[\'analysis-active_response\']) && currentConfig[\'analysis-active_response\'][\'active-response\'] && !currentConfig[\'analysis-active_response\'][\'active-response\'].length"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'analysis-active_response\'] && !isString(currentConfig[\'analysis-active_response\']) && currentConfig[\'analysis-active_response\'][\'active-response\'] && currentConfig[\'analysis-active_response\'][\'active-response\'].length">\n\n        <!-- The main card will all the settings -->\n        <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content flex layout="column">\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Active response definitions</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Find here all the currently defined Active responses</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- The container for both list and detail -->\n                <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                    <!-- List container -->\n                    <div flex="30" layout="column">\n\n                        <md-list flex="auto" class="wz-item-list">\n                            <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'analysis-active_response\'][\'active-response\']">{{ item.command }}</md-list-item>\n                        </md-list>\n\n                    </div>\n                    <!-- End list container -->\n\n                    <!-- Detail container -->\n                    <div flex layout="column">\n\n                        <div flex="auto" class="wz-item-detail">\n                            <wz-config-item\n                                label="Status of this active response"\n                                value="currentConfig[\'analysis-active_response\'][\'active-response\'][selectedItem].disabled === \'yes\' ? \'disabled\' : \'enabled\'">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Command to execute"\n                                value="currentConfig[\'analysis-active_response\'][\'active-response\'][selectedItem].command">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Execute the command on this location"\n                                value="currentConfig[\'analysis-active_response\'][\'active-response\'][selectedItem].location">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Agent ID on which execute the command"\n                                value="currentConfig[\'analysis-active_response\'][\'active-response\'][selectedItem].agent_id">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Match to this severity level or above"\n                                value="currentConfig[\'analysis-active_response\'][\'active-response\'][selectedItem].level">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Match to one of these groups"\n                                value="currentConfig[\'analysis-active_response\'][\'active-response\'][selectedItem].rules_group">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Match to one of these rule IDs"\n                                value="currentConfig[\'analysis-active_response\'][\'active-response\'][selectedItem].rules_id">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Timeout (in seconds) before reverting"\n                                value="currentConfig[\'analysis-active_response\'][\'active-response\'][selectedItem].timeout">\n                            </wz-config-item>\n                        </div>\n\n                    </div>\n                    <!-- End detail container -->\n                </div>\n                <!-- End container for both list and detail -->\n\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/active-response/index.html">Active response documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/active-response.html">Active response reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n<!-- This section contains the main content and the right sidenav -->\n<div flex="auto" layout="row" ng-if="!load && configurationSubTab === \'commands\'">\n\n    <!-- No configuration section -->\n    <wz-no-config\n      flex\n      error="currentConfig[\'analysis-command\']"\n      ng-if="currentConfig[\'analysis-command\'] && isString(currentConfig[\'analysis-command\'])"></wz-no-config>\n    <wz-no-config\n      flex\n      error="\'not-present\'"\n      ng-if="currentConfig[\'analysis-command\'] && !isString(currentConfig[\'analysis-command\']) && currentConfig[\'analysis-command\'].command && !currentConfig[\'analysis-command\'].command.length"></wz-no-config>\n    <!-- End no configuration section -->\n\n    <!-- This section is the main content -->\n    <div flex layout="column" ng-if="currentConfig[\'analysis-command\'] && !isString(currentConfig[\'analysis-command\']) && currentConfig[\'analysis-command\'].command && currentConfig[\'analysis-command\'].command.length">\n\n        <!-- The main card will all the settings -->\n        <md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent">\n            <md-card-content flex layout="column">\n                <div layout="row" layout-align="start center">\n                    <div>\n                        <span class="font-size-16">Command definitions</span>\n                        <div class="wz-margin-top-10">\n                            <span class="md-subheader small">Find here all the currently defined commands used for Active response</span>\n                        </div>\n                    </div>\n                    <span flex></span>\n                    <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n                    <span class="small">&nbsp;&centerdot;&nbsp;</span>\n                    <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n\n                <!-- The container for both list and detail -->\n                <div flex="auto" layout="row" class="wz-margin-top-10">\n\n                    <!-- List container -->\n                    <div flex="30" layout="column">\n\n                        <md-list flex="auto" class="wz-item-list">\n                            <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'analysis-command\'].command">{{item.name}}</md-list-item>\n                        </md-list>\n\n                    </div>\n                    <!-- End list container -->\n\n                    <!-- Detail container -->\n                    <div flex layout="column" ng-if="currentConfig[\'analysis-command\'].command.length">\n\n                        <div flex="auto" class="wz-item-detail">\n                            <wz-config-item\n                                label="Command name"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].name">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Name of executable file"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].executable">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="List of expected fields"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].expect">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Extra arguments"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].extra_args">\n                            </wz-config-item>\n                            <wz-config-item\n                                label="Allow this command to be reverted"\n                                value="currentConfig[\'analysis-command\'].command[selectedItem].timeout_allowed ? \'yes\' : \'no\'">\n                            </wz-config-item>\n                        </div>\n\n                    </div>\n                    <!-- End detail container -->\n                </div>\n                <!-- End container for both list and detail -->\n            </md-card-content>\n        </md-card>\n        <!-- End main card with all the settings -->\n\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/capabilities/active-response/index.html">Active response documentation</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/commands.html">Commands reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	5305: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-if="configurationTab === \'aws-s3\'" ng-init="switchConfigurationSubTab(\'amazon-general\')">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <div>\n            <span class="font-size-18">Amazon S3</span>\n            <span class="wz-agent-status-indicator small teal">Enabled</span>\n        </div>\n        <span class="md-subheader">Security events related to Amazon AWS services, collected directly via AWS API</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Amazon S3 navigation bar -->\n    <md-nav-bar\n        class="wz-nav-bar"\n        md-selected-nav-item="configurationSubTab"\n        nav-bar-aria-label="Amazon S3 navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'amazon-general\')" name="amazon-general">General</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="switchConfigurationSubTab(\'amazon-buckets\')" name="amazon-buckets">Buckets</md-nav-item>\n    </md-nav-bar>\n    <!-- End Amazon S3 navigation bar -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="load">\n        <div></div>\n    </div>\n\n    <!-- This section contains the main content and the right sidenav -->\n    <div flex="auto" layout="row" ng-if="!load">\n\n        <!-- No configuration section -->\n        <wz-no-config\n          flex\n          error="currentConfig[\'wmodules-wmodules\']"\n          ng-if="currentConfig[\'wmodules-wmodules\'] && isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <wz-no-config\n          flex\n          error="\'not-present\'"\n          ng-if="currentConfig && !currentConfig[\'aws-s3\'] && !isString(currentConfig[\'wmodules-wmodules\'])"></wz-no-config>\n        <!-- End no configuration section -->\n\n        <!-- This section is the main content -->\n        <div flex layout="column" ng-if="currentConfig && currentConfig[\'aws-s3\']">\n<!-- General card -->\n<md-card class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'amazon-general\'">\n    <md-card-content>\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Main settings</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">Common settings applied to all Amazon S3 buckets</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- Configuration block -->\n        <div class="wz-padding-top-10">\n\n            <wz-config-item\n                label="Amazon S3 integration status"\n                value="currentConfig[\'aws-s3\'].disabled === \'no\' ? \'enabled\' : \'disabled\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Frequency for reading from S3 buckets"\n                value="currentConfig[\'aws-s3\'].interval">\n            </wz-config-item>\n            <wz-config-item\n                label="Run on start"\n                value="currentConfig[\'aws-s3\'].run_on_start">\n            </wz-config-item>\n            <wz-config-item\n                label="Remove bucket logs after being read"\n                value="currentConfig[\'aws-s3\'].remove_from_bucket || \'yes\'">\n            </wz-config-item>\n            <wz-config-item\n                label="Skip logs that can\'t be processed"\n                value="currentConfig[\'aws-s3\'].skip_on_error">\n            </wz-config-item>\n\n        </div>\n        <!-- End configuration block -->\n    </md-card-content>\n</md-card>\n<!-- End general card -->\n<!-- No configuration section -->\n<wz-no-config\n  flex\n  error="\'not-present\'"\n  ng-if="configurationSubTab === \'amazon-buckets\' && currentConfig && currentConfig[\'aws-s3\'] && !currentConfig[\'aws-s3\'].buckets"></wz-no-config>\n<!-- End no configuration section -->\n\n<!-- Buckets card -->\n<md-card flex="auto" class="wz-md-card" ng-if="!JSONContent && !XMLContent && configurationSubTab === \'amazon-buckets\' && currentConfig && currentConfig[\'aws-s3\'] && currentConfig[\'aws-s3\'].buckets">\n    <md-card-content flex layout="column">\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">Buckets</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">Amazon buckets from where logs are read</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="JSONContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getJSON()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="XMLContent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="getXML()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- The container for both list and detail -->\n        <div flex="auto" layout="row" class="wz-margin-top-10">\n\n            <!-- List container -->\n            <div flex="30" layout="column">\n\n                <md-list flex="auto" class="wz-item-list">\n                        <md-list-item class="wz-text-link" ng-click="updateSelectedItem($index)" ng-repeat="item in currentConfig[\'aws-s3\'].buckets">{{item.name}} ({{item.aws_account_alias}})</md-list-item>\n                </md-list>\n\n            </div>\n            <!-- End list container -->\n\n            <!-- Detail container -->\n            <div flex layout="column" ng-if="currentConfig[\'aws-s3\'].buckets.length">\n                <div flex="auto" class="wz-item-detail">\n                    <wz-config-item\n                        label="Bucket name"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].name">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Bucket type"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].type">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="AWS account ID"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].aws_account_id">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="AWS account alias"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].aws_account_alias">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Profile name with read permissions"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].aws_profile">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="IAM ARN role to read bucket logs"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].iam_role_arn">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Bucket path"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].path">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Parse only logs from this date onwards"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].only_logs_after">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Remove bucket logs after being read"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].remove_from_bucket || \'yes\'">\n                    </wz-config-item>\n                    <wz-config-item\n                        label="Limit log parsing to these regions"\n                        value="currentConfig[\'aws-s3\'].buckets[selectedItem].regions">\n                    </wz-config-item>\n                </div>\n\n            </div>\n            <!-- End detail container -->\n        </div>\n        <!-- End container for both list and detail -->\n    </md-card-content>\n</md-card>\n<!-- End buckets card -->\n        <wz-config-viewer flex getjson="getJSON()" getxml="getXML()" jsoncontent="JSONContent" xmlcontent="XMLContent" />\n\n    </div>\n    <!-- End main content section -->\n\n    <!-- This section is the right sidenav content -->\n    <md-sidenav\n        class="md-sidenav-right"\n        md-is-locked-open="true">\n        <md-list>\n            <md-subheader>More info about this section</md-subheader>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/amazon/index.html">Using Wazuh to monitor AWS</md-list-item>\n            <md-list-item target="_blank" class="wz-text-link" ng-href="https://documentation.cyberforza.com/current/user-manual/reference/ossec-conf/wodle-s3.html">Amazon S3 module reference</md-list-item>\n        </md-list>\n    </md-sidenav>\n    <!-- End right sidenav section -->\n\n</div>\n<!-- End main content and right sidenav section -->\n</div>';
			return pug_html
		}
		module.exports = template
	},
	5306: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div layout="column" ng-controller="clusterController" ng-if="mctrl.tab === \'monitoring\'">\n    <div flex layout="column" ng-show="!isClusterEnabled || !isClusterRunning">\n\n        <!-- Cluster disabled breadcrumbs -->\n        <div layout="row" layout-align="start center">\n           <div layout="row" layout-padding>\n                <div>\n                  <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n                <span> / </span>\n                 <span>{{ mctrl.tabNames[tab] }}</span>\n             </div>\n            </div>\n        </div>\n        <!-- End cluster disabled breadcrumbs -->\n\n        <!-- Status and reports navigation bar -->\n        <md-nav-bar class="wz-nav-bar" ng-show="mctrl.tab !== \'welcome\'" md-selected-nav-item="mctrl.tab" nav-bar-aria-label="Status and reports navigation links">\n            <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'status\')" name="status">Status</md-nav-item>\n            <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'logs\')" name="logs">Logs</md-nav-item>\n            <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'monitoring\')" name="monitoring">Cluster</md-nav-item>\n            <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'reporting\')" name="reporting">Reporting</md-nav-item>\n        </md-nav-bar>\n        <!-- End status and reports navigation bar -->\n\n        <!-- Headline -->\n        <div layout="column" layout-padding>\n            <span class="font-size-18"><i class="fa fa-fw fa-search" aria-hidden="true"></i> Cluster</span>\n            <span class="md-subheader">Visualize your Wazuh cluster nodes and its agents</span>\n        </div>\n        <!-- End headline -->\n\n        <!-- Cluster disabled section -->\n        <div flex layout="row" layout-align="start start" ng-if="!isClusterEnabled">\n            <md-card flex class="wz-md-card" flex>\n                <md-card-content class="wz-text-center">\n                    <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">Cluster\n                        disabled</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div layout="column" class="wz-padding-top-10">\n                        <p>The cluster is disabled. Visit the documentation on <a target="_blank" href="https://documentation.cyberforza.com/current/user-manual/manager/wazuh-cluster.html">this\n                                link</a> to learn about how to enable it.\n                        </p>\n                    </div>\n                </md-card-content>\n            </md-card>\n        </div>\n        <!-- End cluster disabled section -->\n\n        <!-- Cluster not running section -->\n        <div flex layout="row" layout-align="start start" ng-if="!isClusterRunning">\n            <md-card flex class="wz-md-card" flex>\n                <md-card-content class="wz-text-center">\n                    <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">Cluster\n                        not running</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div layout="column" class="wz-padding-top-10">\n                        <p>\n                            The cluster is enabled but it\'s not running.\n                        </p>\n                    </div>\n                </md-card-content>\n            </md-card>\n        </div>\n        <!-- End cluster not running section -->\n    </div>\n\n    <div flex="auto" layout="column" ng-show="isClusterEnabled && isClusterRunning">\n\n        <!-- Loading ring -->\n        <div class=\'uil-ring-css\' ng-show="loading">\n            <div></div>\n        </div>\n\n        <!-- Navigation section -->\n        <div layout="row" layout-align="start center" ng-if="!loading">\n            <div layout="row" layout-padding>\n                <div ng-if="!showConfig && !showNodes">\n                    <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n                    <span> / </span>\n                    <span>{{ mctrl.tabNames[mctrl.tab] }}</span>\n                    <span> / </span>\n                    <span>{{ currentAPI }}</span>\n                </div>\n                <div ng-if="showConfig">\n                    <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n                    <span> / </span>\n                    <span class="wz-text-link cursor-pointer" ng-click="goBack()">{{ mctrl.tabNames[mctrl.tab] }}</span>\n                    <span> / </span>\n                    <span class="wz-text-link cursor-pointer" ng-click="goBack()">{{ currentAPI }}</span>\n                    <span> / ja_Overview</span>\n                </div>\n                <div ng-if="showNodes && !currentNode">\n                    <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n                    <span> / </span>\n                    <span class="wz-text-link cursor-pointer" ng-click="goBack()">{{ mctrl.tabNames[mctrl.tab] }}</span>\n                    <span> / </span>\n                    <span class="wz-text-link cursor-pointer" ng-click="goBack()">{{ currentAPI }}</span>\n                    <span> / </span>\n                    <span>Nodes</span>\n                </div>\n                <div ng-if="currentNode">\n                    <span class="wz-text-link cursor-pointer" ng-click="mctrl.switchTab(\'welcome\')">Management</span>\n                    <span> / </span>\n                    <span class="wz-text-link cursor-pointer" ng-click="goBack()">{{ mctrl.tabNames[mctrl.tab] }}</span>\n                    <span> / </span>\n                    <span class="wz-text-link cursor-pointer" ng-click="goBack()">{{ currentAPI }}</span>\n                    <span> / </span>\n                    <span class="wz-text-link cursor-pointer" ng-click="goNodes()">Nodes</span>\n                    <span> / </span>\n                    <span class="wz-text-bold">{{ currentNode.name }}</span>\n                </div>\n            </div>\n        </div>\n        <!-- End navigation section -->\n\n        <!-- Status and reports navigation bar -->\n        <md-nav-bar ng-if="!loading" class="wz-nav-bar" ng-show="mctrl.tab !== \'welcome\'" md-selected-nav-item="mctrl.tab"\n            nav-bar-aria-label="Status and reports navigation links">\n            <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'status\')" name="status">Status</md-nav-item>\n            <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'logs\')" name="logs">Logs</md-nav-item>\n            <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'monitoring\')" name="monitoring">Cluster</md-nav-item>\n            <md-nav-item class="wz-nav-item" md-nav-click="mctrl.switchTab(\'reporting\')" name="reporting">1_Reporting</md-nav-item>\n        </md-nav-bar>\n        <!-- End status and reports navigation bar -->\n\n        <!-- Headline -->\n        <div ng-show="!loading" layout="column" layout-padding>\n            <span class="font-size-18"><i class="fa fa-fw fa-search" aria-hidden="true"></i> Cluster</span>\n            <span class="md-subheader">Visualize your Wazuh cluster nodes and its agents</span>\n        </div>\n        <!-- End headline -->\n\n        <!-- Discover search bar section -->\n        <kbn-dis ng-show="!loading && (!showNodes || currentNode)"></kbn-dis>\n        <!-- End Discover search bar section -->\n\n        <!-- Loading status section -->\n        <div layout="column" layout-align="center center" class="wz-margin-bottom-40" ng-show="!loading && !rendered && resultState === \'ready\' && (!showNodes || (showNodes && currentNode))">\n            <div class="percentage"><i class="fa fa-fw fa-spin fa-spinner" aria-hidden="true"></i></div>\n            <div class="percentage">{{loadingStatus}}</div>\n        </div>\n        <!-- End loading status section -->\n    </div><!-- Cards for main monitoring section -->\n<div layout="row" layout-align="start stretch" class="wz-timelions" ng-if="!loading && !showConfig && !showNodes && isClusterEnabled && isClusterRunning">\n\n    <!-- Overview card -->\n    <md-card flex class="wz-md-card">\n        <md-card-content>\n            <i class="fa fa-fw fa-pie-chart" aria-hidden="true"></i> <span ng-click="goConfiguration()" class="wz-headline-title wz-text-link cursor-pointer">Overview</span>\n            <md-divider class="wz-margin-top-10"></md-divider>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">IP</span>\n                <span class="color-grey">{{configuration.nodes[0] || \'Unknown\'}}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Running</span>\n                <span class="color-grey">{{ status || \'no\' }}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Version</span>\n                <span class="color-grey">{{version}}</span>\n            </div>\n        </md-card-content>\n    </md-card>\n    <!-- End overview card -->\n\n    <!-- Info card -->\n    <md-card flex class="wz-md-card">\n        <md-card-content>\n            <i class="fa fa-fw fa-info" aria-hidden="true"></i> <span class="wz-headline-title">Information</span>\n            <md-divider class="wz-margin-top-10"></md-divider>\n            <!-- Nodes -->\n            <div layout="row" class="wz-padding-top-10 cursor-pointer" ng-click="goNodes()">\n                <span flex="25" class="wz-text-link" tooltip="Click to open the list of nodes" tooltip-placement="left">Nodes</span>\n                <span class="wz-text-link" tooltip="Click to open the list of nodes" tooltip-placement="right">{{nodesCount}}</span>\n            </div>\n            <!-- Agents -->\n            <div layout="row" class="wz-padding-top-10 cursor-pointer" ng-click="goAgents()">\n                <span flex="25" class="wz-text-link" tooltip="Click to open the list of agents" tooltip-placement="left">Agents</span>\n                <span class="wz-text-link" tooltip="Click to open the list of agents" tooltip-placement="right">{{agentsCount}}</span>\n            </div>\n        </md-card-content>\n    </md-card>\n    <!-- End info card -->\n</div>\n<!-- End cards for main monitoring section -->\n<!-- No results section -->\n<div layout="row" class="wz-margin-right-8 wz-margin-left-8 wz-margin-bottom-45 wz-margin-top-17" ng-show="resultState === \'none\' && !loading && !showConfig && !showNodes">\n    <div flex class="euiCallOut euiCallOut--warning">\n        <div class="euiCallOutHeader">\n            <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path></defs><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use></svg>\n            <span class="euiCallOutHeader__title">There are no results for selected time range. Try another one.</span>\n        </div>\n    </div>\n</div>\n<!-- End no results section -->\n\n<!-- Monitoring Timelion visualizations section -->\n<div layout="row" layout-align="start stretch" class="height-400" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" ng-show="!loading && !showConfig && !showNodes && rendered">\n    <md-card flex class="wz-md-card">\n        <md-card-content class="wazuh-column">\n            <span class="wz-headline-title">Cluster alerts summary</span>\n            <md-divider class="wz-margin-top-10"></md-divider>\n            <kbn-vis vis-id="\'Wazuh-App-Cluster-Overview-Manager\'" id="Wazuh-App-Cluster-Overview-Manager"></kbn-vis>\n        </md-card-content>\n    </md-card>\n    <md-card flex class="wz-md-card">\n        <md-card-content class="wazuh-column">\n            <span class="wz-headline-title">Alerts by node summary</span>\n            <md-divider class="wz-margin-top-10"></md-divider>\n            <kbn-vis vis-id="\'Wazuh-App-Cluster-Overview\'" id="Wazuh-App-Cluster-Overview"></kbn-vis>\n        </md-card-content>\n    </md-card>\n</div>\n<!-- End monitoring Timelion visualizations section -->\n<!-- Cards for overview monitoring section -->\n<div layout="row" layout-align="start stretch" class="wz-timelions" ng-show="showConfig">\n    <!-- Back button -->\n    <md-button class="md-icon-button wz-back-btn-absolute" aria-label="Back" tooltip="Go back" tooltip-placement="bottom" ng-click="goBack()"><i\n        class="fa fa-fw fa-arrow-left" aria-hidden="true"></i></md-button>\n    <!-- Overview visualization card -->\n    <md-card class="wz-md-card" ng-class="{\'no-opacity-overview-monitoring\': resultState !== \'ready\' || !rendered,\'flex-30\': resultState === \'ready\' && rendered}">\n        <md-card-content class="wazuh-column">\n            <span class="wz-headline-title">Top 5 nodes</span>\n            <md-divider class="wz-margin-top-10"></md-divider>\n            <kbn-vis ng-show="rendered" vis-id="\'Wazuh-App-Cluster-Overview-Node-Pie\'" id="Wazuh-App-Cluster-Overview-Node-Pie"></kbn-vis>\n            <span class="wz-padding-top-10 wz-text-center" ng-show="!rendered">There are no results for selected time range. Try another one.</span>\n        </md-card-content>\n    </md-card>\n\n    <!-- Cluster configuration card -->\n    <md-card flex class="wz-md-card">\n        <md-card-content>\n            <i class="fa fa-fw fa-server" aria-hidden="true"></i> <span class="wz-headline-title">Cluster configuration</span>\n            <md-divider class="wz-margin-top-10"></md-divider>\n            <!-- Configuration options -->\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Disabled</span>\n                <span class="color-grey">{{configuration.disabled}}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Hidden</span>\n                <span class="color-grey">{{configuration.hidden}}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Name</span>\n                <span class="color-grey">{{configuration.name}}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Node name</span>\n                <span class="color-grey">{{configuration.node_name}}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Node type</span>\n                <span class="color-grey">{{configuration.node_type}}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Bind address</span>\n                <span class="color-grey">{{configuration.bind_addr}}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">IP</span>\n                <span class="color-grey">{{configuration.nodes[0] || \'Unknown\'}}</span>\n            </div>\n            <div layout="row" class="wz-padding-top-10">\n                <span flex="25">Port</span>\n                <span class="color-grey">{{configuration.port}}</span>\n            </div>\n        </md-card-content>\n    </md-card>\n</div>\n<!-- End cards for overview monitoring section -->\n<div layout="column" ng-if="showNodes && !currentNode">\n    <!-- Back button -->\n    <md-button class="md-icon-button" aria-label="Back" tooltip="Go back" tooltip-placement="bottom" ng-click="goBack()"><i\n            class="fa fa-fw fa-arrow-left" aria-hidden="true"></i></md-button>\n    <div layout="row" class="md-padding">\n        <input placeholder="Filter nodes..." ng-model="custom_search" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid"\n            aria-invalid="false" wz-enter="search(custom_search)">\n        <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-40" ng-click="search(custom_search)">\n            <span class="fa fa-search" aria-hidden="true"></span>\n        </button>\n    </div>\n    <div layout="row" class="md-padding">\n        <wz-table flex path="\'/cluster/nodes\'" keys="[\'name\',\'version\',\'ip\',\'type\']" allow-click="true">\n        </wz-table>\n    </div>\n</div><div layout="column" layout-align="start stretch" ng-show="currentNode">\n    <!-- Back button -->\n    <md-button class="md-icon-button wz-back-btn-absolute" aria-label="Back" tooltip="Go back" tooltip-placement="bottom" ng-click="goNodes()"><i\n        class="fa fa-fw fa-arrow-left" aria-hidden="true"></i></md-button>\n    <!-- Node alerts summary card -->\n    <div layout="row" layout-align="start stretch" class="height-250 wz-timelions" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" ng-show="!loading && currentNode && !showConfig">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">{{ currentNode.name }} alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis ng-show="rendered" vis-id="\'Wazuh-App-Cluster-Overview-Node\'" id="Wazuh-App-Cluster-Overview-Node"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End node alerts summary card -->\n\n    <!-- Node info and files cards section -->\n    <div layout="row" class="wz-margin-top-40" layout-align="start stretch" ng-show="currentNode && currentNode.healthCheck && currentNode.healthCheck">\n\n        <!-- Node information card -->\n        <md-card flex class="wz-md-card" ng-show="currentNode && currentNode.healthCheck && currentNode.healthCheck.info">\n            <md-card-content>\n                <i class="fa fa-fw fa-info" aria-hidden="true"></i> <span class="wz-headline-title">Node information</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">IP</span>\n                    <span class="color-grey">{{currentNode.healthCheck.info.ip}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Version</span>\n                    <span class="color-grey">{{currentNode.healthCheck.info.version}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Type</span>\n                    <span class="color-grey">{{currentNode.healthCheck.info.type}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Name</span>\n                    <span class="color-grey">{{currentNode.healthCheck.info.name}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Active agents</span>\n                    <span class="color-grey">{{ currentNode.healthCheck.info.n_active_agents }}</span>\n                </div>\n            </md-card-content>\n        </md-card>\n\n        <!-- Last files sync card -->\n        <md-card flex class="wz-md-card" ng-show="currentNode && currentNode.healthCheck && currentNode.healthCheck.status">\n            <md-card-content>\n                <i class="fa fa-fw fa-file" aria-hidden="true"></i> <span class="wz-headline-title">Last files integrity synchronization</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Last sync</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_integrity.date_end_master}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Duration</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_integrity.duration}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Total shared files</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_integrity.total_files.shared}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Total missing files</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_integrity.total_files.missing}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Total extra but valid files</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_integrity.total_files.extra_valid}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Total extra files</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_integrity.total_files.extra}}</span>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End node info and files cards section -->\n\n    <!-- Node agents cards section -->\n    <div layout="row" layout-align="start stretch" ng-show="currentNode && currentNode.healthCheck && currentNode.healthCheck.status">\n\n        <!-- Agents sync card -->\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <i class="fa fa-fw fa-tv" aria-hidden="true"></i> <span class="wz-headline-title">Last agents information synchronization</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Last sync</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_agentinfo.date_end_master}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Duration</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_agentinfo.duration}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Total agent info</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_agentinfo.total_agentinfo}}</span>\n                </div>\n            </md-card-content>\n        </md-card>\n\n        <!-- Groups sync card -->\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <i class="fa fa-fw fa-object-group" aria-hidden="true"></i> <span class="wz-headline-title">Last agents groups synchronization</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Last sync</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_agentgroups.date_end_master}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Duration</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_agentgroups.duration}}</span>\n                </div>\n                <div layout="row" class="wz-padding-top-10">\n                    <span flex="30">Total agent info</span>\n                    <span class="color-grey">{{currentNode.healthCheck.status.last_sync_agentgroups.total_agentgroups}}</span>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End ode agents cards section -->\n</div>\n</div>';
			return pug_html
		}
		module.exports = template
	},
	5307: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_interp, pug_html = "";
			pug_html = pug_html + '<div flex="auto" layout="column" ng-if="mctrl.globalRuleSet == \'ruleset\'" class="mozilla-table-size-85">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-file-text-o" aria-hidden="true"></i> Ruleset</span>\n        <span class="md-subheader">Review all your current rules and decoders</span>\n    </div>\n    <!-- End headline -->\n' + (null == (pug_interp = __webpack_require__(5308).call(this, locals)) ? "" : pug_interp) + (null == (pug_interp = __webpack_require__(5309).call(this, locals)) ? "" : pug_interp) + "</div>";
			return pug_html
		}
		module.exports = template
	},
	5308: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex ng-if="!loading && mctrl.globalRuleSet == \'ruleset\' && mctrl.globalRulesetTab == \'rules\'" ng-controller="rulesController" layout="column" id="rulesContainer" layout-align="start space-around">\n\n    <div class=\'uil-ring-css\' ng-show="loading">\n        <div></div>\n    </div>\n<div ng-if="!loading && !viewingDetail" layout="column" class="md-padding">\n    <div id="content" layout="row">\n\n        <input flex placeholder="Filter rules..." ng-model="custom_search" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid wz-margin-top-4 height-36"\n            aria-invalid="false" wz-enter="search(custom_search)">\n        <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-36 wz-margin-top-4" ng-click="search(custom_search)">\n            <span class="fa fa-search" aria-hidden="true"></span>\n        </button>\n\n        <md-button ng-class="(mctrl.globalRulesetTab == \'rules\') ? \'active\' : \'\'"\n            ng-click="mctrl.setRulesTab(\'rules\')" class="wz-button md-raised md-primary manager-ruleset-btn" aria-label="Ruleset rules button">\n            <i class="fa fa-fw fa-file-text-o" aria-hidden="true"></i> Rules\n        </md-button>\n        <md-button ng-class="(mctrl.globalRulesetTab == \'decoders\') ? \'active\' : \'\'"\n            ng-click="mctrl.setRulesTab(\'decoders\')" class="wz-button md-raised md-primary manager-ruleset-btn" aria-label="Ruleset decoders button">\n            <i class="fa fa-fw fa-search" aria-hidden="true"></i> Decoders\n        </md-button>\n    </div>\n\n    <md-chips class="wz-chips" readonly="true" ng-show="appliedFilters.length">\n        <md-chip class="wz-chip" ng-show="includesFilter(\'file\')">\n            <span>File: {{getFilter(\'file\')}}\n                <i class="fa fa-fw fa-times cursor-pointer" aria-hidden="true" ng-click="removeFilter(\'file\')"></i>\n            </span>\n        </md-chip>\n        <md-chip class="wz-chip" ng-show="includesFilter(\'path\')">\n            <span>Path: {{getFilter(\'path\')}}\n                <i class="fa fa-fw fa-times cursor-pointer" aria-hidden="true" ng-click="removeFilter(\'path\')"></i>\n            </span>\n        </md-chip>\n        <md-chip class="wz-chip" ng-show="includesFilter(\'level\')">\n            <span>Level: {{getFilter(\'level\')}}\n                <i class="fa fa-fw fa-times cursor-pointer" aria-hidden="true" ng-click="removeFilter(\'level\')"></i>\n            </span>\n        </md-chip>\n        <md-chip class="wz-chip" ng-show="includesFilter(\'group\')">\n            <span>Group: {{getFilter(\'group\')}}\n                <i class="fa fa-fw fa-times cursor-pointer" aria-hidden="true" ng-click="removeFilter(\'group\')"></i>\n            </span>\n        </md-chip>\n        <md-chip class="wz-chip" ng-show="includesFilter(\'pci\')">\n            <span>PCI control: {{getFilter(\'pci\')}}\n                <i class="fa fa-fw fa-times cursor-pointer" aria-hidden="true" ng-click="removeFilter(\'pci\')"></i>\n            </span>\n        </md-chip>\n        <md-chip class="wz-chip" ng-show="includesFilter(\'gdpr\')">\n            <span>GDPR: {{getFilter(\'gdpr\')}}\n                <i class="fa fa-fw fa-times cursor-pointer" aria-hidden="true" ng-click="removeFilter(\'gdpr\')"></i>\n            </span>\n        </md-chip>\n    </md-chips>\n\n    <div layout="row">\n        <wz-table\n            implicit-filter="appliedFilters"\n            flex\n            path="\'/rules\'"\n            keys="[\'id\',{value:\'file\',size:2},{value:\'description\',size:2},{value:\'groups\',nosortable:true,size:2},{value:\'pci\',nosortable:true,size:2},{value:\'gdpr\',nosortable:true},\'level\']"\n            allow-click="true"\n            row-sizes="[15,13,11]">\n        </wz-table>\n    </div>\n\n    <div layout="row" class="wz-margin-top-10">\n        <span flex></span>\n        <a class="small" id="btnDownload" ng-click="downloadCsv()">Formatted <i aria-hidden="true" class="fa fa-download"></i></a>\n    </div>\n</div>\n<div ng-if="!loading && viewingDetail" layout="column">\n\n    <!-- Back button and title -->\n    <div layout="row" layout-align="start center">\n        <!-- Back button -->\n        <md-button class="md-icon-button" aria-label="Back to rules list" tooltip="Back" tooltip-placement="bottom"\n            ng-click="closeDetailView(true)"><i class="fa fa-fw fa-arrow-left" aria-hidden="true"></i></md-button>\n        <!-- Rule title -->\n        <h1 class="md-headline wz-headline" ng-bind-html="colorRuleArg(currentRule.description)"></h1>\n\n    </div>\n    <!-- End back button, title and status indicator -->\n\n    <!-- Rule information ribbon -->\n    <div layout="row" class="wz-padding-left-8">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div flex="15" ng-if="currentRule.id" class="wz-text-truncatable">ID: <span class="wz-text-bold">{{currentRule.id}}</span></div>\n                <div flex="15" ng-if="currentRule.level || currentRule.level == 0" class="wz-text-truncatable">Level:\n                    <span class="wz-text-bold wz-text-link" ng-click="addDetailFilter(\'level\', currentRule.level)"\n                        tooltip="Filter by this level" tooltip-placement="bottom">{{currentRule.level}}</span></div>\n                <div flex="35" ng-if="currentRule.file" class="wz-text-truncatable">File: <span class="wz-text-bold wz-text-link"\n                        ng-click="addDetailFilter(\'file\', currentRule.file)" tooltip="Filter by this file"\n                        tooltip-placement="bottom">{{currentRule.file}}</span></div>\n                <div flex="35" ng-if="currentRule.path" class="wz-text-truncatable">Path: <span class="wz-text-bold wz-text-link"\n                        ng-click="addDetailFilter(\'path\', currentRule.path)" tooltip="Filter by this path"\n                        tooltip-placement="bottom">{{currentRule.path}}</span></div>\n\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End Rule information ribbon -->\n\n    <!-- Rest of rule information -->\n    <div layout="column" layout-align="start">\n\n        <div layout="row" class="wz-padding-left-8" layout-align="start stretch">\n\n            <!-- Groups section -->\n            <md-card ng-if="currentRule.groups.length > 0" flex="50" class="wz-md-card">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-tasks" aria-hidden="true"></i> Groups</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div layout="row" layout-align="start start" layout-wrap>\n                        <md-button class="md-primary wz-text-link" tooltip="Filter by this group" tooltip-placement="bottom"\n                            ng-repeat="item in currentRule.groups" ng-click="addDetailFilter(\'group\', item)">\n                            {{item}}\n                        </md-button>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End groups section -->\n\n            <!-- Details section -->\n            <md-card flex class="wz-md-card" ng-if="currentRule.details">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-info" aria-hidden="true"></i> Details</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div layout="row" class="wz-padding-top-10" ng-repeat="(key, value) in currentRule.details"\n                        ng-if=\'!isArray(value)\'>\n                        <span flex="20">{{key}}</span>\n                        <span ng-if="!isObject(value)" class="wz-text-right color-grey">{{value}}</span>\n                        <span ng-if="isObject(value)" class="color-grey">\n                            <span ng-repeat="(key, value) in value">{{key}}: {{value}} <span ng-if="!$last">|</span> </span>\n                        </span>\n                    </div>                    \n                </md-card-content>\n            </md-card>\n            <!-- End details section -->\n\n        </div>\n\n        <div layout="row" class="wz-padding-left-8" layout-align="start stretch" ng-if="currentRule.pci.length > 0 || currentRule.gdpr.length > 0">\n\n            <!-- PCI section -->\n            <md-card ng-if="currentRule.pci.length > 0" flex="50" class="wz-md-card">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-cogs" aria-hidden="true"></i> PCI</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div layout="row" layout-align="start start" layout-wrap>\n                        <md-button class="md-primary wz-text-link" tooltip="Filter by this requirement"\n                            tooltip-placement="bottom" ng-repeat="item in currentRule.pci" ng-click="addDetailFilter(\'pci\', item)">\n                            {{item}}\n                        </md-button>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End PCI section -->\n\n            <!-- GDPR section -->\n            <md-card ng-if="currentRule.gdpr.length > 0" flex class="wz-md-card">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-cogs" aria-hidden="true"></i> GDPR</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div layout="row" layout-align="start start" layout-wrap>\n                        <md-button class="md-primary wz-text-link" tooltip="Filter by this requirement"\n                            tooltip-placement="bottom" ng-repeat="item in currentRule.gdpr" ng-click="addDetailFilter(\'gdpr\', item)">\n                            {{item}}\n                        </md-button>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End GDPR section -->\n\n        </div>\n\n        <div layout="row" class="wz-padding-left-16" layout-align="start stretch" ng-if="isArray(currentRule.details.regex) || isArray(currentRule.details.match) || isArray(currentRule.details.prematch)">\n\n            <!-- Regex section -->\n            <md-card flex class="wz-md-card" ng-if="isArray(currentRule.details.regex)">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-asterisk" aria-hidden="true"></i> Regex</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div ng-repeat="item in currentRule.details.regex">\n                        <div layout="row" class="wz-padding-top-10" layout-wrap>\n                            <span>{{item}}</span>\n                        </div>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End regex section -->\n\n            <!-- Match section -->\n            <md-card flex class="wz-md-card" ng-if="isArray(currentRule.details.match)">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-retweet" aria-hidden="true"></i> Match</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div ng-repeat="item in currentRule.details.match">\n                        <div layout="row" class="wz-padding-top-10" layout-wrap>\n                            <span>{{item}}</span>\n                        </div>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End match section -->\n\n            <!-- Prematch section -->\n            <md-card flex class="wz-md-card" ng-if="isArray(currentRule.details.prematch)">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-retweet" aria-hidden="true"></i> Prematch</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div ng-repeat="item in currentRule.details.prematch">\n                        <div layout="row" class="wz-padding-top-10" layout-wrap>\n                            <span>{{item}}</span>\n                        </div>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End prematch section -->\n\n        </div>\n\n        <!-- Related rules section -->\n        <div layout="row" class="wz-padding-left-16" ng-if="currentRule">\n            <h1 class="md-headline wz-headline"><i class="fa fa-fw fa-link" aria-hidden="true"></i> Related rules</h1>\n        </div>\n        <div layout="row" ng-if="currentRule" class="md-padding">\n            <wz-table flex path="\'/rules\'" implicit-filter="[{ name:\'file\',value: currentRule.file}]" keys="[\'id\',{value:\'file\',size:2},{value:\'description\',size:2},{value:\'groups\',nosortable:true,size:2},{value:\'pci\',nosortable:true,size:2},{value:\'gdpr\',nosortable:true},\'level\']"\n                allow-click="true">\n            </wz-table>\n        </div>\n        <!-- End related rules section -->\n\n    </div>\n    <!-- End rest of rule information -->\n\n</div></div>';
			return pug_html
		}
		module.exports = template
	},
	5309: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex ng-if="!loading && mctrl.globalRulesetTab == \'decoders\'" ng-controller="decodersController as dctrl" layout="column" id="rulesContainer" layout-align="start space-around">\n\n    <div class=\'uil-ring-css\' ng-show="loading">\n        <div></div>\n    </div>\n<div ng-if="!loading && !dctrl.viewingDetail" layout="column" class="md-padding">\n    <div id="content" layout="row" layout-align="start start">\n\n        <input flex placeholder="Filter decoders..." ng-model="dctrl.custom_search" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid wz-margin-top-4 height-36"\n            aria-invalid="false" wz-enter="dctrl.search(dctrl.custom_search)">\n        <button type="submit" aria-label="Search" class="kuiLocalSearchButton height-36 wz-margin-top-4 wz-margin-right-16" ng-click="dctrl.search(dctrl.custom_search)">\n            <span class="fa fa-search" aria-hidden="true"></span>\n        </button>\n\n        <div layout="column" layout-align="center" class="height-40 wz-select-input wz-margin-right-8">\n            <select flex class="kuiSelect wz-border-none cursor-pointer max-height-35" ng-model="dctrl.typeFilter" ng-change="dctrl.onlyParents(dctrl.typeFilter)" aria-label="Filter by type" ng-init="\'All decoders\'">\n                <option value="all">All decoders</option>\n                <option value="parents">Parent decoders</option>\n            </select>\n        </div>\n\n        <md-button ng-class="(mctrl.globalRulesetTab == \'rules\') ? \'active\' : \'\'" ng-click="mctrl.setRulesTab(\'rules\')"\n            class="wz-button md-raised md-primary manager-ruleset-btn" aria-label="Ruleset rules button">\n            <i class="fa fa-fw fa-file-text-o" aria-hidden="true"></i> Rules\n        </md-button>\n        <md-button ng-class="(mctrl.globalRulesetTab == \'decoders\') ? \'active\' : \'\'" ng-click="mctrl.setRulesTab(\'decoders\')"\n            class="wz-button md-raised md-primary manager-ruleset-btn" aria-label="Ruleset decoders button">\n            <i class="fa fa-fw fa-search" aria-hidden="true"></i> Decoders\n        </md-button>\n    </div>\n\n    <md-chips class="wz-chips" readonly="true" ng-show="dctrl.appliedFilters.length">\n        <md-chip class="wz-chip" ng-show="dctrl.includesFilter(\'file\')">\n            <span>File: {{ dctrl.getFilter(\'file\') }}\n                <i class="fa fa-fw fa-times cursor-pointer" aria-hidden="true" ng-click="dctrl.removeFilter(\'file\')"></i>\n            </span>\n        </md-chip>\n        <md-chip class="wz-chip" ng-show="dctrl.includesFilter(\'path\')">\n            <span>Path: {{ dctrl.getFilter(\'path\') }}\n                <i class="fa fa-fw fa-times cursor-pointer" aria-hidden="true" ng-click="dctrl.removeFilter(\'path\')"></i>\n            </span>\n        </md-chip>\n    </md-chips>\n\n    <div layout="row">\n        <wz-table\n            implicit-filter="dctrl.appliedFilters"\n            flex\n            path="\'/decoders\'"\n            keys="[\'name\',{value:\'details.program_name\',size:2,nosortable:true},{value:\'details.order\',size:2,nosortable:true},\'file\']"\n            allow-click="true"\n            row-sizes="[15,13,11]"\n        />\n    </div>\n\n    <div layout="row" class="wz-margin-top-10">\n        <span flex></span>\n        <a class="small" id="btnDownload" ng-click="dctrl.downloadCsv()">Formatted <i aria-hidden="true" class="fa fa-download"></i></a>\n    </div>\n</div>\n<div ng-if="!loading && dctrl.viewingDetail" layout="column">\n\n    <!-- Back button and title -->\n    <div layout="row" layout-align="start center">\n        <!-- Back button -->\n        <md-button class="md-icon-button" aria-label="Back to decoders list" tooltip="Back" tooltip-placement="bottom"\n            ng-click="dctrl.closeDetailView()"><i class="fa fa-fw fa-arrow-left" aria-hidden="true"></i></md-button>\n        <!-- Decoder title -->\n        <h1 class="md-headline wz-headline">{{currentDecoder.name}}</h1>\n    </div>\n    <!-- End back button, title and status indicator -->\n\n    <!-- Decoder information ribbon -->\n    <div layout="row" class="wz-padding-left-16">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div flex="20" ng-if="dctrl.currentDecoder.position || dctrl.currentDecoder.position == 0" class="wz-text-truncatable">Position:\n                    <span class="wz-text-bold">{{dctrl.currentDecoder.position}}</span></div>\n                <div flex="40" ng-if="dctrl.currentDecoder.file" class="wz-text-truncatable">File: <span class="wz-text-bold wz-text-link"\n                        ng-click="dctrl.addDetailFilter(\'file\', dctrl.currentDecoder.file)" tooltip="Filter by this file"\n                        tooltip-placement="bottom">{{dctrl.currentDecoder.file}}</span></div>\n                <div flex="40" ng-if="dctrl.currentDecoder.path" class="wz-text-truncatable">Path: <span class="wz-text-bold wz-text-link"\n                        ng-click="dctrl.addDetailFilter(\'path\', dctrl.currentDecoder.path)" tooltip="Filter by this path"\n                        tooltip-placement="bottom">{{dctrl.currentDecoder.path}}</span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End Decoder information ribbon -->\n\n    <!-- Rest of decoder information -->\n    <div layout="column" layout-align="start">\n\n        <div layout="row" class="wz-padding-left-16" layout-align="start stretch">\n\n            <!-- Details section -->\n            <md-card flex class="wz-md-card">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-info" aria-hidden="true"></i> Details</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div layout="row" layout-wrap class="wz-padding-top-10" ng-repeat="(key, value) in dctrl.currentDecoder.details"\n                        ng-if="!dctrl.isArray(value)">\n                        <span flex="20">{{key}}</span>\n                        <span class="wz-text-right color-grey" ng-if="key !== \'regex\' && key !== \'order\'">{{value}}</span>\n                        <span class="wz-text-right color-grey" ng-if="key == \'regex\'" ng-bind-html="dctrl.colorRegex(value)"></span>\n                        <span class="wz-text-right color-grey" ng-if="key == \'order\'" ng-bind-html="dctrl.colorOrder(value)"></span>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End details section -->\n\n            <!-- Regex section -->\n            <md-card flex class="wz-md-card" ng-if="dctrl.isArray(dctrl.currentDecoder.details.regex)">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-asterisk" aria-hidden="true"></i> Regex</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div ng-repeat="item in dctrl.currentDecoder.details.regex">\n                        <div layout="row" layout-wrap class="wz-padding-top-10">\n                            <span ng-bind-html="dctrl.colorRegex(item)"></span>\n                        </div>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End regex section -->\n\n        </div>\n\n        <div layout="row" class="wz-padding-left-16" layout-align="start stretch">\n\n            <!-- Match section -->\n            <md-card flex class="wz-md-card" ng-if="dctrl.isArray(dctrl.currentDecoder.details.match)">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-retweet" aria-hidden="true"></i> Match</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div ng-repeat="item in dctrl.currentDecoder.details.match">\n                        <div layout="row" layout-wrap class="wz-padding-top-10">\n                            <span>{{item}}</span>\n                        </div>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End match section -->\n\n            <!-- Prematch section -->\n            <md-card flex class="wz-md-card" ng-if="dctrl.isArray(dctrl.currentDecoder.details.prematch)">\n                <md-card-content>\n                    <span class="wz-headline-title"><i class="fa fa-fw fa-retweet" aria-hidden="true"></i> Prematch</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <div ng-repeat="item in dctrl.currentDecoder.details.prematch">\n                        <div layout="row" layout-wrap class="wz-padding-top-10">\n                            <span>{{item}}</span>\n                        </div>\n                    </div>\n                </md-card-content>\n            </md-card>\n            <!-- End prematch section -->\n\n        </div>\n\n        <!-- Related decoders section -->\n        <div layout="row" class="wz-padding-left-16" ng-if="dctrl.currentDecoder">\n            <h1 class="md-headline wz-headline"><i class="fa fa-fw fa-link" aria-hidden="true"></i> Related decoders</h1>\n        </div>\n        <div layout="row" ng-if="dctrl.currentDecoder" class="md-padding">\n            <wz-table flex path="\'/decoders\'" implicit-filter="[{ name:\'file\',value: dctrl.currentDecoder.file}]" keys="[\'name\',{value:\'details.program_name\',size:2,nosortable:true},{value:\'details.order\',size:2,nosortable:true},\'file\']"\n                allow-click="true" />\n        </div>\n        <!-- End related decoders section -->\n\n    </div>\n    <!-- End rest of decoder information -->\n\n</div></div>';
			return pug_html
		}
		module.exports = template
	},
	5310: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-cloak ng-controller="overviewController as octrl">\n\n    <!-- Top navbar section -->\n    <wz-menu ng-init="menuNavItem = \'overview\'"></wz-menu>\n    <!-- End top navbar section -->\n\n    <!-- Navigation section -->\n    <div layout="row" layout-align="start center">\n        <!-- Breadcrumbs -->\n        <div layout="row" layout-padding>\n            <!-- If you\'re not on the Welcome tab, show a functional breadcrumb -->\n            <div ng-if="octrl.tab !== \'welcome\'">\n                <span class="wz-text-link cursor-pointer" ng-click="octrl.switchTab(\'welcome\')">Overview</span>\n                <span> / </span>\n                <span>{{ octrl.tabNames[octrl.tab] }}</span>\n            </div>\n            <!-- If you\'re on the Welcome tab, show a blank, simple breadcrumb -->\n            <div ng-if="octrl.tab === \'welcome\'">\n                <span>Overview / Welcome</span>\n            </div>\n        </div>\n        <!-- End breadcrumbs -->\n\n        <!-- Separator -->\n        <span flex></span>\n        <!-- End separator -->\n\n        <!-- Reporting button section -->\n        <div ng-show="octrl.tab !== \'welcome\' && octrl.tabView === \'panels\'">\n            <!-- Report button -->\n        <!--    <md-button md-no-ink class="md-icon-button small wz-no-margin-padding" tooltip="Generate report" tooltip-placement="bottom" ng-disabled="!rendered || loading || resultState !== \'ready\'" ng-click="octrl.startVis2Png()" aria-label="Generate report button">\n                <i class="fa fa-fw fa-print" aria-hidden="true"></i>\n            </md-button>\n   -->     </div>\n        <!-- End Reporting buttons section -->\n\n        <!-- Discover/Dashboard buttons section -->\n        <div ng-show="octrl.tab !== \'welcome\'">\n            <!-- Dashboard button -->\n            <md-button ng-if="octrl.tabView === \'discover\'" class="wz-button-flat small" ng-click="octrl.switchSubtab(\'panels\')" aria-label="Dashboard button">\n                <i class="fa fa-fw fa-th" aria-hidden="true"></i> Dashboard\n            </md-button>\n\n            <!-- Discover button -->\n            <md-button ng-if="octrl.tabView === \'panels\'" class="wz-button-flat small" ng-click="octrl.switchSubtab(\'discover\')" aria-label="Discover button">\n                <i class="fa fa-fw fa-compass" aria-hidden="true"></i> Discover\n            </md-button>\n        </div>\n        <!-- End Discover/Dashboard buttons section -->\n    </div>\n    <!-- End navigation section -->\n\n    <!-- Host monitoring navigation bar -->\n    <md-nav-bar\n        ng-if="octrl.inArray(octrl.tab, octrl.hostMonitoringTabs)"\n        class="wz-nav-bar"\n        ng-show="octrl.tab !== \'welcome\'"\n        md-selected-nav-item="octrl.tab"\n        nav-bar-aria-label="Host monitoring navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="octrl.switchTab(\'general\',true)" name="general">{{ octrl.tabNames[\'general\'] }}</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="octrl.switchTab(\'fim\',true)" name="fim">{{ octrl.tabNames[\'fim\'] }}</md-nav-item>\n        <md-nav-item ng-show="octrl.extensions.aws" class="wz-nav-item" md-nav-click="octrl.switchTab(\'aws\',true)" name="aws">{{ octrl.tabNames[\'aws\'] }}</md-nav-item>\n    </md-nav-bar>\n    <!-- End Host monitoring navigation bar -->\n\n    <!-- System audit navigation bar -->\n    <md-nav-bar\n        ng-if="octrl.inArray(octrl.tab, octrl.systemAuditTabs) && (octrl.extensions.audit || octrl.extensions.oscap || octrl.extensions.ciscat)"\n        class="wz-nav-bar"\n        ng-show="octrl.tab !== \'welcome\'"\n        md-selected-nav-item="octrl.tab"\n        nav-bar-aria-label="System audit navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="octrl.switchTab(\'pm\',true)" name="pm">{{ octrl.tabNames[\'pm\'] }}</md-nav-item>\n        <md-nav-item ng-show="octrl.extensions.audit" class="wz-nav-item" md-nav-click="octrl.switchTab(\'audit\',true)" name="audit">{{ octrl.tabNames[\'audit\'] }}</md-nav-item>\n        <md-nav-item ng-show="octrl.extensions.oscap" class="wz-nav-item" md-nav-click="octrl.switchTab(\'oscap\',true)" name="oscap">{{ octrl.tabNames[\'oscap\'] }}</md-nav-item>\n        <md-nav-item ng-show="octrl.extensions.ciscat" class="wz-nav-item" md-nav-click="octrl.switchTab(\'ciscat\',true)" name="ciscat">{{ octrl.tabNames[\'ciscat\'] }}</md-nav-item>\n    </md-nav-bar>\n    <!-- End System audit navigation bar -->\n\n    <!-- Security navigation bar -->\n    <md-nav-bar\n        ng-if="octrl.inArray(octrl.tab, octrl.securityTabs) && (octrl.extensions.virustotal || octrl.extensions.osquery)"\n        class="wz-nav-bar"\n        ng-show="octrl.tab !== \'welcome\'"\n        md-selected-nav-item="octrl.tab"\n        nav-bar-aria-label="Security navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="octrl.switchTab(\'vuls\',true)" name="vuls">{{ octrl.tabNames[\'vuls\'] }}</md-nav-item>\n        <md-nav-item ng-show="octrl.extensions.virustotal" class="wz-nav-item" md-nav-click="octrl.switchTab(\'virustotal\',true)" name="virustotal">{{ octrl.tabNames[\'virustotal\'] }}</md-nav-item>\n        <md-nav-item ng-show="octrl.extensions.osquery" class="wz-nav-item" md-nav-click="octrl.switchTab(\'osquery\',true)" name="osquery">{{ octrl.tabNames[\'osquery\'] }}</md-nav-item>\n    </md-nav-bar>\n    <!-- End Security navigation bar -->\n\n    <!-- Compliance navigation bar -->\n    <md-nav-bar\n        ng-if="octrl.inArray(octrl.tab, octrl.complianceTabs) && octrl.extensions.pci && octrl.extensions.gdpr"\n        class="wz-nav-bar"\n        ng-show="octrl.tab !== \'welcome\'"\n        md-selected-nav-item="octrl.tab"\n        nav-bar-aria-label="Compliance navigation links">\n        <md-nav-item ng-show="octrl.extensions.pci" class="wz-nav-item" md-nav-click="octrl.switchTab(\'pci\',true)" name="pci">{{ octrl.tabNames[\'pci\'] }}</md-nav-item>\n        <md-nav-item ng-show="octrl.extensions.gdpr" class="wz-nav-item" md-nav-click="octrl.switchTab(\'gdpr\',true)" name="gdpr">{{ octrl.tabNames[\'gdpr\'] }}</md-nav-item>\n    </md-nav-bar>\n    <!-- End Compliance navigation bar -->\n\n    <!-- Discover search bar section -->\n    <kbn-dis ng-show="octrl.tab !== \'welcome\'"></kbn-dis>\n    <!-- End Discover search bar section -->\n\n    <!-- Loading status section -->\n    <div layout="column" layout-align="center center" ng-if="octrl.tab !== \'welcome\' && octrl.tab !== \'aws\'" ng-show="resultState === \'ready\' && octrl.tabView === \'panels\' && !rendered">\n        <div class="percentage"><i class="fa fa-fw fa-spin fa-spinner" aria-hidden="true"></i></div>\n        <div class="percentage">{{loadingStatus}}</div>\n    </div>\n    <!-- End loading status section -->\n\n    <!-- Report status section -->\n    <div layout="column" layout-align="center center" ng-if="octrl.tab !== \'welcome\'" ng-show="reportBusy && reportStatus">\n        <div class="percentage"><i class="fa fa-fw fa-spin fa-spinner" aria-hidden="true"></i></div>\n        <div class="percentage">{{reportStatus}}</div>\n    </div>\n    <!-- End report status section -->\n\n    <!-- No results section -->\n    <div layout="row" class="wz-margin-top-10 wz-margin-right-8 wz-margin-left-8" ng-if="octrl.tab !== \'welcome\'" ng-show="resultState === \'none\' && octrl.tabView === \'panels\'">\n        <div flex class="euiCallOut euiCallOut--warning">\n            <div class="euiCallOutHeader">\n                <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path></defs><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use></svg>\n                <span class="euiCallOutHeader__title">There are no results for selected time range. Try another one.</span>\n            </div>\n        </div>\n    </div>\n    <!-- No results section -->\n<div layout="column" layout-align="start stretch" ng-if="octrl.tab === \'welcome\'">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18">\n            <i class="fa fa-fw fa-bar-chart" aria-hidden="true"></i> Overview</span>\n    </div>\n    <!-- End headline -->\n    <div layout="row" layout-padding>\n        <md-card flex class="wz-metric-color wz-md-card wz-no-padding">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>\n                    Total agents: <span class="wz-text-bold">{{octrl.agentsCountTotal >= 0 ? octrl.agentsCountTotal : \'-\'}}</span>\n                </div>\n                <div class="wz-text-truncatable" flex>\n                    Active agents: <span class="wz-text-bold">{{octrl.agentsCountActive >= 0 ? octrl.agentsCountActive : \'-\'}}</span>\n                </div>\n                <div class="wz-text-truncatable" flex>\n                    Disconnected agents: <span class="wz-text-bold">{{octrl.agentsCountDisconnected >= 0 ? octrl.agentsCountDisconnected : \'-\'}}</span>\n                </div>\n                <div class="wz-text-truncatable" flex>\n                    Never connected agents: <span class="wz-text-bold">{{octrl.agentsCountNeverConnected >= 0 ? octrl.agentsCountNeverConnected : \'-\'}}</span>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-padding>\n        <div class="euiFlexGroup euiFlexGroup--gutterLarge euiFlexGroup--responsive">\n            <div class="euiFlexItem">\n                <div class="euiPanel euiPanel--paddingLarge">\n                    <h3 class="euiTitle wzEuiTitle">Security Information Management</h3>\n                    <div class="euiSpacer euiSpacer--m"></div>\n                    <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_dashboard.svg\'" title="\'Security events\'"\n                            switch-tab="octrl.switchTab(\'general\')" current-tab="\'general\'"\n                            description="octrl.TabDescription.general.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_logging.svg\'" title="\'Integrity monitoring\'"\n                            switch-tab="octrl.switchTab(\'fim\')" current-tab="\'fim\'"\n                            description="octrl.TabDescription.fim.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="octrl.extensions.aws" class="euiFlexItem" logo="\'icons/app_index_pattern.svg\'"\n                            title="\'Amazon AWS\'" switch-tab="octrl.switchTab(\'aws\')" current-tab="\'aws\'"\n                            description="octrl.TabDescription.aws.description"\n                        ></wz-welcome-card>\n                    </div>\n                </div>\n            </div>\n            <div class="euiFlexItem">\n                <div class="euiPanel euiPanel--paddingLarge">\n                    <h3 class="euiTitle wzEuiTitle">Auditing and Policy Monitoring</h3>\n                    <div class="euiSpacer euiSpacer--m"></div>\n                    <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                        <wz-welcome-card\n                            class="euiFlexItem" logo="\'icons/app_advanced_settings.svg\'"\n                            title="\'Policy monitoring\'" switch-tab="octrl.switchTab(\'pm\')" current-tab="\'pm\'"\n                            description="octrl.TabDescription.pm.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="octrl.extensions.audit" class="euiFlexItem" logo="\'icons/app_monitoring.svg\'"\n                            title="\'System auditing\'" switch-tab="octrl.switchTab(\'audit\')" current-tab="\'audit\'"\n                            description="octrl.TabDescription.audit.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="octrl.extensions.oscap" class="euiFlexItem" logo="\'icons/app_discover.svg\'"\n                            title="\'OpenSCAP\'" switch-tab="octrl.switchTab(\'oscap\')" current-tab="\'oscap\'"\n                            description="octrl.TabDescription.oscap.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="octrl.extensions.ciscat" class="euiFlexItem" logo="\'icons/app_management.svg\'"\n                            title="\'CIS-CAT\'" switch-tab="octrl.switchTab(\'ciscat\')" current-tab="\'ciscat\'"\n                            description="octrl.TabDescription.ciscat.description"\n                        ></wz-welcome-card>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <div layout="row" layout-padding>\n        <div class="euiFlexGroup euiFlexGroup--gutterLarge euiFlexGroup--responsive">\n            <div class="euiFlexItem">\n                <div class="euiFlexItem">\n                    <div class="euiPanel euiPanel--paddingLarge">\n                        <h3 class="euiTitle wzEuiTitle">Threat Detection and Response</h3>\n                        <div class="euiSpacer euiSpacer--m"></div>\n                        <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                            <wz-welcome-card\n                                class="euiFlexItem" logo="\'icons/app_security.svg\'"\n                                title="\'Vulnerabilities\'" switch-tab="octrl.switchTab(\'vuls\')" current-tab="\'vuls\'"\n                                description="octrl.TabDescription.vuls.description"\n                            ></wz-welcome-card>\n                            <wz-welcome-card\n                                ng-if="octrl.extensions.virustotal" class="euiFlexItem" logo="\'icons/app_saved_objects.svg\'"\n                                title="\'VirusTotal\'" switch-tab="octrl.switchTab(\'virustotal\')" current-tab="\'virustotal\'"\n                                description="octrl.TabDescription.virustotal.description"\n                            ></wz-welcome-card>\n                            <wz-welcome-card\n                                ng-if="octrl.extensions.osquery" class="euiFlexItem" logo="\'icons/osquery.svg\'"\n                                title="\'Osquery\'" switch-tab="octrl.switchTab(\'osquery\')" current-tab="\'osquery\'"\n                                description="octrl.TabDescription.osquery.description"\n                            ></wz-welcome-card>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <div class="euiFlexItem" ng-if="octrl.extensions && (octrl.extensions.pci || octrl.extensions.gdpr)">\n                <div class="euiPanel euiPanel--paddingLarge">\n                    <h3 class="euiTitle wzEuiTitle">Regulatory Compliance</h3>\n                    <div class="euiSpacer euiSpacer--m"></div>\n                    <div class="euiFlexGrid euiFlexGrid--gutterLarge euiFlexGrid--halves">\n                        <wz-welcome-card\n                            ng-if="octrl.extensions.pci" class="euiFlexItem" logo="\'icons/app_apm.svg\'"\n                            title="\'PCI DSS\'" switch-tab="octrl.switchTab(\'pci\')" current-tab="\'pci\'"\n                            description="octrl.TabDescription.pci.description"\n                        ></wz-welcome-card>\n                        <wz-welcome-card\n                            ng-if="octrl.extensions.gdpr" class="euiFlexItem" logo="\'icons/app_visualize.svg\'"\n                            title="\'GDPR\'" switch-tab="octrl.switchTab(\'gdpr\')" current-tab="\'gdpr\'"\n                            description="octrl.TabDescription.gdpr.description"\n                        ></wz-welcome-card>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n<md-content flex layout="column" ng-if="octrl.tab === \'general\' && octrl.tabView === \'panels\'" layout-align="start" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}">\n    <div layout="row">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Alerts: <span class="wz-text-bold" ng-bind="octrl.totalAlerts()"></span></div>\n                <div class="wz-text-truncatable" flex>Level 12 or above alerts: <span class="wz-text-bold" ng-bind="octrl.level12()"></span></div>\n                <div class="wz-text-truncatable" flex>Authentication failure: <span class="wz-text-bold" ng-bind="octrl.authFailure()"></span></div>\n                <div class="wz-text-truncatable" flex>Authentication success: <span class="wz-text-bold" ng-bind="octrl.authSuccess()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-App-Overview-General-Metric-alerts\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-General-Level-12-alerts\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-General-Authentication-failure\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-General-Authentication-success\'"></kbn-vis>\n    </div>\n\n    <div layout="row" layout-align="start stretch" class="height-230" >\n        <md-card flex="40" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Alert level evolution</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-General-Alert-level-evolution" vis-id="\'Wazuh-App-Overview-General-Alert-level-evolution\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="60" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Alerts</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-General-Alerts" vis-id="\'Wazuh-App-Overview-General-Alerts\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="space-between stretch" class="height-270">\n        <md-card flex class="wz-md-card" >\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 5 agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-General-Top-5-agents" vis-id="\'Wazuh-App-Overview-General-Top-5-agents\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card" >\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Alerts evolution - Top 5 agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-General-Alerts-evolution-Top-5-agents" vis-id="\'Wazuh-App-Overview-General-Alerts-evolution-Top-5-agents\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="35" class="wz-md-card">\n            <md-card-content class="wazuh-column" ng-show="octrl.wzMonitoringEnabled" >\n                <span class="wz-headline-title">Agents status</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-General-Agents-status" vis-id="\'Wazuh-App-Overview-General-Agents-status\'"></kbn-vis>\n            </md-card-content>\n            <md-card-content class="wazuh-column" ng-show="!octrl.wzMonitoringEnabled">\n                <span class="wz-headline-title">Agents status</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row">\n                    <div flex layout="column">\n                        <div layout="row" class="wz-padding-top-10"></div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50" class="wz-text-bold">Total</p>\n                            <p class="wz-text-right color-grey wz-text-bold">{{octrl.agentsCountTotal}}</p>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10"></div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50">Active</p>\n                            <p class="wz-text-right color-grey">{{octrl.agentsCountActive}}</p>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50">Disconnected</p>\n                            <p class="wz-text-right color-grey">{{octrl.agentsCountDisconnected}}</p>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50">Never connected</p>\n                            <p class="wz-text-right color-grey">{{octrl.agentsCountNeverConnected}}</p>\n                        </div>\n                        <div layout="row" class="wz-padding-top-10">\n                            <p flex="50">Agents coverage</p>\n                            <p class="wz-text-right color-grey">{{(octrl.agentsCoverity | number:2)}}%</p>\n                        </div>\n                    </div>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-570">\n        <md-card flex="60" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-General-Alerts-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="40" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Groups summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-General-Groups-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'fim\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}">\n\n    <div layout="row" class="height-225">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 agents with deleted files</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-FIM-deleted" vis-id="\'Wazuh-App-Overview-FIM-deleted\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 agents with new files</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-FIM-added" vis-id="\'Wazuh-App-Overview-FIM-added\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 agents with modified files</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-FIM-modified" vis-id="\'Wazuh-App-Overview-FIM-modified\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" class="height-300">\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-FIM-Top-5-agents-pie" vis-id="\'Wazuh-App-Overview-FIM-Top-5-agents-pie\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Events summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-FIM-Events-summary" vis-id="\'Wazuh-App-Overview-FIM-Events-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="height-300">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 rules</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-FIM-Top-5-rules\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Whodata usage</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-FIM-Whodata-usage" vis-id="\'Wazuh-App-Overview-FIM-Whodata-usage\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 users</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-FIM-top-agents-user\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n</md-content><md-content flex layout="column" ng-if="octrl.tab === \'pm\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <div layout="row" layout-align="center stretch" class="height-290">\n        <md-card flex="50" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Events over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PM-Events-over-time" vis-id="\'Wazuh-App-Overview-PM-Events-over-time\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 5 CIS Requirements</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PM-Top-5-CIS-requirements" vis-id="\'Wazuh-App-Overview-PM-Top-5-CIS-requirements\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 5 PCI DSS Requirements</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PM-Top-5-PCI-DSS-requirements" vis-id="\'Wazuh-App-Overview-PM-Top-5-PCI-DSS-requirements\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-240">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Events per agent evolution</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PM-Events-per-agent-evolution" vis-id="\'Wazuh-App-Overview-PM-Events-per-agent-evolution\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-PM-Alerts-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'vuls\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}"\n    layout-align="start">\n\n    <div layout="row">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Critical severity alerts: <span class="wz-text-bold" ng-bind="octrl.vulnCritical()"></span></div>\n                <div class="wz-text-truncatable" flex>High severity alerts: <span class="wz-text-bold" ng-bind="octrl.vulnHigh()"></span></div>\n                <div class="wz-text-truncatable" flex>Medium severity alerts: <span class="wz-text-bold" ng-bind="octrl.vulnMedium()"></span></div>\n                <div class="wz-text-truncatable" flex>Low severity alerts: <span class="wz-text-bold" ng-bind="octrl.vulnLow()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-App-Overview-vulnerability-Metric-Critical-severity\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-vulnerability-Metric-High-severity\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-vulnerability-Metric-Medium-severity\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-vulnerability-Metric-Low-severity\'"></kbn-vis>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-270">\n        <md-card flex="30" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Most affected agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-vulnerability-Most-affected-agents" vis-id="\'Wazuh-App-Overview-vulnerability-Most-affected-agents\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts evolution over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-vulnerability-Alerts-evolution-over-time" vis-id="\'Wazuh-App-Overview-vulnerability-Alerts-evolution-over-time\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-270">\n        <md-card flex="30" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Severity distribution</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-vulnerability-Vulnerability-severity-distribution" vis-id="\'Wazuh-App-Overview-vulnerability-Vulnerability-severity-distribution\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="30" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Commonly affected packages</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-vulnerability-Commonly-affected-packages" vis-id="\'Wazuh-App-Overview-vulnerability-Commonly-affected-packages\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Most common CVEs</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-vulnerability-Most-common-CVEs" vis-id="\'Wazuh-App-Overview-vulnerability-Most-common-CVEs\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alert summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-vulnerability-Alert-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content><md-content flex layout="column" ng-if="octrl.tab === \'oscap\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <div layout="row">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Last score: <span class="wz-text-bold" ng-bind="octrl.scapLastScore()"></span></div>\n                <div class="wz-text-truncatable" flex>Highest score: <span class="wz-text-bold" ng-bind="octrl.scapHighestScore()"></span></div>\n                <div class="wz-text-truncatable" flex>Lowest score: <span class="wz-text-bold" ng-bind="octrl.scapLowestScore()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-App-Overview-OSCAP-Last-score\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-OSCAP-Highest-score\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-OSCAP-Lowest-score\'"></kbn-vis>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-215">\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 5 Agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-OSCAP-Agents" vis-id="\'Wazuh-App-Overview-OSCAP-Agents\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 5 Profiles</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-OSCAP-Profiles" vis-id="\'Wazuh-App-Overview-OSCAP-Profiles\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 Content</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-OSCAP-Content" vis-id="\'Wazuh-App-Overview-OSCAP-Content\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 5 Severity</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-OSCAP-Severity" vis-id="\'Wazuh-App-Overview-OSCAP-Severity\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="start stretch" class="height-240">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 5 Agents - Severity high</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-OSCAP-Top-5-agents-Severity-high" vis-id="\'Wazuh-App-Overview-OSCAP-Top-5-agents-Severity-high\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-320">\n        <md-card flex="50" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 10 - Alerts</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-OSCAP-Top-10-alerts\'" id="Wazuh-App-Overview-OSCAP-Top-10-alerts"></kbn-vis>\n            </md-card-content>\n        </md-card>\n\n        <md-card flex="50" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 10 - High risk alerts</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-OSCAP-Top-10-high-risk-alerts\'" id="Wazuh-App-Overview-OSCAP-Top-10-high-risk-alerts"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-OSCAP-Last-alerts\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'audit\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="space-around">\n\n    <div layout="row">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>New files: <span class="wz-text-bold" ng-bind="octrl.auditNewFiles()"></span></div>\n                <div class="wz-text-truncatable" flex>Read files: <span class="wz-text-bold" ng-bind="octrl.auditReadFiles()"></span></div>\n                <div class="wz-text-truncatable" flex>Modified files: <span class="wz-text-bold" ng-bind="octrl.auditModifiedFiles()"></span></div>\n                <div class="wz-text-truncatable" flex>Removed files: <span class="wz-text-bold" ng-bind="octrl.auditRemovedFiles()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-App-Overview-Audit-New-files\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-Audit-Read-files\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-Audit-Modified-files\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-Audit-Removed-files\'"></kbn-vis>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-200">\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Groups</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Audit-Groups" vis-id="\'Wazuh-App-Overview-Audit-Groups\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Audit-Agents" vis-id="\'Wazuh-App-Overview-Audit-Agents\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Directories</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Audit-Directories" vis-id="\'Wazuh-App-Overview-Audit-Directories\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="25" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Files</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Audit-Files" vis-id="\'Wazuh-App-Overview-Audit-Files\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-310">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Alerts over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Audit-Alerts-over-time" vis-id="\'Wazuh-App-Overview-Audit-Alerts-over-time\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-448">\n        <div flex="20" layout="column" layout-align="center stretch">\n            <md-card flex="50" class="wz-md-card">\n                <md-card-content class="wazuh-column" >\n                    <span class="wz-headline-title">File read access</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Overview-Audit-File-read-access" vis-id="\'Wazuh-App-Overview-Audit-File-read-access\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="50" class="wz-md-card">\n                <md-card-content class="wazuh-column" >\n                    <span class="wz-headline-title">File write access</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Overview-Audit-File-write-access" vis-id="\'Wazuh-App-Overview-Audit-File-write-access\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div flex="60" layout="column" layout-align="center stretch">\n            <md-card flex class="wz-md-card">\n                <md-card-content class="wazuh-column" >\n                    <span class="wz-headline-title">Commands</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Overview-Audit-Commands" vis-id="\'Wazuh-App-Overview-Audit-Commands\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n\n        <div flex="20" layout="column" layout-align="center stretch">\n            <md-card flex="50" class="wz-md-card">\n                <md-card-content class="wazuh-column" >\n                    <span class="wz-headline-title">Created files</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Overview-Audit-Files-created" vis-id="\'Wazuh-App-Overview-Audit-Files-created\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n            <md-card flex="50" class="wz-md-card">\n                <md-card-content class="wazuh-column" >\n                    <span class="wz-headline-title">Removed files</span>\n                    <md-divider class="wz-margin-top-10"></md-divider>\n                    <kbn-vis id="Wazuh-App-Overview-Audit-Files-deleted" vis-id="\'Wazuh-App-Overview-Audit-Files-deleted\'"></kbn-vis>\n                </md-card-content>\n            </md-card>\n        </div>\n    </div>\n\n    <div flex layout="row" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-Audit-Last-alerts\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'ciscat\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <!-- Metric bar section -->\n    <div layout="row" layout-align="start center">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Last not checked: <span class="wz-text-bold" ng-bind="octrl.ciscatScanNotChecked()"></span></div>\n                <div class="wz-text-truncatable" flex>Last pass: <span class="wz-text-bold" ng-bind="octrl.ciscatScanPass()"></span></div>\n                <div class="wz-text-truncatable" flex>Last scan score: <span class="wz-text-bold" ng-bind="octrl.ciscatScanScore()"></span></div>\n                <div class="wz-text-truncatable">Last scan date: <span class="wz-text-bold" ng-bind="octrl.ciscatScanTimestamp()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End metric bar section -->\n\n    <!-- Metric bar section -->\n    <div layout="row" layout-align="start center">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Last errors: <span class="wz-text-bold" ng-bind="ciscatScanError()"></span></div>\n                <div class="wz-text-truncatable" flex>Last fails: <span class="wz-text-bold" ng-bind="ciscatScanFail()"></span></div>\n                <div class="wz-text-truncatable" flex>Last unknown: <span class="wz-text-bold" ng-bind="ciscatScanUnknown()"></span></div>\n                <div class="wz-text-truncatable">Last scan benchmark: <span class="wz-text-bold" ng-bind="ciscatScanBenchmark()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End metric bar section -->\n\n    <!-- Hidden metric visualizations section -->\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-last-scan-error\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-last-scan-fail\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-last-scan-not-checked\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-last-scan-pass\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-last-scan-score\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-last-scan-timestamp\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-last-scan-benchmark\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-last-scan-unknown\'"></kbn-vis>\n    </div>\n    <!-- End hidden metric visualizations section -->\n\n    <!-- Top groups and result evolution section -->\n    <div layout="row" layout-align="start stretch" class="height-320">\n        <md-card flex="60" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 5 CIS-CAT groups</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-top-5-groups\'" id="Wazuh-app-Overview-CISCAT-top-5-groups"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Scan result evolution</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-scan-result-evolution\'" id="Wazuh-app-Overview-CISCAT-scan-result-evolution"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End top groups and result evolution section -->\n\n    <!-- Alerts summary table section -->\n    <div layout="row" layout-align="start stretch" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-app-Overview-CISCAT-alerts-summary\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End alerts summary table section -->\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'pci\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <div layout="row" layout-align="center stretch">\n        <md-card flex class="wz-md-card">\n            <md-tabs md-selected="selectedPciIndex" class="wz-md-tab" md-border-bottom md-dynamic-height id="pciReq_tab">\n                <md-tab ng-repeat="tab in octrl.pciTabs" ng-disabled="tab.disabled" label="{{tab.title}}">\n                    <div class="md-padding">\n                        <span class="wz-headline-title">PCI DSS Requirement: {{tab.title}}</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <div layout="row" class="wz-padding-top-10 wz-line-height">\n                            <div ng-bind-html="tab.content"></div>\n                        </div>\n                    </div>\n                </md-tab>\n            </md-tabs>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-530">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Last alerts</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PCI-DSS-Requirements-heatmap" vis-id="\'Wazuh-App-Overview-PCI-DSS-Requirements-heatmap\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-255">\n        <md-card flex="70" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">PCI Requirements</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PCI-DSS-requirements" vis-id="\'Wazuh-App-Overview-PCI-DSS-requirements\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="30" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Groups</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PCI-DSS-Groups" vis-id="\'Wazuh-App-Overview-PCI-DSS-Groups\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-255">\n        <md-card flex="30" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PCI-DSS-Agents" vis-id="\'Wazuh-App-Overview-PCI-DSS-Agents\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="70" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Requirements by agent</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-PCI-DSS-Requirements-by-agent" vis-id="\'Wazuh-App-Overview-PCI-DSS-Requirements-by-agent\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-PCI-DSS-Last-alerts\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'gdpr\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <div layout="row" layout-align="center stretch" ng-show="octrl.gdprTabs.length">\n        <md-card flex class="wz-md-card">\n            <md-tabs md-selected="selectedGdprIndex" class="wz-md-tab" md-border-bottom md-dynamic-height id="gdprReq_tab">\n                <md-tab ng-repeat="tab in octrl.gdprTabs" ng-disabled="tab.disabled" label="{{tab.title}}">\n                    <div class="md-padding">\n                        <span class="wz-headline-title">GDPR Requirement: {{tab.title}}</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <div layout="row" class="wz-padding-top-10 wz-line-height">\n                            <div ng-bind-html="tab.content"></div>\n                        </div>\n                    </div>\n                </md-tab>\n            </md-tabs>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-530">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Last alerts</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-GDPR-Requirements-heatmap" vis-id="\'Wazuh-App-Overview-GDPR-Requirements-heatmap\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-255">\n        <md-card flex="30" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Groups</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-GDPR-Groups" vis-id="\'Wazuh-App-Overview-GDPR-Groups\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="70" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">GDPR Requirements</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-GDPR-requirements" vis-id="\'Wazuh-App-Overview-GDPR-requirements\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-255">\n        <md-card flex="70" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Requirements by agent</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-GDPR-Requirements-by-agent" vis-id="\'Wazuh-App-Overview-GDPR-Requirements-by-agent\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="30" class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-GDPR-Agents" vis-id="\'Wazuh-App-Overview-GDPR-Agents\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" layout-align="center stretch" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts summary</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-GDPR-Last-alerts\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'aws\' && octrl.tabView === \'panels\'" layout-align="start">\n    <div layout="column" layout-align="center center" ng-if="octrl.tab === \'aws\'" ng-show="resultState === \'ready\' && octrl.tabView === \'panels\' && !rendered">\n        <div class="percentage"><i class="fa fa-fw fa-spin fa-spinner" aria-hidden="true"></i></div>\n        <div class="percentage">{{loadingStatus}}</div>\n    </div>\n</md-content>\n\n<md-content flex layout="column" ng-if="octrl.tab === \'aws\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n    <div layout="row" class="height-250">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Sources</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-AWS-Top-sources" vis-id="\'Wazuh-App-Overview-AWS-Top-sources\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Accounts</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-AWS-Top-accounts" vis-id="\'Wazuh-App-Overview-AWS-Top-accounts\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">S3 buckets</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-AWS-Top-buckets" vis-id="\'Wazuh-App-Overview-AWS-Top-buckets\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Regions</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-AWS-Top-regions" vis-id="\'Wazuh-App-Overview-AWS-Top-regions\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    \n    <div layout="row" class="height-300">\n        <md-card flex="50" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Events by source over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-AWS-Events-by-source" vis-id="\'Wazuh-App-Overview-AWS-Events-by-source\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex="50" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Events by S3 bucket over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id=" Wazuh-App-Overview-AWS-Events-by-s3-bucket" vis-id="\'Wazuh-App-Overview-AWS-Events-by-s3-bucket\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="height-310">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 buckets</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-AWS-Top-5-buckets\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 rules</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-AWS-Top-5-rules\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'virustotal\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n\n    <div layout="row">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Total malicious: <span class="wz-text-bold" ng-bind="octrl.virusMalicious()"></span></div>\n                <div class="wz-text-truncatable" flex>Total positives: <span class="wz-text-bold" ng-bind="octrl.virusPositives()"></span></div>\n                <div class="wz-text-truncatable" flex>Total: <span class="wz-text-bold" ng-bind="octrl.virusTotal()"></span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-App-Overview-Virustotal-Total-Malicious\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-Virustotal-Total-Positives\'"></kbn-vis>\n        <kbn-vis vis-id="\'Wazuh-App-Overview-Virustotal-Total\'"></kbn-vis>\n    </div>\n\n    <div layout="row" class="height-360">\n        <div flex layout="column">\n            <div flex layout="row">\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column" >\n                        <span class="wz-headline-title">Unique malicious files per agent</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Overview-Virustotal-Malicious-Per-Agent" vis-id="\'Wazuh-App-Overview-Virustotal-Malicious-Per-Agent\'"></kbn-vis>\n                    </md-card-content>\n                </md-card>\n            </div>\n        </div>\n        <div flex layout="column">\n            <div flex layout="row">\n                <md-card flex class="wz-md-card">\n                    <md-card-content class="wazuh-column" >\n                        <span class="wz-headline-title">Last scanned files</span>\n                        <md-divider class="wz-margin-top-10"></md-divider>\n                        <kbn-vis id="Wazuh-App-Overview-Virustotal-Last-Files-Pie" vis-id="\'Wazuh-App-Overview-Virustotal-Last-Files-Pie\'"></kbn-vis>\n                    </md-card-content>\n                </md-card>\n            </div>\n        </div>\n    </div>\n    <div layout="row" class="height-550">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Top 10 agents with positive scans</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Virustotal-Positives-Heatmap" vis-id="\'Wazuh-App-Overview-Virustotal-Positives-Heatmap\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" class="height-250">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column" >\n                <span class="wz-headline-title">Malicious files alerts evolution</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Virustotal-Malicious-Evolution" vis-id="\'Wazuh-App-Overview-Virustotal-Malicious-Evolution\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n    <div layout="row" class="height-570">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Last files</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis vis-id="\'Wazuh-App-Overview-Virustotal-Files-Table\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n</md-content>\n<md-content flex layout="column" ng-if="octrl.tab === \'osquery\' && octrl.tabView === \'panels\'" ng-class="{\'no-opacity\': resultState !== \'ready\' || !rendered}" layout-align="start">\n    <div layout="row">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>Agents reporting Osquery events: <span class="wz-text-bold" ng-bind="octrl.osqueryAgentsReporting()"></span> of <span class="wz-text-bold">{{ agentsCountTotal }}</span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div class="wz-no-display">\n        <kbn-vis vis-id="\'Wazuh-App-Overview-Osquery-Agents-reporting\'"></kbn-vis>\n    </div>\n\n    <div layout="row" class="height-300">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts over time</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Osquery-Alerts-over-time" vis-id="\'Wazuh-App-Overview-Osquery-Alerts-over-time\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="height-300">\n        <md-card flex="30" class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Most common packs</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Osquery-Most-common-packs" vis-id="\'Wazuh-App-Overview-Osquery-Most-common-packs\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Top 5 rules</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Osquery-Top-5-rules" vis-id="\'Wazuh-App-Overview-Osquery-Top-5-rules\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n\n    <div layout="row" class="height-300">\n        <md-card flex class="wz-md-card">\n            <md-card-content class="wazuh-column">\n                <span class="wz-headline-title">Alerts evolution - Top 5 agents</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <kbn-vis id="Wazuh-App-Overview-Osquery-Alerts-evolution-Top-5-agents" vis-id="\'Wazuh-App-Overview-Osquery-Alerts-evolution-Top-5-agents\'"></kbn-vis>\n            </md-card-content>\n        </md-card>\n    </div>\n</md-content></div>';
			return pug_html
		}
		module.exports = template
	},
	5311: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column">\n\n    <wz-menu ng-init="menuNavItem = \'discover\'"></wz-menu>\n<discover-app-w class="app-container">\n  <!-- Local nav. -->\n  <wz-kbn-top-nav name="discover" config="topNavMenu">\n    <!-- Transcluded elements. -->\n    <div data-transclude-slots>\n      <!-- Breadcrumbs. -->\n      <div data-transclude-slot="topLeftCorner" class="kuiLocalBreadcrumbs">\n        <h1 tabindex="0" id="kui_local_breadcrumb" class="kuiLocalBreadcrumb">\n          <span ng-show="opts.savedSearch.id" class="kuiLocalBreadcrumb__emphasis">\n            <span data-test-subj="discoverCurrentQuery" ng-bind="opts.savedSearch.lastSavedTitle"></span>\n            <span\n              id="reload_saved_search"\n              aria-label="Reload Saved Search"\n              tooltip="Reload Saved Search"\n              ng-click="resetQuery()"\n              kbn-accessible-click\n              class="kuiIcon fa-undo small"\n            ></span>&nbsp;\n          </span>\n          <span data-test-subj="discoverQueryHits" class="kuiLocalBreadcrumb__emphasis">{{(hits || 0) | number:0}}</span>\n          <ng-pluralize count="hits" when="{\'1\':\'hit\', \'other\':\'hits\'}"></ng-pluralize>\n        </h1>\n      </div>\n\n      <!-- Search. -->\n      <div data-transclude-slot="bottomRow" class="fullWidth">\n        <query-bar\n          query="state.query"\n          on-submit="updateQueryAndFetch"\n          app-name="\'discover\'"\n          index-patterns="[indexPattern]"\n        ></query-bar>\n      </div>\n    </div>\n  </wz-kbn-top-nav>\n\n  <main class="container-fluid">\n    <div class="row">\n      <filter-bar\n        state="state"\n        index-patterns="[indexPattern]"\n      ></filter-bar>\n    </div>\n    <div class="row">\n      <div class="col-md-2 sidebar-container collapsible-sidebar" id="discover-sidebar">\n        <disc-field-chooser\n          class="dscFieldChooser"\n          columns="state.columns"\n          hits="rows"\n          field-counts="fieldCounts"\n          index-pattern="searchSource.getField(\'index\')"\n          index-pattern-list="opts.indexPatternList"\n          state="state"\n          on-add-field="addColumn"\n          on-add-filter="filterQuery"\n          on-remove-field="removeColumn"\n        >\n        </disc-field-chooser>\n      </div>\n\n      <div class="dscWrapper col-md-10">\n        <div class="dscWrapper__content">\n          <div layout="row" class="wz-margin-top-10" ng-if="isUnsupportedIndexPattern">\n            <div flex class="euiCallOut euiCallOut--warning" data-test-subj="discoverNoResults">\n                <div class="euiCallOutHeader">\n                    <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path></defs><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use></svg>\n                    <span class="euiCallOutHeader__title">Unsupported index pattern.</span>\n                </div>\n            </div>\n          </div>\n          <div layout="row" class="wz-margin-top-10" ng-if="resultState === \'none\'">\n            <div flex class="euiCallOut euiCallOut--warning" data-test-subj="discoverNoResults">\n                <div class="euiCallOutHeader">\n                    <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16"><defs><path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path></defs><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use></svg>\n                    <span class="euiCallOutHeader__title">No results match your search criteria</span>\n                </div>\n            </div>\n          </div>\n\n          <!-- loading -->\n          <div ng-show="resultState === \'loading\'">\n            <discover-fetch-error\n              ng-show="fetchError"\n              fetch-error="fetchError"\n            ></discover-fetch-error>\n\n            <div\n              ng-hide="fetchError"\n              class="dscOverlay"\n            >\n              <div class="euiTitle" >\n                <h2>Searching</h2>\n              </div>\n              <div class="euiSpacer euiSpacer--m"></div>\n              <div ng-show="fetchStatus">{{fetchStatus.complete}}/{{fetchStatus.total}}</div>\n            </div>\n          </div>\n\n          <!-- result -->\n          <div class="dscResults" ng-show="resultState === \'ready\'">\n            <button\n              class="kuiButton kuiButton--basic kuiButton--iconText dscSkipButton"\n              ng-click="showAllRows(); scrollToBottom()"\n            >\n              <span class="kuiButton__inner">\n                <span aria-hidden="true" class="kuiButton__icon kuiIcon fa-chevron-down"></span>\n                <span>Skip to bottom</span>\n              </span>\n            </button>\n\n            <section aria-label="Histogram of found documents" class="dscTimechart" ng-if="opts.timefield">\n              <header class="dscTimechart__header">\n                <div class="small">\n                  <span tooltip="To change the time, click the clock icon in the navigation bar">{{timeRange.from | moment}} - {{timeRange.to | moment}}</span>\n\n                  &mdash;\n\n                  <span class="form-inline">\n                    <select\n                      class="dscResults__interval form-control"\n                      ng-model="state.interval"\n                      ng-options="interval.val as interval.display for interval in intervalOptions | filter: intervalEnabled"\n                      ng-blur="toggleInterval()"\n                      data-test-subj="discoverIntervalSelect"\n                      >\n                    </select>\n                    <span ng-if="bucketInterval.scaled">\n                      <icon-tip\n                        content="getBucketIntervalToolTipText()"\n                        position="\'top\'"\n                      ></icon-tip>\n                      Scaled to {{ bucketInterval.description }}\n                    </span>\n                  </span>\n                </div>\n\n              </header>\n\n              <div id="discoverHistogram"\n                 ng-if="vis && rows.length !== 0"\n                 style="display: flex; height: 200px"\n                >\n              </div>\n            </section>\n\n            <section class="dscTable" fixed-scroll aria-label="Documents">\n              <doc-table\n                hits="rows"\n                index-pattern="indexPattern"\n                sorting="state.sort"\n                columns="state.columns"\n                infinite-scroll="true"\n                filter="filterQuery"\n                filters="state.filters"\n                data-shared-item\n                data-title="{{opts.savedSearch.lastSavedTitle}}"\n                data-description="{{opts.savedSearch.description}}"\n                minimum-visible-rows="minimumVisibleRows"\n                render-complete\n                on-add-column="addColumn"\n                on-change-sort-order="setSortOrder"\n                on-move-column="moveColumn"\n                on-remove-column="removeColumn"\n              ></doc-table>\n\n              <a tabindex="0" id="discoverBottomMarker"></a>\n\n              <div ng-if="rows.length == opts.sampleSize" class="dscTable__footer">\n                These are the first {{opts.sampleSize}} documents matching\n                your search, refine your search to see others.\n                <a kbn-accessible-click ng-click="scrollToTop()">Back to top.</a>\n              </div>\n            </section>\n          </div>\n        </div>\n      </div>\n    </div>\n  </main>\n</discover-app-w></div>';
			return pug_html
		}
		module.exports = template
	},
	5312: function (module, exports, __webpack_require__)
	{
		__webpack_require__(47);

		function template(locals)
		{
			var pug_html = "";
			pug_html += '<div flex="auto" layout="column" ng-cloak ng-controller="settingsController as ctrl">\n\n    <!-- Top navbar section -->\n    <wz-menu ng-init="menuNavItem = \'settings\'"></wz-menu>\n    <!-- End top navbar section -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="ctrl.load">\n        <div></div>\n    </div>\n    <!-- End loading ring -->\n\n    <!-- Navigation section -->\n    <div layout="row" layout-align="start center" ng-if="!ctrl.load">\n        <!-- Breadcrumbs -->\n        <div layout="row" layout-padding>\n            <!-- Always show a functional breadcrumb -->\n            <div>\n                <span>Settings</span>\n                <span> / </span>\n                <span>{{ ctrl.tabNames[ctrl.tab] }}</span>\n            </div>\n        </div>\n        <!-- End breadcrumbs -->\n    </div>\n    <!-- End navigation section -->\n\n    <!-- Navigation bar -->\n    <md-nav-bar\n        ng-if="!ctrl.load"\n        class="wz-nav-bar"\n        md-selected-nav-item="ctrl.tab"\n        nav-bar-aria-label="Settings navigation links">\n        <md-nav-item class="wz-nav-item" md-nav-click="ctrl.switchTab(\'api\')" name="api">API</md-nav-item>\n        <md-nav-item class="wz-nav-item" ng-if="ctrl.apiEntries && ctrl.apiEntries.length" md-nav-click="ctrl.switchTab(\'extensions\')" name="extensions">Extensions</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="ctrl.switchTab(\'pattern\')" name="pattern">Pattern</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="ctrl.switchTab(\'configuration\')" name="configuration">Configuration</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="ctrl.switchTab(\'logs\'); ctrl.refreshLogs()" name="logs">Logs</md-nav-item>\n        <md-nav-item class="wz-nav-item" md-nav-click="ctrl.switchTab(\'about\')" name="about">About</md-nav-item>\n    </md-nav-bar>\n    <!-- End navigation bar -->\n<div layout="column" layout-align="start stretch" ng-if="ctrl.tab === \'api\' && !ctrl.load && ctrl.apiEntries.length === 0">\n\n    <!-- About card section -->\n    <div layout="row" layout-align="start start">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">Welcome to the threatanalytics app </span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column" class="wz-padding-top-10">\n                    <div layout-padding class="wz-line-height">\n                        Threat-analytics plugin provides management and monitoring capabilities, giving users control over the Wazuh infrastructure. Using this plugin you can monitor your agents status and configuration, query and visualize your alert data and monitor manager rules and configuration. Additionally this user interface provides a number of extensions listed below.\n                    </div>\n                    <div layout-padding layout="row">\n                        <div layout="column">\n                            <div>\n                                Threat-Analytics plugin main extensions:\n                            </div>\n                            <div layout-padding>\n                                <ul class="wz-circle-list md-body-1">\n                                    <li><strong>Linux Audit system integration</strong></li>\n                                    <li><strong>PCI DSS regulatory compliance</strong></li>\n                                    <li><strong>GDPR regulatory compliance</strong></li>\n                                    <li><strong>OpenSCAP configuration and vulnerability assessment</strong></li>\n                                    <li><strong>CIS-CAT configuration assessment scanner</strong></li>\n                                    <li><strong>Amazon Web Services (AWS) integration</strong></li>\n                                    <li><strong>VirusTotal threat intelligence</strong></li>\n                                </ul>\n                            </div>\n                        </div>\n                        <div layout="column">\n                            <div>\n                                Threat-Analytics plugin main sections:\n                            </div>\n                            <div layout-padding>\n                                <ul class="wz-circle-list md-body-1">\n                                    <li><strong>Manager status and configuration monitoring</strong></li>\n                                    <li><strong>Ruleset management and agent groups</strong></li>\n                                    <li><strong>Agent configuration management</strong></li>\n                                    <li><strong>Security Information Management</strong></li>\n                                    <li><strong>Auditing and Policy monitoring</strong></li>\n                                    <li><strong>Threat Detection and Response</strong></li>\n                                    <li><strong>Regulatory Compliance</strong></li>\n                                </ul>\n                            </div>\n                        </div>\n                    </div>\n                    <div layout-padding>\n                        Enjoy your threat-analytics experience and please don\'t hesitate to give us your feedback.\n                    </div>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <!--md-button target="_blank" href="https://groups.google.com/forum/#!forum/wazuh" class="wz-text-link cursor-pointer small" aria-label="Open Wazuh mailing list"--!>\n                    <!--i class="fa fa-fw fa-envelope" aria-hidden="true"></i> 1_Mailing list\n                </md-button--!>\n                <!--md-button target="_blank" href="https://github.com/wazuh/wazuh-kibana-app" class="wz-text-link cursor-pointer small" aria-label="Open thratanalytics app repository"--!>\n                    <!--i class="fa fa-fw fa-github" aria-hidden="true"></i--!> <!--threat-analytics app repository\n--!>                </md-button--!>\n                <!--md-button target="_blank" href="https://github.com/wazuh/wazuh" class="wz-text-link cursor-pointer small" aria-label="Open Wazuh core repository">\n                    <i class="fa fa-fw fa-github" aria-hidden="true"></i> Wazuh core repository\n                </md-button--!>\n            </md-card-actions>\n        </md-card>\n    </div>\n    <!-- End about card section -->\n\n</div>\n<div layout="column" layout-align="start stretch" ng-if="!ctrl.load && ctrl.apiIsDown">\n    <!-- API down card section -->\n    <div layout="row" layout-align="start start">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <i class="fa fa-fw fa-exclamation-triangle" aria-hidden="true"></i> <span class="wz-headline-title">The Wazuh API seems to be down</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column" class="wz-padding-top-10">\n                    <div layout-padding>\n                        Please, check if the Wazuh API is running with one of the commands below:\n                    </div>\n                    <div layout="row">\n                        <div layout="column">\n                            <div layout-padding>\n                                For <strong>systemd</strong>:\n                            </div>\n                            <div layout-padding>\n                                <pre class="json-beautifier"><code># systemctl status wazuh-api</code></pre>\n                            </div>\n                        </div>\n                        <div layout="column">\n                            <div layout-padding>\n                                For <strong>SysV Init</strong>:\n                            </div>\n                            <div layout-padding>\n                                <pre class="json-beautifier"><code># service wazuh-api status</code></pre>\n                            </div>\n                        </div>\n                    </div>\n                    <div layout-padding>\n                        If the API is <strong>active (running)</strong>, please check the credentials below.\n                    </div>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End API down card section -->\n</div>\n<div layout="column" layout-align="start stretch" ng-if="ctrl.tab === \'api\' && !ctrl.load">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-tasks" aria-hidden="true"></i> API configuration</span>\n        <span class="md-subheader">Use Threat-Analytics API settings to connect the plugin to your Threat-Analytics manager or cluster</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- API configuration card section -->\n    <div layout="row" layout-align="start start">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <!-- API entries headings section -->\n                <div layout="row" class="wz-padding-bottom-14">\n                    <p flex="15" class="wz-text-bold">Cluster</p>\n                    <p flex="20" class="wz-text-bold">Manager</p>\n                    <p flex="15" class="wz-text-bold">API URL</p>\n                    <p flex="15" class="wz-text-bold">API Port</p>\n                    <p flex="15" class="wz-text-bold">User</p>\n                    <p flex="20" class="wz-text-bold">Actions</p>\n                </div>\n                <!-- End API entries headings section -->\n\n                <!-- API entries list section -->\n                <div ng-repeat="entry in ctrl.apiEntries">\n                    <!-- API entry -->\n                    <div layout="row" layout-align="space-between center" class="wz-padding-top-10 wz-padding-bottom-14">\n                        <p flex="15">\n                            <i ng-show="(entry._id === ctrl.currentDefault)" tooltip="This is the default Manager" tooltip-placement="right" class="fa fa-star wz-color-orange" aria-hidden="true"></i> {{entry._source.cluster_info.cluster}}</p>\n                        <p flex="20">{{entry._source.cluster_info.manager}}</p>\n                        <p flex="15">{{entry._source.url}}</p>\n                        <p flex="15">{{entry._source.api_port}}</p>\n                        <p flex="15">{{entry._source.api_user}}</p>\n                        <p flex="20">\n                            <i ng-click="ctrl.setDefault(entry)" tooltip="Set as default Manager" class="fa fa-star font-size-18 cursor-pointer" aria-hidden="true"></i>\n                            <i ng-click="ctrl.removeManager(entry)" tooltip="Remove manager" class="fa fa-trash wz-margin-left-7 cursor-pointer" aria-hidden="true"></i>\n                            <i ng-click="ctrl.checkManager(entry)" tooltip="Check connection" class="fa fa-refresh wz-margin-left-7 cursor-pointer" aria-hidden="true"></i>\n                            <i ng-click="ctrl.toggleEditor(entry)" tooltip="Edit" class="fa fa-pencil wz-margin-left-7 cursor-pointer" aria-hidden="true"></i>\n                        </p>\n                    </div>\n                    <!-- End API entry -->\n                    <!-- Edit API form -->\n                    <div layout="row" layout-align="space-between center" ng-if="ctrl.showEditForm[entry._id] && ctrl.isEditing">\n                        <form flex ng-submit="ctrl.updateSettings(entry)" layout="column" layout-align="start stretch" class="margin-top-30">\n                            <!-- Input section -->\n                            <md-input-container class="wz-input-container">\n                                <label>Username</label>\n                                <input ng-model="ctrl.formUpdate.user" ng-init="formUpdate.user=entry._source.api_user" type="text" placeholder="" aria-label="username"\n                                    required/>\n                            </md-input-container>\n                            <md-input-container class="wz-input-container">\n                                <label>Password</label>\n                                <input ng-model="ctrl.formUpdate.password" type="password" placeholder="" aria-label="password" required/>\n                            </md-input-container>\n                            <md-input-container class="wz-input-container">\n                                <label>URL</label>\n                                <input ng-model="ctrl.formUpdate.url" ng-init="formUpdate.url=entry._source.url" type="url" placeholder="http(s)://" aria-label="full url"\n                                    required/>\n                            </md-input-container>\n                            <md-input-container class="wz-input-container">\n                                <label>Port</label>\n                                <input ng-model="ctrl.formUpdate.port" ng-init="formUpdate.port=entry._source.api_port" type="text" placeholder="" aria-label="port"\n                                    required/>\n                            </md-input-container>\n                            <!-- Button and errors section -->\n                            <div layout="row" layout-align="center center" ng-if="ctrl.messageError">\n                                <p class="color-f9">{{ctrl.messageErrorUpdate}}</p>\n                            </div>\n                            <div layout="row" layout-align="center center">\n                                <md-button type="submit" class="wz-button md-raised md-primary" aria-label="Update API button">\n                                    <i class="fa fa-pencil fa-fw" aria-hidden="true"></i> Update Wazuh API entry\n                                </md-button>\n                            </div>\n                        </form>\n                    </div>\n                    <!-- End edit API form -->\n                </div>\n                <!-- End API entries list section -->\n\n                <!-- Add API button section -->\n                <div ng-show="!ctrl.isUpdating()" layout="row" layout-align="center center" class="wz-padding-top-10">\n                    <md-button ng-click="ctrl.switch()" class="wz-button md-raised md-primary"\n                        aria-label="Add new API button">\n                        <i class="fa fa-plus-circle fa-fw" aria-hidden="true"></i> Add new Threat-Analytics API entry\n                    </md-button>\n                </div>\n                <!-- End add API button section -->\n\n                <!-- Add API section-->\n                <div layout="row" ng-show="!currentAPI || (ctrl.addManagerContainer && !ctrl.isEditing)">\n                    <!-- Add API form -->\n                    <form flex ng-submit="ctrl.saveSettings()" layout="column" layout-align="start stretch"\n                        class="margin-top-30">\n                        <!-- Input section -->\n                        <md-input-container class="wz-input-container">\n                            <label>Username</label>\n                            <input ng-model="ctrl.formData.user" type="text" placeholder="" aria-label="username" required/>\n                        </md-input-container>\n                        <md-input-container class="wz-input-container">\n                            <label>Password</label>\n                            <input ng-model="ctrl.formData.password" type="password" placeholder="" aria-label="password" required/>\n                        </md-input-container>\n                        <md-input-container class="wz-input-container">\n                            <label>URL</label>\n                            <input ng-model="ctrl.formData.url" type="url" placeholder="http(s)://" aria-label="full url" required/>\n                        </md-input-container>\n                        <md-input-container class="wz-input-container">\n                            <label>Port</label>\n                            <input ng-model="ctrl.formData.port" type="text" placeholder="" aria-label="port" required/>\n                        </md-input-container>\n                        <!-- Button and errors section -->\n                        <div layout="row" layout-align="center center" ng-if="ctrl.messageError">\n                            <p class="color-f9">{{ctrl.messageError}}</p>\n                        </div>\n                        <div layout="row" layout-align="center center">\n                            <md-button type="submit" class="wz-button md-raised md-primary" aria-label="Save API button">\n                                <i class="fa fa-floppy-o fa-fw" aria-hidden="true"></i> Save Threat-Analytics API entry\n                            </md-button>\n                        </div>\n                    </form>\n                    <!-- End add API form -->\n                </div>\n                <!-- End add API section-->\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End API configuration card section -->\n\n</div>\n<div layout="column" layout-align="start stretch" ng-if="ctrl.tab === \'extensions\' && !ctrl.load">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-check-square-o" aria-hidden="true"></i> Threat-Analytics extensions</span>\n        <span class="md-subheader">A threatanalytics extension is used to enable visualizations and dashboards that are specific to a particular use case.</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Section cards -->\n    <div layout="row" layout-align="start stretch" layout-wrap>\n\n        <!-- PCI DSS -->\n        <md-card flex="45" layout="column" class="wz-md-card">\n            <md-card-content flex="auto" layout="column">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-credit-card" aria-hidden="true"></i> {{ ctrl.tabNames[\'pci\'] }}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column">\n                    <p class="md-body-1 wz-padding-top-10">The Payment Card Industry Data Security Standard (PCI DSS) is a proprietary information security standard for organizations that handle branded credit cards from the major card schemes including Visa, MasterCard, American Express, Discover, and JCB.</p>\n                    <p class="md-body-1 wz-padding-top-10">The PCI Standard is mandated by the card brands and administered by the Payment Card Industry Security Standards Council. The standard was created to increase controls around cardholder data to reduce credit card fraud.</p>\n                </div>\n                <span flex></span>\n                <!--div layout="row" class="wz-padding-top-10">\n                    <md-switch class="wz-switch" aria-label="PCI DSS extension switch" ng-model="ctrl.extensions.pci" ng-change="ctrl.toggleExtension(\'pci\',ctrl.extensions.pci)"></md-switch>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <md-button target="_blank" href="https://documentation.cyberforza.com/current/pci-dss/index.html" class="wz-text-link cursor-pointer small" aria-label="Open Wazuh PCI DSS documentation">\n                    <i class="fa fa-fw fa-info" aria-hidden="true"></i> More info\n                </md-button>\n            </md-card-actions--!>\n        </md-card>\n\n        <!-- GDPR -->\n        <md-card flex="45" layout="column" class="wz-md-card">\n            <md-card-content flex="auto" layout="column">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-list-ol" aria-hidden="true"></i> {{ ctrl.tabNames[\'gdpr\'] }}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column">\n                    <p class="md-body-1 wz-padding-top-10">The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection and privacy for all individuals within the European Union. It also addresses the export of personal data outside the EU.</p>\n                    <p class="md-body-1 wz-padding-top-10">The GDPR aims primarily to give control to citizens and residents over their personal data and to simplify the regulatory environment for international business by unifying the regulation within the EU.</p>\n                </div>\n                <span flex></span>\n                <!--div layout="row" class="wz-padding-top-10">\n                    <md-switch class="wz-switch" aria-label="GDPR extension switch" ng-model="ctrl.extensions.gdpr" ng-change="ctrl.toggleExtension(\'gdpr\',ctrl.extensions.gdpr)"></md-switch>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <md-button target="_blank" href="https://documentation.cyberforza.com/current/gdpr/index.html" class="wz-text-link cursor-pointer small" aria-label="Open Wazuh GDPR documentation">\n                    <i class="fa fa-fw fa-info" aria-hidden="true"></i> More info\n                </md-button>\n            </md-card-actions--!>\n        </md-card>\n\n        <!-- Audit -->\n        <md-card flex="45" layout="column" class="wz-md-card">\n            <md-card-content flex="auto" layout="column">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-balance-scale" aria-hidden="true"></i> {{ ctrl.tabNames[\'audit\'] }}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column">\n                    <p class="md-body-1 wz-padding-top-10">The Linux Audit system provides a way to track security-relevant information on your system.</p>\n                    <p class="md-body-1 wz-padding-top-10">Based on pre-configured rules, Audit generates log entries to record as much information about the events that are happening on your system as possible.</p>\n                </div>\n                <span flex></span>\n                <!--div layout="row" class="wz-padding-top-10">\n                    <md-switch class="wz-switch" aria-label="Audit extension switch" ng-model="ctrl.extensions.audit" ng-change="ctrl.toggleExtension(\'audit\',ctrl.extensions.audit)"></md-switch>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <md-button target="_blank" href="https://documentation.cyberforza.com/current/user-manual/capabilities/system-calls-monitoring/index.html" class="wz-text-link cursor-pointer small" aria-label="Open Audit documentation">\n                    <i class="fa fa-fw fa-info" aria-hidden="true"></i> More info\n                </md-button>\n            </md-card-actions--!>\n        </md-card>\n\n        <!-- Open SCAP -->\n        <md-card flex="45" layout="column" class="wz-md-card">\n            <md-card-content flex="auto" layout="column">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-search" aria-hidden="true"></i> {{ ctrl.tabNames[\'oscap\'] }}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column">\n                    <p class="md-body-1 wz-padding-top-10">OpenSCAP is an OVAL (Open Vulnerability Assessment Language) interpreter, that is used for system configuration and vulnerability assessment.</p>\n                    <p class="md-body-1 wz-padding-top-10">Developed and supported by RedHat, it is recognized as a standardized compliance and hardening checking solution for enterprise-level infrastructure.</p>\n                </div>\n                <span flex></span>\n                <!--div layout="row" class="wz-padding-top-10">\n                    <md-switch class="wz-switch" aria-label="Open SCAP extension switch" ng-model="ctrl.extensions.oscap" ng-change="ctrl.toggleExtension(\'oscap\',ctrl.extensions.oscap)"></md-switch>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <md-button target="_blank" href="https://documentation.cyberforza.com/current/user-manual/capabilities/policy-monitoring/openscap/index.html" class="wz-text-link cursor-pointer small" aria-label="Open Open SCAP documentation">\n                    <i class="fa fa-fw fa-info" aria-hidden="true"></i> More info\n                </md-button--!>\n            </md-card-actions--!>\n        </md-card>\n\n        <!-- CIS-CAT -->\n        <md-card flex="45" layout="column" class="wz-md-card">\n            <md-card-content flex="auto" layout="column">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-rocket" aria-hidden="true"></i> {{ ctrl.tabNames[\'ciscat\'] }}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column">\n                    <p class="md-body-1 wz-padding-top-10">CIS (Center for Internet Security) is an entity dedicated to safeguard private and public organizations against cyber threats. This entity provides CIS benchmarks guidelines, which are a recognized global standard and best practices for securing IT systems and data against cyberattacks.</p>\n                </div>\n                <span flex></span>\n                <!--div layout="row" class="wz-padding-top-10">\n                    <md-switch class="wz-switch" aria-label="CIS-CAT extension switch" ng-model="ctrl.extensions.ciscat" ng-change="ctrl.toggleExtension(\'ciscat\',ctrl.extensions.ciscat)"></md-switch>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <md-button target="_blank" href="https://documentation.cyberforza.com/current/user-manual/capabilities/policy-monitoring/ciscat/ciscat.html" class="wz-text-link cursor-pointer small" aria-label="Open CIS-CAT integration documentation">\n                    <i class="fa fa-fw fa-info" aria-hidden="true"></i> More info\n                </md-button>\n            </md-card-actions--!>\n        </md-card>\n\n        <!-- Osquery -->\n        <md-card flex="45" layout="column" class="wz-md-card">\n            <md-card-content flex="auto" layout="column">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-rocket" aria-hidden="true"></i> {{ ctrl.tabNames[\'osquery\'] }}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column">\n                    <p class="md-body-1 wz-padding-top-10">Osquery can be used to expose an operating system as a high-performance relational database. This allows you to write SQL-based queries to explore operating system data.</p>\n                </div>\n                <span flex></span>\n                <!--div layout="row" class="wz-padding-top-10">\n                    <md-switch class="wz-switch" aria-label="Osquery extension switch" ng-model="ctrl.extensions.osquery" ng-change="ctrl.toggleExtension(\'osquery\',ctrl.extensions.osquery)"></md-switch>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <md-button target="_blank" href="https://documentation.cyberforza.com/current/user-manual/capabilities/osquery.html" class="wz-text-link cursor-pointer small" aria-label="Osquery integration documentation">\n                    <i class="fa fa-fw fa-info" aria-hidden="true"></i> More info\n                </md-button>\n            </md-card-actions--!>\n        </md-card>\n\n        <!-- Amazon -->\n        <md-card flex="45" layout="column" class="wz-md-card">\n            <md-card-content flex="auto" layout="column">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-amazon" aria-hidden="true"></i> {{ ctrl.tabNames[\'aws\'] }}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column">\n                    <p class="md-body-1 wz-padding-top-10">Threat-Analytics provides an agent module that can be used to retrieve data from S3 buckets. In combination with log analysis rules, this module provides the ability to analyze and alert on AWS Cloudtrail, GuardDuty, Macie, IAM, VPC Flow and other Amazon AWS  services data.</p>\n                </div>\n                <span flex></span>\n                <!--div layout="row" class="wz-padding-top-10">\n                    <md-switch class="wz-switch" aria-label="AWS extension switch" ng-model="ctrl.extensions.aws" ng-change="ctrl.toggleExtension(\'aws\',ctrl.extensions.aws)"></md-switch>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <md-button target="_blank" href="https://documentation.cyberforza.com/current/amazon/index.html" class="wz-text-link cursor-pointer small" aria-label="Open AWS integration documentation">\n                    <i class="fa fa-fw fa-info" aria-hidden="true"></i> More info\n                </md-button>\n            </md-card-actionsr--!>\n        </md-card>\n\n        <!-- VirusTotal -->\n        <md-card flex="45" layout="column" class="wz-md-card">\n            <md-card-content flex="auto" layout="column">\n                <span class="wz-headline-title"><i class="fa fa-fw fa-bug" aria-hidden="true"></i> {{ ctrl.tabNames[\'virustotal\'] }}</span>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="column">\n                    <p class="md-body-1 wz-padding-top-10">VirusTotal is an online service that analyzes files and URLs enabling the identification of viruses, worms, trojans, and other kinds of malicious content detected by antivirus engines and website scanners. Virustotal is commonly used as a threat intelligence source to help with security analysis and incident response.</p>\n                </div>\n                <span flex></span>\n                <!--div layout="row" class="wz-padding-top-10">\n                    <md-switch class="wz-switch" aria-label="VirusTotal extension switch" ng-model="ctrl.extensions.virustotal" ng-change="ctrl.toggleExtension(\'virustotal\',ctrl.extensions.virustotal)"></md-switch>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <md-button target="_blank" href="https://documentation.cyberforza.com/current/user-manual/capabilities/virustotal-scan/index.html" class="wz-text-link cursor-pointer small" aria-label="Open VirusTotal integration documentation">\n                    <i class="fa fa-fw fa-info" aria-hidden="true"></i> More info\n                </md-button>\n            </md-card-actions--!>\n        </md-card>\n    </div>\n    <!-- End section cards -->\n\n</div>\n<div layout="column" layout-align="start stretch" ng-if="ctrl.tab === \'pattern\' && !ctrl.load">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-filter" aria-hidden="true"></i> Index pattern</span>\n        <span class="md-subheader">Choose and index pattern, so threat-analytics can use it to retrieve data from indices for queries and visualizations.</span>\n    </div>\n    <!-- End headline -->\n\n    <!-- Pattern selector section -->\n    <div layout="row" layout-align="start start">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <div layout="row">\n                    <p class="md-body-1"><strong>Note:</strong> The chosen index pattern must use the template for threat-analytics alerts, otherwise, you won\'t be able to select it.</p>\n                </div>\n                <div flex="25" layout="column" class="wz-select-input wz-margin-top-10">\n                    <select class="kuiSelect wz-border-none cursor-pointer" ng-model="ctrl.selectedIndexPattern" ng-change="ctrl.changeIndexPattern(ctrl.selectedIndexPattern)" aria-label="Select index pattern">\n                        <option ng-repeat="indexPattern in ctrl.indexPatterns | orderObjectBy:\'title\'" value="{{indexPattern.id}}">{{indexPattern.title}}</option>\n                    </select>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End pattern selector section -->\n\n</div>\n<div layout="column" layout-align="start stretch" ng-if="ctrl.tab === \'configuration\' && !ctrl.load">\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-wrench" aria-hidden="true"></i> Threat-Analytics plugin\n            configuration settings</span>\n        <!--span class="md-subheader">Configuration file located at <span class="wz-text-monospace">/usr/share/kibana/plugins/wazuh/config.yml</span></span--!>\n    </div>\n    <!-- End headline -->\n    <div layout="row" layout-align="start center" ng-if="!ctrl.load">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <div layout="row">\n                    <i class="fa fa-fw fa-file-o" aria-hidden="true"></i>\n                    <span class="wz-headline-title">Current configuration</span>\n                    <span flex></span>\n                    <a tooltip="About and help" target="_blank" tooltip-placement="left" href="https://documentation.cyberforza.com/current/user-manual/kibana-app/reference/config-file.html"\n                        aria-label="Link to open app about section">\n                        <i class="fa fa-fw fa-question-circle-o ng-scope" aria-hidden="true"></i>\n                    </a>\n                </div>\n                <md-divider class="wz-margin-top-10"></md-divider>\n                <div layout="row" class="wz-padding-top-10">\n                    <table class="table table-striped table-condensed table-layout-fixed table-hover table-vertical-align-middle">\n                        <thead class="wz-text-bold">\n                            <th class="wz-text-left col-lg-2">Setting</th>\n                            <th class="wz-text-left col-lg-2">Value</th>\n                            <th class="wz-text-left">Description</th>\n                            <th class="wz-text-left">Actions</th>\n                        </thead>\n                        <tbody>\n                            <tr class="wz-word-wrap" ng-repeat="(key,value) in ctrl.configuration track by $index"\n                                ng-style="ctrl.editingKey === key && {\'background\': \'#e2f7ff\'}">\n                                <td>{{key}}</td>\n                                <td>\n                                    <input ng-if="ctrl.editingKey === key && ctrl.configurationTypes[key] === \'string\'"\n                                        ng-disabled="ctrl.loadingChange" id="input-{{key}}" type="text" class="wz-input-text"\n                                        ng-model="ctrl.editingNewValue"></input>\n                                    <input ng-if="ctrl.editingKey === key && ctrl.configurationTypes[key] === \'number\'"\n                                        ng-disabled="ctrl.loadingChange" id="input-{{key}}" type="number" class="wz-input-text"\n                                        ng-model="ctrl.editingNewValue" min=0></input>\n                                    <select ng-if="ctrl.editingKey === key && ctrl.configurationTypes[key] === \'boolean\'"\n                                        ng-disabled="ctrl.loadingChange" id="input-{{key}}" class="wz-input-text wz-width-100"\n                                        ng-model="ctrl.editingNewValue" ng-options="o as o for o in [true, false]"></select>\n                                    <textarea ng-if="ctrl.editingKey === key && ctrl.configurationTypes[key] === \'object\'"\n                                        ng-disabled="ctrl.loadingChange" id="input-{{key}}" class="wz-input-text wz-width-100"\n                                        ng-model="ctrl.editingNewValue"></textarea>\n                                    <span ng-show="!ctrl.editingKey || ctrl.editingKey !== key">{{value}}</span>\n                                </td>\n                                <td>{{ctrl.configEquivalence(key)}}</td>\n                                <td class="action-btn-td">\n                                    <div ng-hide="key === \'admin\' || !ctrl.configuration[\'admin\']">\n                                        <span ng-show="!ctrl.editingKey || ctrl.editingKey !== key" tooltip="Edit"\n                                            ng-click="ctrl.setEditingKey(key, value)" class="fa fa-fw fa-pencil cursor-pointer"></span>\n                                        <span ng-show="ctrl.editingKey === key && !ctrl.loadingChange" tooltip="Cancel"\n                                            class="fa fa-fw fa-times cursor-pointer" ng-click="ctrl.cancelEditingKey()"></span>\n                                        <span ng-show="ctrl.editingKey === key && ctrl.editingNewValue !== \'\' && !ctrl.loadingChange"\n                                            tooltip="Apply" class="fa fa-fw fa-success cursor-pointer" ng-click="ctrl.editKey(key, ctrl.editingNewValue)"></span>\n                                        <span ng-show="ctrl.editingKey === key && ctrl.loadingChange"><i class="fa fa-fw fa-spin fa-spinner"></i></span>\n                                    </div>\n                                </td>\n                            </tr>\n                        </tbody>\n                    </table>\n                </div>\n            </md-card-content>\n        </md-card>\n    </div>\n</div><div layout="column" layout-align="start stretch" ng-if="ctrl.tab === \'logs\' && !ctrl.load">\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-file-text-o" aria-hidden="true"></i> Threat-Analytics plugin log messages</span>\n        <!--span class="md-subheader">Log file located at <span class="wz-text-monospace">/usr/share/kibana/optimize/wazuh-logs/wazuhapp.log</span></span--!>\n    </div>\n    <!-- End headline -->\n\n    <!-- Loading ring -->\n    <div class=\'uil-ring-css\' ng-show="ctrl.loadingLogs">\n        <div></div>\n    </div>\n    <!-- End loading ring -->\n\n    <div layout="row" ng-show="!ctrl.loadingLogs">\n        <md-button class="wz-report-refresh-btn" ng-click="ctrl.refreshLogs()"><i class="fa fa-fw fa-refresh"></i> Refresh</md-button>\n    </div>\n\n    <div layout="row" class="md-padding" ng-show="!ctrl.loadingLogs">\n        <table class="table table-striped table-condensed" style="table-layout: fixed !important" id="wz_table">\n            <thead class="wz-text-bold">\n                <th class="wz-text-left col-lg-2"  >Date</th>\n                <th class="wz-text-left col-lg-1" >Level</th>\n                <th class="wz-text-left" >Message</th>\n            </thead>\n            <tbody>\n                <tr class="wz-word-wrap" ng-repeat="item in ctrl.logs">\n                    <td>\n                       {{ item.date | date: "medium" }}\n                    </td>\n                    <td>\n                        {{ item.level.toUpperCase() }}\n                     </td>\n                     <td>\n                        {{ item.message }}\n                     </td>\n\n                </tr>\n            </tbody>\n        </table>\n    </div>\n</div>\n<div layout="column" layout-align="start stretch" ng-if="ctrl.tab === \'about\' && !ctrl.load">\n\n    <!-- Headline -->\n    <div layout="column" layout-padding>\n        <span class="font-size-18"><i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> Threat-Analytics plugin description</span>\n        <span class="md-subheader">Threat-Analytics web user interface </span>\n    </div>\n    <!-- End headline -->\n\n    <!-- App information section -->\n    <div layout="row" layout-align="start center" ng-if="!ctrl.load">\n        <md-card flex class="wz-metric-color wz-md-card">\n            <md-card-content layout="row" class="wz-padding-metric">\n                <div class="wz-text-truncatable" flex>App version: <span class="wz-text-bold">{{ctrl.appInfo["app-version"]}}</span></div>\n                <div class="wz-text-truncatable" flex>App revision: <span class="wz-text-bold">{{ctrl.appInfo["revision"]}}</span></div>\n                <div class="wz-text-truncatable" flex>Install date: <span class="wz-text-bold">{{ctrl.appInfo["installationDate"] | date : "medium"}}</span></div>\n            </md-card-content>\n        </md-card>\n    </div>\n    <!-- End app information section -->\n\n    <!-- About card section -->\n    <div layout="row" layout-align="start start">\n        <md-card flex class="wz-md-card">\n            <md-card-content>\n                <div layout="column">\n                    <div layout-padding class="wz-line-height">\n                        Threat-Analytics plugin provides management and monitoring capabilities, giving users control over the threatanalytics infrastructure. Using this plugin you can monitor your agents status and configuration, query and visualize your alert data and monitor manager rules and configuration. Additionally this user interface provides a number of extensions listed below.\n                    </div>\n                    <div layout-padding layout="row">\n                        <div layout="column">\n                            <div>\n                               Threat-Analytics plugin main extensions:\n                            </div>\n                            <div layout-padding>\n                                <ul class="wz-circle-list md-body-1">\n                                    <li><strong>Linux Audit system integration</strong></li>\n                                    <li><strong>PCI DSS regulatory compliance</strong></li>\n                                    <li><strong>GDPR regulatory compliance</strong></li>\n                                    <li><strong>OpenSCAP configuration and vulnerability assessment</strong></li>\n                                    <li><strong>CIS-CAT configuration assessment scanner</strong></li>\n                                    <li><strong>Amazon Web Services (AWS) integration</strong></li>\n                                    <li><strong>VirusTotal threat intelligence</strong></li>\n                                </ul>\n                            </div>\n                        </div>\n                        <div layout="column">\n                            <div>\n                                Threat-Analytics plugin main sections:\n                            </div>\n                            <div layout-padding>\n                                <ul class="wz-circle-list md-body-1">\n                                    <li><strong>Manager status and configuration monitoring</strong></li>\n                                    <li><strong>Ruleset management and agent groups</strong></li>\n                                    <li><strong>Agent configuration management</strong></li>\n                                    <li><strong>Security Information Management</strong></li>\n                                    <li><strong>Auditing and Policy monitoring</strong></li>\n                                    <li><strong>Threat Detection and Response</strong></li>\n                                    <li><strong>Regulatory Compliance</strong></li>\n                                </ul>\n                            </div>\n                        </div>\n                    </div>\n                    <div layout-padding>\n                        Enjoy your threat-analytics experience and please don\'t hesitate to give us your feedback.\n                    </div>\n                </div>\n            </md-card-content>\n            <md-card-actions layout="row" layout-align="end center" class="wz-card-actions">\n                <!--md-button target="_blank" href="https://groups.google.com/forum/#!forum/wazuh" class="wz-text-link cursor-pointer small" aria-label="Open Wazuh mailing list"--!>\n                    <!--i class="fa fa-fw fa-envelope" aria-hidden="true"></i--!> <!--Mailing list\n --!>               <!--/md-button>\n                <md-button target="_blank" href="https://github.com/wazuh/wazuh-kibana-app" class="wz-text-link cursor-pointer small" aria-label="Open Wazuh app repository">\n                    <i class="fa fa-fw fa-github" aria-hidden="true"></i> Wazuh app repository\n                </md-button--!>\n                <!--md-button target="_blank" href="https://github.com/wazuh/wazuh" class="wz-text-link cursor-pointer small" aria-label="Open Wazuh core repository">\n                    <i class="fa fa-fw fa-github" aria-hidden="true"></i> Wazuh core repository\n                </md-button--!>\n            </md-card-actions>\n        </md-card>\n    </div>\n    <!-- End about card section -->\n\n</div>\n</div>';
			return pug_html
		}
		module.exports = template
	},
	5313: function (module, exports)
	{
		module.exports = '<div flex="auto" layout="column" ng-controller="blankScreenController as ctrl" layout-align="center center">\n    <div class="wz-text-center">\n        <img class="loading-logo-fail" aria-hidden="true" kbn-src="/plugins/wazuh/img/icon_fail.png"/>\n    </div>\n\n    <div class="checks-fail">\n            <md-divider></md-divider>\n        <div layout="row" class="wz-line-height layout-align-center-center">\n            <pre class="json-beautifier"><code>{{ctrl.errorToShow || \'Something went wrong\'}}</code></pre>\n        </div>\n        <md-divider></md-divider>\n        <div layout="row" class="wz-padding-top-10 wz-line-height layout-align-center-center">\n            <p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a>\n            <br>\n            <a href="https://documentation.cyberforza.com/current/installation-guide/">https://documentation.cyberforza.com/current/installation-guide/</a></p>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n        <div layout="row" class="wz-padding-top-10 wz-line-height layout-align-center-center">\n            <p>Let me out of here!<br>\n            <md-button class="wz-button md-raised md-primary" ng-click="ctrl.goOverview()" aria-label="Go overview">\n                <i class="fa fa-fw fa-sign-out"></i> Go app\n            </md-button>\n            </p>\n        </div>\n    </div>\n</div>\n'
	},
	5314: function (module, exports)
	{
		module.exports = '<div flex="auto" ng-controller="devToolsController" layout="column" class="dev-tools-max-height">\n\n    <wz-menu ng-init="menuNavItem = \'wazuh-dev\'"></wz-menu>\n    <md-content flex layout="column" class="md-padding" layout-align="start">\n        <div>\n            <div id="wz-dev-left-column" flex layout="column">\n                <span class="wz-headline-title wz-dev-title">Console <i ng-click="send()" class="fa fa-play wz-play-dev-color cursor-pointer pull-right fa-fw wz-always-top" id="play_button" aria-hidden="true"></i></span>\n                <textarea flex id="api_input"></textarea>\n            </div>\n            <div class="wz-dev-column-separator layout-column"><span></span></div>\n            <div id="wz-dev-right-column" flex layout="column">\n                <span class="wz-headline-title wz-dev-title"><i ng-click="help()" class="fa fa-question wz-question-dev-color cursor-pointer pull-right fa-fw" aria-hidden="true"></i></span>\n                <textarea flex id="api_output"></textarea>\n            </div>\n        </div>\n    </md-content>\n</div>\n'
	},
	5315: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.CSVRequest = function ()
		{
			function CSVRequest(genericReq)
			{
				_classCallCheck(this, CSVRequest);
				this.genericReq = genericReq
			}
			_createClass(CSVRequest, [
			{
				key: "fetch",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(path, id)
					{
						var filters = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
						var output;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return this.genericReq.request("POST", "/api/csv",
								{
									path: path,
									id: id,
									filters: filters
								});
							case 3:
								output = _context.sent;
								return _context.abrupt("return", output.data);
							case 7:
								_context.prev = 7;
								_context.t0 = _context["catch"](0);
								return _context.abrupt("return", Promise.reject(_context.t0));
							case 10:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 7]
						])
					}));

					function fetch(_x2, _x3)
					{
						return _ref.apply(this, arguments)
					}
					return fetch
				}()
			}]);
			return CSVRequest
		}()
	},
	5316: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.CommonData = function ()
		{
			function CommonData($rootScope, $timeout, genericReq, appState, errorHandler, $location, shareAgent, globalState)
			{
				_classCallCheck(this, CommonData);
				this.$rootScope = $rootScope;
				this.$timeout = $timeout;
				this.genericReq = genericReq;
				this.appState = appState;
				this.errorHandler = errorHandler;
				this.$location = $location;
				this.shareAgent = shareAgent;
				this.globalState = globalState;
				this.savedTimefilter = null;
				this.refreshInterval = {
					pause: true,
					value: 0
				}
			}
			_createClass(CommonData, [
			{
				key: "removeRuleId",
				value: function removeRuleId()
				{
					if (!this.globalState || !this.globalState.filters) return;
					var arr = [];
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = void 0;
					try
					{
						for (var _step, _iterator = this.globalState.filters[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
						{
							var item = _step.value;
							if (item.query && item.query.match && item.query.match["rule.id"] && item.query.match["rule.id"].query) continue;
							arr.push(item)
						}
					}
					catch (err)
					{
						_didIteratorError = true;
						_iteratorError = err
					}
					finally
					{
						try
						{
							!_iteratorNormalCompletion && _iterator.return && _iterator.return()
						}
						finally
						{
							if (_didIteratorError) throw _iteratorError
						}
					}
					this.globalState.filters = arr
				}
			},
			{
				key: "removeDuplicateRuleGroups",
				value: function removeDuplicateRuleGroups(group)
				{
					if (!this.globalState || !this.globalState.filters) return;
					var globalRuleGroupFilters = this.globalState.filters.map(function (item)
					{
						if (item.query && item.query.match && item.query.match["rule.groups"] && item.query.match["rule.groups"].query) return item.query.match["rule.groups"].query;
						return null
					});
					globalRuleGroupFilters.includes(group) && this.globalState.filters.splice(globalRuleGroupFilters.indexOf(group), 1)
				}
			},
			{
				key: "removeDuplicateExists",
				value: function removeDuplicateExists(condition)
				{
					if (!this.globalState || !this.globalState.filters) return;
					var globalRuleExistsFilters = this.globalState.filters.map(function (item)
					{
						if (item.exists && item.exists.field) return item.exists.field;
						return null
					});
					globalRuleExistsFilters.includes(condition) && this.globalState.filters.splice(globalRuleExistsFilters.indexOf(condition), 1)
				}
			},
			{
				key: "af",
				value: function af(filterHandler, tab, localChange, agent)
				{
					var _this = this;
					try
					{
						var tabFilters = {
							general:
							{
								group: ""
							},
							fim:
							{
								group: "syscheck"
							},
							pm:
							{
								group: "rootcheck"
							},
							vuls:
							{
								group: "vulnerability-detector"
							},
							oscap:
							{
								group: "oscap"
							},
							ciscat:
							{
								group: "ciscat"
							},
							audit:
							{
								group: "audit"
							},
							pci:
							{
								group: "pci_dss"
							},
							gdpr:
							{
								group: "gdpr"
							},
							aws:
							{
								group: "amazon"
							},
							virustotal:
							{
								group: "virustotal"
							},
							osquery:
							{
								group: "osquery"
							}
						};
						var filters = [];
						var isCluster = "enabled" == this.appState.getClusterInfo().status;
						filters.push(filterHandler.managerQuery(isCluster ? this.appState.getClusterInfo().cluster : this.appState.getClusterInfo().manager, isCluster));
						if ("general" !== tab)
							if ("pci" === tab)
							{
								this.removeDuplicateExists("rule.pci_dss");
								filters.push(filterHandler.pciQuery())
							}
						else if ("gdpr" === tab)
						{
							this.removeDuplicateExists("rule.gdpr");
							filters.push(filterHandler.gdprQuery())
						}
						else
						{
							this.removeDuplicateRuleGroups(tabFilters[tab].group);
							filters.push(filterHandler.ruleGroupQuery(tabFilters[tab].group))
						}
						agent && filters.push(filterHandler.agentQuery(agent));
						this.$rootScope.$emit("wzEventFilters",
						{
							filters: filters,
							localChange: localChange
						});
						this.$rootScope.$$listenerCount["wzEventFilters"] || this.$timeout(100).then(function ()
						{
							return _this.af(filterHandler, tab, localChange, agent = false)
						})
					}
					catch (error)
					{
						this.errorHandler.handle("An error occurred while creating custom filters for visualizations", agent ? "Agents" : "Overview", true)
					}
				}
			},
			{
				key: "getGDPR",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var gdprTabs, data, key;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								gdprTabs = [];
								_context.next = 4;
								return this.genericReq.request("GET", "/api/gdpr/all");
							case 4:
								data = _context.sent;
								if (data.data)
								{
									_context.next = 7;
									break
								}
								return _context.abrupt("return", []);
							case 7:
								for (key in data.data) gdprTabs.push(
								{
									title: key,
									content: data.data[key]
								});
								return _context.abrupt("return", gdprTabs);
							case 11:
								_context.prev = 11;
								_context.t0 = _context["catch"](0);
								return _context.abrupt("return", Promise.reject(_context.t0));
							case 14:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 11]
						])
					}));

					function getGDPR()
					{
						return _ref.apply(this, arguments)
					}
					return getGDPR
				}()
			},
			{
				key: "getPCI",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2()
					{
						var pciTabs, data, key;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								pciTabs = [];
								_context2.next = 4;
								return this.genericReq.request("GET", "/api/pci/all");
							case 4:
								data = _context2.sent;
								if (data.data)
								{
									_context2.next = 7;
									break
								}
								return _context2.abrupt("return", []);
							case 7:
								for (key in data.data) pciTabs.push(
								{
									title: key,
									content: data.data[key]
								});
								return _context2.abrupt("return", pciTabs);
							case 11:
								_context2.prev = 11;
								_context2.t0 = _context2["catch"](0);
								return _context2.abrupt("return", Promise.reject(_context2.t0));
							case 14:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 11]
						])
					}));

					function getPCI()
					{
						return _ref2.apply(this, arguments)
					}
					return getPCI
				}()
			},
			{
				key: "assignFilters",
				value: function assignFilters(filterHandler, tab, localChange, agent)
				{
					return this.af(filterHandler, tab, localChange, agent)
				}
			},
			{
				key: "validateRange",
				value: function validateRange(data)
				{
					var result = {
						duration: "Unknown",
						inProgress: false,
						end: data.end || "Unknown",
						start: data.start || "Unknown"
					};
					if (data.end && data.start)
					{
						result.duration = (new Date(data.end) - new Date(data.start)) / 1e3 / 60;
						result.duration = Math.round(100 * result.duration) / 100;
						result.duration <= 0 && (result.inProgress = true)
					}
					return result
				}
			},
			{
				key: "checkTabLocation",
				value: function checkTabLocation()
				{
					if (this.$location.search().tab) return this.$location.search().tab;
					this.$location.search("tab", "welcome");
					return "welcome"
				}
			},
			{
				key: "checkTabViewLocation",
				value: function checkTabViewLocation()
				{
					if (this.$location.search().tabView) return this.$location.search().tabView;
					this.$location.search("tabView", "panels");
					return "panels"
				}
			},
			{
				key: "checkLocationAgentId",
				value: function checkLocationAgentId(newAgentId, globalAgent)
				{
					if (newAgentId)
					{
						this.$location.search("agent", newAgentId);
						return newAgentId
					}
					if (this.$location.search().agent && !globalAgent) return this.$location.search().agent;
					this.shareAgent.deleteAgent();
					this.$location.search("agent", globalAgent.id);
					return globalAgent.id
				}
			},
			{
				key: "setTimefilter",
				value: function setTimefilter(time)
				{
					time && (this.savedTimefilter = time)
				}
			},
			{
				key: "removeTimefilter",
				value: function removeTimefilter()
				{
					this.savedTimefilter = null
				}
			},
			{
				key: "getTimefilter",
				value: function getTimefilter()
				{
					return this.savedTimefilter
				}
			},
			{
				key: "setRefreshInterval",
				value: function setRefreshInterval(interval)
				{
					interval && Object.assign(this.refreshInterval, interval)
				}
			},
			{
				key: "getRefreshInterval",
				value: function getRefreshInterval()
				{
					return this.refreshInterval
				}
			}]);
			return CommonData
		}()
	},
	5317: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.ReportingService = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _jquery = __webpack_require__(16);
		var _jquery2 = _interopRequireDefault(_jquery);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ReportingService = function ()
		{
			function ReportingService($rootScope, vis2png, rawVisualizations, visHandlers, genericReq, errorHandler)
			{
				_classCallCheck(this, ReportingService);
				this.$rootScope = $rootScope;
				this.vis2png = vis2png;
				this.rawVisualizations = rawVisualizations;
				this.visHandlers = visHandlers;
				this.genericReq = genericReq;
				this.errorHandler = errorHandler
			}
			_createClass(ReportingService, [
			{
				key: "startVis2Png",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(tab)
					{
						var isAgents = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						var syscollectorFilters = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
						var idArray, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item, tmpHTMLElement, appliedFilters, array, name, data;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								if (!this.vis2png.isWorking())
								{
									_context.next = 4;
									break
								}
								this.errorHandler.handle("Report in progress", "Reporting", true);
								return _context.abrupt("return");
							case 4:
								this.$rootScope.reportBusy = true;
								this.$rootScope.reportStatus = "Generating report...0%";
								this.$rootScope.$$phase || this.$rootScope.$digest();
								this.vis2png.clear();
								idArray = this.rawVisualizations.getList().map(function (item)
								{
									return item.id
								});
								_iteratorNormalCompletion = true;
								_didIteratorError = false;
								_iteratorError = void 0;
								_context.prev = 12;
								for (_iterator = idArray[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
								{
									item = _step.value;
									tmpHTMLElement = (0, _jquery2.default)("#" + item);
									this.vis2png.assignHTMLItem(item, tmpHTMLElement)
								}
								_context.next = 20;
								break;
							case 16:
								_context.prev = 16;
								_context.t0 = _context["catch"](12);
								_didIteratorError = true;
								_iteratorError = _context.t0;
							case 20:
								_context.prev = 20;
								_context.prev = 21;
								!_iteratorNormalCompletion && _iterator.return && _iterator.return();
							case 23:
								_context.prev = 23;
								if (!_didIteratorError)
								{
									_context.next = 26;
									break
								}
								throw _iteratorError;
							case 26:
								return _context.finish(23);
							case 27:
								return _context.finish(20);
							case 28:
								appliedFilters = this.visHandlers.getAppliedFilters(syscollectorFilters);
								_context.next = 31;
								return this.vis2png.checkArray(idArray);
							case 31:
								array = _context.sent;
								name = "wazuh-" + (isAgents ? "agents" : "overview") + "-" + tab + "-" + (Date.now() / 1e3 | 0) + ".pdf";
								data = {
									array: array,
									name: name,
									title: isAgents ? "Agents " + tab : "Overview " + tab,
									filters: appliedFilters.filters,
									time: appliedFilters.time,
									searchBar: appliedFilters.searchBar,
									tables: appliedFilters.tables,
									tab: tab,
									section: isAgents ? "agents" : "overview",
									isAgents: isAgents
								};
								_context.next = 36;
								return this.genericReq.request("POST", "/reports", data);
							case 36:
								this.$rootScope.reportBusy = false;
								this.$rootScope.reportStatus = false;
								this.$rootScope.$$phase || this.$rootScope.$digest();
/*    Jagan     */
								this.errorHandler.info("Success. Go to Wazuh > Management > Reporting", "Reporting");
								return _context.abrupt("return");
							case 43:
								_context.prev = 43;
								_context.t1 = _context["catch"](0);
								this.$rootScope.reportBusy = false;
								this.$rootScope.reportStatus = false;
								this.errorHandler.handle(_context.t1, "Reporting");
							case 48:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 43],
							[12, 16, 20, 28],
							[21, , 23, 27]
						])
					}));

					function startVis2Png(_x3)
					{
						return _ref.apply(this, arguments)
					}
					return startVis2Png
				}()
			}]);
			return ReportingService
		}()
	},
	5318: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.VisFactoryService = function ()
		{
			function VisFactoryService($rootScope, appState, genericReq, discoverPendingUpdates, rawVisualizations, tabVisualizations, loadedVisualizations, commonData, visHandlers)
			{
				_classCallCheck(this, VisFactoryService);
				this.$rootScope = $rootScope;
				this.appState = appState;
				this.genericReq = genericReq;
				this.discoverPendingUpdates = discoverPendingUpdates;
				this.rawVisualizations = rawVisualizations;
				this.tabVisualizations = tabVisualizations;
				this.loadedVisualizations = loadedVisualizations;
				this.commonData = commonData;
				this.visHandlers = visHandlers
			}
			_createClass(VisFactoryService, [
			{
				key: "clear",
				value: function clear()
				{
					var onlyAgent = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
					onlyAgent || this.visHandlers.removeAll();
					this.discoverPendingUpdates.removeAll();
					this.rawVisualizations.removeAll();
					this.loadedVisualizations.removeAll()
				}
			},
			{
				key: "clearAll",
				value: function clearAll()
				{
					this.clear();
					this.tabVisualizations.removeAll()
				}
			},
			{
				key: "buildOverviewVisualizations",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(filterHandler, tab, subtab, localChange)
					{
						var data;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return this.genericReq.request("GET", "/elastic/visualizations/overview-" + tab + "/" + this.appState.getCurrentPattern());
							case 3:
								data = _context.sent;
								this.rawVisualizations.assignItems(data.data.raw);
								this.commonData.assignFilters(filterHandler, tab, localChange);
								this.$rootScope.$emit("changeTabView",
								{
									tabView: subtab
								});
								this.$rootScope.$broadcast("updateVis");
								return _context.abrupt("return");
							case 11:
								_context.prev = 11;
								_context.t0 = _context["catch"](0);
								return _context.abrupt("return", Promise.reject(_context.t0));
							case 14:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 11]
						])
					}));

					function buildOverviewVisualizations(_x2, _x3, _x4, _x5)
					{
						return _ref.apply(this, arguments)
					}
					return buildOverviewVisualizations
				}()
			},
			{
				key: "buildAgentsVisualizations",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(filterHandler, tab, subtab, localChange, id)
					{
						var data;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								_context2.next = 3;
								return this.genericReq.request("GET", "/elastic/visualizations/agents-" + tab + "/" + this.appState.getCurrentPattern());
							case 3:
								data = _context2.sent;
								this.rawVisualizations.assignItems(data.data.raw);
								this.commonData.assignFilters(filterHandler, tab, localChange, id);
								this.$rootScope.$emit("changeTabView",
								{
									tabView: subtab
								});
								this.$rootScope.$broadcast("updateVis");
								return _context2.abrupt("return");
							case 11:
								_context2.prev = 11;
								_context2.t0 = _context2["catch"](0);
								return _context2.abrupt("return", Promise.reject(_context2.t0));
							case 14:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 11]
						])
					}));

					function buildAgentsVisualizations(_x6, _x7, _x8, _x9, _x10)
					{
						return _ref2.apply(this, arguments)
					}
					return buildAgentsVisualizations
				}()
			}]);
			return VisFactoryService
		}()
	},
	5319: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.service("regionmapsConfig", function ()
		{
			return {
				noop: function noop()
				{},
				layers: []
			}
		}).service("mapConfig", function ()
		{
			return {
				noop: function noop()
				{}
			}
		}).service("tilemapsConfig", function ()
		{
			return {
				noop: function noop()
				{},
				deprecated:
				{
					config:
					{
						options: false
					}
				}
			}
		})
	},
	5320: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.filter("orderObjectBy", function ()
		{
			return function (items, field, reverse)
			{
				if (!items) return [];
				var isNumeric = function isNumeric(n)
				{
					return !isNaN(parseFloat(n)) && isFinite(n)
				};
				var filtered = [];
				items.forEach(function (item, key)
				{
					item.key = key;
					filtered.push(item)
				});
				var index = function index(obj, i)
				{
					return obj[i]
				};
				filtered.sort(function (a, b)
				{
					var reducedA = field.split(".").reduce(index, a);
					var reducedB = field.split(".").reduce(index, b);
					if (isNumeric(reducedA) && isNumeric(reducedB))
					{
						reducedA = Number(reducedA);
						reducedB = Number(reducedB)
					}
					return reducedA === reducedB ? 0 : reducedA > reducedB ? 1 : -1
				});
				reverse && filtered.reverse();
				return filtered
			}
		})
	},
	5321: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.GroupHandler = function ()
		{
			function GroupHandler(apiReq)
			{
				_classCallCheck(this, GroupHandler);
				this.apiReq = apiReq
			}
			_createClass(GroupHandler, [
			{
				key: "removeGroup",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(group)
					{
						var result;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return this.apiReq.request("DELETE", "/agents/groups/" + group,
								{});
							case 3:
								result = _context.sent;
								return _context.abrupt("return", result);
							case 7:
								_context.prev = 7;
								_context.t0 = _context["catch"](0);
								return _context.abrupt("return", Promise.reject(_context.t0));
							case 10:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 7]
						])
					}));

					function removeGroup(_x)
					{
						return _ref.apply(this, arguments)
					}
					return removeGroup
				}()
			},
			{
				key: "removeAgentFromGroup",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(group, agentId)
					{
						var result;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								_context2.next = 3;
								return this.apiReq.request("DELETE", "/agents/" + agentId + "/group/" + group,
								{});
							case 3:
								result = _context2.sent;
								return _context2.abrupt("return", result);
							case 7:
								_context2.prev = 7;
								_context2.t0 = _context2["catch"](0);
								return _context2.abrupt("return", Promise.reject(_context2.t0));
							case 10:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 7]
						])
					}));

					function removeAgentFromGroup(_x2, _x3)
					{
						return _ref2.apply(this, arguments)
					}
					return removeAgentFromGroup
				}()
			},
			{
				key: "addAgentToGroup",
				value: function ()
				{
					var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(group, agentId)
					{
						var result;
						return regeneratorRuntime.wrap(function _callee3$(_context3)
						{
							while (1) switch (_context3.prev = _context3.next)
							{
							case 0:
								_context3.prev = 0;
								_context3.next = 3;
								return this.apiReq.request("PUT", "/agents/" + agentId + "/group/" + group,
								{});
							case 3:
								result = _context3.sent;
								return _context3.abrupt("return", result);
							case 7:
								_context3.prev = 7;
								_context3.t0 = _context3["catch"](0);
								return _context3.abrupt("return", Promise.reject(_context3.t0));
							case 10:
							case "end":
								return _context3.stop()
							}
						}, _callee3, this, [
							[0, 7]
						])
					}));

					function addAgentToGroup(_x4, _x5)
					{
						return _ref3.apply(this, arguments)
					}
					return addAgentToGroup
				}()
			},
			{
				key: "sendConfiguration",
				value: function ()
				{
					var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(group, content)
					{
						var result;
						return regeneratorRuntime.wrap(function _callee4$(_context4)
						{
							while (1) switch (_context4.prev = _context4.next)
							{
							case 0:
								_context4.prev = 0;
								_context4.next = 3;
								return this.apiReq.request("POST", "/agents/groups/" + group + "/files/agent.conf",
								{
									content: content,
									origin: "xmleditor"
								});
							case 3:
								result = _context4.sent;
								return _context4.abrupt("return", result);
							case 7:
								_context4.prev = 7;
								_context4.t0 = _context4["catch"](0);
								return _context4.abrupt("return", Promise.reject(_context4.t0));
							case 10:
							case "end":
								return _context4.stop()
							}
						}, _callee4, this, [
							[0, 7]
						])
					}));

					function sendConfiguration(_x6, _x7)
					{
						return _ref4.apply(this, arguments)
					}
					return sendConfiguration
				}()
			},
			{
				key: "createGroup",
				value: function ()
				{
					var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(name)
					{
						var result;
						return regeneratorRuntime.wrap(function _callee5$(_context5)
						{
							while (1) switch (_context5.prev = _context5.next)
							{
							case 0:
								_context5.prev = 0;
								_context5.next = 3;
								return this.apiReq.request("PUT", "/agents/groups/" + name,
								{});
							case 3:
								result = _context5.sent;
								return _context5.abrupt("return", result);
							case 7:
								_context5.prev = 7;
								_context5.t0 = _context5["catch"](0);
								return _context5.abrupt("return", Promise.reject(_context5.t0));
							case 10:
							case "end":
								return _context5.stop()
							}
						}, _callee5, this, [
							[0, 7]
						])
					}));

					function createGroup(_x8)
					{
						return _ref5.apply(this, arguments)
					}
					return createGroup
				}()
			}]);
			return GroupHandler
		}()
	},
	5322: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(5323);
		__webpack_require__(5326);
		__webpack_require__(5342);
		__webpack_require__(5346);
		__webpack_require__(5350);
		__webpack_require__(5355)
	},
	5323: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var _overview = __webpack_require__(5324);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.controller("overviewController", _overview.OverviewController)
	},
	5324: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.OverviewController = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _filterHandler = __webpack_require__(954);
		var _generateMetric = __webpack_require__(1695);
		var _tabNames = __webpack_require__(646);
		var _tabDescription = __webpack_require__(1696);
		var _overviewMetrics = __webpack_require__(5325);
		var _timefilter = __webpack_require__(27);

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.OverviewController = function ()
		{
			function OverviewController($scope, $location, $rootScope, appState, errorHandler, apiReq, tabVisualizations, commonData, reportingService, visFactoryService, wazuhConfig)
			{
				_classCallCheck(this, OverviewController);
				this.$scope = $scope;
				this.$location = $location;
				this.$rootScope = $rootScope;
				this.appState = appState;
				this.errorHandler = errorHandler;
				this.apiReq = apiReq;
				this.tabVisualizations = tabVisualizations;
				this.commonData = commonData;
				this.reportingService = reportingService;
				this.visFactoryService = visFactoryService;
				this.wazuhConfig = wazuhConfig
			}
			_createClass(OverviewController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					var _this = this;
					this.wodlesConfiguration = false;
					this.TabDescription = _tabDescription.TabDescription;
					this.$rootScope.reportStatus = false;
					this.$location.search("_a", null);
					this.filterHandler = new _filterHandler.FilterHandler(this.appState.getCurrentPattern());
					this.visFactoryService.clearAll();
					var currentApi = JSON.parse(this.appState.getCurrentAPI()).id;
					var extensions = this.appState.getExtensions(currentApi);
					this.extensions = extensions;
					this.wzMonitoringEnabled = false;
					this.tabNames = _tabNames.TabNames;
					this.tabView = this.commonData.checkTabViewLocation();
					this.tab = this.commonData.checkTabLocation();
					this.tabHistory = [];
					"welcome" !== this.tab && this.tabHistory.push(this.tab);
					this.tabVisualizations.assign("overview");
					this.hostMonitoringTabs = ["general", "fim", "aws"];
					this.systemAuditTabs = ["pm", "audit", "oscap", "ciscat"];
					this.securityTabs = ["vuls", "virustotal", "osquery"];
					this.complianceTabs = ["pci", "gdpr"];
					this.wodlesConfiguration = null;
					this.init();
					this.$scope.$on("$destroy", function ()
					{
						_this.visFactoryService.clearAll()
					})
				}
			},
			{
				key: "inArray",
				value: function inArray(item, array)
				{
					return item && Array.isArray(array) && array.includes(item)
				}
			},
			{
				key: "createMetrics",
				value: function createMetrics(metricsObject)
				{
					var _this2 = this;
					var _loop = function _loop(key)
					{
						_this2[key] = function ()
						{
							return (0, _generateMetric.generateMetric)(metricsObject[key])
						}
					};
					for (var key in metricsObject) _loop(key)
				}
			},
			{
				key: "checkMetrics",
				value: function checkMetrics(tab, subtab)
				{
					if ("panels" === subtab) switch (tab)
					{
					case "general":
						this.createMetrics(_overviewMetrics.metricsGeneral);
						break;
					case "audit":
						this.createMetrics(_overviewMetrics.metricsAudit);
						break;
					case "vuls":
						this.createMetrics(_overviewMetrics.metricsVulnerability);
						break;
					case "oscap":
						this.createMetrics(_overviewMetrics.metricsScap);
						break;
					case "ciscat":
						this.createMetrics(_overviewMetrics.metricsCiscat);
						break;
					case "virustotal":
						this.createMetrics(_overviewMetrics.metricsVirustotal);
						break;
					case "osquery":
						this.createMetrics(_overviewMetrics.metricsOsquery)
					}
				}
			},
			{
				key: "switchSubtab",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(subtab)
					{
						var force = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						var sameTab = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						var preserveDiscover = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
						var localChange;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								if (!(this.tabView === subtab && !force))
								{
									_context.next = 3;
									break
								}
								return _context.abrupt("return");
							case 3:
								this.visFactoryService.clear();
								this.$location.search("tabView", subtab);
								localChange = "panels" === subtab && "discover" === this.tabView && sameTab;
								this.tabView = subtab;
								if (!("panels" === subtab && "welcome" !== this.tab))
								{
									_context.next = 12;
									break
								}
								_context.next = 10;
								return this.visFactoryService.buildOverviewVisualizations(this.filterHandler, this.tab, subtab, localChange || preserveDiscover);
							case 10:
								_context.next = 13;
								break;
							case 12:
								this.$rootScope.$emit("changeTabView",
								{
									tabView: this.tabView
								});
							case 13:
								this.checkMetrics(this.tab, subtab);
								_context.next = 19;
								break;
							case 16:
								_context.prev = 16;
								_context.t0 = _context["catch"](0);
								this.errorHandler.handle(_context.t0, "Overview");
							case 19:
								this.$scope.$$phase || this.$scope.$digest();
								return _context.abrupt("return");
							case 21:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 16]
						])
					}));

					function switchSubtab(_x4)
					{
						return _ref.apply(this, arguments)
					}
					return switchSubtab
				}()
			},
			{
				key: "calculateWodleTagFromTab",
				value: function calculateWodleTagFromTab(tab)
				{
					if ("aws" === tab) return "aws-s3";
					return false
				}
			},
			{
				key: "switchTab",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(newTab)
					{
						var force = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						var pciTabs, gdprTabs, sameTab, preserveDiscover;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								if ("welcome" === newTab)
								{
									this.commonData.setRefreshInterval(_timefilter.timefilter.getRefreshInterval());
									_timefilter.timefilter.setRefreshInterval(
									{
										pause: true,
										value: 0
									})
								}
								else "welcome" === this.tab && _timefilter.timefilter.setRefreshInterval(this.commonData.getRefreshInterval());
								if (!("undefined" === typeof this.agentsCountTotal))
								{
									_context2.next = 5;
									break
								}
								_context2.next = 5;
								return this.getSummary();
							case 5:
								if (!("pci" === newTab))
								{
									_context2.next = 11;
									break
								}
								_context2.next = 8;
								return this.commonData.getPCI();
							case 8:
								pciTabs = _context2.sent;
								this.pciTabs = pciTabs;
								this.selectedPciIndex = 0;
							case 11:
								if (!("gdpr" === newTab))
								{
									_context2.next = 17;
									break
								}
								_context2.next = 14;
								return this.commonData.getGDPR();
							case 14:
								gdprTabs = _context2.sent;
								this.gdprTabs = gdprTabs;
								this.selectedGdprIndex = 0;
							case 17:
								"welcome" !== newTab && this.tabHistory.push(newTab);
								this.tabHistory.length > 2 && (this.tabHistory = this.tabHistory.slice(-2));
								this.tabVisualizations.setTab(newTab);
								if (!(this.tab === newTab && !force))
								{
									_context2.next = 22;
									break
								}
								return _context2.abrupt("return");
							case 22:
								sameTab = (this.tab === newTab && this.tabHistory.length < 2 || 2 === this.tabHistory.length && this.tabHistory[0] === this.tabHistory[1]) && "nav" !== force;
								"nav" === force && (force = false);
								this.$location.search("tab", newTab);
								preserveDiscover = 2 === this.tabHistory.length && this.tabHistory[0] === this.tabHistory[1];
								this.tab = newTab;
								_context2.next = 29;
								return this.switchSubtab("panels", true, sameTab, preserveDiscover);
							case 29:
								_context2.next = 34;
								break;
							case 31:
								_context2.prev = 31;
								_context2.t0 = _context2["catch"](0);
								this.errorHandler.handle(_context2.t0, "Overview");
							case 34:
								this.$scope.$$phase || this.$scope.$digest();
								return _context2.abrupt("return");
							case 36:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 31]
						])
					}));

					function switchTab(_x6)
					{
						return _ref2.apply(this, arguments)
					}
					return switchTab
				}()
			},
			{
				key: "startVis2Png",
				value: function startVis2Png()
				{
					return this.reportingService.startVis2Png(this.tab)
				}
			},
			{
				key: "getSummary",
				value: function ()
				{
					var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3()
					{
						var data, result, active, total;
						return regeneratorRuntime.wrap(function _callee3$(_context3)
						{
							while (1) switch (_context3.prev = _context3.next)
							{
							case 0:
								_context3.prev = 0;
								_context3.next = 3;
								return this.apiReq.request("GET", "/agents/summary",
								{});
							case 3:
								data = _context3.sent;
								result = ((data ||
								{}).data ||
								{}).data || false;
								if (!result)
								{
									_context3.next = 15;
									break
								}
								active = result.Active - 1;
								total = result.Total - 1;
								this.agentsCountActive = active;
								this.agentsCountDisconnected = result.Disconnected;
								this.agentsCountNeverConnected = result["Never connected"];
								this.agentsCountTotal = total;
								this.agentsCoverity = total ? active / total * 100 : 0;
								_context3.next = 16;
								break;
							case 15:
								throw new Error("Error fetching /agents/summary from Wazuh API");
							case 16:
								return _context3.abrupt("return");
							case 19:
								_context3.prev = 19;
								_context3.t0 = _context3["catch"](0);
								return _context3.abrupt("return", Promise.reject(_context3.t0));
							case 22:
							case "end":
								return _context3.stop()
							}
						}, _callee3, this, [
							[0, 19]
						])
					}));

					function getSummary()
					{
						return _ref3.apply(this, arguments)
					}
					return getSummary
				}()
			},
			{
				key: "loadConfiguration",
				value: function ()
				{
					var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4()
					{
						var configuration;
						return regeneratorRuntime.wrap(function _callee4$(_context4)
						{
							while (1) switch (_context4.prev = _context4.next)
							{
							case 0:
								_context4.prev = 0;
								configuration = this.wazuhConfig.getConfig();
								this.wzMonitoringEnabled = !!configuration["wazuh.monitoring.enabled"];
								return _context4.abrupt("return");
							case 6:
								_context4.prev = 6;
								_context4.t0 = _context4["catch"](0);
								this.wzMonitoringEnabled = true;
								return _context4.abrupt("return", Promise.reject(_context4.t0));
							case 10:
							case "end":
								return _context4.stop()
							}
						}, _callee4, this, [
							[0, 6]
						])
					}));

					function loadConfiguration()
					{
						return _ref4.apply(this, arguments)
					}
					return loadConfiguration
				}()
			},
			{
				key: "init",
				value: function ()
				{
					var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5()
					{
						return regeneratorRuntime.wrap(function _callee5$(_context5)
						{
							while (1) switch (_context5.prev = _context5.next)
							{
							case 0:
								_context5.prev = 0;
								_context5.next = 3;
								return this.loadConfiguration();
							case 3:
								_context5.next = 5;
								return this.switchTab(this.tab, true);
							case 5:
								_context5.next = 10;
								break;
							case 7:
								_context5.prev = 7;
								_context5.t0 = _context5["catch"](0);
								this.errorHandler.handle(_context5.t0, "Overview (init)");
							case 10:
								this.$scope.$$phase || this.$scope.$digest();
								return _context5.abrupt("return");
							case 12:
							case "end":
								return _context5.stop()
							}
						}, _callee5, this, [
							[0, 7]
						])
					}));

					function init()
					{
						return _ref5.apply(this, arguments)
					}
					return init
				}()
			}]);
			return OverviewController
		}()
	},
	5325: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var metricsGeneral = {
			totalAlerts: "[vis-id=\"'Wazuh-App-Overview-General-Metric-alerts'\"]",
			level12: "[vis-id=\"'Wazuh-App-Overview-General-Level-12-alerts'\"]",
			authFailure: "[vis-id=\"'Wazuh-App-Overview-General-Authentication-failure'\"]",
			authSuccess: "[vis-id=\"'Wazuh-App-Overview-General-Authentication-success'\"]"
		};
		var metricsAudit = {
			auditNewFiles: "[vis-id=\"'Wazuh-App-Overview-Audit-New-files'\"]",
			auditReadFiles: "[vis-id=\"'Wazuh-App-Overview-Audit-Read-files'\"]",
			auditModifiedFiles: "[vis-id=\"'Wazuh-App-Overview-Audit-Modified-files'\"]",
			auditRemovedFiles: "[vis-id=\"'Wazuh-App-Overview-Audit-Removed-files'\"]"
		};
		var metricsVulnerability = {
			vulnCritical: "[vis-id=\"'Wazuh-App-Overview-vulnerability-Metric-Critical-severity'\"]",
			vulnHigh: "[vis-id=\"'Wazuh-App-Overview-vulnerability-Metric-High-severity'\"]",
			vulnMedium: "[vis-id=\"'Wazuh-App-Overview-vulnerability-Metric-Medium-severity'\"]",
			vulnLow: "[vis-id=\"'Wazuh-App-Overview-vulnerability-Metric-Low-severity'\"]"
		};
		var metricsScap = {
			scapLastScore: "[vis-id=\"'Wazuh-App-Overview-OSCAP-Last-score'\"]",
			scapHighestScore: "[vis-id=\"'Wazuh-App-Overview-OSCAP-Highest-score'\"]",
			scapLowestScore: "[vis-id=\"'Wazuh-App-Overview-OSCAP-Lowest-score'\"]"
		};
		var metricsCiscat = {
			ciscatScanNotChecked: "[vis-id=\"'Wazuh-app-Overview-CISCAT-last-scan-not-checked'\"]",
			ciscatScanScore: "[vis-id=\"'Wazuh-app-Overview-CISCAT-last-scan-score'\"]",
			ciscatScanPass: "[vis-id=\"'Wazuh-app-Overview-CISCAT-last-scan-pass'\"]",
			ciscatScanFail: "[vis-id=\"'Wazuh-app-Overview-CISCAT-last-scan-fail'\"]",
			ciscatScanTimestamp: "[vis-id=\"'Wazuh-app-Overview-CISCAT-last-scan-timestamp'\"]",
			ciscatScanError: "[vis-id=\"'Wazuh-app-Overview-CISCAT-last-scan-error'\"]",
			ciscatScanBenchmark: "[vis-id=\"'Wazuh-app-Overview-CISCAT-last-scan-benchmark'\"]",
			ciscatScanUnknown: "[vis-id=\"'Wazuh-app-Overview-CISCAT-last-scan-unknown'\"]"
		};
		var metricsVirustotal = {
			virusMalicious: "[vis-id=\"'Wazuh-App-Overview-Virustotal-Total-Malicious'\"]",
			virusPositives: "[vis-id=\"'Wazuh-App-Overview-Virustotal-Total-Positives'\"]",
			virusTotal: "[vis-id=\"'Wazuh-App-Overview-Virustotal-Total'\"]"
		};
		var metricsOsquery = {
			osqueryAgentsReporting: "[vis-id=\"'Wazuh-App-Overview-Osquery-Agents-reporting'\"]"
		};
		exports.default = {
			metricsGeneral: metricsGeneral,
			metricsAudit: metricsAudit,
			metricsVulnerability: metricsVulnerability,
			metricsScap: metricsScap,
			metricsCiscat: metricsCiscat,
			metricsVirustotal: metricsVirustotal,
			metricsOsquery: metricsOsquery
		};
		module.exports = exports["default"]
	},
	5326: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var _groups = __webpack_require__(5327);
		var _configuration = __webpack_require__(5328);
		var _decoders = __webpack_require__(5336);
		var _logs = __webpack_require__(5337);
		var _management = __webpack_require__(5338);
		var _rules = __webpack_require__(5339);
		var _status = __webpack_require__(5340);
		var _monitoring = __webpack_require__(5341);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.controller("managementController", _management.ManagementController).controller("managementConfigurationController", _configuration.ConfigurationController).controller("decodersController", _decoders.DecodersController).controller("groupsPreviewController", _groups.GroupsController).controller("managerLogController", _logs.LogsController).controller("rulesController", _rules.RulesController).controller("managerStatusController", _status.StatusController).controller("clusterController", _monitoring.ClusterController)
	},
	5327: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _slicedToArray = function ()
		{
			function sliceIterator(arr, i)
			{
				var _arr = [];
				var _n = true;
				var _d = false;
				var _e = void 0;
				try
				{
					for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true)
					{
						_arr.push(_s.value);
						if (i && _arr.length === i) break
					}
				}
				catch (err)
				{
					_d = true;
					_e = err
				}
				finally
				{
					try
					{
						!_n && _i["return"] && _i["return"]()
					}
					finally
					{
						if (_d) throw _e
					}
				}
				return _arr
			}
			return function (arr, i)
			{
				if (Array.isArray(arr)) return arr;
				if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
				throw new TypeError("Invalid attempt to destructure non-iterable instance")
			}
		}();
		exports.GroupsController = GroupsController;
		var _jsonBeautifier = __webpack_require__(1697);
		var _jsonBeautifier2 = _interopRequireDefault(_jsonBeautifier);
		var _fileSaver = __webpack_require__(398);
		var FileSaver = _interopRequireWildcard(_fileSaver);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _toConsumableArray(arr)
		{
			if (Array.isArray(arr))
			{
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2
			}
			return Array.from(arr)
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function GroupsController($scope, $location, apiReq, errorHandler, csvReq, appState, shareAgent, groupHandler, wzTableFilter, wazuhConfig)
		{
			var _this = this;
			$scope.addingGroup = false;
			$scope.$on("groupsIsReloaded", function ()
			{
				$scope.groupsSelectedTab = false;
				$scope.editingFile = false;
				$scope.currentGroup = false;
				$scope.$emit("removeCurrentGroup");
				$scope.lookingGroup = false;
				$scope.$$phase || $scope.$digest()
			});
			$scope.load = true;
			$scope.downloadCsv = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(data_path)
			{
				var currentApi, output, blob;
				return regeneratorRuntime.wrap(function _callee$(_context)
				{
					while (1) switch (_context.prev = _context.next)
					{
					case 0:
						_context.prev = 0;
						errorHandler.info("Your download should begin automatically...", "CSV");
						currentApi = JSON.parse(appState.getCurrentAPI()).id;
						_context.next = 5;
						return csvReq.fetch(data_path, currentApi, wzTableFilter.get());
					case 5:
						output = _context.sent;
						blob = new Blob([output],
						{
							type: "text/csv"
						});
						FileSaver.saveAs(blob, "groups.csv");
						return _context.abrupt("return");
					case 11:
						_context.prev = 11;
						_context.t0 = _context["catch"](0);
						errorHandler.handle(_context.t0, "Download CSV");
					case 14:
						return _context.abrupt("return");
					case 15:
					case "end":
						return _context.stop()
					}
				}, _callee, _this, [
					[0, 11]
				])
			})), function (_x)
			{
				return _ref.apply(this, arguments)
			});
			var _ref;
			$scope.search = function (term)
			{
				$scope.$broadcast("wazuhSearch",
				{
					term: term
				})
			};
			var globalAgent = shareAgent.getAgent();
			var load = (_ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2()
			{
				var globalGroup, data, filtered, configuration;
				return regeneratorRuntime.wrap(function _callee2$(_context2)
				{
					while (1) switch (_context2.prev = _context2.next)
					{
					case 0:
						_context2.prev = 0;
						if (!globalAgent)
						{
							_context2.next = 15;
							break
						}
						globalGroup = shareAgent.getSelectedGroup();
						_context2.next = 5;
						return apiReq.request("GET", "/agents/groups/",
						{
							limit: 1e3
						});
					case 5:
						data = _context2.sent;
						filtered = data.data.data.items.filter(function (group)
						{
							return group.name === globalGroup
						});
						if (!(Array.isArray(filtered) && filtered.length))
						{
							_context2.next = 13;
							break
						}
						$scope.loadGroup(filtered[0], true);
						$scope.lookingGroup = true;
						$scope.addingAgents = false;
						_context2.next = 14;
						break;
					case 13:
						throw Error("Group " + globalGroup + " not found");
					case 14:
						shareAgent.deleteAgent();
					case 15:
						configuration = wazuhConfig.getConfig();
						$scope.adminMode = !!(configuration ||
						{}).admin;
						$scope.load = false;
						$scope.$$phase || $scope.$digest();
						_context2.next = 24;
						break;
					case 21:
						_context2.prev = 21;
						_context2.t0 = _context2["catch"](0);
						errorHandler.handle(_context2.t0, "Groups");
					case 24:
						return _context2.abrupt("return");
					case 25:
					case "end":
						return _context2.stop()
					}
				}, _callee2, _this, [
					[0, 21]
				])
			})), function load()
			{
				return _ref2.apply(this, arguments)
			});
			var _ref2;
			load();
			$scope.toggle = function ()
			{
				return $scope.lookingGroup = true
			};
			$scope.showAgent = function (agent)
			{
				shareAgent.setAgent(agent);
				$location.search("tab", null);
				$location.path("/agents")
			};
			$scope.loadGroup = (_ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(group, firstTime)
			{
				var count;
				return regeneratorRuntime.wrap(function _callee3$(_context3)
				{
					while (1) switch (_context3.prev = _context3.next)
					{
					case 0:
						_context3.prev = 0;
						firstTime || ($scope.lookingGroup = true);
						_context3.next = 4;
						return apiReq.request("GET", "/agents/groups/" + group.name + "/files",
						{
							limit: 1
						});
					case 4:
						count = _context3.sent;
						$scope.totalFiles = count.data.data.totalItems;
						$scope.fileViewer = false;
						$scope.currentGroup = group;
						$scope.$emit("setCurrentGroup",
						{
							currentGroup: $scope.currentGroup
						});
						$scope.fileViewer = false;
						$scope.$$phase || $scope.$digest();
						_context3.next = 16;
						break;
					case 13:
						_context3.prev = 13;
						_context3.t0 = _context3["catch"](0);
						errorHandler.handle(_context3.t0, "Groups");
					case 16:
						return _context3.abrupt("return");
					case 17:
					case "end":
						return _context3.stop()
					}
				}, _callee3, _this, [
					[0, 13]
				])
			})), function (_x2, _x3)
			{
				return _ref3.apply(this, arguments)
			});
			var _ref3;
			$scope.$on("wazuhShowGroup", function (event, parameters)
			{
				$scope.groupsSelectedTab = "agents";
				return $scope.loadGroup(parameters.group)
			});
			$scope.$on("wazuhShowGroupFile", function (event, parameters)
			{
				if (((parameters ||
					{}).fileName || "").includes("agent.conf") && $scope.adminMode) return $scope.editGroupAgentConfig();
				return $scope.showFile(parameters.groupName, parameters.fileName)
			});
			var updateGroupInformation = (_ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(event, parameters)
			{
				var result, _result$map, _result$map2, count, sums, updatedGroup;
				return regeneratorRuntime.wrap(function _callee4$(_context4)
				{
					while (1) switch (_context4.prev = _context4.next)
					{
					case 0:
						_context4.prev = 0;
						if (!$scope.currentGroup)
						{
							_context4.next = 17;
							break
						}
						_context4.t0 = Promise;
						_context4.next = 5;
						return apiReq.request("GET", "/agents/groups/" + parameters.group,
						{
							limit: 1
						});
					case 5:
						_context4.t1 = _context4.sent;
						_context4.next = 8;
						return apiReq.request("GET", "/agents/groups",
						{
							search: parameters.group
						});
					case 8:
						_context4.t2 = _context4.sent;
						_context4.t3 = [_context4.t1, _context4.t2];
						_context4.next = 12;
						return _context4.t0.all.call(_context4.t0, _context4.t3);
					case 12:
						result = _context4.sent;
						_result$map = result.map(function (item)
						{
							return ((item ||
							{}).data ||
							{}).data || false
						}), _result$map2 = _slicedToArray(_result$map, 2), count = _result$map2[0], sums = _result$map2[1];
						updatedGroup = ((sums ||
						{}).items || []).find(function (item)
						{
							return item.name === parameters.group
						});
						$scope.currentGroup.count = (count ||
						{}).totalItems || 0;
						if (updatedGroup)
						{
							$scope.currentGroup.configSum = updatedGroup.configSum;
							$scope.currentGroup.mergedSum = updatedGroup.mergedSum
						}
					case 17:
						_context4.next = 22;
						break;
					case 19:
						_context4.prev = 19;
						_context4.t4 = _context4["catch"](0);
						errorHandler.handle(_context4.t4, "Groups");
					case 22:
						$scope.$$phase || $scope.$digest();
						return _context4.abrupt("return");
					case 24:
					case "end":
						return _context4.stop()
					}
				}, _callee4, _this, [
					[0, 19]
				])
			})), function updateGroupInformation(_x4, _x5)
			{
				return _ref4.apply(this, arguments)
			});
			var _ref4;
			$scope.$on("updateGroupInformation", updateGroupInformation);
			$scope.goBackToAgents = function ()
			{
				$scope.groupsSelectedTab = "agents";
				$scope.file = false;
				$scope.filename = false;
				$scope.$$phase || $scope.$digest()
			};
			$scope.goBackFiles = function ()
			{
				$scope.groupsSelectedTab = "files";
				$scope.addingAgents = false;
				$scope.editingFile = false;
				$scope.file = false;
				$scope.filename = false;
				$scope.fileViewer = false;
				$scope.$$phase || $scope.$digest()
			};
			$scope.goBackGroups = function ()
			{
				$scope.currentGroup = false;
				$scope.$emit("removeCurrentGroup");
				$scope.lookingGroup = false;
				$scope.editingFile = false;
				$scope.$$phase || $scope.$digest()
			};
			$scope.showFile = (_ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(groupName, fileName)
			{
				var tmpName, data;
				return regeneratorRuntime.wrap(function _callee5$(_context5)
				{
					while (1) switch (_context5.prev = _context5.next)
					{
					case 0:
						_context5.prev = 0;
						$scope.filename && ($scope.filename = "");
						"../ar.conf" === fileName && (fileName = "ar.conf");
						$scope.fileViewer = true;
						tmpName = "/agents/groups/" + groupName + "/files/" + fileName;
						_context5.next = 7;
						return apiReq.request("GET", tmpName,
						{});
					case 7:
						data = _context5.sent;
						$scope.file = _jsonBeautifier2.default.prettyPrint(data.data.data);
						$scope.filename = fileName;
						$scope.$$phase || $scope.$digest();
						_context5.next = 16;
						break;
					case 13:
						_context5.prev = 13;
						_context5.t0 = _context5["catch"](0);
						errorHandler.handle(_context5.t0, "Groups");
					case 16:
						return _context5.abrupt("return");
					case 17:
					case "end":
						return _context5.stop()
					}
				}, _callee5, _this, [
					[0, 13]
				])
			})), function (_x6, _x7)
			{
				return _ref5.apply(this, arguments)
			});
			var _ref5;
			var fetchFile = (_ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6()
			{
				var data, xml;
				return regeneratorRuntime.wrap(function _callee6$(_context6)
				{
					while (1) switch (_context6.prev = _context6.next)
					{
					case 0:
						_context6.prev = 0;
						_context6.next = 3;
						return apiReq.request("GET", "/agents/groups/" + $scope.currentGroup.name + "/files/agent.conf",
						{
							format: "xml"
						});
					case 3:
						data = _context6.sent;
						xml = ((data ||
						{}).data ||
						{}).data || false;
						if (xml)
						{
							_context6.next = 7;
							break
						}
						throw new Error("Could not fetch agent.conf file");
					case 7:
						return _context6.abrupt("return", xml);
					case 10:
						_context6.prev = 10;
						_context6.t0 = _context6["catch"](0);
						return _context6.abrupt("return", Promise.reject(_context6.t0));
					case 13:
					case "end":
						return _context6.stop()
					}
				}, _callee6, _this, [
					[0, 10]
				])
			})), function fetchFile()
			{
				return _ref6.apply(this, arguments)
			});
			var _ref6;
			$scope.editGroupAgentConfig = _asyncToGenerator(regeneratorRuntime.mark(function _callee7()
			{
				return regeneratorRuntime.wrap(function _callee7$(_context7)
				{
					while (1) switch (_context7.prev = _context7.next)
					{
					case 0:
						$scope.editingFile = true;
						_context7.prev = 1;
						_context7.next = 4;
						return fetchFile();
					case 4:
						$scope.fetchedXML = _context7.sent;
						$scope.$broadcast("fetchedFile",
						{
							data: $scope.fetchedXML
						});
						_context7.next = 12;
						break;
					case 8:
						_context7.prev = 8;
						_context7.t0 = _context7["catch"](1);
						$scope.fetchedXML = null;
						errorHandler.handle(_context7.t0, "Fetch file error");
					case 12:
						$scope.$$phase || $scope.$digest();
					case 13:
					case "end":
						return _context7.stop()
					}
				}, _callee7, _this, [
					[1, 8]
				])
			}));
			$scope.closeEditingFile = function ()
			{
				$scope.editingFile = false;
				$scope.$broadcast("closeEditXmlFile",
				{})
			};
			$scope.xmlIsValid = function (valid)
			{
				$scope.xmlHasErrors = valid;
				$scope.$$phase || $scope.$digest()
			};
			$scope.doSaveGroupAgentConfig = function ()
			{
				$scope.$broadcast("saveXmlFile",
				{
					group: $scope.currentGroup.name
				})
			};
			$scope.reload = (_ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8(element, searchTerm, addOffset, start)
			{
				return regeneratorRuntime.wrap(function _callee8$(_context8)
				{
					while (1) switch (_context8.prev = _context8.next)
					{
					case 0:
						if (!("left" === element))
						{
							_context8.next = 14;
							break
						}
						if ($scope.availableAgents.loadedAll)
						{
							_context8.next = 12;
							break
						}
						$scope.multipleSelectorLoading = true;
						start ? $scope.selectedAgents.offset = 0 : $scope.availableAgents.offset += addOffset + 1;
						_context8.prev = 4;
						_context8.next = 7;
						return loadAllAgents(searchTerm, start);
					case 7:
						_context8.next = 12;
						break;
					case 9:
						_context8.prev = 9;
						_context8.t0 = _context8["catch"](4);
						errorHandler.handle(_context8.t0, "Error fetching all available agents");
					case 12:
						_context8.next = 19;
						break;
					case 14:
						if ($scope.selectedAgents.loadedAll)
						{
							_context8.next = 19;
							break
						}
						$scope.multipleSelectorLoading = true;
						$scope.selectedAgents.offset += addOffset + 1;
						_context8.next = 19;
						return $scope.loadSelectedAgents(searchTerm);
					case 19:
						$scope.multipleSelectorLoading = false;
						$scope.$$phase || $scope.$digest();
					case 21:
					case "end":
						return _context8.stop()
					}
				}, _callee8, _this, [
					[4, 9]
				])
			})), function (_x8, _x9, _x10, _x11)
			{
				return _ref8.apply(this, arguments)
			});
			var _ref8;
			$scope.loadSelectedAgents = (_ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(searchTerm)
			{
				var params, result, mapped;
				return regeneratorRuntime.wrap(function _callee9$(_context9)
				{
					while (1) switch (_context9.prev = _context9.next)
					{
					case 0:
						_context9.prev = 0;
						params = {
							offset: searchTerm ? 0 : $scope.selectedAgents.offset,
							select: ["id", "name"]
						};
						searchTerm && (params.search = searchTerm);
						_context9.next = 5;
						return apiReq.request("GET", "/agents/groups/" + $scope.currentGroup.name, params);
					case 5:
						result = _context9.sent;
						$scope.totalSelectedAgents = result.data.data.totalItems;
						mapped = result.data.data.items.map(function (item)
						{
							return {
								key: item.id,
								value: item.name
							}
						});
						if (searchTerm)
						{
							$scope.selectedAgents.data = mapped;
							$scope.selectedAgents.loadedAll = true
						}
						else $scope.selectedAgents.data = $scope.selectedAgents.data.concat(mapped);
						(0 === $scope.selectedAgents.data.length || $scope.selectedAgents.data.length < 500 || $scope.selectedAgents.offset >= $scope.totalSelectedAgents) && ($scope.selectedAgents.loadedAll = true);
						_context9.next = 15;
						break;
					case 12:
						_context9.prev = 12;
						_context9.t0 = _context9["catch"](0);
						errorHandler.handle(_context9.t0, "Error fetching group agents");
					case 15:
						$scope.selectedAgents.loaded = true;
					case 16:
					case "end":
						return _context9.stop()
					}
				}, _callee9, _this, [
					[0, 12]
				])
			})), function (_x12)
			{
				return _ref9.apply(this, arguments)
			});
			var _ref9;
			var loadAllAgents = (_ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(searchTerm, start)
			{
				var params, req, mapped;
				return regeneratorRuntime.wrap(function _callee10$(_context10)
				{
					while (1) switch (_context10.prev = _context10.next)
					{
					case 0:
						_context10.prev = 0;
						params = {
							limit: 500,
							offset: searchTerm ? 0 : $scope.availableAgents.offset,
							select: ["id", "name"]
						};
						if (searchTerm)
						{
							params.search = searchTerm;
							$scope.availableAgents.offset = 0
						}
						_context10.next = 5;
						return apiReq.request("GET", "/agents/", params);
					case 5:
						req = _context10.sent;
						$scope.totalAgents = req.data.data.totalItems;
						mapped = req.data.data.items.filter(function (item)
						{
							return 0 == $scope.selectedAgents.data.filter(function (selected)
							{
								return selected.key == item.id
							}).length && "000" !== item.id
						}).map(function (item)
						{
							return {
								key: item.id,
								value: item.name
							}
						});
						$scope.availableAgents.data = searchTerm || start ? mapped : $scope.availableAgents.data.concat(mapped);
						if (!($scope.availableAgents.data.length < 10 && !searchTerm))
						{
							_context10.next = 15;
							break
						}
						$scope.availableAgents.offset >= $scope.totalAgents && ($scope.availableAgents.loadedAll = true);
						if ($scope.availableAgents.loadedAll)
						{
							_context10.next = 15;
							break
						}
						$scope.availableAgents.offset += 499;
						_context10.next = 15;
						return loadAllAgents();
					case 15:
						_context10.next = 20;
						break;
					case 17:
						_context10.prev = 17;
						_context10.t0 = _context10["catch"](0);
						errorHandler.handle(_context10.t0, "Error fetching all available agents");
					case 20:
					case "end":
						return _context10.stop()
					}
				}, _callee10, _this, [
					[0, 17]
				])
			})), function loadAllAgents(_x13, _x14)
			{
				return _ref10.apply(this, arguments)
			});
			var _ref10;
			$scope.addMultipleAgents = (_ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(toggle)
			{
				return regeneratorRuntime.wrap(function _callee11$(_context11)
				{
					while (1) switch (_context11.prev = _context11.next)
					{
					case 0:
						_context11.prev = 0;
						$scope.addingAgents = toggle;
						if (!(toggle && !$scope.availableAgents.loaded))
						{
							_context11.next = 16;
							break
						}
						$scope.availableAgents = {
							loaded: false,
							data: [],
							offset: 0,
							loadedAll: false
						};
						$scope.selectedAgents = {
							loaded: false,
							data: [],
							offset: 0,
							loadedAll: false
						};
						$scope.multipleSelectorLoading = true;
					case 6:
						if ($scope.selectedAgents.loadedAll)
						{
							_context11.next = 12;
							break
						}
						_context11.next = 9;
						return $scope.loadSelectedAgents();
					case 9:
						$scope.selectedAgents.offset += 499;
						_context11.next = 6;
						break;
					case 12:
						$scope.firstSelectedList = [].concat(_toConsumableArray($scope.selectedAgents.data));
						_context11.next = 15;
						return loadAllAgents();
					case 15:
						$scope.multipleSelectorLoading = false;
					case 16:
						_context11.next = 21;
						break;
					case 18:
						_context11.prev = 18;
						_context11.t0 = _context11["catch"](0);
						errorHandler.handle(_context11.t0, "Error adding agents");
					case 21:
						$scope.$$phase || $scope.$digest();
						return _context11.abrupt("return");
					case 23:
					case "end":
						return _context11.stop()
					}
				}, _callee11, _this, [
					[0, 18]
				])
			})), function (_x15)
			{
				return _ref11.apply(this, arguments)
			});
			var _ref11;
			var getItemsToSave = function getItemsToSave()
			{
				var original = $scope.firstSelectedList;
				var modified = $scope.selectedAgents.data;
				$scope.deletedAgents = [];
				$scope.addedAgents = [];
				modified.forEach(function (mod)
				{
					0 === original.filter(function (e)
					{
						return e.key === mod.key
					}).length && $scope.addedAgents.push(mod)
				});
				original.forEach(function (orig)
				{
					0 === modified.filter(function (e)
					{
						return e.key === orig.key
					}).length && $scope.deletedAgents.push(orig)
				});
				var addedIds = [].concat(_toConsumableArray(new Set($scope.addedAgents.map(function (x)
				{
					return x.key
				}))));
				var deletedIds = [].concat(_toConsumableArray(new Set($scope.deletedAgents.map(function (x)
				{
					return x.key
				}))));
				return {
					addedIds: addedIds,
					deletedIds: deletedIds
				}
			};
			$scope.saveAddAgents = _asyncToGenerator(regeneratorRuntime.mark(function _callee12()
			{
				var itemsToSave, failedIds, addResponse, deleteResponse;
				return regeneratorRuntime.wrap(function _callee12$(_context12)
				{
					while (1) switch (_context12.prev = _context12.next)
					{
					case 0:
						itemsToSave = getItemsToSave();
						failedIds = [];
						_context12.prev = 2;
						$scope.multipleSelectorLoading = true;
						if (!itemsToSave.addedIds.length)
						{
							_context12.next = 9;
							break
						}
						_context12.next = 7;
						return apiReq.request("POST", "/agents/group/" + $scope.currentGroup.name,
						{
							ids: itemsToSave.addedIds
						});
					case 7:
						addResponse = _context12.sent;
						addResponse.data.data.failed_ids && failedIds.push.apply(failedIds, _toConsumableArray(addResponse.data.data.failed_ids));
					case 9:
						if (!itemsToSave.deletedIds.length)
						{
							_context12.next = 14;
							break
						}
						_context12.next = 12;
						return apiReq.request("DELETE", "/agents/group/" + $scope.currentGroup.name,
						{
							ids: itemsToSave.deletedIds
						});
					case 12:
						deleteResponse = _context12.sent;
						deleteResponse.data.data.failed_ids && failedIds.push.apply(failedIds, _toConsumableArray(deleteResponse.data.data.failed_ids));
					case 14:
						failedIds.length ? errorHandler.info("Warning. Group has been updated but an error has occurred with the following agents " + failedIds, "", true) : errorHandler.info("Success. Group has been updated", "");
						$scope.addMultipleAgents(false);
						$scope.multipleSelectorLoading = false;
						_context12.next = 19;
						return updateGroupInformation(null,
						{
							group: $scope.currentGroup.name
						});
					case 19:
						_context12.next = 25;
						break;
					case 21:
						_context12.prev = 21;
						_context12.t0 = _context12["catch"](2);
						$scope.multipleSelectorLoading = false;
						errorHandler.handle(_context12.t0, "Error applying changes");
					case 25:
						$scope.$$phase || $scope.$digest();
						return _context12.abrupt("return");
					case 27:
					case "end":
						return _context12.stop()
					}
				}, _callee12, _this, [
					[2, 21]
				])
			}));
			$scope.checkLimit = function ()
			{
				if ($scope.firstSelectedList)
				{
					var itemsToSave = getItemsToSave();
					$scope.currentAdding = itemsToSave.addedIds.length;
					$scope.currentDeleting = itemsToSave.deletedIds.length;
					$scope.moreThan500 = $scope.currentAdding > 500 || $scope.currentDeleting > 500
				}
			};
			$scope.$on("$destroy", function () {});
			$scope.$watch("lookingGroup", function (value)
			{
				$scope.availableAgents = {
					loaded: false,
					data: [],
					offset: 0,
					loadedAll: false
				};
				$scope.selectedAgents = {
					loaded: false,
					data: [],
					offset: 0,
					loadedAll: false
				};
				$scope.addMultipleAgents(false);
				if (!value)
				{
					$scope.file = false;
					$scope.filename = false
				}
			});
			$scope.switchAddingGroup = function ()
			{
				$scope.addingGroup = !$scope.addingGroup
			};
			$scope.createGroup = (_ref13 = _asyncToGenerator(regeneratorRuntime.mark(function _callee13(name)
			{
				return regeneratorRuntime.wrap(function _callee13$(_context13)
				{
					while (1) switch (_context13.prev = _context13.next)
					{
					case 0:
						_context13.prev = 0;
						$scope.addingGroup = false;
						_context13.next = 4;
						return groupHandler.createGroup(name);
					case 4:
						errorHandler.info("Success. Group " + name + " has been created", "");
						_context13.next = 10;
						break;
					case 7:
						_context13.prev = 7;
						_context13.t0 = _context13["catch"](0);
						errorHandler.handle("" + (_context13.t0.message || _context13.t0), "");
					case 10:
						$scope.$broadcast("wazuhSearch",
						{});
					case 11:
					case "end":
						return _context13.stop()
					}
				}, _callee13, _this, [
					[0, 7]
				])
			})), function (_x16)
			{
				return _ref13.apply(this, arguments)
			});
			var _ref13
		}
	},
	5328: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.ConfigurationController = void 0;
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _configHandler = __webpack_require__(1698);

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ConfigurationController = function ()
		{
			function ConfigurationController($scope, $location, errorHandler, apiReq, appState)
			{
				_classCallCheck(this, ConfigurationController);
				this.$scope = $scope;
				this.errorHandler = errorHandler;
				this.apiReq = apiReq;
				this.appState = appState;
				this.$location = $location;
				this.$scope.load = false;
				this.$scope.isArray = Array.isArray;
				this.configurationHandler = new _configHandler.ConfigurationHandler(apiReq, errorHandler);
				this.$scope.currentConfig = null;
				this.$scope.configurationTab = "";
				this.$scope.configurationSubTab = "";
				this.$scope.integrations = {};
				this.$scope.selectedItem = 0
			}
			_createClass(ConfigurationController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					var _this = this;
					this.$scope.getXML = function ()
					{
						return _this.configurationHandler.getXML(_this.$scope)
					};
					this.$scope.getJSON = function ()
					{
						return _this.configurationHandler.getJSON(_this.$scope)
					};
					this.$scope.isString = function (item)
					{
						return "string" === typeof item
					};
					this.$scope.hasSize = function (obj)
					{
						return obj && "object" === ("undefined" === typeof obj ? "undefined" : _typeof(obj)) && Object.keys(obj).length
					};
					this.$scope.switchConfigTab = function (configurationTab, sections)
					{
						var navigate = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						_this.$scope.navigate = navigate;
						try
						{
							_this.$scope.configSubTab = JSON.stringify(
							{
								configurationTab: configurationTab,
								sections: sections
							});
							if (!_this.$location.search().configSubTab)
							{
								_this.appState.setSessionStorageItem("configSubTab", _this.$scope.configSubTab);
								_this.$location.search("configSubTab", true)
							}
						}
						catch (error)
						{
							_this.errorHandler.handle(error, "Set configuration path")
						}
						_this.configurationHandler.switchConfigTab(configurationTab, sections, _this.$scope)
					};
					this.$scope.switchWodle = function (wodleName)
					{
						var navigate = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
						_this.$scope.navigate = navigate;
						_this.$scope.configWodle = wodleName;
						_this.$location.search().configWodle || _this.$location.search("configWodle", _this.$scope.configWodle);
						_this.configurationHandler.switchWodle(wodleName, _this.$scope)
					};
					this.$scope.switchConfigurationTab = function (configurationTab, navigate)
					{
						_this.$scope.navigate = navigate;
						_this.configurationHandler.switchConfigurationTab(configurationTab, _this.$scope);
						if (_this.$scope.navigate)
						{
							_this.$location.search("configSubTab", null);
							_this.appState.removeSessionStorageItem("configSubTab");
							_this.$location.search("configWodle", null)
						}
						else
						{
							var configSubTab = _this.$location.search().configSubTab;
							if (configSubTab) try
							{
								var config = _this.appState.getSessionStorageItem("configSubTab");
								var configSubTabObj = JSON.parse(config);
								_this.$scope.switchConfigTab(configSubTabObj.configurationTab, configSubTabObj.sections, false)
							}
							catch (error)
							{
								_this.errorHandler.handle(error, "Get configuration path")
							}
							else
							{
								var configWodle = _this.$location.search().configWodle;
								configWodle && _this.$scope.switchWodle(configWodle, false)
							}
						}
					};
					this.$scope.switchConfigurationSubTab = function (configurationSubTab)
					{
						return _this.configurationHandler.switchConfigurationSubTab(configurationSubTab, _this.$scope)
					};
					this.$scope.updateSelectedItem = function (i)
					{
						return _this.$scope.selectedItem = i
					};
					this.$scope.getIntegration = function (list)
					{
						return _this.configurationHandler.getIntegration(list, _this.$scope)
					};
					this.$scope.$on("$routeChangeStart", function ()
					{
						return _this.appState.removeSessionStorageItem("configSubTab")
					})
				}
			}]);
			return ConfigurationController
		}()
	},
	5329: function (module, exports, __webpack_require__)
	{
		"use strict";
		var xmlcreate_1 = __webpack_require__(5330);
		var options_1 = __webpack_require__(5332);
		var utils_1 = __webpack_require__(1710);

		function parseString(str, parentElement, options)
		{
			var requiresCdata = function (s)
			{
				return options.cdataInvalidChars && (-1 !== s.indexOf("<") || -1 !== s.indexOf("&")) || -1 !== options.cdataKeys.indexOf(parentElement.name) || -1 !== options.cdataKeys.indexOf("*")
			};
			if (parentElement instanceof xmlcreate_1.XmlElement)
				if (requiresCdata(str))
				{
					var cdataStrs = str.split("]]>");
					for (var i = 0; i < cdataStrs.length; i++)
					{
						requiresCdata(cdataStrs[i]) ? parentElement.cdata(cdataStrs[i]) : parentElement.charData(cdataStrs[i]);
						i < cdataStrs.length - 1 && parentElement.charData("]]>")
					}
				}
			else parentElement.charData(str);
			else parentElement.text(str)
		}

		function parseAttribute(name, value, parentElement, options)
		{
			var attribute = parentElement.attribute(name, "");
			if (!utils_1.isPrimitive(value)) throw new Error("attribute value for name '" + name + "' should be a primitive (string, number, boolean, null, or undefined)");
			parseString(utils_1.stringify(value), attribute, options)
		}

		function parseObjectOrMapEntry(key, value, parentElement, options)
		{
			if (key === options.aliasString)
			{
				if (!utils_1.isString(value)) throw new Error("aliasString value for " + value + " should be a string");
				parentElement.name = value;
				return
			}
			if (0 === key.indexOf(options.attributeString))
			{
				if (!utils_1.isObject(value)) throw new Error("attributes object for " + key + " should be an object");
				for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++)
				{
					var subkey = _a[_i];
					parseAttribute(subkey, value[subkey], parentElement, options)
				}
				return
			}
			if (0 === key.indexOf(options.valueString))
			{
				if (utils_1.isPrimitive(value))
				{
					parseValue(key, value, parentElement, options);
					return
				}
				throw new Error("value " + value + " should be a primitive (string, number, boolean, null, or undefined)")
			}
			var element = parentElement;
			utils_1.isArray(value) || utils_1.isSet(value) || (element = parentElement.element(key));
			parseValue(key, value, element, options)
		}

		function parseObjectOrMap(objectOrMap, parentElement, options)
		{
			if (utils_1.isMap(objectOrMap)) objectOrMap.forEach(function (value, key)
			{
				parseObjectOrMapEntry(utils_1.stringify(key), value, parentElement, options)
			});
			else
				for (var _i = 0, _a = Object.keys(objectOrMap); _i < _a.length; _i++)
				{
					var key = _a[_i];
					parseObjectOrMapEntry(key, objectOrMap[key], parentElement, options)
				}
		}

		function parseArrayOrSet(key, arrayOrSet, parentElement, options)
		{
			var arrayNameFunc;
			options.wrapHandlers.hasOwnProperty("*") && (arrayNameFunc = options.wrapHandlers["*"]);
			options.wrapHandlers.hasOwnProperty(key) && (arrayNameFunc = options.wrapHandlers[key]);
			var arrayKey = key;
			var arrayElement = parentElement;
			if (!utils_1.isUndefined(arrayNameFunc))
			{
				var arrayNameFuncKey = arrayNameFunc(arrayKey, arrayOrSet);
				if (utils_1.isString(arrayNameFuncKey))
				{
					arrayKey = arrayNameFuncKey;
					arrayElement = parentElement.element(key)
				}
				else if (!utils_1.isNull(arrayNameFuncKey)) throw new Error("wrapHandlers function for " + arrayKey + " should return a string or null")
			}
			arrayOrSet.forEach(function (item)
			{
				var element = arrayElement;
				utils_1.isArray(item) || utils_1.isSet(item) || (element = arrayElement.element(arrayKey));
				parseValue(arrayKey, item, element, options)
			})
		}

		function parseValue(key, value, parentElement, options)
		{
			var type = Object.prototype.toString.call(value);
			var handler;
			options.typeHandlers.hasOwnProperty("*") && (handler = options.typeHandlers["*"]);
			options.typeHandlers.hasOwnProperty(type) && (handler = options.typeHandlers[type]);
			utils_1.isUndefined(handler) || (value = handler(value));
			if (utils_1.isObject(value) || utils_1.isMap(value))
			{
				parseObjectOrMap(value, parentElement, options);
				return
			}
			if (utils_1.isArray(value) || utils_1.isSet(value))
			{
				parseArrayOrSet(key, value, parentElement, options);
				return
			}
			parseString(utils_1.stringify(value), parentElement, options)
		}

		function parseToDocument(root, value, options)
		{
			var document = new xmlcreate_1.XmlDocument(root);
			options.declaration.include && document.decl(options.declaration);
			options.dtd.include && document.dtd(options.dtd.name, options.dtd.sysId, options.dtd.pubId);
			parseValue(root, value, document.root(), options);
			return document
		}

		function parse(root, object, options)
		{
			var opts = new options_1.Options(options);
			var document = parseToDocument(root, object, opts);
			return document.toString(opts.format)
		}
		exports.parse = parse
	},
	5330: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var XmlAttribute_1 = __webpack_require__(1699);
		exports.XmlAttribute = XmlAttribute_1.default;
		var XmlAttributeText_1 = __webpack_require__(956);
		exports.XmlAttributeText = XmlAttributeText_1.default;
		var XmlCdata_1 = __webpack_require__(1700);
		exports.XmlCdata = XmlCdata_1.default;
		var XmlCharData_1 = __webpack_require__(1701);
		exports.XmlCharData = XmlCharData_1.default;
		var XmlCharRef_1 = __webpack_require__(957);
		exports.XmlCharRef = XmlCharRef_1.default;
		var XmlComment_1 = __webpack_require__(647);
		exports.XmlComment = XmlComment_1.default;
		var XmlDecl_1 = __webpack_require__(1702);
		exports.XmlDecl = XmlDecl_1.default;
		var XmlDocument_1 = __webpack_require__(5331);
		exports.XmlDocument = XmlDocument_1.default;
		var XmlDtd_1 = __webpack_require__(1703);
		exports.XmlDtd = XmlDtd_1.default;
		var XmlDtdAttlist_1 = __webpack_require__(1704);
		exports.XmlDtdAttlist = XmlDtdAttlist_1.default;
		var XmlDtdElement_1 = __webpack_require__(1705);
		exports.XmlDtdElement = XmlDtdElement_1.default;
		var XmlDtdEntity_1 = __webpack_require__(1706);
		exports.XmlDtdEntity = XmlDtdEntity_1.default;
		var XmlDtdNotation_1 = __webpack_require__(1707);
		exports.XmlDtdNotation = XmlDtdNotation_1.default;
		var XmlDtdParamEntityRef_1 = __webpack_require__(1708);
		exports.XmlDtdParamEntityRef = XmlDtdParamEntityRef_1.default;
		var XmlElement_1 = __webpack_require__(1709);
		exports.XmlElement = XmlElement_1.default;
		var XmlEntityRef_1 = __webpack_require__(958);
		exports.XmlEntityRef = XmlEntityRef_1.default;
		var XmlNode_1 = __webpack_require__(72);
		exports.XmlNode = XmlNode_1.default;
		var XmlProcInst_1 = __webpack_require__(648);
		exports.XmlProcInst = XmlProcInst_1.default;

		function document(root)
		{
			return new XmlDocument_1.default(root)
		}
		exports.document = document
	},
	5331: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var options_1 = __webpack_require__(485);
		var utils_1 = __webpack_require__(64);
		var XmlComment_1 = __webpack_require__(647);
		var XmlDecl_1 = __webpack_require__(1702);
		var XmlDtd_1 = __webpack_require__(1703);
		var XmlElement_1 = __webpack_require__(1709);
		var XmlNode_1 = __webpack_require__(72);
		var XmlProcInst_1 = __webpack_require__(648);
		var XmlDocument = function (_super)
		{
			__extends(XmlDocument, _super);

			function XmlDocument(root)
			{
				var _this = _super.call(this) || this;
				_super.prototype.insertChild.call(_this, new XmlElement_1.default(root));
				return _this
			}
			XmlDocument.prototype.comment = function (content, index)
			{
				void 0 === index && (index = this._children.length);
				var comment = new XmlComment_1.default(content);
				this.insertChild(comment, index);
				return comment
			};
			XmlDocument.prototype.decl = function (options)
			{
				var declaration = new XmlDecl_1.default(options);
				this.insertChild(declaration, 0);
				return declaration
			};
			XmlDocument.prototype.dtd = function (name, sysId, pubId, index)
			{
				var dtd = new XmlDtd_1.default(name, sysId, pubId);
				utils_1.isUndefined(index) && (index = this._children[0] instanceof XmlDecl_1.default ? 1 : 0);
				this.insertChild(dtd, index);
				return dtd
			};
			XmlDocument.prototype.insertChild = function (node, index)
			{
				void 0 === index && (index = this._children.length);
				if (!(node instanceof XmlComment_1.default || node instanceof XmlDecl_1.default || node instanceof XmlDtd_1.default || node instanceof XmlProcInst_1.default)) throw new TypeError("node should be an instance of XmlComment, XmlDecl, XmlDtd, or XmlProcInst");
				if (node instanceof XmlComment_1.default || node instanceof XmlProcInst_1.default)
				{
					if (this._children[0] instanceof XmlDecl_1.default && 0 === index) throw new Error("XmlComment or XmlProcInst node should be inserted after the XmlDecl node")
				}
				else if (node instanceof XmlDecl_1.default)
				{
					if (this._children[0] instanceof XmlDecl_1.default) throw new Error("XmlDocument node should only contain one XmlDecl node");
					if (0 !== index) throw new Error("XmlDecl node should be inserted at the beginning of an XmlDocument node")
				}
				else if (node instanceof XmlDtd_1.default)
				{
					if (this._children[0] instanceof XmlDecl_1.default && 0 === index) throw new Error("XmlDtd node should be inserted after the XmlDecl node");
					for (var i = 0; i < index && i < this._children.length; i++)
						if (this._children[i] instanceof XmlElement_1.default) throw new Error("XmlDtd node should be inserted before the XmlElement node");
					for (var _i = 0, _a = this._children; _i < _a.length; _i++)
					{
						var child = _a[_i];
						if (child instanceof XmlDtd_1.default) throw new Error("XmlDocument node should only contain one XmlDtd node")
					}
				}
				return _super.prototype.insertChild.call(this, node, index)
			};
			XmlDocument.prototype.procInst = function (target, content, index)
			{
				void 0 === index && (index = this._children.length);
				var procInst = new XmlProcInst_1.default(target, content);
				this.insertChild(procInst, index);
				return procInst
			};
			XmlDocument.prototype.removeChild = function (node)
			{
				if (node instanceof XmlElement_1.default) throw new Error("XmlElement nodes cannot be removed from XmlDocument nodes");
				return _super.prototype.removeChild.call(this, node)
			};
			XmlDocument.prototype.removeChildAtIndex = function (index)
			{
				if (this._children[index] instanceof XmlElement_1.default) throw new Error("XmlElement nodes cannot be removed from XmlDocument nodes");
				return _super.prototype.removeChildAtIndex.call(this, index)
			};
			XmlDocument.prototype.root = function ()
			{
				for (var _i = 0, _a = this._children; _i < _a.length; _i++)
				{
					var node = _a[_i];
					if (node instanceof XmlElement_1.default) return node
				}
				throw new Error("XmlDocument does not contain a root node")
			};
			XmlDocument.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				var optionsObj = new options_1.StringOptions(options);
				var str = "";
				for (var _i = 0, _a = this._children; _i < _a.length; _i++)
				{
					var node = _a[_i];
					str += node.toString(options);
					optionsObj.pretty && (str += optionsObj.newline)
				}
				var len = str.length - optionsObj.newline.length;
				str.substr(len) === optionsObj.newline && (str = str.substr(0, len));
				return str
			};
			return XmlDocument
		}(XmlNode_1.default);
		exports.default = XmlDocument
	},
	5332: function (module, exports, __webpack_require__)
	{
		"use strict";
		var utils_1 = __webpack_require__(1710);
		var Options = function ()
		{
			function Options(options)
			{
				void 0 === options && (options = {});
				this.aliasString = "=";
				this.attributeString = "@";
				this.cdataInvalidChars = false;
				this.cdataKeys = [];
				this.valueString = "#";
				if (!utils_1.isObject(options)) throw new TypeError("options should be an Object or undefined");
				if (utils_1.isString(options.aliasString)) this.aliasString = options.aliasString;
				else if (!utils_1.isUndefined(options.aliasString)) throw new TypeError("options.aliasString should be a string or undefined");
				if (utils_1.isString(options.attributeString)) this.attributeString = options.attributeString;
				else if (!utils_1.isUndefined(options.attributeString)) throw new TypeError("options.attributeString should be a string or undefined");
				if (utils_1.isBoolean(options.cdataInvalidChars)) this.cdataInvalidChars = options.cdataInvalidChars;
				else if (!utils_1.isUndefined(options.cdataInvalidChars)) throw new TypeError("options.cdataInvalidChars should be a boolean or undefined");
				if (utils_1.isStringArray(options.cdataKeys)) this.cdataKeys = options.cdataKeys;
				else if (!utils_1.isUndefined(options.cdataKeys)) throw new TypeError("options.cdataKeys should be an Array or undefined");
				this.declaration = new DeclarationOptions(options.declaration);
				this.dtd = new DtdOptions(options.dtd);
				this.format = new FormatOptions(options.format);
				this.typeHandlers = new TypeHandlers(options.typeHandlers);
				if (utils_1.isString(options.valueString)) this.valueString = options.valueString;
				else if (!utils_1.isUndefined(options.valueString)) throw new TypeError("options.valueString should be a string or undefined");
				this.wrapHandlers = new WrapHandlers(options.wrapHandlers)
			}
			return Options
		}();
		exports.Options = Options;
		var DeclarationOptions = function ()
		{
			function DeclarationOptions(declarationOptions)
			{
				void 0 === declarationOptions && (declarationOptions = {});
				this.include = true;
				if (!utils_1.isObject(declarationOptions)) throw new TypeError("options.declaration should be an Object or undefined");
				if (utils_1.isBoolean(declarationOptions.include)) this.include = declarationOptions.include;
				else if (!utils_1.isUndefined(declarationOptions.include)) throw new TypeError("options.declaration.include should be a boolean or undefined");
				this.encoding = declarationOptions.encoding;
				this.standalone = declarationOptions.standalone;
				this.version = declarationOptions.version
			}
			return DeclarationOptions
		}();
		exports.DeclarationOptions = DeclarationOptions;
		var DtdOptions = function ()
		{
			function DtdOptions(dtdOptions)
			{
				void 0 === dtdOptions && (dtdOptions = {});
				this.include = false;
				if (!utils_1.isObject(dtdOptions)) throw new TypeError("options.dtd should be an Object or undefined");
				if (utils_1.isBoolean(dtdOptions.include)) this.include = dtdOptions.include;
				else if (!utils_1.isUndefined(dtdOptions.include)) throw new TypeError("options.dtd.include should be a boolean or undefined");
				this.name = dtdOptions.name;
				this.sysId = dtdOptions.sysId;
				this.pubId = dtdOptions.pubId
			}
			return DtdOptions
		}();
		exports.DtdOptions = DtdOptions;
		var FormatOptions = function ()
		{
			function FormatOptions(formatOptions)
			{
				void 0 === formatOptions && (formatOptions = {});
				if (!utils_1.isObject(formatOptions)) throw new TypeError("options.format should be an Object or undefined");
				this.doubleQuotes = formatOptions.doubleQuotes;
				this.indent = formatOptions.indent;
				this.newline = formatOptions.newline;
				this.pretty = formatOptions.pretty
			}
			return FormatOptions
		}();
		exports.FormatOptions = FormatOptions;
		var TypeHandlers = function ()
		{
			function TypeHandlers(typeHandlers)
			{
				void 0 === typeHandlers && (typeHandlers = {});
				if (!utils_1.isObject(typeHandlers)) throw new TypeError("options.typeHandlers should be an Object or undefined");
				for (var key in typeHandlers)
					if (typeHandlers.hasOwnProperty(key))
					{
						if (!utils_1.isFunction(typeHandlers[key])) throw new TypeError("options.typeHandlers['" + key + "'] should be a Function");
						this[key] = typeHandlers[key]
					}
			}
			return TypeHandlers
		}();
		exports.TypeHandlers = TypeHandlers;
		var WrapHandlers = function ()
		{
			function WrapHandlers(wrapHandlers)
			{
				void 0 === wrapHandlers && (wrapHandlers = {});
				if (!utils_1.isObject(wrapHandlers)) throw new TypeError("options.wrapHandlers should be an Object or undefined");
				for (var key in wrapHandlers)
					if (wrapHandlers.hasOwnProperty(key))
					{
						if (!utils_1.isFunction(wrapHandlers[key])) throw new TypeError("options.wrapHandlers['" + key + "'] should be a Function");
						this[key] = wrapHandlers[key]
					}
			}
			return WrapHandlers
		}();
		exports.WrapHandlers = WrapHandlers
	},
	5333: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.default = function (xml)
		{
			var reg = /(>)\s*(<)(\/*)/g;
			var wsexp = / *(.*) +\n/g;
			var contexp = /(<.+>)(.+\n)/g;
			xml = xml.replace(reg, "$1\n$2$3").replace(wsexp, "$1\n").replace(contexp, "$1\n$2");
			var formatted = "";
			var lines = xml.split("\n");
			var indent = 0;
			var lastType = "other";
			var transitions = {
				"single->single": 0,
				"single->closing": -1,
				"single->opening": 0,
				"single->other": 0,
				"closing->single": 0,
				"closing->closing": -1,
				"closing->opening": 0,
				"closing->other": 0,
				"opening->single": 1,
				"opening->closing": 0,
				"opening->opening": 1,
				"opening->other": 1,
				"other->single": 0,
				"other->closing": -1,
				"other->opening": 0,
				"other->other": 0
			};
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = void 0;
			try
			{
				for (var _step, _iterator = lines[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
				{
					var ln = _step.value;
					if (ln.match(/\s*<\?xml/))
					{
						formatted += ln + "\n";
						continue
					}
					var single = Boolean(ln.match(/<.+\/>/));
					var closing = Boolean(ln.match(/<\/.+>/));
					var opening = Boolean(ln.match(/<[^!].*>/));
					var type = single ? "single" : closing ? "closing" : opening ? "opening" : "other";
					var fromTo = lastType + "->" + type;
					lastType = type;
					var padding = "";
					indent += transitions[fromTo];
					for (var j = 0; j < indent; j++) padding += "\t";
					"opening->closing" == fromTo ? formatted = formatted.substr(0, formatted.length - 1) + ln + "\n" : formatted += padding + ln + "\n"
				}
			}
			catch (err)
			{
				_didIteratorError = true;
				_iteratorError = err
			}
			finally
			{
				try
				{
					!_iteratorNormalCompletion && _iterator.return && _iterator.return()
				}
				finally
				{
					if (_didIteratorError) throw _iteratorError
				}
			}
			return formatted
		};
		module.exports = exports["default"]
	},
	5334: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		exports.queryConfig = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(agentId, sections, apiReq, errorHandler)
		{
			var result, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, section, component, configuration, partialResult;
			return regeneratorRuntime.wrap(function _callee$(_context)
			{
				while (1) switch (_context.prev = _context.next)
				{
				case 0:
					_context.prev = 0;
					if (!(!agentId || "string" !== typeof agentId || !sections || !sections.length || "object" !== ("undefined" === typeof sections ? "undefined" : _typeof(sections)) || !Array.isArray(sections)))
					{
						_context.next = 3;
						break
					}
					throw new Error("Invalid parameters");
				case 3:
					result = {};
					_iteratorNormalCompletion = true;
					_didIteratorError = false;
					_iteratorError = void 0;
					_context.prev = 7;
					_iterator = sections[Symbol.iterator]();
				case 9:
					if (_iteratorNormalCompletion = (_step = _iterator.next()).done)
					{
						_context.next = 27;
						break
					}
					section = _step.value;
					component = section.component, configuration = section.configuration;
					if (!(!component || "string" !== typeof component || !configuration || "string" !== typeof configuration))
					{
						_context.next = 14;
						break
					}
					throw new Error("Invalid section");
				case 14:
					_context.prev = 14;
					_context.next = 17;
					return apiReq.request("GET", "/agents/" + agentId + "/config/" + component + "/" + configuration,
					{});
				case 17:
					partialResult = _context.sent;
					result[component + "-" + configuration] = partialResult.data.data;
					_context.next = 24;
					break;
				case 21:
					_context.prev = 21;
					_context.t0 = _context["catch"](14);
					result[component + "-" + configuration] = errorHandler.handle(_context.t0, "Fetch configuration", false, true);
				case 24:
					_iteratorNormalCompletion = true;
					_context.next = 9;
					break;
				case 27:
					_context.next = 33;
					break;
				case 29:
					_context.prev = 29;
					_context.t1 = _context["catch"](7);
					_didIteratorError = true;
					_iteratorError = _context.t1;
				case 33:
					_context.prev = 33;
					_context.prev = 34;
					!_iteratorNormalCompletion && _iterator.return && _iterator.return();
				case 36:
					_context.prev = 36;
					if (!_didIteratorError)
					{
						_context.next = 39;
						break
					}
					throw _iteratorError;
				case 39:
					return _context.finish(36);
				case 40:
					return _context.finish(33);
				case 41:
					return _context.abrupt("return", result);
				case 44:
					_context.prev = 44;
					_context.t2 = _context["catch"](0);
					return _context.abrupt("return", Promise.reject(_context.t2));
				case 47:
				case "end":
					return _context.stop()
				}
			}, _callee, this, [
				[0, 44],
				[7, 29, 33, 41],
				[14, 21],
				[34, , 36, 40]
			])
		})), function queryConfig(_x, _x2, _x3, _x4)
		{
			return _ref.apply(this, arguments)
		});
		var _ref;

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
	},
	5335: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.objectWithoutProperties = objectWithoutProperties;

		function objectWithoutProperties(obj)
		{
			try
			{
				var result = JSON.parse(JSON.stringify(obj, function (key, val)
				{
					if ("$$hashKey" == key) return;
					return val
				}));
				return result
			}
			catch (error)
			{
				return {}
			}
		}
	},
	5336: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.DecodersController = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _fileSaver = __webpack_require__(398);
		var FileSaver = _interopRequireWildcard(_fileSaver);
		var _colors = __webpack_require__(1711);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.DecodersController = function ()
		{
			function DecodersController($scope, $sce, errorHandler, appState, csvReq, wzTableFilter)
			{
				_classCallCheck(this, DecodersController);
				this.$scope = $scope;
				this.$sce = $sce;
				this.errorHandler = errorHandler;
				this.appState = appState;
				this.csvReq = csvReq;
				this.wzTableFilter = wzTableFilter
			}
			_createClass(DecodersController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					var _this = this;
					this.appliedFilters = [];
					this.searchTerm = "";
					this.viewingDetail = false;
					this.typeFilter = "all";
					this.isArray = Array.isArray;
					this.$scope.$on("rulesetIsReloaded", function ()
					{
						_this.viewingDetail = false;
						_this.$scope.$$phase || _this.$scope.$digest()
					});
					this.$scope.$on("wazuhShowDecoder", function (event, parameters)
					{
						_this.currentDecoder = parameters.decoder;
						_this.viewingDetail = true;
						_this.$scope.$$phase || _this.$scope.$digest()
					})
				}
			},
			{
				key: "includesFilter",
				value: function includesFilter(filterName)
				{
					return this.appliedFilters.map(function (item)
					{
						return item.name
					}).includes(filterName)
				}
			},
			{
				key: "getFilter",
				value: function getFilter(filterName)
				{
					var filtered = this.appliedFilters.filter(function (item)
					{
						return item.name === filterName
					});
					return filtered.length ? filtered[0].value : ""
				}
			},
			{
				key: "removeFilter",
				value: function removeFilter(filterName)
				{
					this.appliedFilters = this.appliedFilters.filter(function (item)
					{
						return item.name !== filterName
					});
					return this.$scope.$broadcast("wazuhRemoveFilter",
					{
						filterName: filterName
					})
				}
			},
			{
				key: "colorRegex",
				value: function colorRegex(regex)
				{
					regex = regex.toString();
					var valuesArray = regex.match(/\(((?!<\/span>).)*?\)(?!<\/span>)/gim);
					var coloredString = regex;
					for (var i = 0, len = valuesArray.length; i < len; i++) coloredString = coloredString.replace(/\(((?!<\/span>).)*?\)(?!<\/span>)/im, '<span style="color: ' + _colors.colors[i] + ' ">' + valuesArray[i] + "</span>");
					return this.$sce.trustAsHtml(coloredString)
				}
			},
			{
				key: "colorOrder",
				value: function colorOrder(order)
				{
					order = order.toString();
					var valuesArray = order.split(",");
					var coloredString = order;
					for (var i = 0, len = valuesArray.length; i < len; i++) coloredString = coloredString.replace(valuesArray[i], '<span style="color: ' + _colors.colors[i] + ' ">' + valuesArray[i] + "</span>");
					return this.$sce.trustAsHtml(coloredString)
				}
			},
			{
				key: "search",
				value: function search(term)
				{
					if (term && term.startsWith("path:") && term.split("path:")[1].trim())
					{
						this.custom_search = "";
						var filter = {
							name: "path",
							value: term.split("path:")[1].trim()
						};
						this.appliedFilters = this.appliedFilters.filter(function (item)
						{
							return "path" !== item.name
						});
						this.appliedFilters.push(filter);
						this.$scope.$broadcast("wazuhFilter",
						{
							filter: filter
						})
					}
					else if (term && term.startsWith("file:") && term.split("file:")[1].trim())
					{
						this.custom_search = "";
						var _filter = {
							name: "file",
							value: term.split("file:")[1].trim()
						};
						this.appliedFilters = this.appliedFilters.filter(function (item)
						{
							return "file" !== item.name
						});
						this.appliedFilters.push(_filter);
						this.$scope.$broadcast("wazuhFilter",
						{
							filter: _filter
						})
					}
					else this.$scope.$broadcast("wazuhSearch",
					{
						term: term,
						removeFilters: true
					})
				}
			},
			{
				key: "onlyParents",
				value: function onlyParents(typeFilter)
				{
					this.appliedFilters = [];
					"all" === typeFilter ? this.$scope.$broadcast("wazuhUpdateInstancePath",
					{
						path: "/decoders"
					}) : this.$scope.$broadcast("wazuhUpdateInstancePath",
					{
						path: "/decoders/parents"
					})
				}
			},
			{
				key: "downloadCsv",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var path, currentApi, output, blob;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								path = "parents" === this.typeFilter ? "/decoders/parents" : "/decoders";
								currentApi = JSON.parse(this.appState.getCurrentAPI()).id;
								_context.next = 5;
								return this.csvReq.fetch(path, currentApi, this.wzTableFilter.get());
							case 5:
								output = _context.sent;
								blob = new Blob([output],
								{
									type: "text/csv"
								});
								FileSaver.saveAs(blob, "decoders.csv");
								return _context.abrupt("return");
							case 11:
								_context.prev = 11;
								_context.t0 = _context["catch"](0);
								this.errorHandler.handle(_context.t0, "Download CSV");
							case 14:
								return _context.abrupt("return");
							case 15:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 11]
						])
					}));

					function downloadCsv()
					{
						return _ref.apply(this, arguments)
					}
					return downloadCsv
				}()
			},
			{
				key: "addDetailFilter",
				value: function addDetailFilter(name, value)
				{
					this.appliedFilters.push(
					{
						name: name,
						value: value
					});
					this.searchTerm = "";
					this.closeDetailView()
				}
			},
			{
				key: "closeDetailView",
				value: function closeDetailView(clear)
				{
					clear && (this.appliedFilters = this.appliedFilters.slice(0, this.appliedFilters.length - 1));
					this.viewingDetail = false;
					this.currentDecoder = false;
					this.$scope.$$phase || this.$scope.$digest()
				}
			}]);
			return DecodersController
		}()
	},
	5337: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.LogsController = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _fileSaver = __webpack_require__(398);
		var FileSaver = _interopRequireWildcard(_fileSaver);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		var LogsController = function ()
		{
			function LogsController($scope, apiReq, errorHandler, csvReq, appState, wzTableFilter)
			{
				_classCallCheck(this, LogsController);
				this.$scope = $scope;
				this.apiReq = apiReq;
				this.errorHandler = errorHandler;
				this.csvReq = csvReq;
				this.appState = appState;
				this.wzTableFilter = wzTableFilter;
				this.nodeList = false;
				this.type_log = "all";
				this.category = "all"
			}
			_createClass(LogsController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					this.initialize()
				}
			},
			{
				key: "search",
				value: function search(term)
				{
					this.$scope.$broadcast("wazuhSearch",
					{
						term: term
					})
				}
			},
			{
				key: "filter",
				value: function filter(_filter)
				{
					this.$scope.$broadcast("wazuhFilter",
					{
						filter: _filter
					})
				}
			},
			{
				key: "playRealtime",
				value: function playRealtime()
				{
					this.realtime = true;
					this.$scope.$broadcast("wazuhPlayRealTime")
				}
			},
			{
				key: "stopRealtime",
				value: function stopRealtime()
				{
					this.realtime = false;
					this.$scope.$broadcast("wazuhStopRealTime")
				}
			},
			{
				key: "downloadCsv",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var currentApi, path, output, blob;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								this.errorHandler.info("Your download should begin automatically...", "CSV");
								currentApi = JSON.parse(this.appState.getCurrentAPI()).id;
								path = this.selectedNode ? "/cluster/" + this.selectedNode + "/logs" : "/manager/logs";
								_context.next = 6;
								return this.csvReq.fetch(path, currentApi, this.wzTableFilter.get());
							case 6:
								output = _context.sent;
								blob = new Blob([output],
								{
									type: "text/csv"
								});
								FileSaver.saveAs(blob, "logs.csv");
								return _context.abrupt("return");
							case 12:
								_context.prev = 12;
								_context.t0 = _context["catch"](0);
								this.errorHandler.handle(_context.t0, "Download CSV");
							case 15:
								return _context.abrupt("return");
							case 16:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 12]
						])
					}));

					function downloadCsv()
					{
						return _ref.apply(this, arguments)
					}
					return downloadCsv
				}()
			},
			{
				key: "changeNode",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(node)
					{
						var summary, daemons;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								this.type_log = "all";
								this.category = "all";
								this.selectedNode = node;
								this.$scope.$broadcast("wazuhUpdateInstancePath",
								{
									path: "/cluster/" + node + "/logs"
								});
								_context2.next = 7;
								return this.apiReq.request("GET", "/cluster/" + node + "/logs/summary",
								{});
							case 7:
								summary = _context2.sent;
								daemons = summary.data.data;
								this.daemons = Object.keys(daemons).map(function (item)
								{
									return {
										title: item
									}
								});
								this.$scope.$$phase || this.$scope.$digest();
								_context2.next = 16;
								break;
							case 13:
								_context2.prev = 13;
								_context2.t0 = _context2["catch"](0);
								this.errorHandler.handle(_context2.t0, "Logs");
							case 16:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 13]
						])
					}));

					function changeNode(_x)
					{
						return _ref2.apply(this, arguments)
					}
					return changeNode
				}()
			},
			{
				key: "initialize",
				value: function ()
				{
					var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3()
					{
						var clusterStatus, clusterEnabled, nodeList, data, daemons;
						return regeneratorRuntime.wrap(function _callee3$(_context3)
						{
							while (1) switch (_context3.prev = _context3.next)
							{
							case 0:
								_context3.prev = 0;
								_context3.next = 3;
								return this.apiReq.request("GET", "/cluster/status",
								{});
							case 3:
								clusterStatus = _context3.sent;
								clusterEnabled = "yes" === (((clusterStatus ||
								{}).data ||
								{}).data ||
								{}).running && "yes" === (((clusterStatus ||
								{}).data ||
								{}).data ||
								{}).enabled;
								if (!clusterEnabled)
								{
									_context3.next = 10;
									break
								}
								_context3.next = 8;
								return this.apiReq.request("GET", "/cluster/nodes",
								{});
							case 8:
								nodeList = _context3.sent;
								if (Array.isArray((((nodeList ||
									{}).data ||
									{}).data ||
									{}).items))
								{
									this.nodeList = nodeList.data.data.items.map(function (item)
									{
										return item.name
									}).reverse();
									this.selectedNode = nodeList.data.data.items.filter(function (item)
									{
										return "master" === item.type
									})[0].name
								}
							case 10:
								this.logsPath = clusterEnabled ? "/cluster/" + this.selectedNode + "/logs" : "/manager/logs";
								if (!clusterEnabled)
								{
									_context3.next = 17;
									break
								}
								_context3.next = 14;
								return this.apiReq.request("GET", "/cluster/" + this.selectedNode + "/logs/summary",
								{});
							case 14:
								_context3.t0 = _context3.sent;
								_context3.next = 20;
								break;
							case 17:
								_context3.next = 19;
								return this.apiReq.request("GET", "/manager/logs/summary",
								{});
							case 19:
								_context3.t0 = _context3.sent;
							case 20:
								data = _context3.t0;
								daemons = data.data.data;
								this.daemons = Object.keys(daemons).map(function (item)
								{
									return {
										title: item
									}
								});
								this.$scope.$$phase || this.$scope.$digest();
								return _context3.abrupt("return");
							case 27:
								_context3.prev = 27;
								_context3.t1 = _context3["catch"](0);
								this.errorHandler.handle(_context3.t1, "Logs");
							case 30:
								return _context3.abrupt("return");
							case 31:
							case "end":
								return _context3.stop()
							}
						}, _callee3, this, [
							[0, 27]
						])
					}));

					function initialize()
					{
						return _ref3.apply(this, arguments)
					}
					return initialize
				}()
			}]);
			return LogsController
		}();
		exports.LogsController = LogsController
	},
	5338: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.ManagementController = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _tabNames = __webpack_require__(646);

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ManagementController = function ()
		{
			function ManagementController($scope, $location, shareAgent)
			{
				var _this = this;
				_classCallCheck(this, ManagementController);
				this.$scope = $scope;
				this.$location = $location;
				this.shareAgent = shareAgent;
				this.tab = "welcome";
				this.rulesetTab = "rules";
				this.tabNames = _tabNames.TabNames;
				this.wazuhManagementTabs = ["ruleset", "groups"];
				this.statusReportsTabs = ["status", "logs", "reporting", "monitoring"];
				this.currentGroup = false;
				this.$scope.$on("setCurrentGroup", function (ev, params)
				{
					_this.currentGroup = (params ||
					{}).currentGroup || false
				});
				this.$scope.$on("removeCurrentGroup", function ()
				{
					_this.currentGroup = false
				})
			}
			_createClass(ManagementController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					if (this.shareAgent.getAgent() && this.shareAgent.getSelectedGroup())
					{
						this.tab = "groups";
						this.switchTab(this.tab);
						return
					}
					var location = this.$location.search();
					if (location && location.tab)
					{
						this.tab = location.tab;
						this.switchTab(this.tab)
					}
				}
			},
			{
				key: "inArray",
				value: function inArray(item, array)
				{
					return item && Array.isArray(array) && array.includes(item)
				}
			},
			{
				key: "switchTab",
				value: function switchTab(tab)
				{
					this.tab = tab;
					"groups" === this.tab && this.$scope.$broadcast("groupsIsReloaded");
					if ("ruleset" === this.tab)
					{
						this.$scope.$broadcast("rulesetIsReloaded");
						this.globalRuleSet = "ruleset";
						this.globalRulesetTab = this.rulesetTab
					}
					else
					{
						this.globalRuleSet = false;
						this.globalRulesetTab = false
					}
					this.$location.search("tab", this.tab)
				}
			},
			{
				key: "setRulesTab",
				value: function setRulesTab(tab)
				{
					this.rulesetTab = tab;
					this.globalRulesetTab = this.rulesetTab
				}
			}]);
			return ManagementController
		}()
	},
	5339: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		exports.RulesController = RulesController;
		var _fileSaver = __webpack_require__(398);
		var FileSaver = _interopRequireWildcard(_fileSaver);
		var _colors = __webpack_require__(1711);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function RulesController($scope, $sce, errorHandler, appState, csvReq, wzTableFilter, $location, apiReq)
		{
			var _this = this;
			$scope.isObject = function (item)
			{
				return "object" === ("undefined" === typeof item ? "undefined" : _typeof(item))
			};
			$scope.appliedFilters = [];
			$scope.search = function (term)
			{
				if (term && term.startsWith("group:") && term.split("group:")[1].trim())
				{
					$scope.custom_search = "";
					var filter = {
						name: "group",
						value: term.split("group:")[1].trim()
					};
					$scope.appliedFilters = $scope.appliedFilters.filter(function (item)
					{
						return "group" !== item.name
					});
					$scope.appliedFilters.push(filter);
					$scope.$broadcast("wazuhFilter",
					{
						filter: filter
					})
				}
				else if (term && term.startsWith("level:") && term.split("level:")[1].trim())
				{
					$scope.custom_search = "";
					var _filter = {
						name: "level",
						value: term.split("level:")[1].trim()
					};
					$scope.appliedFilters = $scope.appliedFilters.filter(function (item)
					{
						return "level" !== item.name
					});
					$scope.appliedFilters.push(_filter);
					$scope.$broadcast("wazuhFilter",
					{
						filter: _filter
					})
				}
				else if (term && term.startsWith("pci:") && term.split("pci:")[1].trim())
				{
					$scope.custom_search = "";
					var _filter2 = {
						name: "pci",
						value: term.split("pci:")[1].trim()
					};
					$scope.appliedFilters = $scope.appliedFilters.filter(function (item)
					{
						return "pci" !== item.name
					});
					$scope.appliedFilters.push(_filter2);
					$scope.$broadcast("wazuhFilter",
					{
						filter: _filter2
					})
				}
				else if (term && term.startsWith("gdpr:") && term.split("gdpr:")[1].trim())
				{
					$scope.custom_search = "";
					var _filter3 = {
						name: "gdpr",
						value: term.split("gdpr:")[1].trim()
					};
					$scope.appliedFilters = $scope.appliedFilters.filter(function (item)
					{
						return "gdpr" !== item.name
					});
					$scope.appliedFilters.push(_filter3);
					$scope.$broadcast("wazuhFilter",
					{
						filter: _filter3
					})
				}
				else if (term && term.startsWith("file:") && term.split("file:")[1].trim())
				{
					$scope.custom_search = "";
					var _filter4 = {
						name: "file",
						value: term.split("file:")[1].trim()
					};
					$scope.appliedFilters = $scope.appliedFilters.filter(function (item)
					{
						return "file" !== item.name
					});
					$scope.appliedFilters.push(_filter4);
					$scope.$broadcast("wazuhFilter",
					{
						filter: _filter4
					})
				}
				else $scope.$broadcast("wazuhSearch",
				{
					term: term,
					removeFilters: 0
				})
			};
			$scope.includesFilter = function (filterName)
			{
				return $scope.appliedFilters.map(function (item)
				{
					return item.name
				}).includes(filterName)
			};
			$scope.getFilter = function (filterName)
			{
				var filtered = $scope.appliedFilters.filter(function (item)
				{
					return item.name === filterName
				});
				return filtered.length ? filtered[0].value : ""
			};
			$scope.removeFilter = function (filterName)
			{
				$scope.appliedFilters = $scope.appliedFilters.filter(function (item)
				{
					return item.name !== filterName
				});
				return $scope.$broadcast("wazuhRemoveFilter",
				{
					filterName: filterName
				})
			};
			$scope.searchTerm = "";
			$scope.viewingDetail = false;
			$scope.isArray = Array.isArray;
			$scope.colorRuleArg = function (ruleArg)
			{
				ruleArg = ruleArg.toString();
				var valuesArray = ruleArg.match(/\$\(((?!<\/span>).)*?\)(?!<\/span>)/gim);
				var coloredString = ruleArg;
				if (valuesArray && valuesArray.length)
					for (var i = 0, len = valuesArray.length; i < len; i++) coloredString = coloredString.replace(/\$\(((?!<\/span>).)*?\)(?!<\/span>)/im, '<span style="color: ' + _colors.colors[i] + ' ">' + valuesArray[i] + "</span>");
				return $sce.trustAsHtml(coloredString)
			};
			$scope.$on("rulesetIsReloaded", function ()
			{
				$scope.viewingDetail = false;
				$scope.$$phase || $scope.$digest()
			});
			$scope.downloadCsv = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
			{
				var currentApi, output, blob;
				return regeneratorRuntime.wrap(function _callee$(_context)
				{
					while (1) switch (_context.prev = _context.next)
					{
					case 0:
						_context.prev = 0;
						errorHandler.info("Your download should begin automatically...", "CSV");
						currentApi = JSON.parse(appState.getCurrentAPI()).id;
						_context.next = 5;
						return csvReq.fetch("/rules", currentApi, wzTableFilter.get());
					case 5:
						output = _context.sent;
						blob = new Blob([output],
						{
							type: "text/csv"
						});
						FileSaver.saveAs(blob, "rules.csv");
						return _context.abrupt("return");
					case 11:
						_context.prev = 11;
						_context.t0 = _context["catch"](0);
						errorHandler.handle(_context.t0, "Download CSV");
					case 14:
						return _context.abrupt("return");
					case 15:
					case "end":
						return _context.stop()
					}
				}, _callee, _this, [
					[0, 11]
				])
			}));
			$scope.addDetailFilter = function (name, value)
			{
				$scope.appliedFilters.push(
				{
					name: name,
					value: value
				});
				$scope.searchTerm = "";
				$scope.closeDetailView()
			};
			$scope.$on("wazuhShowRule", function (event, parameters)
			{
				$scope.currentRule = parameters.rule;
				(Object.keys(($scope.currentRule ||
				{}).details ||
				{}) || []).length || ($scope.currentRule.details = false);
				$scope.viewingDetail = true;
				$scope.$$phase || $scope.$digest()
			});
			$scope.closeDetailView = function (clear)
			{
				clear && ($scope.appliedFilters = $scope.appliedFilters.slice(0, $scope.appliedFilters.length - 1));
				$scope.viewingDetail = false;
				$scope.currentRule = false;
				$scope.$$phase || $scope.$digest()
			};
			if ($location.search() && $location.search().ruleid)
			{
				var incomingRule = $location.search().ruleid;
				$location.search("ruleid", null);
				apiReq.request("get", "/rules/" + incomingRule,
				{}).then(function (data)
				{
					$scope.currentRule = data.data.data.items[0];
					(Object.keys(($scope.currentRule ||
					{}).details ||
					{}) || []).length || ($scope.currentRule.details = false);
					$scope.viewingDetail = true;
					$scope.$$phase || $scope.$digest()
				}).catch(function ()
				{
					return errorHandler.handle("Error fetching rule: " + incomingRule + " from the Wazuh API", "Ruleset")
				})
			}
		}
	},
	5340: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _slicedToArray = function ()
		{
			function sliceIterator(arr, i)
			{
				var _arr = [];
				var _n = true;
				var _d = false;
				var _e = void 0;
				try
				{
					for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true)
					{
						_arr.push(_s.value);
						if (i && _arr.length === i) break
					}
				}
				catch (err)
				{
					_d = true;
					_e = err
				}
				finally
				{
					try
					{
						!_n && _i["return"] && _i["return"]()
					}
					finally
					{
						if (_d) throw _e
					}
				}
				return _arr
			}
			return function (arr, i)
			{
				if (Array.isArray(arr)) return arr;
				if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
				throw new TypeError("Invalid attempt to destructure non-iterable instance")
			}
		}();
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.StatusController = function ()
		{
			function StatusController($scope, errorHandler, apiReq)
			{
				_classCallCheck(this, StatusController);
				this.$scope = $scope;
				this.errorHandler = errorHandler;
				this.apiReq = apiReq;
				this.load = true;
				this.nodes = [];
				this.selectedNode = false;
				this.clusterError = false
			}
			_createClass(StatusController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					return this.init()
				}
			},
			{
				key: "getDaemonStatusClass",
				value: function getDaemonStatusClass(daemonStatus)
				{
					return "running" === daemonStatus ? "status teal" : "status red"
				}
			},
			{
				key: "init",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var data, parsedData, _parsedData, stats, clusterStatus, managerInfo, active, total, nodes, masterNode, daemons, nodeInfo, _daemons, lastAgentRaw, _lastAgentRaw$data$da, lastAgent;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return Promise.all([this.apiReq.request("GET", "/agents/summary",
								{}), this.apiReq.request("GET", "/cluster/status",
								{}), this.apiReq.request("GET", "/manager/info",
								{})]);
							case 3:
								data = _context.sent;
								parsedData = data.map(function (item)
								{
									return ((item ||
									{}).data ||
									{}).data || false
								});
								_parsedData = _slicedToArray(parsedData, 3), stats = _parsedData[0], clusterStatus = _parsedData[1], managerInfo = _parsedData[2];
								active = stats.Active - 1;
								total = stats.Total - 1;
								this.agentsCountActive = active;
								this.agentsCountDisconnected = stats.Disconnected;
								this.agentsCountNeverConnected = stats["Never connected"];
								this.agentsCountTotal = total;
								this.agentsCoverity = total ? active / total * 100 : 0;
								if (!(clusterStatus && "yes" === clusterStatus.enabled && "yes" === clusterStatus.running))
								{
									_context.next = 30;
									break
								}
								_context.next = 16;
								return this.apiReq.request("GET", "/cluster/nodes",
								{});
							case 16:
								nodes = _context.sent;
								this.nodes = nodes.data.data.items.reverse();
								masterNode = nodes.data.data.items.filter(function (item)
								{
									return "master" === item.type
								})[0];
								_context.next = 21;
								return this.apiReq.request("GET", "/cluster/" + masterNode.name + "/status",
								{});
							case 21:
								daemons = _context.sent;
								this.daemons = daemons.data.data;
								this.selectedNode = masterNode.name;
								_context.next = 26;
								return this.apiReq.request("GET", "/cluster/" + masterNode.name + "/info",
								{});
							case 26:
								nodeInfo = _context.sent;
								this.managerInfo = nodeInfo.data.data;
								_context.next = 39;
								break;
							case 30:
								if (!(clusterStatus && "yes" === clusterStatus.enabled && "no" === clusterStatus.running))
								{
									_context.next = 34;
									break
								}
								this.clusterError = "Cluster is enabled but it's not running, please check your cluster health.";
								_context.next = 39;
								break;
							case 34:
								_context.next = 36;
								return this.apiReq.request("GET", "/manager/status",
								{});
							case 36:
								_daemons = _context.sent;
								this.daemons = _daemons.data.data;
								this.managerInfo = managerInfo;
							case 39:
								_context.next = 41;
								return this.apiReq.request("GET", "/agents",
								{
									limit: 1,
									sort: "-dateAdd"
								});
							case 41:
								lastAgentRaw = _context.sent;
								_lastAgentRaw$data$da = _slicedToArray(lastAgentRaw.data.data.items, 1), lastAgent = _lastAgentRaw$data$da[0];
								this.agentInfo = lastAgent;
								this.load = false;
								this.$scope.$$phase || this.$scope.$digest();
								return _context.abrupt("return");
							case 49:
								_context.prev = 49;
								_context.t0 = _context["catch"](0);
								this.load = false;
								return _context.abrupt("return", this.errorHandler.handle(_context.t0, "Manager"));
							case 53:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 49]
						])
					}));

					function init()
					{
						return _ref.apply(this, arguments)
					}
					return init
				}()
			},
			{
				key: "changeNode",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(node)
					{
						var daemons, nodeInfo;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								this.clusterError = false;
								this.load = true;
								_context2.next = 5;
								return this.apiReq.request("GET", "/cluster/" + node + "/status",
								{});
							case 5:
								daemons = _context2.sent;
								this.daemons = daemons.data.data;
								_context2.next = 9;
								return this.apiReq.request("GET", "/cluster/" + node + "/info",
								{});
							case 9:
								nodeInfo = _context2.sent;
								this.managerInfo = nodeInfo.data.data;
								this.load = false;
								this.$scope.$$phase || this.$scope.$digest();
								_context2.next = 19;
								break;
							case 15:
								_context2.prev = 15;
								_context2.t0 = _context2["catch"](0);
								this.load = false;
								this.clusterError = "Node " + node + " is down";
							case 19:
								this.$scope.$$phase || this.$scope.$digest();
								return _context2.abrupt("return");
							case 21:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 15]
						])
					}));

					function changeNode(_x)
					{
						return _ref2.apply(this, arguments)
					}
					return changeNode
				}()
			}]);
			return StatusController
		}()
	},
	5341: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _slicedToArray = function ()
		{
			function sliceIterator(arr, i)
			{
				var _arr = [];
				var _n = true;
				var _d = false;
				var _e = void 0;
				try
				{
					for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true)
					{
						_arr.push(_s.value);
						if (i && _arr.length === i) break
					}
				}
				catch (err)
				{
					_d = true;
					_e = err
				}
				finally
				{
					try
					{
						!_n && _i["return"] && _i["return"]()
					}
					finally
					{
						if (_d) throw _e
					}
				}
				return _arr
			}
			return function (arr, i)
			{
				if (Array.isArray(arr)) return arr;
				if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
				throw new TypeError("Invalid attempt to destructure non-iterable instance")
			}
		}();
		exports.ClusterController = ClusterController;
		var _filterHandler = __webpack_require__(954);
		var _timefilter = __webpack_require__(27);

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function ClusterController($scope, $rootScope, $timeout, errorHandler, apiReq, $window, $location, discoverPendingUpdates, rawVisualizations, loadedVisualizations, visHandlers, tabVisualizations, appState, genericReq)
		{
			var _this = this;
			_timefilter.timefilter.setRefreshInterval(
			{
				pause: true,
				value: 0
			});
			$scope.search = function (term)
			{
				$scope.$broadcast("wazuhSearch",
				{
					term: term
				})
			};
			var clusterEnabled = appState.getClusterInfo() && "enabled" === appState.getClusterInfo().status;
			$scope.isClusterEnabled = clusterEnabled;
			$scope.isClusterRunning = true;
			$location.search("tabView", "cluster-monitoring");
			$location.search("tab", "monitoring");
			$location.search("_a", null);
			var filterHandler = new _filterHandler.FilterHandler(appState.getCurrentPattern());
			discoverPendingUpdates.removeAll();
			tabVisualizations.removeAll();
			rawVisualizations.removeAll();
			loadedVisualizations.removeAll();
			tabVisualizations.setTab("monitoring");
			tabVisualizations.assign(
			{
				monitoring: 2
			});
			$scope.loading = true;
			$scope.showConfig = false;
			$scope.showNodes = false;
			$scope.currentNode = null;
			$scope.nodeSearchTerm = "";
			var setBooleans = function setBooleans(component)
			{
				$scope.showConfig = "showConfig" === component;
				$scope.showNodes = "showNodes" === component;
				$scope.currentNode = null
			};
			$scope.goAgents = function ()
			{
				$window.location.href = "#/agents-preview"
			};
			$scope.goConfiguration = function ()
			{
				setBooleans("showConfig");
				tabVisualizations.assign(
				{
					monitoring: 1
				});
				assignFilters();
				$rootScope.$broadcast("updateVis")
			};
			$scope.goNodes = function ()
			{
				setBooleans("showNodes");
				tabVisualizations.assign(
				{
					monitoring: 1
				});
				assignFilters();
				$rootScope.$broadcast("updateVis")
			};
			$scope.goBack = function ()
			{
				setBooleans(null);
				tabVisualizations.assign(
				{
					monitoring: 2
				});
				assignFilters();
				$rootScope.$broadcast("updateVis")
			};
			$scope.$on("wazuhShowClusterNode", (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(event, parameters)
			{
				var data, end, start, _end, _start, _end2, _start2;
				return regeneratorRuntime.wrap(function _callee$(_context)
				{
					while (1) switch (_context.prev = _context.next)
					{
					case 0:
						_context.prev = 0;
						tabVisualizations.assign(
						{
							monitoring: 1
						});
						$scope.currentNode = parameters.node;
						_context.next = 5;
						return apiReq.request("GET", "/cluster/healthcheck",
						{
							node: $scope.currentNode.name
						});
					case 5:
						data = _context.sent;
						$scope.currentNode.healthCheck = data.data.data.nodes[$scope.currentNode.name];
						if ($scope.currentNode.healthCheck && $scope.currentNode.healthCheck.status)
						{
							$scope.currentNode.healthCheck.status.last_sync_integrity.duration = "n/a";
							$scope.currentNode.healthCheck.status.last_sync_agentinfo.duration = "n/a";
							$scope.currentNode.healthCheck.status.last_sync_agentgroups.duration = "n/a";
							if ("n/a" !== $scope.currentNode.healthCheck.status.last_sync_integrity.date_start_master && "n/a" !== $scope.currentNode.healthCheck.status.last_sync_integrity.date_end_master)
							{
								end = new Date($scope.currentNode.healthCheck.status.last_sync_integrity.date_end_master);
								start = new Date($scope.currentNode.healthCheck.status.last_sync_integrity.date_start_master);
								$scope.currentNode.healthCheck.status.last_sync_integrity.duration = (end - start) / 1e3 + "s"
							}
							if ("n/a" !== $scope.currentNode.healthCheck.status.last_sync_agentinfo.date_start_master && "n/a" !== $scope.currentNode.healthCheck.status.last_sync_agentinfo.date_end_master)
							{
								_end = new Date($scope.currentNode.healthCheck.status.last_sync_agentinfo.date_end_master);
								_start = new Date($scope.currentNode.healthCheck.status.last_sync_agentinfo.date_start_master);
								$scope.currentNode.healthCheck.status.last_sync_agentinfo.duration = (_end - _start) / 1e3 + "s"
							}
							if ("n/a" !== $scope.currentNode.healthCheck.status.last_sync_agentgroups.date_start_master && "n/a" !== $scope.currentNode.healthCheck.status.last_sync_agentgroups.date_end_master)
							{
								_end2 = new Date($scope.currentNode.healthCheck.status.last_sync_agentgroups.date_end_master);
								_start2 = new Date($scope.currentNode.healthCheck.status.last_sync_agentgroups.date_start_master);
								$scope.currentNode.healthCheck.status.last_sync_agentgroups.duration = (_end2 - _start2) / 1e3 + "s"
							}
						}
						assignFilters($scope.currentNode.name);
						$rootScope.$broadcast("updateVis");
						$scope.$$phase || $scope.$digest();
						_context.next = 16;
						break;
					case 13:
						_context.prev = 13;
						_context.t0 = _context["catch"](0);
						errorHandler.handle(_context.t0, "Cluster");
					case 16:
					case "end":
						return _context.stop()
					}
				}, _callee, _this, [
					[0, 13]
				])
			})), function (_x, _x2)
			{
				return _ref.apply(this, arguments)
			}));
			var _ref;
			var filters = [];
			var assignFilters = function assignFilters()
			{
				var node = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
				try
				{
					filters = [];
					filters.push(filterHandler.managerQuery(appState.getClusterInfo().cluster, true));
					node && filters.push(filterHandler.nodeQuery(node));
					$rootScope.$emit("wzEventFilters",
					{
						filters: filters,
						localChange: false
					});
					$rootScope.$$listenerCount["wzEventFilters"] || $timeout(100).then(function ()
					{
						return assignFilters(node)
					})
				}
				catch (error)
				{
					errorHandler.handle("An error occurred while creating custom filters for visualizations", "Cluster", true)
				}
			};
			var load = (_ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2()
			{
				var status, data, result, _result, nodeList, clusterConfig, version, agents, clusterHealthCheck, visData;
				return regeneratorRuntime.wrap(function _callee2$(_context2)
				{
					while (1) switch (_context2.prev = _context2.next)
					{
					case 0:
						_context2.prev = 0;
						visHandlers.removeAll();
						discoverPendingUpdates.removeAll();
						rawVisualizations.removeAll();
						loadedVisualizations.removeAll();
						_context2.next = 7;
						return apiReq.request("GET", "/cluster/status",
						{});
					case 7:
						status = _context2.sent;
						$scope.status = status.data.data.running;
						if (!("no" === $scope.status))
						{
							_context2.next = 13;
							break
						}
						$scope.isClusterRunning = false;
						$scope.loading = false;
						return _context2.abrupt("return");
					case 13:
						_context2.next = 15;
						return Promise.all([apiReq.request("GET", "/cluster/nodes",
						{}), apiReq.request("GET", "/cluster/config",
						{}), apiReq.request("GET", "/version",
						{}), apiReq.request("GET", "/agents",
						{
							limit: 1
						}), apiReq.request("GET", "/cluster/healthcheck",
						{})]);
					case 15:
						data = _context2.sent;
						result = data.map(function (item)
						{
							return ((item ||
							{}).data ||
							{}).data || false
						});
						_result = _slicedToArray(result, 5), nodeList = _result[0], clusterConfig = _result[1], version = _result[2], agents = _result[3], clusterHealthCheck = _result[4];
						$scope.nodesCount = nodeList.totalItems;
						$scope.configuration = clusterConfig;
						$scope.version = version;
						$scope.agentsCount = agents.totalItems - 1;
						$scope.healthCheck = clusterHealthCheck;
						nodeList.name = $scope.configuration.name;
						nodeList.master_node = $scope.configuration.node_name;
						_context2.next = 27;
						return genericReq.request("POST", "/elastic/visualizations/cluster-monitoring/" + appState.getCurrentPattern(),
						{
							nodes: nodeList
						});
					case 27:
						visData = _context2.sent;
						rawVisualizations.assignItems(visData.data.raw);
						assignFilters();
						$rootScope.$broadcast("updateVis");
						$scope.loading = false;
						$scope.$$phase || $scope.$digest();
						return _context2.abrupt("return");
					case 36:
						_context2.prev = 36;
						_context2.t0 = _context2["catch"](0);
						$scope.loading = false;
						errorHandler.handle(_context2.t0, "Cluster");
					case 40:
					case "end":
						return _context2.stop()
					}
				}, _callee2, _this, [
					[0, 36]
				])
			})), function load()
			{
				return _ref2.apply(this, arguments)
			});
			var _ref2;
			clusterEnabled && load();
			$scope.$on("$destroy", function ()
			{
				$location.search("tabView", null);
				discoverPendingUpdates.removeAll();
				tabVisualizations.removeAll();
				rawVisualizations.removeAll();
				loadedVisualizations.removeAll();
				visHandlers.removeAll()
			})
		}
	},
	5342: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var _agentsPreview = __webpack_require__(5343);
		var _agents = __webpack_require__(5344);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.controller("agentsController", _agents.AgentsController).controller("agentsPreviewController", _agentsPreview.AgentsPreviewController)
	},
	5343: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.AgentsPreviewController = void 0;
		var _slicedToArray = function ()
		{
			function sliceIterator(arr, i)
			{
				var _arr = [];
				var _n = true;
				var _d = false;
				var _e = void 0;
				try
				{
					for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true)
					{
						_arr.push(_s.value);
						if (i && _arr.length === i) break
					}
				}
				catch (err)
				{
					_d = true;
					_e = err
				}
				finally
				{
					try
					{
						!_n && _i["return"] && _i["return"]()
					}
					finally
					{
						if (_d) throw _e
					}
				}
				return _arr
			}
			return function (arr, i)
			{
				if (Array.isArray(arr)) return arr;
				if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
				throw new TypeError("Invalid attempt to destructure non-iterable instance")
			}
		}();
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _fileSaver = __webpack_require__(398);
		var FileSaver = _interopRequireWildcard(_fileSaver);
		var _timefilter = __webpack_require__(27);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		var AgentsPreviewController = function ()
		{
			function AgentsPreviewController($scope, genericReq, appState, $location, errorHandler, csvReq, shareAgent, wzTableFilter, commonData)
			{
				_classCallCheck(this, AgentsPreviewController);
				this.$scope = $scope;
				this.genericReq = genericReq;
				this.appState = appState;
				this.$location = $location;
				this.errorHandler = errorHandler;
				this.csvReq = csvReq;
				this.shareAgent = shareAgent;
				this.wzTableFilter = wzTableFilter;
				this.commonData = commonData
			}
			_createClass(AgentsPreviewController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					var _this = this;
					this.init = true;
					var loc = this.$location.search();
					if ((loc ||
						{}).agent && "000" !== (loc ||
						{}).agent)
					{
						this.commonData.setTimefilter(_timefilter.timefilter.getTime());
						return this.showAgent(
						{
							id: loc.agent
						})
					}
					this.isClusterEnabled = this.appState.getClusterInfo() && "enabled" === this.appState.getClusterInfo().status;
					this.loading = true;
					this.osPlatforms = [];
					this.versions = [];
					this.groups = [];
					this.nodes = [];
					this.mostActiveAgent = {
						name: "",
						id: ""
					};
					loc && loc.tab && (this.submenuNavItem = loc.tab);
					this.$scope.$watch("submenuNavItem", function ()
					{
						_this.$location.search("tab", _this.submenuNavItem)
					});
					this.init = false;
					this.load()
				}
			},
			{
				key: "query",
				value: function query(_query, search)
				{
					this.$scope.$broadcast("wazuhQuery",
					{
						query: _query,
						search: search
					})
				}
			},
			{
				key: "showAgent",
				value: function showAgent(agent)
				{
					this.shareAgent.setAgent(agent);
					this.$location.path("/agents")
				}
			},
			{
				key: "downloadCsv",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var currentApi, output, blob;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								this.errorHandler.info("Your download should begin automatically...", "CSV");
								currentApi = JSON.parse(this.appState.getCurrentAPI()).id;
								_context.next = 5;
								return this.csvReq.fetch("/agents", currentApi, this.wzTableFilter.get());
							case 5:
								output = _context.sent;
								blob = new Blob([output],
								{
									type: "text/csv"
								});
								FileSaver.saveAs(blob, "agents.csv");
								return _context.abrupt("return");
							case 11:
								_context.prev = 11;
								_context.t0 = _context["catch"](0);
								this.errorHandler.handle(_context.t0, "Download CSV");
							case 14:
								return _context.abrupt("return");
							case 15:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 11]
						])
					}));

					function downloadCsv()
					{
						return _ref.apply(this, arguments)
					}
					return downloadCsv
				}()
			},
			{
				key: "load",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2()
					{
						var api, clusterInfo, firstUrlParam, secondUrlParam, pattern, data, _data, agentsUnique, agentsTop, unique, info;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								api = JSON.parse(this.appState.getCurrentAPI()).id;
								clusterInfo = this.appState.getClusterInfo();
								firstUrlParam = "enabled" === clusterInfo.status ? "cluster" : "manager";
								secondUrlParam = clusterInfo[firstUrlParam];
								pattern = this.appState.getCurrentPattern();
								_context2.next = 8;
								return Promise.all([this.genericReq.request("GET", "/api/agents-unique/" + api,
								{}), this.genericReq.request("GET", "/elastic/top/" + firstUrlParam + "/" + secondUrlParam + "/agent.name/" + pattern)]);
							case 8:
								data = _context2.sent;
								_data = _slicedToArray(data, 2), agentsUnique = _data[0], agentsTop = _data[1];
								unique = agentsUnique.data.result;
								this.searchBarModel = {
									status: ["Active", "Disconnected", "Never connected"],
									group: unique.groups,
									version: unique.versions,
									"os.platform": unique.osPlatforms.map(function (x)
									{
										return x.platform
									}),
									"os.version": unique.osPlatforms.map(function (x)
									{
										return x.version
									}),
									"os.name": unique.osPlatforms.map(function (x)
									{
										return x.name
									})
								};
								"enabled" === clusterInfo.status && unique.nodes && (this.searchBarModel.node_name = unique.nodes);
								this.searchBarModel["os.name"] = Array.from(new Set(this.searchBarModel["os.name"]));
								this.searchBarModel["os.version"] = Array.from(new Set(this.searchBarModel["os.version"]));
								this.searchBarModel["os.platform"] = Array.from(new Set(this.searchBarModel["os.platform"]));
								this.groups = unique.groups;
								this.nodes = unique.nodes.map(function (item)
								{
									return {
										id: item
									}
								});
								this.versions = unique.versions.map(function (item)
								{
									return {
										id: item
									}
								});
								this.osPlatforms = unique.osPlatforms;
								this.lastAgent = unique.lastAgent;
								this.agentsCountActive = unique.summary.agentsCountActive;
								this.agentsCountDisconnected = unique.summary.agentsCountDisconnected;
								this.agentsCountNeverConnected = unique.summary.agentsCountNeverConnected;
								this.agentsCountTotal = unique.summary.agentsCountTotal;
								this.agentsCoverity = unique.summary.agentsCoverity;
								if (!("" === agentsTop.data.data))
								{
									_context2.next = 31;
									break
								}
								this.mostActiveAgent.name = this.appState.getClusterInfo().manager;
								this.mostActiveAgent.id = "000";
								_context2.next = 36;
								break;
							case 31:
								this.mostActiveAgent.name = agentsTop.data.data;
								_context2.next = 34;
								return this.genericReq.request("GET", "/elastic/top/" + firstUrlParam + "/" + secondUrlParam + "/agent.id/" + pattern);
							case 34:
								info = _context2.sent;
								"" === info.data.data && "" !== this.mostActiveAgent.name ? this.mostActiveAgent.id = "000" : this.mostActiveAgent.id = info.data.data;
							case 36:
								this.loading = false;
								this.$scope.$$phase || this.$scope.$digest();
								return _context2.abrupt("return");
							case 41:
								_context2.prev = 41;
								_context2.t0 = _context2["catch"](0);
								this.errorHandler.handle(_context2.t0, "Agents Preview");
							case 44:
								return _context2.abrupt("return");
							case 45:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 41]
						])
					}));

					function load()
					{
						return _ref2.apply(this, arguments)
					}
					return load
				}()
			}]);
			return AgentsPreviewController
		}();
		exports.AgentsPreviewController = AgentsPreviewController
	},
	5344: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.AgentsController = void 0;
		var _extends = Object.assign || function (target)
		{
			for (var i = 1; i < arguments.length; i++)
			{
				var source = arguments[i];
				for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key])
			}
			return target
		};
		var _slicedToArray = function ()
		{
			function sliceIterator(arr, i)
			{
				var _arr = [];
				var _n = true;
				var _d = false;
				var _e = void 0;
				try
				{
					for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true)
					{
						_arr.push(_s.value);
						if (i && _arr.length === i) break
					}
				}
				catch (err)
				{
					_d = true;
					_e = err
				}
				finally
				{
					try
					{
						!_n && _i["return"] && _i["return"]()
					}
					finally
					{
						if (_d) throw _e
					}
				}
				return _arr
			}
			return function (arr, i)
			{
				if (Array.isArray(arr)) return arr;
				if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
				throw new TypeError("Invalid attempt to destructure non-iterable instance")
			}
		}();
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _filterHandler = __webpack_require__(954);
		var _generateMetric = __webpack_require__(1695);
		var _tabNames = __webpack_require__(646);
		var _fileSaver = __webpack_require__(398);
		var FileSaver = _interopRequireWildcard(_fileSaver);
		var _tabDescription = __webpack_require__(1696);
		var _agentsMetrics = __webpack_require__(5345);
		var _configHandler = __webpack_require__(1698);
		var _timefilter = __webpack_require__(27);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.AgentsController = function ()
		{
			function AgentsController($scope, $location, $rootScope, appState, apiReq, errorHandler, tabVisualizations, shareAgent, commonData, reportingService, visFactoryService, csvReq, wzTableFilter, $mdDialog, groupHandler, wazuhConfig)
			{
				_classCallCheck(this, AgentsController);
				this.$scope = $scope;
				this.$location = $location;
				this.$rootScope = $rootScope;
				this.appState = appState;
				this.apiReq = apiReq;
				this.errorHandler = errorHandler;
				this.tabVisualizations = tabVisualizations;
				this.shareAgent = shareAgent;
				this.commonData = commonData;
				this.reportingService = reportingService;
				this.visFactoryService = visFactoryService;
				this.csvReq = csvReq;
				this.wzTableFilter = wzTableFilter;
				this.$mdDialog = $mdDialog;
				this.groupHandler = groupHandler;
				this.wazuhConfig = wazuhConfig;
				this.$scope.isArray = Array.isArray;
				this.configurationHandler = new _configHandler.ConfigurationHandler(apiReq, errorHandler);
				this.$scope.currentConfig = null;
				this.$scope.configurationTab = "";
				this.$scope.configurationSubTab = "";
				this.$scope.integrations = {};
				this.$scope.selectedItem = 0;
				this.targetLocation = null;
				this.ignoredTabs = ["syscollector", "welcome", "configuration"];
				this.$scope.showSyscheckFiles = false;
				this.$scope.editGroup = false;
				this.$scope.addingGroupToAgent = false
			}
			_createClass(AgentsController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					var _this = this;
					var savedTimefilter = this.commonData.getTimefilter();
					if (savedTimefilter)
					{
						_timefilter.timefilter.setTime(savedTimefilter);
						this.commonData.removeTimefilter()
					}
					this.$scope.TabDescription = _tabDescription.TabDescription;
					this.$rootScope.reportStatus = false;
					this.$location.search("_a", null);
					this.filterHandler = new _filterHandler.FilterHandler(this.appState.getCurrentPattern());
					this.visFactoryService.clearAll();
					var currentApi = JSON.parse(this.appState.getCurrentAPI()).id;
					var extensions = this.appState.getExtensions(currentApi);
					this.$scope.extensions = extensions;
					this.targetLocation = this.shareAgent.getTargetLocation();
					if (this.targetLocation && "object" === _typeof(this.targetLocation))
					{
						this.$scope.tabView = this.targetLocation.subTab;
						this.$scope.tab = this.targetLocation.tab
					}
					else
					{
						this.$scope.tabView = this.commonData.checkTabViewLocation();
						this.$scope.tab = this.commonData.checkTabLocation()
					}
					this.tabHistory = [];
					this.ignoredTabs.includes(this.$scope.tab) || this.tabHistory.push(this.$scope.tab);
					this.$scope.tabNames = _tabNames.TabNames;
					this.tabVisualizations.assign("agents");
					this.$scope.hostMonitoringTabs = ["general", "fim", "syscollector"];
					this.$scope.systemAuditTabs = ["pm", "audit", "oscap", "ciscat"];
					this.$scope.securityTabs = ["vuls", "virustotal", "osquery"];
					this.$scope.complianceTabs = ["pci", "gdpr"];
					this.$scope.inArray = function (item, array)
					{
						return item && Array.isArray(array) && array.includes(item)
					};
					this.$scope.switchSubtab = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(subtab)
					{
						var force = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						var onlyAgent = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
						var sameTab = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
						var preserveDiscover = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								return _context.abrupt("return", _this.switchSubtab(subtab, force, onlyAgent, sameTab, preserveDiscover));
							case 1:
							case "end":
								return _context.stop()
							}
						}, _callee, _this)
					})), function (_x5)
					{
						return _ref.apply(this, arguments)
					});
					var _ref;
					this.changeAgent = false;
					this.$scope.switchTab = function (tab)
					{
						var force = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						return _this.switchTab(tab, force)
					};
					this.$scope.getAgentStatusClass = function (agentStatus)
					{
						return "Active" === agentStatus ? "teal" : "red"
					};
					this.$scope.formatAgentStatus = function (agentStatus)
					{
						return ["Active", "Disconnected"].includes(agentStatus) ? agentStatus : "Never connected"
					};
					this.$scope.getAgent = (_ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(newAgentId)
					{
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								return _context2.abrupt("return", _this.getAgent(newAgentId));
							case 1:
							case "end":
								return _context2.stop()
							}
						}, _callee2, _this)
					})), function (_x7)
					{
						return _ref2.apply(this, arguments)
					});
					var _ref2;
					this.$scope.goGroups = function (agent, group)
					{
						return _this.goGroups(agent, group)
					};
					this.$scope.analyzeAgents = (_ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(searchTerm)
					{
						return regeneratorRuntime.wrap(function _callee3$(_context3)
						{
							while (1) switch (_context3.prev = _context3.next)
							{
							case 0:
								return _context3.abrupt("return", _this.analyzeAgents(searchTerm));
							case 1:
							case "end":
								return _context3.stop()
							}
						}, _callee3, _this)
					})), function (_x8)
					{
						return _ref3.apply(this, arguments)
					});
					var _ref3;
					this.$scope.downloadCsv = (_ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(path, fileName)
					{
						var filters = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
						return regeneratorRuntime.wrap(function _callee4$(_context4)
						{
							while (1) switch (_context4.prev = _context4.next)
							{
							case 0:
								return _context4.abrupt("return", _this.downloadCsv(path, fileName, filters));
							case 1:
							case "end":
								return _context4.stop()
							}
						}, _callee4, _this)
					})), function (_x10, _x11)
					{
						return _ref4.apply(this, arguments)
					});
					var _ref4;
					this.$scope.search = function (term, specificPath)
					{
						return _this.$scope.$broadcast("wazuhSearch",
						{
							term: term,
							specificPath: specificPath
						})
					};
					this.$scope.searchSyscheckFile = function (term, specificFilter)
					{
						return _this.$scope.$broadcast("wazuhSearch",
						{
							term: term,
							specificFilter: specificFilter
						})
					};
					this.$scope.startVis2Png = function ()
					{
						return _this.startVis2Png()
					};
					this.$scope.$on("$destroy", function ()
					{
						_this.visFactoryService.clearAll()
					});
					this.$scope.isArray = Array.isArray;
					this.$scope.goGroup = function ()
					{
						_this.shareAgent.setAgent(_this.$scope.agent);
						_this.$location.path("/manager/groups")
					};
					var configuration = this.wazuhConfig.getConfig();
					this.$scope.adminMode = !!(configuration ||
					{}).admin;
					try
					{
						this.$scope.getAgent()
					}
					catch (e)
					{
						this.errorHandler.handle("Unexpected exception loading controller", "Agents")
					}
					this.$scope.getXML = function ()
					{
						return _this.configurationHandler.getXML(_this.$scope)
					};
					this.$scope.getJSON = function ()
					{
						return _this.configurationHandler.getJSON(_this.$scope)
					};
					this.$scope.isString = function (item)
					{
						return "string" === typeof item
					};
					this.$scope.hasSize = function (obj)
					{
						return obj && "object" === ("undefined" === typeof obj ? "undefined" : _typeof(obj)) && Object.keys(obj).length
					};
					this.$scope.switchConfigTab = function (configurationTab, sections)
					{
						var navigate = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						_this.$scope.navigate = navigate;
						try
						{
							_this.$scope.configSubTab = JSON.stringify(
							{
								configurationTab: configurationTab,
								sections: sections
							});
							if (!_this.$location.search().configSubTab)
							{
								_this.appState.setSessionStorageItem("configSubTab", _this.$scope.configSubTab);
								_this.$location.search("configSubTab", true)
							}
						}
						catch (error)
						{
							_this.errorHandler.handle(error, "Set configuration path")
						}
						_this.configurationHandler.switchConfigTab(configurationTab, sections, _this.$scope, _this.$scope.agent.id)
					};
					this.$scope.switchWodle = function (wodleName)
					{
						var navigate = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
						_this.$scope.navigate = navigate;
						_this.$scope.configWodle = wodleName;
						_this.$location.search().configWodle || _this.$location.search("configWodle", _this.$scope.configWodle);
						_this.configurationHandler.switchWodle(wodleName, _this.$scope, _this.$scope.agent.id)
					};
					this.$scope.switchConfigurationTab = function (configurationTab, navigate)
					{
						_this.$scope.navigate = navigate;
						_this.configurationHandler.switchConfigurationTab(configurationTab, _this.$scope);
						if (_this.$scope.navigate)
						{
							_this.$location.search("configSubTab", null);
							_this.appState.removeSessionStorageItem("configSubTab");
							_this.$location.search("configWodle", null)
						}
						else
						{
							var configSubTab = _this.$location.search().configSubTab;
							if (configSubTab) try
							{
								var config = _this.appState.getSessionStorageItem("configSubTab");
								var configSubTabObj = JSON.parse(config);
								_this.$scope.switchConfigTab(configSubTabObj.configurationTab, configSubTabObj.sections, false)
							}
							catch (error)
							{
								_this.errorHandler.handle(error, "Get configuration path")
							}
							else
							{
								var configWodle = _this.$location.search().configWodle;
								configWodle && _this.$scope.switchWodle(configWodle, false)
							}
						}
					};
					this.$scope.switchConfigurationSubTab = function (configurationSubTab)
					{
						_this.configurationHandler.switchConfigurationSubTab(configurationSubTab, _this.$scope)
					};
					this.$scope.updateSelectedItem = function (i)
					{
						return _this.$scope.selectedItem = i
					};
					this.$scope.getIntegration = function (list)
					{
						return _this.configurationHandler.getIntegration(list, _this.$scope)
					};
					this.$scope.switchSyscheckFiles = function ()
					{
						_this.$scope.showSyscheckFiles = !_this.$scope.showSyscheckFiles;
						_this.$scope.showSyscheckFiles || _this.$rootScope.$emit("changeTabView",
						{
							tabView: _this.$scope.tabView
						});
						_this.$scope.$$phase || _this.$scope.$digest()
					};
					this.$scope.goDiscover = function ()
					{
						return _this.goDiscover()
					};
					this.$scope.$on("$routeChangeStart", function ()
					{
						return _this.appState.removeSessionStorageItem("configSubTab")
					});
					this.$scope.switchGroupEdit = function ()
					{
						_this.$scope.addingGroupToAgent = false;
						_this.switchGroupEdit()
					};
					this.$scope.showConfirmAddGroup = function (group)
					{
						_this.$scope.addingGroupToAgent = !_this.$scope.addingGroupToAgent && group
					};
					this.$scope.cancelAddGroup = function ()
					{
						return _this.$scope.addingGroupToAgent = false
					};
					this.$scope.confirmAddGroup = function (group)
					{
						_this.groupHandler.addAgentToGroup(group, _this.$scope.agent.id).then(function ()
						{
							return _this.apiReq.request("GET", "/agents/" + _this.$scope.agent.id,
							{})
						}).then(function (agent)
						{
							_this.$scope.agent.group = agent.data.data.group;
							_this.$scope.groups = _this.$scope.groups.filter(function (item)
							{
								return !agent.data.data.group.includes(item)
							});
							_this.$scope.addingGroupToAgent = false;
							_this.errorHandler.info("Group " + group + " has been added.", "");
							_this.$scope.$$phase || _this.$scope.$digest()
						}).catch(function (error)
						{
							_this.$scope.addingGroupToAgent = false;
							_this.errorHandler.handle(error.message || error, "Error adding group to agent")
						})
					}
				}
			},
			{
				key: "createMetrics",
				value: function createMetrics(metricsObject)
				{
					var _this2 = this;
					var _loop = function _loop(key)
					{
						_this2.$scope[key] = function ()
						{
							return (0, _generateMetric.generateMetric)(metricsObject[key])
						}
					};
					for (var key in metricsObject) _loop(key)
				}
			},
			{
				key: "checkMetrics",
				value: function checkMetrics(tab, subtab)
				{
					if ("panels" === subtab) switch (tab)
					{
					case "audit":
						this.createMetrics(_agentsMetrics.metricsAudit);
						break;
					case "vuls":
						this.createMetrics(_agentsMetrics.metricsVulnerability);
						break;
					case "oscap":
						this.createMetrics(_agentsMetrics.metricsScap);
						break;
					case "ciscat":
						this.createMetrics(_agentsMetrics.metricsCiscat);
						break;
					case "virustotal":
						this.createMetrics(_agentsMetrics.metricsVirustotal)
					}
				}
			},
			{
				key: "switchSubtab",
				value: function ()
				{
					var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(subtab)
					{
						var force = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						var onlyAgent = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
						var sameTab = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
						var preserveDiscover = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
						var localChange, condition;
						return regeneratorRuntime.wrap(function _callee5$(_context5)
						{
							while (1) switch (_context5.prev = _context5.next)
							{
							case 0:
								_context5.prev = 0;
								if (!(this.$scope.tabView === subtab && !force))
								{
									_context5.next = 3;
									break
								}
								return _context5.abrupt("return");
							case 3:
								this.visFactoryService.clear(onlyAgent);
								this.$location.search("tabView", subtab);
								localChange = "panels" === subtab && "discover" === this.$scope.tabView && sameTab;
								this.$scope.tabView = subtab;
								if (!(("panels" === subtab || this.targetLocation && "object" === _typeof(this.targetLocation) && "discover" === this.targetLocation.subTab && "discover" === subtab) && !this.ignoredTabs.includes(this.$scope.tab)))
								{
									_context5.next = 14;
									break
								}
								condition = !this.changeAgent && (localChange || preserveDiscover);
								_context5.next = 11;
								return this.visFactoryService.buildAgentsVisualizations(this.filterHandler, this.$scope.tab, subtab, condition, this.$scope.agent.id);
							case 11:
								this.changeAgent = false;
								_context5.next = 15;
								break;
							case 14:
								this.$rootScope.$emit("changeTabView",
								{
									tabView: this.$scope.tabView
								});
							case 15:
								this.checkMetrics(this.$scope.tab, subtab);
								return _context5.abrupt("return");
							case 19:
								_context5.prev = 19;
								_context5.t0 = _context5["catch"](0);
								this.errorHandler.handle(_context5.t0, "Agents");
								return _context5.abrupt("return");
							case 23:
							case "end":
								return _context5.stop()
							}
						}, _callee5, this, [
							[0, 19]
						])
					}));

					function switchSubtab(_x18)
					{
						return _ref5.apply(this, arguments)
					}
					return switchSubtab
				}()
			},
			{
				key: "switchTab",
				value: function ()
				{
					var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(tab)
					{
						var force = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						var agentInfo, pciTabs, gdprTabs, isSync, onlyAgent, sameTab, preserveDiscover, targetSubTab;
						return regeneratorRuntime.wrap(function _callee6$(_context6)
						{
							while (1) switch (_context6.prev = _context6.next)
							{
							case 0:
								if (this.ignoredTabs.includes(tab))
								{
									this.commonData.setRefreshInterval(_timefilter.timefilter.getRefreshInterval());
									_timefilter.timefilter.setRefreshInterval(
									{
										pause: true,
										value: 0
									})
								}
								else this.ignoredTabs.includes(this.$scope.tab) && _timefilter.timefilter.setRefreshInterval(this.commonData.getRefreshInterval());
								_context6.prev = 1;
								if (!((this.$scope ||
									{}).agent || false))
								{
									_context6.next = 7;
									break
								}
								_context6.next = 5;
								return this.apiReq.request("GET", "/agents/" + this.$scope.agent.id,
								{
									select: "status"
								});
							case 5:
								agentInfo = _context6.sent;
								this.$scope.agent.status = (((agentInfo ||
								{}).data ||
								{}).data ||
								{}).status || this.$scope.agent.status;
							case 7:
								_context6.next = 11;
								break;
							case 9:
								_context6.prev = 9;
								_context6.t0 = _context6["catch"](1);
							case 11:
								_context6.prev = 11;
								this.$scope.showSyscheckFiles = false;
								if (!("pci" === tab))
								{
									_context6.next = 19;
									break
								}
								_context6.next = 16;
								return this.commonData.getPCI();
							case 16:
								pciTabs = _context6.sent;
								this.$scope.pciTabs = pciTabs;
								this.$scope.selectedPciIndex = 0;
							case 19:
								if (!("gdpr" === tab))
								{
									_context6.next = 25;
									break
								}
								_context6.next = 22;
								return this.commonData.getPCI();
							case 22:
								gdprTabs = _context6.sent;
								this.$scope.gdprTabs = gdprTabs;
								this.$scope.selectedGdprIndex = 0;
							case 25:
								if (!("syscollector" === tab))
								{
									_context6.next = 33;
									break
								}
								_context6.prev = 26;
								_context6.next = 29;
								return this.loadSyscollector(this.$scope.agent.id);
							case 29:
								_context6.next = 33;
								break;
							case 31:
								_context6.prev = 31;
								_context6.t1 = _context6["catch"](26);
							case 33:
								if (!("configuration" === tab))
								{
									_context6.next = 41;
									break
								}
								_context6.next = 36;
								return this.apiReq.request("GET", "/agents/" + this.$scope.agent.id + "/group/is_sync",
								{});
							case 36:
								isSync = _context6.sent;
								this.$scope.isSynchronized = (((isSync ||
								{}).data ||
								{}).data ||
								{}).synced || false;
								this.$scope.switchConfigurationTab("welcome");
								_context6.next = 42;
								break;
							case 41:
								this.configurationHandler.reset(this.$scope);
							case 42:
								this.ignoredTabs.includes(tab) || this.tabHistory.push(tab);
								this.tabHistory.length > 2 && (this.tabHistory = this.tabHistory.slice(-2));
								this.tabVisualizations.setTab(tab);
								if (!(this.$scope.tab === tab && !force))
								{
									_context6.next = 47;
									break
								}
								return _context6.abrupt("return");
							case 47:
								onlyAgent = this.$scope.tab === tab && force;
								sameTab = this.$scope.tab === tab;
								this.$location.search("tab", tab);
								preserveDiscover = 2 === this.tabHistory.length && this.tabHistory[0] === this.tabHistory[1] && !force;
								this.$scope.tab = tab;
								targetSubTab = this.targetLocation && "object" === _typeof(this.targetLocation) ? this.targetLocation.subTab : "panels";
								this.ignoredTabs.includes(this.$scope.tab) || this.$scope.switchSubtab(targetSubTab, true, onlyAgent, sameTab, preserveDiscover);
								this.shareAgent.deleteTargetLocation();
								this.targetLocation = null;
								_context6.next = 61;
								break;
							case 58:
								_context6.prev = 58;
								_context6.t2 = _context6["catch"](11);
								return _context6.abrupt("return", Promise.reject(_context6.t2));
							case 61:
								this.$scope.$$phase || this.$scope.$digest();
							case 62:
							case "end":
								return _context6.stop()
							}
						}, _callee6, this, [
							[1, 9],
							[11, 58],
							[26, 31]
						])
					}));

					function switchTab(_x20)
					{
						return _ref6.apply(this, arguments)
					}
					return switchTab
				}()
			},
			{
				key: "goDiscover",
				value: function goDiscover()
				{
					this.targetLocation = {
						tab: "general",
						subTab: "discover"
					};
					return this.switchTab("general")
				}
			},
			{
				key: "validateRootCheck",
				value: function validateRootCheck()
				{
					var result = this.commonData.validateRange(this.$scope.agent.rootcheck);
					this.$scope.agent.rootcheck = result
				}
			},
			{
				key: "validateSysCheck",
				value: function validateSysCheck()
				{
					var result = this.commonData.validateRange(this.$scope.agent.syscheck);
					this.$scope.agent.syscheck = result
				}
			},
			{
				key: "loadSyscollector",
				value: function ()
				{
					var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(id)
					{
						var data, result, _result, hardwareResponse, osResponse, portsResponse, packagesDateResponse, processesDateResponse, netifaceResponse, resultNetiface, netaddrResponse, resultNetaddrResponse, packagesDate, processesDate;
						return regeneratorRuntime.wrap(function _callee7$(_context7)
						{
							while (1) switch (_context7.prev = _context7.next)
							{
							case 0:
								_context7.prev = 0;
								_context7.next = 3;
								return Promise.all([this.apiReq.request("GET", "/syscollector/" + id + "/hardware",
								{}), this.apiReq.request("GET", "/syscollector/" + id + "/os",
								{}), this.apiReq.request("GET", "/syscollector/" + id + "/ports",
								{
									limit: 1
								}), this.apiReq.request("GET", "/syscollector/" + id + "/packages",
								{
									limit: 1,
									select: "scan_time"
								}), this.apiReq.request("GET", "/syscollector/" + id + "/processes",
								{
									limit: 1,
									select: "scan_time"
								})]);
							case 3:
								data = _context7.sent;
								result = data.map(function (item)
								{
									return ((item ||
									{}).data ||
									{}).data || false
								});
								_result = _slicedToArray(result, 5), hardwareResponse = _result[0], osResponse = _result[1], portsResponse = _result[2], packagesDateResponse = _result[3], processesDateResponse = _result[4];
								netifaceResponse = false;
								_context7.prev = 7;
								_context7.next = 10;
								return this.apiReq.request("GET", "/syscollector/" + id + "/netiface",
								{});
							case 10:
								resultNetiface = _context7.sent;
								netifaceResponse = ((resultNetiface ||
								{}).data ||
								{}).data || false;
								_context7.next = 16;
								break;
							case 14:
								_context7.prev = 14;
								_context7.t0 = _context7["catch"](7);
							case 16:
								netaddrResponse = false;
								_context7.prev = 17;
								_context7.next = 20;
								return this.apiReq.request("GET", "/syscollector/" + id + "/netaddr",
								{
									limit: 1
								});
							case 20:
								resultNetaddrResponse = _context7.sent;
								netaddrResponse = ((resultNetaddrResponse ||
								{}).data ||
								{}).data || false;
								_context7.next = 26;
								break;
							case 24:
								_context7.prev = 24;
								_context7.t1 = _context7["catch"](17);
							case 26:
								this.$scope.syscollector = {};
								packagesDate = !!packagesDateResponse && _extends(
								{}, packagesDateResponse);
								processesDate = !!processesDateResponse && _extends(
								{}, processesDateResponse);
								this.$scope.syscollector = {
									hardware: !("object" !== ("undefined" === typeof hardwareResponse ? "undefined" : _typeof(hardwareResponse)) || !Object.keys(hardwareResponse).length) && _extends(
									{}, hardwareResponse),
									os: !("object" !== ("undefined" === typeof osResponse ? "undefined" : _typeof(osResponse)) || !Object.keys(osResponse).length) && _extends(
									{}, osResponse),
									netiface: !!netifaceResponse && _extends(
									{}, netifaceResponse),
									ports: !!portsResponse && _extends(
									{}, portsResponse),
									netaddr: !!netaddrResponse && _extends(
									{}, netaddrResponse),
									packagesDate: ((packagesDate ||
									{}).items || []).length ? packagesDate.items[0].scan_time : "Unknown",
									processesDate: ((processesDate ||
									{}).items || []).length ? processesDate.items[0].scan_time : "Unknown"
								};
								return _context7.abrupt("return");
							case 33:
								_context7.prev = 33;
								_context7.t2 = _context7["catch"](0);
								return _context7.abrupt("return", Promise.reject(_context7.t2));
							case 36:
							case "end":
								return _context7.stop()
							}
						}, _callee7, this, [
							[0, 33],
							[7, 14],
							[17, 24]
						])
					}));

					function loadSyscollector(_x21)
					{
						return _ref7.apply(this, arguments)
					}
					return loadSyscollector
				}()
			},
			{
				key: "getAgent",
				value: function ()
				{
					var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8(newAgentId)
					{
						var _this3 = this;
						var globalAgent, id, data, result, _result2, agentInfo, syscheckLastScan, rootcheckLastScan, groups;
						return regeneratorRuntime.wrap(function _callee8$(_context8)
						{
							while (1) switch (_context8.prev = _context8.next)
							{
							case 0:
								_context8.prev = 0;
								this.$scope.isSynchronized = false;
								this.$scope.load = true;
								this.changeAgent = true;
								globalAgent = this.shareAgent.getAgent();
								id = this.commonData.checkLocationAgentId(newAgentId, globalAgent);
								_context8.next = 8;
								return Promise.all([this.apiReq.request("GET", "/agents/" + id,
								{}), this.apiReq.request("GET", "/syscheck/" + id + "/last_scan",
								{}), this.apiReq.request("GET", "/rootcheck/" + id + "/last_scan",
								{})]);
							case 8:
								data = _context8.sent;
								result = data.map(function (item)
								{
									return ((item ||
									{}).data ||
									{}).data || false
								});
								_result2 = _slicedToArray(result, 3), agentInfo = _result2[0], syscheckLastScan = _result2[1], rootcheckLastScan = _result2[2];
								this.$scope.agent = agentInfo;
								if (this.$scope.agent.os)
								{
									this.$scope.agentOS = this.$scope.agent.os.name + " " + this.$scope.agent.os.version;
									this.$scope.agent.isLinuxOS = this.$scope.agent.os.uname.includes("Linux")
								}
								else
								{
									this.$scope.agentOS = "Unknown";
									this.$scope.agent.isLinuxOS = false
								}
								this.$scope.agent.syscheck = syscheckLastScan;
								this.validateSysCheck();
								this.$scope.agent.rootcheck = rootcheckLastScan;
								this.validateRootCheck();
								_context8.next = 19;
								return this.$scope.switchTab(this.$scope.tab, true);
							case 19:
								_context8.next = 21;
								return this.apiReq.request("GET", "/agents/groups",
								{});
							case 21:
								groups = _context8.sent;
								this.$scope.groups = groups.data.data.items.map(function (item)
								{
									return item.name
								}).filter(function (item)
								{
									return _this3.$scope.agent.group && !_this3.$scope.agent.group.includes(item)
								});
								this.$scope.load = false;
								this.$scope.$$phase || this.$scope.$digest();
								return _context8.abrupt("return");
							case 28:
								_context8.prev = 28;
								_context8.t0 = _context8["catch"](0);
								this.errorHandler.handle(_context8.t0, "Agents");
								if (_context8.t0 && "string" === typeof _context8.t0 && _context8.t0.includes("Agent does not exist"))
								{
									this.$location.search("agent", null);
									this.$location.path("/agents-preview")
								}
							case 32:
								return _context8.abrupt("return");
							case 33:
							case "end":
								return _context8.stop()
							}
						}, _callee8, this, [
							[0, 28]
						])
					}));

					function getAgent(_x22)
					{
						return _ref8.apply(this, arguments)
					}
					return getAgent
				}()
			},
			{
				key: "switchGroupEdit",
				value: function switchGroupEdit()
				{
					this.$scope.editGroup = !!!this.$scope.editGroup;
					this.$scope.$$phase || this.$scope.$digest()
				}
			},
			{
				key: "goGroups",
				value: function goGroups(agent, group)
				{
					this.visFactoryService.clearAll();
					this.shareAgent.setAgent(agent, group);
					this.$location.search("tab", "groups");
					this.$location.path("/manager")
				}
			},
			{
				key: "analyzeAgents",
				value: function ()
				{
					var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(searchTerm)
					{
						var reqData, _reqData;
						return regeneratorRuntime.wrap(function _callee9$(_context9)
						{
							while (1) switch (_context9.prev = _context9.next)
							{
							case 0:
								_context9.prev = 0;
								if (!searchTerm)
								{
									_context9.next = 8;
									break
								}
								_context9.next = 4;
								return this.apiReq.request("GET", "/agents",
								{
									search: searchTerm
								});
							case 4:
								reqData = _context9.sent;
								return _context9.abrupt("return", reqData.data.data.items.filter(function (item)
								{
									return "000" !== item.id
								}));
							case 8:
								_context9.next = 10;
								return this.apiReq.request("GET", "/agents",
								{});
							case 10:
								_reqData = _context9.sent;
								return _context9.abrupt("return", _reqData.data.data.items.filter(function (item)
								{
									return "000" !== item.id
								}));
							case 12:
								_context9.next = 17;
								break;
							case 14:
								_context9.prev = 14;
								_context9.t0 = _context9["catch"](0);
								this.errorHandler.handle(_context9.t0, "Agents");
							case 17:
								return _context9.abrupt("return");
							case 18:
							case "end":
								return _context9.stop()
							}
						}, _callee9, this, [
							[0, 14]
						])
					}));

					function analyzeAgents(_x23)
					{
						return _ref9.apply(this, arguments)
					}
					return analyzeAgents
				}()
			},
			{
				key: "downloadCsv",
				value: function ()
				{
					var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(path, fileName)
					{
						var filters = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
						var currentApi, output, blob;
						return regeneratorRuntime.wrap(function _callee10$(_context10)
						{
							while (1) switch (_context10.prev = _context10.next)
							{
							case 0:
								_context10.prev = 0;
								this.errorHandler.info("Your download should begin automatically...", "CSV");
								currentApi = JSON.parse(this.appState.getCurrentAPI()).id;
								_context10.next = 5;
								return this.csvReq.fetch(path, currentApi, filters);
							case 5:
								output = _context10.sent;
								blob = new Blob([output],
								{
									type: "text/csv"
								});
								FileSaver.saveAs(blob, fileName);
								_context10.next = 13;
								break;
							case 10:
								_context10.prev = 10;
								_context10.t0 = _context10["catch"](0);
								this.errorHandler.handle(_context10.t0, "Download CSV");
							case 13:
								return _context10.abrupt("return");
							case 14:
							case "end":
								return _context10.stop()
							}
						}, _callee10, this, [
							[0, 10]
						])
					}));

					function downloadCsv(_x25, _x26)
					{
						return _ref10.apply(this, arguments)
					}
					return downloadCsv
				}()
			},
			{
				key: "startVis2Png",
				value: function startVis2Png()
				{
					var syscollectorFilters = [];
					if ("syscollector" === this.$scope.tab && (this.$scope.agent ||
						{}).id)
					{
						syscollectorFilters.push(this.filterHandler.managerQuery(this.appState.getClusterInfo().cluster, true));
						syscollectorFilters.push(this.filterHandler.agentQuery(this.$scope.agent.id))
					}
					this.reportingService.startVis2Png(this.$scope.tab, (this.$scope.agent ||
					{}).id || true, syscollectorFilters.length ? syscollectorFilters : null)
				}
			}]);
			return AgentsController
		}()
	},
	5345: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var metricsAudit = {
			auditNewFiles: "[vis-id=\"'Wazuh-App-Agents-Audit-New-files-metric'\"]",
			auditReadFiles: "[vis-id=\"'Wazuh-App-Agents-Audit-Read-files-metric'\"]",
			auditModifiedFiles: "[vis-id=\"'Wazuh-App-Agents-Audit-Modified-files-metric'\"]",
			auditRemovedFiles: "[vis-id=\"'Wazuh-App-Agents-Audit-Removed-files-metric'\"]"
		};
		var metricsVulnerability = {
			vulnCritical: "[vis-id=\"'Wazuh-App-Agents-vulnerability-Metric-Critical-severity'\"]",
			vulnHigh: "[vis-id=\"'Wazuh-App-Agents-vulnerability-Metric-High-severity'\"]",
			vulnMedium: "[vis-id=\"'Wazuh-App-Agents-vulnerability-Metric-Medium-severity'\"]",
			vulnLow: "[vis-id=\"'Wazuh-App-Agents-vulnerability-Metric-Low-severity'\"]"
		};
		var metricsScap = {
			scapLastScore: "[vis-id=\"'Wazuh-App-Agents-OSCAP-Last-score'\"]",
			scapHighestScore: "[vis-id=\"'Wazuh-App-Agents-OSCAP-Higher-score-metric'\"]",
			scapLowestScore: "[vis-id=\"'Wazuh-App-Agents-OSCAP-Lower-score-metric'\"]"
		};
		var metricsCiscat = {
			ciscatScanNotChecked: "[vis-id=\"'Wazuh-app-Agents-CISCAT-last-scan-not-checked'\"]",
			ciscatScanScore: "[vis-id=\"'Wazuh-app-Agents-CISCAT-last-scan-score'\"]",
			ciscatScanPass: "[vis-id=\"'Wazuh-app-Agents-CISCAT-last-scan-pass'\"]",
			ciscatScanFail: "[vis-id=\"'Wazuh-app-Agents-CISCAT-last-scan-fail'\"]",
			ciscatScanTimestamp: "[vis-id=\"'Wazuh-app-Agents-CISCAT-last-scan-timestamp'\"]",
			ciscatScanError: "[vis-id=\"'Wazuh-app-Agents-CISCAT-last-scan-error'\"]",
			ciscatScanBenchmark: "[vis-id=\"'Wazuh-app-Agents-CISCAT-last-scan-benchmark'\"]",
			ciscatScanUnknown: "[vis-id=\"'Wazuh-app-Agents-CISCAT-last-scan-unknown'\"]"
		};
		var metricsVirustotal = {
			virusMalicious: "[vis-id=\"'Wazuh-App-Agents-Virustotal-Total-Malicious'\"]",
			virusPositives: "[vis-id=\"'Wazuh-App-Agents-Virustotal-Total-Positives'\"]",
			virusTotal: "[vis-id=\"'Wazuh-App-Agents-Virustotal-Total'\"]"
		};
		exports.default = {
			metricsAudit: metricsAudit,
			metricsVulnerability: metricsVulnerability,
			metricsScap: metricsScap,
			metricsCiscat: metricsCiscat,
			metricsVirustotal: metricsVirustotal
		};
		module.exports = exports["default"]
	},
	5346: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var _settings = __webpack_require__(5347);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.controller("settingsController", _settings.SettingsController)
	},
	5347: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.SettingsController = void 0;
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _base = __webpack_require__(5348);
		var _tabNames = __webpack_require__(646);
		var _configEquivalences = __webpack_require__(5349);

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.SettingsController = function ()
		{
			function SettingsController($scope, $window, $location, testAPI, appState, genericReq, errorHandler, wzMisc, wazuhConfig)
			{
				_classCallCheck(this, SettingsController);
				this.$scope = $scope;
				this.$window = $window;
				this.$location = $location;
				this.testAPI = testAPI;
				this.appState = appState;
				this.genericReq = genericReq;
				this.errorHandler = errorHandler;
				this.wzMisc = wzMisc;
				this.wazuhConfig = wazuhConfig;
				if (this.wzMisc.getWizard())
				{
					$window.sessionStorage.removeItem("healthCheck");
					this.wzMisc.setWizard(false)
				}
				this.apiIsDown = this.wzMisc.getApiIsDown();
				this.currentApiEntryIndex = false;
				this.formData = {};
				this.tab = "api";
				this.load = true;
				this.loadingLogs = true;
				this.addManagerContainer = false;
				this.showEditForm = {};
				this.formUpdate = {};
				this.editingKey = false;
				this.userRegEx = new RegExp(/^.{3,100}$/);
				this.passRegEx = new RegExp(/^.{3,100}$/);
				this.urlRegEx = new RegExp(/^https?:\/\/[a-zA-Z0-9-.]{1,300}$/);
				this.urlRegExIP = new RegExp(/^https?:\/\/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/);
				this.portRegEx = new RegExp(/^[0-9]{2,5}$/);
				this.tabNames = _tabNames.TabNames;
				this.configuration = wazuhConfig.getConfig();
				this.configurationTypes = [];
				for (var key in this.configuration) this.configurationTypes[key] = _typeof(this.configuration[key]);
				this.indexPatterns = [];
				this.apiEntries = [];
				var location = this.$location.search();
				location && location.tab && (this.tab = location.tab);
				this.savingApi = false
			}
			_createClass(SettingsController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					var _this = this;
					this.getSettings().then(function ()
					{
						return _this.getAppInfo()
					})
				}
			},
			{
				key: "switchTab",
				value: function switchTab(tab)
				{
					this.tab = tab;
					this.$location.search("tab", this.tab)
				}
			},
			{
				key: "removeManager",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(item)
					{
						var index, key;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								index = this.apiEntries.indexOf(item);
								this.appState.getCurrentAPI() && this.apiEntries[index]._id === JSON.parse(this.appState.getCurrentAPI()).id && this.appState.removeCurrentAPI();
								_context.next = 5;
								return this.genericReq.request("DELETE", "/elastic/apis/" + this.apiEntries[index]._id);
							case 5:
								this.showEditForm[this.apiEntries[index]._id] = false;
								this.apiEntries.splice(index, 1);
								this.wzMisc.setApiIsDown(false);
								this.apiIsDown = false;
								this.isEditing = false;
								for (key in this.showEditForm) this.showEditForm[key] = false;
								this.$scope.$emit("updateAPI",
								{});
								this.errorHandler.info("The API was removed successfully", "Settings");
								this.$scope.$$phase || this.$scope.$digest();
								return _context.abrupt("return");
							case 17:
								_context.prev = 17;
								_context.t0 = _context["catch"](0);
								this.errorHandler.handle("Could not remove the API", "Settings");
							case 20:
								return _context.abrupt("return");
							case 21:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 17]
						])
					}));

					function removeManager(_x)
					{
						return _ref.apply(this, arguments)
					}
					return removeManager
				}()
			},
			{
				key: "getCurrentAPIIndex",
				value: function getCurrentAPIIndex()
				{
					var _this2 = this;
					this.apiEntries.map(function (entry, index, array)
					{
						entry._id === _this2.currentDefault && (_this2.currentApiEntryIndex = index)
					})
				}
			},
			{
				key: "sortByTimestamp",
				value: function sortByTimestamp(a, b)
				{
					var intA = parseInt(a._id);
					var intB = parseInt(b._id);
					return intA > intB ? -1 : intA < intB ? 1 : 0
				}
			},
			{
				key: "setDefault",
				value: function setDefault(item)
				{
					var index = this.apiEntries.indexOf(item);
					this.appState.setClusterInfo(this.apiEntries[index]._source.cluster_info);
					"disabled" == this.apiEntries[index]._source.cluster_info.status ? this.appState.setCurrentAPI(JSON.stringify(
					{
						name: this.apiEntries[index]._source.cluster_info.manager,
						id: this.apiEntries[index]._id
					})) : this.appState.setCurrentAPI(JSON.stringify(
					{
						name: this.apiEntries[index]._source.cluster_info.cluster,
						id: this.apiEntries[index]._id
					}));
					this.$scope.$emit("updateAPI",
					{});
					var currentApi = this.appState.getCurrentAPI();
					this.currentDefault = JSON.parse(currentApi).id;
					this.errorHandler.info("API " + this.apiEntries[index]._source.cluster_info.manager + " set as default", "Settings");
					this.getCurrentAPIIndex();
					currentApi && !this.appState.getExtensions(JSON.parse(currentApi).id) && this.appState.setExtensions(this.apiEntries[this.currentApiEntryIndex]._id, this.apiEntries[this.currentApiEntryIndex]._source.extensions);
					this.extensions = this.appState.getExtensions(JSON.parse(currentApi).id);
					this.$scope.$$phase || this.$scope.$digest();
					return
				}
			},
			{
				key: "getSettings",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2()
					{
						var patternList, data, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, currentApi;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								_context2.next = 3;
								return this.genericReq.request("GET", "/elastic/index-patterns",
								{});
							case 3:
								patternList = _context2.sent;
								this.indexPatterns = patternList.data.data;
								if (patternList.data.data.length)
								{
									_context2.next = 10;
									break
								}
								this.wzMisc.setBlankScr("Sorry but no valid index patterns were found");
								this.$location.search("tab", null);
								this.$location.path("/blank-screen");
								return _context2.abrupt("return");
							case 10:
								_context2.next = 12;
								return this.genericReq.request("GET", "/elastic/apis");
							case 12:
								data = _context2.sent;
								_iteratorNormalCompletion = true;
								_didIteratorError = false;
								_iteratorError = void 0;
								_context2.prev = 16;
								for (_iterator = data.data[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
								{
									entry = _step.value;
									this.showEditForm[entry._id] = false
								}
								_context2.next = 24;
								break;
							case 20:
								_context2.prev = 20;
								_context2.t0 = _context2["catch"](16);
								_didIteratorError = true;
								_iteratorError = _context2.t0;
							case 24:
								_context2.prev = 24;
								_context2.prev = 25;
								!_iteratorNormalCompletion && _iterator.return && _iterator.return();
							case 27:
								_context2.prev = 27;
								if (!_didIteratorError)
								{
									_context2.next = 30;
									break
								}
								throw _iteratorError;
							case 30:
								return _context2.finish(27);
							case 31:
								return _context2.finish(24);
							case 32:
								this.apiEntries = data.data.length > 0 ? data.data : [];
								this.apiEntries = this.apiEntries.sort(this.sortByTimestamp);
								currentApi = this.appState.getCurrentAPI();
								currentApi && (this.currentDefault = JSON.parse(currentApi).id);
								this.$scope.$$phase || this.$scope.$digest();
								this.getCurrentAPIIndex();
								if (!(!this.currentApiEntryIndex && 0 !== this.currentApiEntryIndex))
								{
									_context2.next = 40;
									break
								}
								return _context2.abrupt("return");
							case 40:
								currentApi && !this.appState.getExtensions(JSON.parse(currentApi).id) && this.appState.setExtensions(this.apiEntries[this.currentApiEntryIndex]._id, this.apiEntries[this.currentApiEntryIndex]._source.extensions);
								this.extensions = this.appState.getExtensions(JSON.parse(currentApi).id);
								this.$scope.$$phase || this.$scope.$digest();
								return _context2.abrupt("return");
							case 46:
								_context2.prev = 46;
								_context2.t1 = _context2["catch"](0);
								this.errorHandler.handle("Error getting API entries", "Settings");
							case 49:
								return _context2.abrupt("return");
							case 50:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 46],
							[16, 20, 24, 32],
							[25, , 27, 31]
						])
					}));

					function getSettings()
					{
						return _ref2.apply(this, arguments)
					}
					return getSettings
				}()
			},
			{
				key: "validator",
				value: function validator(formName)
				{
					if (!this.userRegEx.test(this[formName].user)) return "Invalid user field";
					if (!this.passRegEx.test(this[formName].password)) return "Invalid password field";
					if (!this.urlRegEx.test(this[formName].url) && !this.urlRegExIP.test(this[formName].url)) return "Invalid url field";
					var validatePort = parseInt(this[formName].port);
					if (!this.portRegEx.test(this[formName].port) || validatePort <= 0 || validatePort >= 99999) return "Invalid port field";
					return false
				}
			},
			{
				key: "toggleEditor",
				value: function toggleEditor(entry)
				{
					this.formUpdate && this.formUpdate.password && (this.formUpdate.password = "");
					for (var key in this.showEditForm)
					{
						if (entry && entry._id === key) continue;
						this.showEditForm[key] = false
					}
					this.showEditForm[entry._id] = !this.showEditForm[entry._id];
					this.isEditing = this.showEditForm[entry._id];
					this.addManagerContainer = false;
					this.$scope.$$phase || this.$scope.$digest()
				}
			},
			{
				key: "saveSettings",
				value: function ()
				{
					var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3()
					{
						var invalid, tmpData, config, checkData, data, newEntry;
						return regeneratorRuntime.wrap(function _callee3$(_context3)
						{
							while (1) switch (_context3.prev = _context3.next)
							{
							case 0:
								_context3.prev = 0;
								if (!this.savingApi)
								{
									_context3.next = 4;
									break
								}
								this.errorHandler.info("Please, wait for success message", "Settings");
								return _context3.abrupt("return");
							case 4:
								this.savingApi = true;
								this.messageError = "";
								this.isEditing = false;
								invalid = this.validator("formData");
								if (!invalid)
								{
									_context3.next = 13;
									break
								}
								this.messageError = invalid;
								this.errorHandler.handle(invalid, "Settings");
								this.savingApi = false;
								return _context3.abrupt("return");
							case 13:
								tmpData = {
									user: this.formData.user,
									password: _base.base64.encode(this.formData.password),
									url: this.formData.url,
									port: this.formData.port,
									cluster_info:
									{},
									insecure: "true",
									extensions:
									{}
								};
								config = this.wazuhConfig.getConfig();
								this.appState.setPatternSelector(config["ip.selector"]);
								tmpData.extensions.audit = config["extensions.audit"];
								tmpData.extensions.pci = config["extensions.pci"];
								tmpData.extensions.gdpr = config["extensions.gdpr"];
								tmpData.extensions.oscap = config["extensions.oscap"];
								tmpData.extensions.ciscat = config["extensions.ciscat"];
								tmpData.extensions.aws = config["extensions.aws"];
								tmpData.extensions.virustotal = config["extensions.virustotal"];
								tmpData.extensions.osquery = config["extensions.osquery"];
								_context3.next = 26;
								return this.testAPI.check(tmpData);
							case 26:
								checkData = _context3.sent;
								tmpData.cluster_info = checkData.data;
								_context3.next = 30;
								return this.genericReq.request("PUT", "/elastic/api", tmpData);
							case 30:
								data = _context3.sent;
								this.appState.setExtensions(data.data.response._id, tmpData.extensions);
								newEntry = {
									_id: data.data.response._id,
									_source:
									{
										cluster_info: tmpData.cluster_info,
										active: tmpData.active,
										url: tmpData.url,
										api_user: tmpData.user,
										api_port: tmpData.port,
										extensions: tmpData.extensions
									}
								};
								this.apiEntries.push(newEntry);
								this.apiEntries = this.apiEntries.sort(this.sortByTimestamp);
								this.errorHandler.info("Wazuh API successfully added", "Settings");
								this.addManagerContainer = false;
								this.formData = {};
								if (!this.appState.getCurrentAPI())
								{
									"disabled" === this.apiEntries[this.apiEntries.length - 1]._source.cluster_info.status ? this.appState.setCurrentAPI(JSON.stringify(
									{
										name: this.apiEntries[this.apiEntries.length - 1]._source.cluster_info.manager,
										id: this.apiEntries[this.apiEntries.length - 1]._id
									})) : this.appState.setCurrentAPI(JSON.stringify(
									{
										name: this.apiEntries[this.apiEntries.length - 1]._source.cluster_info.cluster,
										id: this.apiEntries[this.apiEntries.length - 1]._id
									}));
									this.$scope.$emit("updateAPI",
									{});
									this.currentDefault = JSON.parse(this.appState.getCurrentAPI()).id
								}
								_context3.prev = 39;
								_context3.next = 42;
								return this.genericReq.request("GET", "/api/monitoring");
							case 42:
								_context3.next = 47;
								break;
							case 44:
								_context3.prev = 44;
								_context3.t0 = _context3["catch"](39); - 1 === (_context3.t0 ||
								{}).status ? this.errorHandler.handle("Wazuh API was inserted correctly, but something happened while fetching agents data.", "Fetch agents", true) : this.errorHandler.handle(_context3.t0, "Fetch agents");
							case 47:
								_context3.next = 49;
								return this.getSettings();
							case 49:
								_context3.next = 55;
								break;
							case 51:
								_context3.prev = 51;
								_context3.t1 = _context3["catch"](0);
								400 === _context3.t1.status && (_context3.t1.message = "Please, fill all the fields in order to connect with Wazuh RESTful API.");
								this.printError(_context3.t1);
							case 55:
								this.savingApi = false;
								this.$scope.$$phase || this.$scope.$digest();
								return _context3.abrupt("return");
							case 58:
							case "end":
								return _context3.stop()
							}
						}, _callee3, this, [
							[0, 51],
							[39, 44]
						])
					}));

					function saveSettings()
					{
						return _ref3.apply(this, arguments)
					}
					return saveSettings
				}()
			},
			{
				key: "isUpdating",
				value: function isUpdating()
				{
					for (var key in this.showEditForm)
						if (this.showEditForm[key]) return true;
					return false
				}
			},
			{
				key: "updateSettings",
				value: function ()
				{
					var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(item)
					{
						var invalid, index, tmpData, data;
						return regeneratorRuntime.wrap(function _callee4$(_context4)
						{
							while (1) switch (_context4.prev = _context4.next)
							{
							case 0:
								_context4.prev = 0;
								if (!this.savingApi)
								{
									_context4.next = 4;
									break
								}
								this.errorHandler.info("Please, wait for success message", "Settings");
								return _context4.abrupt("return");
							case 4:
								this.savingApi = true;
								this.messageErrorUpdate = "";
								invalid = this.validator("formUpdate");
								if (!invalid)
								{
									_context4.next = 12;
									break
								}
								this.messageErrorUpdate = invalid;
								this.errorHandler.handle(invalid, "Settings");
								this.savingApi = false;
								return _context4.abrupt("return");
							case 12:
								index = this.apiEntries.indexOf(item);
								tmpData = {
									user: this.formUpdate.user,
									password: _base.base64.encode(this.formUpdate.password),
									url: this.formUpdate.url,
									port: this.formUpdate.port,
									cluster_info:
									{},
									insecure: "true",
									id: this.apiEntries[index]._id,
									extensions: this.apiEntries[index]._source.extensions
								};
								_context4.next = 16;
								return this.testAPI.check(tmpData);
							case 16:
								data = _context4.sent;
								tmpData.cluster_info = data.data;
								_context4.next = 20;
								return this.genericReq.request("PUT", "/elastic/api-settings", tmpData);
							case 20:
								this.apiEntries[index]._source.cluster_info = tmpData.cluster_info;
								this.wzMisc.setApiIsDown(false);
								this.apiIsDown = false;
								this.apiEntries[index]._source.cluster_info.cluster = tmpData.cluster_info.cluster;
								this.apiEntries[index]._source.cluster_info.manager = tmpData.cluster_info.manager;
								this.apiEntries[index]._source.url = tmpData.url;
								this.apiEntries[index]._source.api_port = tmpData.port;
								this.apiEntries[index]._source.api_user = tmpData.user;
								this.apiEntries = this.apiEntries.sort(this.sortByTimestamp);
								this.showEditForm[this.apiEntries[index]._id] = false;
								this.isEditing = false;
								this.errorHandler.info("The API was updated successfully", "Settings");
								_context4.next = 37;
								break;
							case 34:
								_context4.prev = 34;
								_context4.t0 = _context4["catch"](0);
								this.printError(_context4.t0, true);
							case 37:
								this.savingApi = false;
								this.$scope.$$phase || this.$scope.$digest();
								return _context4.abrupt("return");
							case 40:
							case "end":
								return _context4.stop()
							}
						}, _callee4, this, [
							[0, 34]
						])
					}));

					function updateSettings(_x2)
					{
						return _ref4.apply(this, arguments)
					}
					return updateSettings
				}()
			},
			{
				key: "switch",
				value: function _switch()
				{
					this.addManagerContainer = !this.addManagerContainer
				}
			},
			{
				key: "checkManager",
				value: function ()
				{
					var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(item, isIndex)
					{
						var index, tmpData, data, tmpUrl;
						return regeneratorRuntime.wrap(function _callee5$(_context5)
						{
							while (1) switch (_context5.prev = _context5.next)
							{
							case 0:
								_context5.prev = 0;
								index = isIndex ? item : this.apiEntries.indexOf(item);
								tmpData = {
									user: this.apiEntries[index]._source.api_user,
									url: this.apiEntries[index]._source.url,
									port: this.apiEntries[index]._source.api_port,
									cluster_info:
									{},
									insecure: "true",
									id: this.apiEntries[index]._id
								};
								_context5.next = 5;
								return this.testAPI.check(tmpData);
							case 5:
								data = _context5.sent;
								tmpData.cluster_info = data.data;
								tmpUrl = "/elastic/api-hostname/" + this.apiEntries[index]._id;
								_context5.next = 10;
								return this.genericReq.request("PUT", tmpUrl,
								{
									cluster_info: tmpData.cluster_info
								});
							case 10:
								this.$scope.$emit("updateAPI",
								{
									cluster_info: tmpData.cluster_info
								});
								this.apiEntries[index]._source.cluster_info = tmpData.cluster_info;
								this.wzMisc.setApiIsDown(false);
								this.apiIsDown = false;
								this.errorHandler.info("Connection success", "Settings");
								this.$scope.$$phase || this.$scope.$digest();
								return _context5.abrupt("return");
							case 19:
								_context5.prev = 19;
								_context5.t0 = _context5["catch"](0);
								this.wzMisc.getApiIsDown() || this.printError(_context5.t0);
							case 22:
							case "end":
								return _context5.stop()
							}
						}, _callee5, this, [
							[0, 19]
						])
					}));

					function checkManager(_x3, _x4)
					{
						return _ref5.apply(this, arguments)
					}
					return checkManager
				}()
			},
			{
				key: "toggleExtension",
				value: function toggleExtension(extension, state)
				{
					try
					{
						var api = JSON.parse(this.appState.getCurrentAPI()).id;
						var currentExtensions = this.appState.getExtensions(api);
						currentExtensions[extension] = state;
						this.appState.setExtensions(api, currentExtensions);
						this.getCurrentAPIIndex();
						this.apiEntries[this.currentApiEntryIndex]._source.extensions = currentExtensions;
						this.$scope.$$phase || this.$scope.$digest()
					}
					catch (error)
					{
						this.errorHandler.handle(error, "Settings")
					}
				}
			},
			{
				key: "changeIndexPattern",
				value: function ()
				{
					var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(newIndexPattern)
					{
						return regeneratorRuntime.wrap(function _callee6$(_context6)
						{
							while (1) switch (_context6.prev = _context6.next)
							{
							case 0:
								_context6.prev = 0;
								this.appState.setCurrentPattern(newIndexPattern);
								_context6.next = 4;
								return this.genericReq.request("GET", "/elastic/known-fields/" + newIndexPattern,
								{});
							case 4:
								this.$scope.$emit("updatePattern",
								{});
								this.errorHandler.info("Successfully changed the default index-pattern", "Settings");
								this.selectedIndexPattern = newIndexPattern;
								this.$scope.$$phase || this.$scope.$digest();
								return _context6.abrupt("return");
							case 11:
								_context6.prev = 11;
								_context6.t0 = _context6["catch"](0);
								this.errorHandler.handle("Error while changing the default index-pattern", "Settings");
							case 14:
								return _context6.abrupt("return");
							case 15:
							case "end":
								return _context6.stop()
							}
						}, _callee6, this, [
							[0, 11]
						])
					}));

					function changeIndexPattern(_x5)
					{
						return _ref6.apply(this, arguments)
					}
					return changeIndexPattern
				}()
			},
			{
				key: "printError",
				value: function printError(error, updating)
				{
					var text = this.errorHandler.handle(error, "Settings");
					updating ? this.messageErrorUpdate = text : this.messageError = text
				}
			},
			{
				key: "getAppLogs",
				value: function ()
				{
					var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7()
					{
						var logs;
						return regeneratorRuntime.wrap(function _callee7$(_context7)
						{
							while (1) switch (_context7.prev = _context7.next)
							{
							case 0:
								_context7.prev = 0;
								this.loadingLogs = true;
								_context7.next = 4;
								return this.genericReq.request("GET", "/utils/logs",
								{});
							case 4:
								logs = _context7.sent;
								this.logs = logs.data.lastLogs.map(function (item)
								{
									return JSON.parse(item)
								});
								this.loadingLogs = false;
								this.$scope.$$phase || this.$scope.$digest();
								_context7.next = 13;
								break;
							case 10:
								_context7.prev = 10;
								_context7.t0 = _context7["catch"](0);
								this.logs = [
								{
									date: new Date,
									level: "error",
									message: "Error when loading Wazuh app logs"
								}];
							case 13:
							case "end":
								return _context7.stop()
							}
						}, _callee7, this, [
							[0, 10]
						])
					}));

					function getAppLogs()
					{
						return _ref7.apply(this, arguments)
					}
					return getAppLogs
				}()
			},
			{
				key: "getAppInfo",
				value: function ()
				{
					var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8()
					{
						var data, config;
						return regeneratorRuntime.wrap(function _callee8$(_context8)
						{
							while (1) switch (_context8.prev = _context8.next)
							{
							case 0:
								_context8.prev = 0;
								_context8.next = 3;
								return this.genericReq.request("GET", "/elastic/setup");
							case 3:
								data = _context8.sent;
								this.appInfo = {};
								this.appInfo["app-version"] = data.data.data["app-version"];
								this.appInfo["installationDate"] = data.data.data["installationDate"];
								this.appInfo["revision"] = data.data.data["revision"];
								this.load = false;
								config = this.wazuhConfig.getConfig();
								this.appState.setPatternSelector(config["ip.selector"]);
								void 0 !== this.appState.getCurrentPattern() && null !== this.appState.getCurrentPattern() ? this.selectedIndexPattern = this.appState.getCurrentPattern() : this.selectedIndexPattern = config["pattern"];
								if (this.appState.getCurrentAPI()) this.extensions = this.appState.getExtensions(JSON.parse(this.appState.getCurrentAPI()).id);
								else
								{
									this.extensions = {};
									this.extensions.audit = config["extensions.audit"];
									this.extensions.pci = config["extensions.pci"];
									this.extensions.gdpr = config["extensions.gdpr"];
									this.extensions.oscap = config["extensions.oscap"];
									this.extensions.ciscat = config["extensions.ciscat"];
									this.extensions.aws = config["extensions.aws"];
									this.extensions.virustotal = config["extensions.virustotal"];
									this.extensions.osquery = config["extensions.osquery"]
								}
								"logs" === this.tab && this.getAppLogs();
								this.getCurrentAPIIndex();
								if (!(this.currentApiEntryIndex || 0 === this.currentApiEntryIndex))
								{
									_context8.next = 18;
									break
								}
								_context8.next = 18;
								return this.checkManager(this.currentApiEntryIndex, true);
							case 18:
								this.$scope.$$phase || this.$scope.$digest();
								return _context8.abrupt("return");
							case 22:
								_context8.prev = 22;
								_context8.t0 = _context8["catch"](0);
								this.errorHandler.handle("Error when loading Wazuh setup info", "Settings");
							case 25:
								return _context8.abrupt("return");
							case 26:
							case "end":
								return _context8.stop()
							}
						}, _callee8, this, [
							[0, 22]
						])
					}));

					function getAppInfo()
					{
						return _ref8.apply(this, arguments)
					}
					return getAppInfo
				}()
			},
			{
				key: "refreshLogs",
				value: function refreshLogs()
				{
					return this.getAppLogs()
				}
			},
			{
				key: "configEquivalence",
				value: function configEquivalence(key)
				{
					return _configEquivalences.configEquivalences[key] || "-"
				}
			},
			{
				key: "cancelEditingKey",
				value: function cancelEditingKey()
				{
					this.editingKey = false;
					this.editingNewValue = ""
				}
			},
			{
				key: "setEditingKey",
				value: function setEditingKey(key, value)
				{
					if ("object" === ("undefined" === typeof value ? "undefined" : _typeof(value))) try
					{
						value = JSON.stringify(value)
					}
					catch (err)
					{
						this.errorHandler.handle("Error parsing value", key)
					}
					this.editingKey = key;
					this.editingNewValue = value
				}
			},
			{
				key: "editKey",
				value: function ()
				{
					var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(key, newValue)
					{
						var response;
						return regeneratorRuntime.wrap(function _callee9$(_context9)
						{
							while (1) switch (_context9.prev = _context9.next)
							{
							case 0:
								_context9.prev = 0;
								this.loadingChange = true;
								_context9.next = 4;
								return this.genericReq.request("PUT", "/utils/configuration",
								{
									key: key,
									value: newValue
								});
							case 4:
								response = _context9.sent;
								response.data.data ? this.errorHandler.handle("You must restart Kibana for the changes to take effect", "", true) : this.errorHandler.info("Success. The configuration has been successfully updated");
								this.configuration[key] = newValue;
								this.cancelEditingKey();
								this.loadingChange = false;
								_context9.next = 16;
								break;
							case 11:
								_context9.prev = 11;
								_context9.t0 = _context9["catch"](0);
								this.cancelEditingKey();
								this.loadingChange = false;
								this.errorHandler.handle(_context9.t0);
							case 16:
							case "end":
								return _context9.stop()
							}
						}, _callee9, this, [
							[0, 11]
						])
					}));

					function editKey(_x6, _x7)
					{
						return _ref9.apply(this, arguments)
					}
					return editKey
				}()
			}]);
			return SettingsController
		}()
	},
	5348: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.base64 = {
			encode: function encode(text)
			{
				var textRegex = /([^\u0000-\u00ff])/;
				if (textRegex.test(text)) throw new Error("Can't base64 encode non-ASCII characters.");
				var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
				var i = 0,
					cur = void 0,
					prev = void 0,
					byteNum = void 0,
					result = [];
				while (i < text.length)
				{
					cur = text.charCodeAt(i);
					byteNum = i % 3;
					switch (byteNum)
					{
					case 0:
						result.push(digits.charAt(cur >> 2));
						break;
					case 1:
						result.push(digits.charAt((3 & prev) << 4 | cur >> 4));
						break;
					case 2:
						result.push(digits.charAt((15 & prev) << 2 | cur >> 6));
						result.push(digits.charAt(63 & cur))
					}
					prev = cur;
					i++
				}
				if (0 == byteNum)
				{
					result.push(digits.charAt((3 & prev) << 4));
					result.push("==")
				}
				else if (1 == byteNum)
				{
					result.push(digits.charAt((15 & prev) << 2));
					result.push("=")
				}
				return result.join("")
			},
			decode: function decode(text)
			{
				text = text.replace(/\s/g, "");
				var textRegex = /^[a-z0-9\-_\s]+\={0,2}$/i;
				if (!textRegex.test(text) || text.length % 4 > 0) throw new Error("Not a base64-encoded string.");
				var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
				var cur = void 0,
					prev = void 0,
					digitNum = void 0,
					i = 0,
					result = [];
				text = text.replace(/=/g, "");
				while (i < text.length)
				{
					cur = digits.indexOf(text.charAt(i));
					digitNum = i % 4;
					switch (digitNum)
					{
					case 1:
						result.push(String.fromCharCode(prev << 2 | cur >> 4));
						break;
					case 2:
						result.push(String.fromCharCode((15 & prev) << 4 | cur >> 2));
						break;
					case 3:
						result.push(String.fromCharCode((3 & prev) << 6 | cur))
					}
					prev = cur;
					i++
				}
				return result.join("")
			}
		}
	},
	5349: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.configEquivalences = {
			pattern: "Default index pattern to use on the app.",
			"checks.pattern": "Enable or disable the index pattern health check when opening the app.",
			"checks.template": "Enable or disable the template health check when opening the app.",
			"checks.api": "Enable or disable the API health check when opening the app.",
			"checks.setup": "Enable or disable the setup health check when opening the app.",
			"extensions.pci": "Enable or disable the PCI DSS tab on Overview and Agents.",
			"extensions.gdpr": "Enable or disable the GDPR tab on Overview and Agents.",
			"extensions.audit": "Enable or disable the Audit tab on Overview and Agents.",
			"extensions.oscap": "Enable or disable the Open SCAP tab on Overview and Agents.",
			"extensions.ciscat": "Enable or disable the CIS-CAT tab on Overview and Agents.",
			"extensions.aws": "Enable or disable the Amazon (AWS) tab on Overview and Agents.",
			"extensions.virustotal": "Enable or disable the VirusTotal tab on Overview and Agents.",
			"extensions.osquery": "Enable or disable the Osquery tab on Overview and Agents.",
			timeout: "Defines the maximum time the app will wait for an API response when making requests to it.",
			"wazuh.shards": "Define the number of shards to use for the .wazuh index.",
			"wazuh.replicas": "Define the number of replicas to use for the .wazuh index.",
			"wazuh-version.shards": "Define the number of shards to use for the .wazuh-version index.",
			"wazuh-version.replicas": "Define the number of replicas to use for the .wazuh-version index.",
			"ip.selector": "Defines if the user is allowed to change the selected index pattern directly from the top menu bar.",
			"ip.ignore": "Disable certain index pattern names from being available in index pattern selector from the threatanalytics app.",
			"xpack.rbac.enabled": "Enable or disable X-Pack RBAC security capabilities when using the app.",
			"threatanalytics.monitoring.enabled": "Enable or disable the threatanalytics-monitoring index creation and/or visualization.",
			"threatanalytics.monitoring.frequency": "Define in seconds the frequency the app generates a new document on the wazuh-monitoring index.",
			"threatanalytics.monitoring.shards": "Define the number of shards to use for the threatanalytics-monitoring-3.x-* indices.",
			"threatanalytics.monitoring.replicas": "Define the number of replicas to use for the threatanalytics-monitoring-3.x-* indices.",
			"threatanalytics.monitoring.pattern": "Default index pattern to use on the app for threatanalytics-monitoring.",
			admin: "Enable or disable administrator requests to the threatanalytics API when using the app."
		}
	},
	5350: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var _devTools = __webpack_require__(5351);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.controller("devToolsController", _devTools.DevToolsController)
	},
	5351: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.DevToolsController = void 0;
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _codemirror = __webpack_require__(58);
		var _codemirror2 = _interopRequireDefault(_codemirror);
		var _jsonLint = __webpack_require__(5352);
		var _jsonLint2 = _interopRequireDefault(_jsonLint);
		var _excludedDevtoolsAutocompleteKeys = __webpack_require__(5353);
		var _querystringBrowser = __webpack_require__(5354);
		var _querystringBrowser2 = _interopRequireDefault(_querystringBrowser);
		var _jquery = __webpack_require__(16);
		var _jquery2 = _interopRequireDefault(_jquery);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.DevToolsController = function ()
		{
			function DevToolsController($scope, apiReq, genericReq, $window, appState, errorHandler, $document)
			{
				_classCallCheck(this, DevToolsController);
				this.$scope = $scope;
				this.apiReq = apiReq;
				this.genericReq = genericReq;
				this.$window = $window;
				this.appState = appState;
				this.errorHandler = errorHandler;
				this.$document = $document;
				this.groups = [];
				this.linesWithClass = [];
				this.widgets = []
			}
			_createClass(DevToolsController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					var _this = this;
					this.apiInputBox = _codemirror2.default.fromTextArea(this.$document[0].getElementById("api_input"),
					{
						lineNumbers: true,
						matchBrackets: true,
						mode:
						{
							name: "javascript",
							json: true
						},
						theme: "ttcn",
						foldGutter: true,
						styleSelectedText: true,
						gutters: ["CodeMirror-foldgutter"]
					});
					_codemirror2.default.commands.autocomplete = function (cm)
					{
						_codemirror2.default.showHint(cm, _codemirror2.default.hint.dictionaryHint,
						{
							completeSingle: false
						})
					};
					this.apiInputBox.on("change", function ()
					{
						_this.groups = _this.analyzeGroups();
						var currentState = _this.apiInputBox.getValue().toString();
						_this.appState.setCurrentDevTools(currentState);
						var currentGroup = _this.calculateWhichGroup();
						if (currentGroup)
						{
							var hasWidget = _this.widgets.filter(function (item)
							{
								return item.start === currentGroup.start
							});
							hasWidget.length && _this.apiInputBox.removeLineWidget(hasWidget[0].widget);
							setTimeout(function ()
							{
								return _this.checkJsonParseError()
							}, 150)
						}
					});
					this.apiInputBox.on("cursorActivity", function ()
					{
						var currentGroup = _this.calculateWhichGroup();
						_this.highlightGroup(currentGroup);
						_this.checkJsonParseError()
					});
					this.apiOutputBox = _codemirror2.default.fromTextArea(this.$document[0].getElementById("api_output"),
					{
						lineNumbers: true,
						matchBrackets: true,
						mode:
						{
							name: "javascript",
							json: true
						},
						readOnly: true,
						lineWrapping: true,
						styleActiveLine: true,
						theme: "ttcn",
						foldGutter: true,
						gutters: ["CodeMirror-foldgutter"]
					});
					this.$scope.send = function (firstTime)
					{
						return _this.send(firstTime)
					};
					this.$scope.help = function ()
					{
						_this.$window.open("https://documentation.cyberforza.com/current/user-manual/api/reference.html")
					};
					this.init();
					this.$scope.send(true)
				}
			},
			{
				key: "analyzeGroups",
				value: function analyzeGroups()
				{
					try
					{
						var currentState = this.apiInputBox.getValue().toString();
						this.appState.setCurrentDevTools(currentState);
						var tmpgroups = [];
						var splitted = currentState.split(/[\r\n]+(?=(?:GET|PUT|POST|DELETE|#)\b)/gm).filter(function (item)
						{
							return item.replace(/\s/g, "").length
						});
						var start = 0;
						var end = 0;
						var slen = splitted.length;
						for (var i = 0; i < slen; i++)
						{
							var tmp = splitted[i].split("\n");
							Array.isArray(tmp) && (tmp = tmp.filter(function (item)
							{
								return !item.includes("#")
							}));
							var cursor = this.apiInputBox.getSearchCursor(splitted[i], null,
							{
								multiline: true
							});
							if (!cursor.findNext()) return [];
							start = cursor.from().line;
							end = start + tmp.length;
							var tmpRequestText = tmp[0];
							var tmpRequestTextJson = "";
							var tmplen = tmp.length;
							for (var j = 1; j < tmplen; ++j) !tmp[j] || tmp[j].includes("#") || (tmpRequestTextJson += tmp[j]);
							if (tmpRequestTextJson && "string" === typeof tmpRequestTextJson)
							{
								var rtjlen = tmp.length;
								while (rtjlen--)
								{
									if ("}" === tmp[rtjlen].trim()) break;
									end -= 1
								}
							}
							if (!tmpRequestTextJson && tmp.length > 1)
							{
								tmp = [tmp[0]];
								end = start + 1
							}
							i !== slen - 1 || tmpRequestTextJson || tmp.length > 1 && (end -= tmp.length - 1);
							end--;
							tmpgroups.push(
							{
								requestText: tmpRequestText,
								requestTextJson: tmpRequestTextJson,
								start: start,
								end: end
							})
						}
						return tmpgroups
					}
					catch (error)
					{
						return []
					}
				}
			},
			{
				key: "highlightGroup",
				value: function highlightGroup(group)
				{
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = void 0;
					try
					{
						for (var _step, _iterator = this.linesWithClass[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
						{
							var line = _step.value;
							this.apiInputBox.removeLineClass(line, "background", "CodeMirror-styled-background")
						}
					}
					catch (err)
					{
						_didIteratorError = true;
						_iteratorError = err
					}
					finally
					{
						try
						{
							!_iteratorNormalCompletion && _iterator.return && _iterator.return()
						}
						finally
						{
							if (_didIteratorError) throw _iteratorError
						}
					}
					this.linesWithClass = [];
					if (group)
					{
						if (!group.requestTextJson)
						{
							this.linesWithClass.push(this.apiInputBox.addLineClass(group.start, "background", "CodeMirror-styled-background"));
							return
						}
						for (var i = group.start; i <= group.end; i++) this.linesWithClass.push(this.apiInputBox.addLineClass(i, "background", "CodeMirror-styled-background"))
					}
				}
			},
			{
				key: "checkJsonParseError",
				value: function checkJsonParseError()
				{
					var _this2 = this;
					var affectedGroups = [];
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = void 0;
					try
					{
						for (var _step2, _iterator2 = this.widgets[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true)
						{
							var widget = _step2.value;
							this.apiInputBox.removeLineWidget(widget.widget)
						}
					}
					catch (err)
					{
						_didIteratorError2 = true;
						_iteratorError2 = err
					}
					finally
					{
						try
						{
							!_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return()
						}
						finally
						{
							if (_didIteratorError2) throw _iteratorError2
						}
					}
					this.widgets = [];
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = void 0;
					try
					{
						for (var _step3, _iterator3 = this.groups[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true)
						{
							var item = _step3.value;
							if (item.requestTextJson) try
							{
								_jsonLint2.default.parse(item.requestTextJson)
							}
							catch (error)
							{
								(function ()
								{
									affectedGroups.push(item.requestText);
									var msg = _this2.$document[0].createElement("div");
									msg.id = (new Date).getTime() / 1e3;
									var icon = msg.appendChild(_this2.$document[0].createElement("div"));
									icon.className = "lint-error-icon";
									icon.id = (new Date).getTime() / 1e3;
									icon.onmouseover = function ()
									{
										var advice = msg.appendChild(_this2.$document[0].createElement("span"));
										advice.id = (new Date).getTime() / 1e3;
										advice.innerText = error.message || "Error parsing query";
										advice.className = "lint-block-wz"
									};
									icon.onmouseleave = function ()
									{
										msg.removeChild(msg.lastChild)
									};
									_this2.widgets.push(
									{
										start: item.start,
										widget: _this2.apiInputBox.addLineWidget(item.start, msg,
										{
											coverGutter: false,
											noHScroll: true
										})
									})
								})()
							}
						}
					}
					catch (err)
					{
						_didIteratorError3 = true;
						_iteratorError3 = err
					}
					finally
					{
						try
						{
							!_iteratorNormalCompletion3 && _iterator3.return && _iterator3.return()
						}
						finally
						{
							if (_didIteratorError3) throw _iteratorError3
						}
					}
					return affectedGroups
				}
			},
			{
				key: "getAvailableMethods",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var response;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return this.genericReq.request("GET", "/api/routes",
								{});
							case 3:
								response = _context.sent;
								this.apiInputBox.model = response.error ? [] : response.data;
								_context.next = 10;
								break;
							case 7:
								_context.prev = 7;
								_context.t0 = _context["catch"](0);
								this.apiInputBox.model = [];
							case 10:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 7]
						])
					}));

					function getAvailableMethods()
					{
						return _ref.apply(this, arguments)
					}
					return getAvailableMethods
				}()
			},
			{
				key: "init",
				value: function init()
				{
					this.apiInputBox.setSize("auto", "100%");
					this.apiInputBox.model = [];
					this.getAvailableMethods();
					this.apiInputBox.on("keyup", function (cm, e)
					{
						_excludedDevtoolsAutocompleteKeys.ExcludedIntelliSenseTriggerKeys[(e.keyCode || e.which).toString()] || cm.execCommand("autocomplete", null,
						{
							completeSingle: false
						})
					});
					this.apiOutputBox.setSize("auto", "100%");
					var currentState = this.appState.getCurrentDevTools();
					if (currentState) this.apiInputBox.getDoc().setValue(currentState);
					else
					{
						var demoStr = "GET /agents?status=Active\n\n#Example comment\nGET /manager/info\n\nGET /syscollector/000/packages?search=ssh\n" + JSON.stringify(
						{
							limit: 5
						}, null, 2);
						this.appState.setCurrentDevTools(demoStr);
						this.apiInputBox.getDoc().setValue(demoStr)
					}
					this.groups = this.analyzeGroups();
					var currentGroup = this.calculateWhichGroup();
					this.highlightGroup(currentGroup);
					_codemirror2.default.registerHelper("hint", "dictionaryHint", function (editor)
					{
						var model = editor.model;

						function getDictionary(line, word)
						{
							var hints = [];
							var exp = line.split(/\s+/g);
							if (exp[0] && exp[0].match(/^(?:GET|PUT|POST|DELETE).*$/))
							{
								var method = model.find(function (item)
								{
									return item.method === exp[0]
								});
								var forbidChars = /^[^?{]+$/;
								if (method && !exp[2] && forbidChars.test(word))
								{
									method.endpoints.forEach(function (endpoint)
									{
										endpoint.path = endpoint.name;
										if (endpoint.args && endpoint.args.length > 0)
										{
											var argSubs = [];
											endpoint.args.forEach(function (arg)
											{
												var pathSplitted = endpoint.name.split("/");
												var arrayIdx = pathSplitted.indexOf(arg.name);
												var wordSplitted = word.split("/");
												wordSplitted[arrayIdx] && "" != wordSplitted[arrayIdx] && argSubs.push(
												{
													id: arg.name,
													value: wordSplitted[arrayIdx]
												})
											});
											var auxPath = endpoint.name;
											argSubs.forEach(function (arg)
											{
												auxPath = auxPath.replace(arg.id, arg.value)
											});
											endpoint.path = auxPath
										}
									});
									hints = method.endpoints.map(function (a)
									{
										return a.path
									})
								}
							}
							else hints = model.map(function (a)
							{
								return a.method
							});
							return hints
						}
						var cur = editor.getCursor();
						var curLine = editor.getLine(cur.line);
						var start = cur.ch;
						var end = start;
						var whiteSpace = /\s/;
						while (end < curLine.length && !whiteSpace.test(curLine.charAt(end))) ++end;
						while (start && !whiteSpace.test(curLine.charAt(start - 1))) --start;
						var curWord = start !== end && curLine.slice(start, end);
						return {
							list: (curWord ? getDictionary(curLine, curWord).filter(function (item)
							{
								return item.toUpperCase().includes(curWord.toUpperCase())
							}) : []).sort(),
							from: _codemirror2.default.Pos(cur.line, start),
							to: _codemirror2.default.Pos(cur.line, end)
						}
					});
					var evtDocument = this.$document[0];
					(0, _jquery2.default)(".wz-dev-column-separator").mousedown(function (e)
					{
						e.preventDefault();
						var leftOrigWidth = (0, _jquery2.default)("#wz-dev-left-column").width();
						var rightOrigWidth = (0, _jquery2.default)("#wz-dev-right-column").width();
						(0, _jquery2.default)(evtDocument).mousemove(function (e)
						{
							var leftWidth = e.pageX - 215 + 14;
							var rightWidth = leftOrigWidth - leftWidth;
							(0, _jquery2.default)("#wz-dev-left-column").css("width", leftWidth);
							(0, _jquery2.default)("#wz-dev-right-column").css("width", rightOrigWidth + rightWidth)
						})
					});
					(0, _jquery2.default)(evtDocument).mouseup(function ()
					{
						(0, _jquery2.default)(evtDocument).unbind("mousemove")
					});
					this.$window.onresize = function ()
					{
						(0, _jquery2.default)("#wz-dev-left-column").attr("style", "width: calc(30% - 7px); !important");
						(0, _jquery2.default)("#wz-dev-right-column").attr("style", "width: calc(70% - 7px); !important")
					}
				}
			},
			{
				key: "calculateWhichGroup",
				value: function calculateWhichGroup(firstTime)
				{
					try
					{
						var selection = this.apiInputBox.getCursor();
						var desiredGroup = firstTime ? this.groups.filter(function (item)
						{
							return item.requestText
						}) : this.groups.filter(function (item)
						{
							return item.requestText && item.end >= selection.line && item.start <= selection.line
						});
						var cords = this.apiInputBox.cursorCoords(
						{
							line: desiredGroup[0].start,
							ch: 0
						});
						(0, _jquery2.default)("#play_button").is(":visible") || (0, _jquery2.default)("#play_button").show();
						var currentPlayButton = (0, _jquery2.default)("#play_button").offset();
						(0, _jquery2.default)("#play_button").offset(
						{
							top: cords.top,
							left: currentPlayButton.left
						});
						firstTime && this.highlightGroup(desiredGroup[0]);
						return desiredGroup[0]
					}
					catch (error)
					{
						(0, _jquery2.default)("#play_button").hide();
						return null
					}
				}
			},
			{
				key: "send",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(firstTime)
					{
						var desiredGroup, cords, currentPlayButton, affectedGroups, filteredAffectedGroups, method, requestCopy, inlineSplit, extra, req, JSONraw, key, path, output, parsedError;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								this.groups = this.analyzeGroups();
								desiredGroup = this.calculateWhichGroup(firstTime);
								if (!desiredGroup)
								{
									_context2.next = 28;
									break
								}
								if (firstTime)
								{
									cords = this.apiInputBox.cursorCoords(
									{
										line: desiredGroup.start,
										ch: 0
									});
									currentPlayButton = (0, _jquery2.default)("#play_button").offset();
									(0, _jquery2.default)("#play_button").offset(
									{
										top: cords.top + 10,
										left: currentPlayButton.left
									})
								}
								affectedGroups = this.checkJsonParseError();
								filteredAffectedGroups = affectedGroups.filter(function (item)
								{
									return item === desiredGroup.requestText
								});
								if (!filteredAffectedGroups.length)
								{
									_context2.next = 10;
									break
								}
								this.apiOutputBox.setValue("Error parsing JSON query");
								return _context2.abrupt("return");
							case 10:
								method = desiredGroup.requestText.startsWith("GET") ? "GET" : desiredGroup.requestText.startsWith("POST") ? "POST" : desiredGroup.requestText.startsWith("PUT") ? "PUT" : desiredGroup.requestText.startsWith("DELETE") ? "DELETE" : "GET";
								requestCopy = desiredGroup.requestText.includes(method) ? desiredGroup.requestText.split(method)[1].trim() : desiredGroup.requestText;
								inlineSplit = requestCopy.split("?");
								extra = inlineSplit && inlineSplit[1] ? _querystringBrowser2.default.parse(inlineSplit[1]) :
								{};
								req = requestCopy ? requestCopy.startsWith("/") ? requestCopy : "/" + requestCopy : "/";
								JSONraw = {};
								try
								{
									JSONraw = JSON.parse(desiredGroup.requestTextJson)
								}
								catch (error)
								{
									JSONraw = {}
								}
								"undefined" !== typeof extra.pretty && delete extra.pretty;
								"undefined" !== typeof JSONraw.pretty && delete JSONraw.pretty;
								for (key in extra) JSONraw[key] = extra[key];
								path = req.includes("?") ? req.split("?")[0] : req;
								"object" === ("undefined" === typeof JSONraw ? "undefined" : _typeof(JSONraw)) && (JSONraw.devTools = true);
								_context2.next = 24;
								return this.apiReq.request(method, path, JSONraw);
							case 24:
								output = _context2.sent;
								this.apiOutputBox.setValue(JSON.stringify((output ||
								{}).data, null, 2));
								_context2.next = 29;
								break;
							case 28:
								this.apiOutputBox.setValue("Welcome!");
							case 29:
								_context2.next = 43;
								break;
							case 31:
								_context2.prev = 31;
								_context2.t0 = _context2["catch"](0);
								parsedError = this.errorHandler.handle(_context2.t0, null, null, true);
								if (!("string" === typeof parsedError))
								{
									_context2.next = 38;
									break
								}
								return _context2.abrupt("return", this.apiOutputBox.setValue(_context2.t0));
							case 38:
								if (!(_context2.t0 && _context2.t0.data && "object" === _typeof(_context2.t0.data)))
								{
									_context2.next = 42;
									break
								}
								return _context2.abrupt("return", this.apiOutputBox.setValue(JSON.stringify(_context2.t0)));
							case 42:
								return _context2.abrupt("return", this.apiOutputBox.setValue("Empty"));
							case 43:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 31]
						])
					}));

					function send(_x)
					{
						return _ref2.apply(this, arguments)
					}
					return send
				}()
			}]);
			return DevToolsController
		}()
	},
	5352: function (module, exports, __webpack_require__)
	{
		"use strict";
		var jsonlint = function ()
		{
			var parser = {
				trace: function trace()
				{},
				yy:
				{},
				symbols_:
				{
					error: 2,
					JSONString: 3,
					STRING: 4,
					JSONNumber: 5,
					NUMBER: 6,
					JSONNullLiteral: 7,
					NULL: 8,
					JSONBooleanLiteral: 9,
					TRUE: 10,
					FALSE: 11,
					JSONText: 12,
					JSONValue: 13,
					EOF: 14,
					JSONObject: 15,
					JSONArray: 16,
					"{": 17,
					"}": 18,
					JSONMemberList: 19,
					JSONMember: 20,
					":": 21,
					",": 22,
					"[": 23,
					"]": 24,
					JSONElementList: 25,
					$accept: 0,
					$end: 1
				},
				terminals_:
				{
					2: "error",
					4: "STRING",
					6: "NUMBER",
					8: "NULL",
					10: "TRUE",
					11: "FALSE",
					14: "EOF",
					17: "{",
					18: "}",
					21: ":",
					22: ",",
					23: "[",
					24: "]"
				},
				productions_: [0, [3, 1],
					[5, 1],
					[7, 1],
					[9, 1],
					[9, 1],
					[12, 2],
					[13, 1],
					[13, 1],
					[13, 1],
					[13, 1],
					[13, 1],
					[13, 1],
					[15, 2],
					[15, 3],
					[20, 3],
					[19, 1],
					[19, 3],
					[16, 2],
					[16, 3],
					[25, 1],
					[25, 3]
				],
				performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$)
				{
					var $0 = $$.length - 1;
					switch (yystate)
					{
					case 1:
						this.$ = yytext.replace(/\\(\\|")/g, "$1").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "\t").replace(/\\v/g, "\v").replace(/\\f/g, "\f").replace(/\\b/g, "\b");
						break;
					case 2:
						this.$ = Number(yytext);
						break;
					case 3:
						this.$ = null;
						break;
					case 4:
						this.$ = true;
						break;
					case 5:
						this.$ = false;
						break;
					case 6:
						return this.$ = $$[$0 - 1];
					case 13:
						this.$ = {};
						break;
					case 14:
						this.$ = $$[$0 - 1];
						break;
					case 15:
						this.$ = [$$[$0 - 2], $$[$0]];
						break;
					case 16:
						this.$ = {};
						this.$[$$[$0][0]] = $$[$0][1];
						break;
					case 17:
						this.$ = $$[$0 - 2];
						$$[$0 - 2][$$[$0][0]] = $$[$0][1];
						break;
					case 18:
						this.$ = [];
						break;
					case 19:
						this.$ = $$[$0 - 1];
						break;
					case 20:
						this.$ = [$$[$0]];
						break;
					case 21:
						this.$ = $$[$0 - 2];
						$$[$0 - 2].push($$[$0])
					}
				},
				table: [
				{
					3: 5,
					4: [1, 12],
					5: 6,
					6: [1, 13],
					7: 3,
					8: [1, 9],
					9: 4,
					10: [1, 10],
					11: [1, 11],
					12: 1,
					13: 2,
					15: 7,
					16: 8,
					17: [1, 14],
					23: [1, 15]
				},
				{
					1: [3]
				},
				{
					14: [1, 16]
				},
				{
					14: [2, 7],
					18: [2, 7],
					22: [2, 7],
					24: [2, 7]
				},
				{
					14: [2, 8],
					18: [2, 8],
					22: [2, 8],
					24: [2, 8]
				},
				{
					14: [2, 9],
					18: [2, 9],
					22: [2, 9],
					24: [2, 9]
				},
				{
					14: [2, 10],
					18: [2, 10],
					22: [2, 10],
					24: [2, 10]
				},
				{
					14: [2, 11],
					18: [2, 11],
					22: [2, 11],
					24: [2, 11]
				},
				{
					14: [2, 12],
					18: [2, 12],
					22: [2, 12],
					24: [2, 12]
				},
				{
					14: [2, 3],
					18: [2, 3],
					22: [2, 3],
					24: [2, 3]
				},
				{
					14: [2, 4],
					18: [2, 4],
					22: [2, 4],
					24: [2, 4]
				},
				{
					14: [2, 5],
					18: [2, 5],
					22: [2, 5],
					24: [2, 5]
				},
				{
					14: [2, 1],
					18: [2, 1],
					21: [2, 1],
					22: [2, 1],
					24: [2, 1]
				},
				{
					14: [2, 2],
					18: [2, 2],
					22: [2, 2],
					24: [2, 2]
				},
				{
					3: 20,
					4: [1, 12],
					18: [1, 17],
					19: 18,
					20: 19
				},
				{
					3: 5,
					4: [1, 12],
					5: 6,
					6: [1, 13],
					7: 3,
					8: [1, 9],
					9: 4,
					10: [1, 10],
					11: [1, 11],
					13: 23,
					15: 7,
					16: 8,
					17: [1, 14],
					23: [1, 15],
					24: [1, 21],
					25: 22
				},
				{
					1: [2, 6]
				},
				{
					14: [2, 13],
					18: [2, 13],
					22: [2, 13],
					24: [2, 13]
				},
				{
					18: [1, 24],
					22: [1, 25]
				},
				{
					18: [2, 16],
					22: [2, 16]
				},
				{
					21: [1, 26]
				},
				{
					14: [2, 18],
					18: [2, 18],
					22: [2, 18],
					24: [2, 18]
				},
				{
					22: [1, 28],
					24: [1, 27]
				},
				{
					22: [2, 20],
					24: [2, 20]
				},
				{
					14: [2, 14],
					18: [2, 14],
					22: [2, 14],
					24: [2, 14]
				},
				{
					3: 20,
					4: [1, 12],
					20: 29
				},
				{
					3: 5,
					4: [1, 12],
					5: 6,
					6: [1, 13],
					7: 3,
					8: [1, 9],
					9: 4,
					10: [1, 10],
					11: [1, 11],
					13: 30,
					15: 7,
					16: 8,
					17: [1, 14],
					23: [1, 15]
				},
				{
					14: [2, 19],
					18: [2, 19],
					22: [2, 19],
					24: [2, 19]
				},
				{
					3: 5,
					4: [1, 12],
					5: 6,
					6: [1, 13],
					7: 3,
					8: [1, 9],
					9: 4,
					10: [1, 10],
					11: [1, 11],
					13: 31,
					15: 7,
					16: 8,
					17: [1, 14],
					23: [1, 15]
				},
				{
					18: [2, 17],
					22: [2, 17]
				},
				{
					18: [2, 15],
					22: [2, 15]
				},
				{
					22: [2, 21],
					24: [2, 21]
				}],
				defaultActions:
				{
					16: [2, 6]
				},
				parseError: function parseError(str, hash)
				{
					throw new Error(str)
				},
				parse: function parse(input)
				{
					var self = this,
						stack = [0],
						vstack = [null],
						lstack = [],
						table = this.table,
						yytext = "",
						yylineno = 0,
						yyleng = 0,
						recovering = 0,
						TERROR = 2,
						EOF = 1;
					this.lexer.setInput(input);
					this.lexer.yy = this.yy;
					this.yy.lexer = this.lexer;
					"undefined" == typeof this.lexer.yylloc && (this.lexer.yylloc = {});
					var yyloc = this.lexer.yylloc;
					lstack.push(yyloc);
					"function" === typeof this.yy.parseError && (this.parseError = this.yy.parseError);

					function popStack(n)
					{
						stack.length = stack.length - 2 * n;
						vstack.length = vstack.length - n;
						lstack.length = lstack.length - n
					}

					function lex()
					{
						var token;
						token = self.lexer.lex() || 1;
						"number" !== typeof token && (token = self.symbols_[token] || token);
						return token
					}
					var symbol, preErrorSymbol, state, action, r, p, len, newState, expected, yyval = {};
					while (true)
					{
						state = stack[stack.length - 1];
						if (this.defaultActions[state]) action = this.defaultActions[state];
						else
						{
							null == symbol && (symbol = lex());
							action = table[state] && table[state][symbol]
						}
						if ("undefined" === typeof action || !action.length || !action[0])
						{
							if (!recovering)
							{
								expected = [];
								for (p in table[state]) this.terminals_[p] && p > 2 && expected.push("'" + this.terminals_[p] + "'");
								var errStr = "";
								errStr = this.lexer.showPosition ? "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + this.terminals_[symbol] + "'" : "Parse error on line " + (yylineno + 1) + ": Unexpected " + (1 == symbol ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
								this.parseError(errStr,
								{
									text: this.lexer.match,
									token: this.terminals_[symbol] || symbol,
									line: this.lexer.yylineno,
									loc: yyloc,
									expected: expected
								})
							}
							if (3 == recovering)
							{
								if (symbol == EOF) throw new Error(errStr || "Parsing halted.");
								yyleng = this.lexer.yyleng;
								yytext = this.lexer.yytext;
								yylineno = this.lexer.yylineno;
								yyloc = this.lexer.yylloc;
								symbol = lex()
							}
							while (1)
							{
								if (TERROR.toString() in table[state]) break;
								if (0 == state) throw new Error(errStr || "Parsing halted.");
								popStack(1);
								state = stack[stack.length - 1]
							}
							preErrorSymbol = symbol;
							symbol = TERROR;
							state = stack[stack.length - 1];
							action = table[state] && table[state][TERROR];
							recovering = 3
						}
						if (action[0] instanceof Array && action.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
						switch (action[0])
						{
						case 1:
							stack.push(symbol);
							vstack.push(this.lexer.yytext);
							lstack.push(this.lexer.yylloc);
							stack.push(action[1]);
							symbol = null;
							if (preErrorSymbol)
							{
								symbol = preErrorSymbol;
								preErrorSymbol = null
							}
							else
							{
								yyleng = this.lexer.yyleng;
								yytext = this.lexer.yytext;
								yylineno = this.lexer.yylineno;
								yyloc = this.lexer.yylloc;
								recovering > 0 && recovering--
							}
							break;
						case 2:
							len = this.productions_[action[1]][1];
							yyval.$ = vstack[vstack.length - len];
							yyval._$ = {
								first_line: lstack[lstack.length - (len || 1)].first_line,
								last_line: lstack[lstack.length - 1].last_line,
								first_column: lstack[lstack.length - (len || 1)].first_column,
								last_column: lstack[lstack.length - 1].last_column
							};
							r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
							if ("undefined" !== typeof r) return r;
							if (len)
							{
								stack = stack.slice(0, -1 * len * 2);
								vstack = vstack.slice(0, -1 * len);
								lstack = lstack.slice(0, -1 * len)
							}
							stack.push(this.productions_[action[1]][0]);
							vstack.push(yyval.$);
							lstack.push(yyval._$);
							newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
							stack.push(newState);
							break;
						case 3:
							return true
						}
					}
					return true
				}
			};
			var lexer = function ()
			{
				var lexer = {
					EOF: 1,
					parseError: function parseError(str, hash)
					{
						if (!this.yy.parseError) throw new Error(str);
						this.yy.parseError(str, hash)
					},
					setInput: function setInput(input)
					{
						this._input = input;
						this._more = this._less = this.done = false;
						this.yylineno = this.yyleng = 0;
						this.yytext = this.matched = this.match = "";
						this.conditionStack = ["INITIAL"];
						this.yylloc = {
							first_line: 1,
							first_column: 0,
							last_line: 1,
							last_column: 0
						};
						return this
					},
					input: function input()
					{
						var ch = this._input[0];
						this.yytext += ch;
						this.yyleng++;
						this.match += ch;
						this.matched += ch;
						var lines = ch.match(/\n/);
						lines && this.yylineno++;
						this._input = this._input.slice(1);
						return ch
					},
					unput: function unput(ch)
					{
						this._input = ch + this._input;
						return this
					},
					more: function more()
					{
						this._more = true;
						return this
					},
					less: function less(n)
					{
						this._input = this.match.slice(n) + this._input
					},
					pastInput: function pastInput()
					{
						var past = this.matched.substr(0, this.matched.length - this.match.length);
						return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "")
					},
					upcomingInput: function upcomingInput()
					{
						var next = this.match;
						next.length < 20 && (next += this._input.substr(0, 20 - next.length));
						return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "")
					},
					showPosition: function showPosition()
					{
						var pre = this.pastInput();
						var c = new Array(pre.length + 1).join("-");
						return pre + this.upcomingInput() + "\n" + c + "^"
					},
					next: function next()
					{
						if (this.done) return this.EOF;
						this._input || (this.done = true);
						var token, match, tempMatch, index, lines;
						if (!this._more)
						{
							this.yytext = "";
							this.match = ""
						}
						var rules = this._currentRules();
						for (var i = 0; i < rules.length; i++)
						{
							tempMatch = this._input.match(this.rules[rules[i]]);
							if (tempMatch && (!match || tempMatch[0].length > match[0].length))
							{
								match = tempMatch;
								index = i;
								if (!this.options.flex) break
							}
						}
						if (match)
						{
							lines = match[0].match(/\n.*/g);
							lines && (this.yylineno += lines.length);
							this.yylloc = {
								first_line: this.yylloc.last_line,
								last_line: this.yylineno + 1,
								first_column: this.yylloc.last_column,
								last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
							};
							this.yytext += match[0];
							this.match += match[0];
							this.yyleng = this.yytext.length;
							this._more = false;
							this._input = this._input.slice(match[0].length);
							this.matched += match[0];
							token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
							this.done && this._input && (this.done = false);
							return token || void 0
						}
						if ("" === this._input) return this.EOF;
						this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(),
						{
							text: "",
							token: null,
							line: this.yylineno
						})
					},
					lex: function lex()
					{
						var r = this.next();
						return "undefined" !== typeof r ? r : this.lex()
					},
					begin: function begin(condition)
					{
						this.conditionStack.push(condition)
					},
					popState: function popState()
					{
						return this.conditionStack.pop()
					},
					_currentRules: function _currentRules()
					{
						return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
					},
					topState: function topState()
					{
						return this.conditionStack[this.conditionStack.length - 2]
					},
					pushState: function begin(condition)
					{
						this.begin(condition)
					}
				};
				lexer.options = {};
				lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START)
				{
					switch ($avoiding_name_collisions)
					{
					case 0:
						break;
					case 1:
						return 6;
					case 2:
						yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
						return 4;
					case 3:
						return 17;
					case 4:
						return 18;
					case 5:
						return 23;
					case 6:
						return 24;
					case 7:
						return 22;
					case 8:
						return 21;
					case 9:
						return 10;
					case 10:
						return 11;
					case 11:
						return 8;
					case 12:
						return 14;
					case 13:
						return "INVALID"
					}
				};
				lexer.rules = [/^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/];
				lexer.conditions = {
					INITIAL:
					{
						rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
						inclusive: true
					}
				};
				return lexer
			}();
			parser.lexer = lexer;
			return parser
		}();
		true;
		exports.parser = jsonlint;
		exports.parse = function ()
		{
			return jsonlint.parse.apply(jsonlint, arguments)
		}
	},
	5353: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.ExcludedIntelliSenseTriggerKeys = {
			9: "tab",
			13: "enter",
			16: "shift",
			17: "ctrl",
			18: "alt",
			19: "pause",
			20: "capslock",
			27: "escape",
			33: "pageup",
			34: "pagedown",
			35: "end",
			36: "home",
			37: "left",
			38: "up",
			39: "right",
			40: "down",
			45: "insert",
			91: "left window key",
			92: "right window key",
			93: "select",
			112: "f1",
			113: "f2",
			114: "f3",
			115: "f4",
			116: "f5",
			117: "f6",
			118: "f7",
			119: "f8",
			120: "f9",
			121: "f10",
			122: "f11",
			123: "f12",
			144: "numlock",
			145: "scrolllock"
		}
	},
	5354: function (module, exports, __webpack_require__)
	{
		"use strict";
		var QueryString = exports;
		var Buffer = __webpack_require__(141).Buffer;
		QueryString.unescapeBuffer = function (s, decodeSpaces)
		{
			var out = new Buffer(s.length);
			var state = 0;
			var n, m, hexchar;
			for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++)
			{
				var c = inIndex < s.length ? s.charCodeAt(inIndex) : NaN;
				switch (state)
				{
				case 0:
					switch (c)
					{
					case 37:
						n = 0;
						m = 0;
						state = 1;
						break;
					case 43:
						decodeSpaces && (c = 32);
					default:
						out[outIndex++] = c
					}
					break;
				case 1:
					hexchar = c;
					if (c >= 48 && c <= 57) n = c - 48;
					else if (c >= 65 && c <= 70) n = c - 65 + 10;
					else
					{
						if (!(c >= 97 && c <= 102))
						{
							out[outIndex++] = 37;
							out[outIndex++] = c;
							state = 0;
							break
						}
						n = c - 97 + 10
					}
					state = 2;
					break;
				case 2:
					state = 0;
					if (c >= 48 && c <= 57) m = c - 48;
					else if (c >= 65 && c <= 70) m = c - 65 + 10;
					else
					{
						if (!(c >= 97 && c <= 102))
						{
							out[outIndex++] = 37;
							out[outIndex++] = hexchar;
							out[outIndex++] = c;
							break
						}
						m = c - 97 + 10
					}
					out[outIndex++] = 16 * n + m
				}
			}
			return out.slice(0, outIndex - 1)
		};

		function qsUnescape(s, decodeSpaces)
		{
			try
			{
				return decodeURIComponent(s)
			}
			catch (e)
			{
				return QueryString.unescapeBuffer(s, decodeSpaces).toString()
			}
		}
		QueryString.unescape = qsUnescape;
		var hexTable = new Array(256);
		for (var i = 0; i < 256; ++i) hexTable[i] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
		QueryString.escape = function (str)
		{
			"string" !== typeof str && (str += "");
			var out = "";
			var lastPos = 0;
			for (var i = 0; i < str.length; ++i)
			{
				var c = str.charCodeAt(i);
				if (33 === c || 45 === c || 46 === c || 95 === c || 126 === c || c >= 39 && c <= 42 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) continue;
				i - lastPos > 0 && (out += str.slice(lastPos, i));
				if (c < 128)
				{
					lastPos = i + 1;
					out += hexTable[c];
					continue
				}
				if (c < 2048)
				{
					lastPos = i + 1;
					out += hexTable[192 | c >> 6] + hexTable[128 | 63 & c];
					continue
				}
				if (c < 55296 || c >= 57344)
				{
					lastPos = i + 1;
					out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c];
					continue
				}++i;
				var c2;
				if (!(i < str.length)) throw new URIError("URI malformed");
				c2 = 1023 & str.charCodeAt(i);
				lastPos = i + 1;
				c = 65536 + ((1023 & c) << 10 | c2);
				out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c]
			}
			if (0 === lastPos) return str;
			if (lastPos < str.length) return out + str.slice(lastPos);
			return out
		};
		var stringifyPrimitive = function (v)
		{
			if ("string" === typeof v) return v;
			if ("number" === typeof v && isFinite(v)) return "" + v;
			if ("boolean" === typeof v) return v ? "true" : "false";
			return ""
		};
		QueryString.stringify = QueryString.encode = function (obj, sep, eq, options)
		{
			sep = sep || "&";
			eq = eq || "=";
			var encode = QueryString.escape;
			options && "function" === typeof options.encodeURIComponent && (encode = options.encodeURIComponent);
			if (null !== obj && "object" === typeof obj)
			{
				var keys = Object.keys(obj);
				var len = keys.length;
				var flast = len - 1;
				var fields = "";
				for (var i = 0; i < len; ++i)
				{
					var k = keys[i];
					var v = obj[k];
					var ks = encode(stringifyPrimitive(k)) + eq;
					if (Array.isArray(v))
					{
						var vlen = v.length;
						var vlast = vlen - 1;
						for (var j = 0; j < vlen; ++j)
						{
							fields += ks + encode(stringifyPrimitive(v[j]));
							j < vlast && (fields += sep)
						}
						vlen && i < flast && (fields += sep)
					}
					else
					{
						fields += ks + encode(stringifyPrimitive(v));
						i < flast && (fields += sep)
					}
				}
				return fields
			}
			return ""
		};
		QueryString.parse = QueryString.decode = function (qs, sep, eq, options)
		{
			sep = sep || "&";
			eq = eq || "=";
			var obj = {};
			if ("string" !== typeof qs || 0 === qs.length) return obj;
			"string" !== typeof sep && (sep += "");
			var eqLen = eq.length;
			var sepLen = sep.length;
			var maxKeys = 1e3;
			options && "number" === typeof options.maxKeys && (maxKeys = options.maxKeys);
			var pairs = Infinity;
			maxKeys > 0 && (pairs = maxKeys);
			var decode = QueryString.unescape;
			options && "function" === typeof options.decodeURIComponent && (decode = options.decodeURIComponent);
			var customDecode = decode !== qsUnescape;
			var keys = [];
			var lastPos = 0;
			var sepIdx = 0;
			var eqIdx = 0;
			var key = "";
			var value = "";
			var keyEncoded = customDecode;
			var valEncoded = customDecode;
			var encodeCheck = 0;
			for (var i = 0; i < qs.length; ++i)
			{
				var code = qs.charCodeAt(i);
				if (code === sep.charCodeAt(sepIdx))
				{
					if (++sepIdx === sepLen)
					{
						var end = i - sepIdx + 1;
						eqIdx < eqLen ? lastPos < end && (key += qs.slice(lastPos, end)) : lastPos < end && (value += qs.slice(lastPos, end));
						keyEncoded && (key = decodeStr(key, decode));
						valEncoded && (value = decodeStr(value, decode));
						if (-1 === keys.indexOf(key))
						{
							obj[key] = value;
							keys[keys.length] = key
						}
						else
						{
							var curValue = obj[key];
							curValue instanceof Array ? curValue[curValue.length] = value : obj[key] = [curValue, value]
						}
						if (0 === --pairs) break;
						keyEncoded = valEncoded = customDecode;
						encodeCheck = 0;
						key = value = "";
						lastPos = i + 1;
						sepIdx = eqIdx = 0
					}
					continue
				}
				sepIdx = 0;
				valEncoded || (37 === code ? encodeCheck = 1 : encodeCheck > 0 && (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102) ? 3 === ++encodeCheck && (valEncoded = true) : encodeCheck = 0);
				if (eqIdx < eqLen)
				{
					if (code === eq.charCodeAt(eqIdx))
					{
						if (++eqIdx === eqLen)
						{
							end = i - eqIdx + 1;
							lastPos < end && (key += qs.slice(lastPos, end));
							encodeCheck = 0;
							lastPos = i + 1
						}
						continue
					}
					eqIdx = 0;
					keyEncoded || (37 === code ? encodeCheck = 1 : encodeCheck > 0 && (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102) ? 3 === ++encodeCheck && (keyEncoded = true) : encodeCheck = 0)
				}
				if (43 === code)
				{
					if (eqIdx < eqLen)
					{
						i - lastPos > 0 && (key += qs.slice(lastPos, i));
						key += "%20";
						keyEncoded = true
					}
					else
					{
						i - lastPos > 0 && (value += qs.slice(lastPos, i));
						value += "%20";
						valEncoded = true
					}
					lastPos = i + 1
				}
			}
			if (pairs > 0 && (lastPos < qs.length || eqIdx > 0))
			{
				lastPos < qs.length && (eqIdx < eqLen ? key += qs.slice(lastPos) : sepIdx < sepLen && (value += qs.slice(lastPos)));
				keyEncoded && (key = decodeStr(key, decode));
				valEncoded && (value = decodeStr(value, decode));
				if (-1 === keys.indexOf(key))
				{
					obj[key] = value;
					keys[keys.length] = key
				}
				else
				{
					curValue = obj[key];
					curValue instanceof Array ? curValue[curValue.length] = value : obj[key] = [curValue, value]
				}
			}
			return obj
		};

		function decodeStr(s, decoder)
		{
			try
			{
				return decoder(s)
			}
			catch (e)
			{
				return QueryString.unescape(s, true)
			}
		}
	},
	5355: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var _reporting = __webpack_require__(5356);
		var _healthCheck = __webpack_require__(5357);
		var _blankScreenController = __webpack_require__(5358);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.controller("reportingController", _reporting.ReportingController).controller("healthCheck", _healthCheck.HealthCheck).controller("blankScreenController", _blankScreenController.BlankScreenController)
	},
	5356: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ReportingController = function ()
		{
			function ReportingController($scope, errorHandler, genericReq)
			{
				_classCallCheck(this, ReportingController);
				this.$scope = $scope;
				this.errorHandler = errorHandler;
				this.genericReq = genericReq;
				this.loading = true;
				this.itemsPerPage = 15;
				this.pagedItems = [];
				this.currentPage = 0;
				this.items = [];
				this.gap = 0
			}
			_createClass(ReportingController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					this.load()
				}
			},
			{
				key: "search",
				value: function search()
				{
					this.filteredItems = this.items;
					this.currentPage = 0;
					this.groupToPages()
				}
			},
			{
				key: "deleteReport",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(name)
					{
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								this.loading = true;
								_context.next = 4;
								return this.genericReq.request("DELETE", "/reports/" + name,
								{});
							case 4:
								_context.next = 6;
								return this.load();
							case 6:
								this.errorHandler.info("Success", "Reporting");
								_context.next = 12;
								break;
							case 9:
								_context.prev = 9;
								_context.t0 = _context["catch"](0);
								this.errorHandler.handle(_context.t0, "Reporting");
							case 12:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 9]
						])
					}));

					function deleteReport(_x)
					{
						return _ref.apply(this, arguments)
					}
					return deleteReport
				}()
			},
			{
				key: "groupToPages",
				value: function groupToPages()
				{
					this.pagedItems = [];
					for (var i = 0; i < this.filteredItems.length; i++) i % this.itemsPerPage === 0 ? this.pagedItems[Math.floor(i / this.itemsPerPage)] = [this.filteredItems[i]] : this.pagedItems[Math.floor(i / this.itemsPerPage)].push(this.filteredItems[i])
				}
			},
			{
				key: "range",
				value: function range(size, start, end)
				{
					var ret = [];
					if (size < end)
					{
						end = size;
						start = size - this.gap
					}
					for (var i = start; i < end; i++) ret.push(i);
					return ret
				}
			},
			{
				key: "prevPage",
				value: function prevPage()
				{
					this.currentPage > 0 && this.currentPage--
				}
			},
			{
				key: "nextPage",
				value: function nextPage(n)
				{
					!n && 0 !== n && this.currentPage < this.pagedItems.length - 1 && this.currentPage++
				}
			},
			{
				key: "setPage",
				value: function setPage(n)
				{
					this.currentPage = n;
					this.nextPage(n)
				}
			},
			{
				key: "load",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2()
					{
						var data, gap, gapInteger;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								this.loading = true;
								_context2.next = 4;
								return this.genericReq.request("GET", "/reports",
								{});
							case 4:
								data = _context2.sent;
								this.items = data.data.list;
								gap = this.items.length / 15;
								gapInteger = parseInt(this.items.length / 15);
								this.gap = gap - parseInt(this.items.length / 15) > 0 ? gapInteger + 1 : gapInteger;
								this.gap > 5 && (this.gap = 5);
								this.search();
								this.loading = false;
								this.$scope.$$phase || this.$scope.$digest();
								_context2.next = 18;
								break;
							case 15:
								_context2.prev = 15;
								_context2.t0 = _context2["catch"](0);
								this.errorHandler.handle(_context2.t0, "Reporting");
							case 18:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 15]
						])
					}));

					function load()
					{
						return _ref2.apply(this, arguments)
					}
					return load
				}()
			}]);
			return ReportingController
		}()
	},
	5357: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.HealthCheck = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _saved_objects = __webpack_require__(54);

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.HealthCheck = function ()
		{
			function HealthCheck($scope, $rootScope, $timeout, $location, genericReq, apiReq, appState, testAPI, errorHandler, wazuhConfig, Private, $window)
			{
				_classCallCheck(this, HealthCheck);
				this.$scope = $scope;
				this.$rootScope = $rootScope;
				this.$timeout = $timeout;
				this.$location = $location;
				this.genericReq = genericReq;
				this.apiReq = apiReq;
				this.appState = appState;
				this.testAPI = testAPI;
				this.errorHandler = errorHandler;
				this.wazuhConfig = wazuhConfig;
				this.$window = $window;
				this.results = [];
				this.savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);
				this.checks = {
					api: true,
					pattern: true,
					setup: true,
					template: true
				};
				this.errors = [];
				this.processedChecks = 0;
				this.totalChecks = 0
			}
			_createClass(HealthCheck, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					this.load()
				}
			},
			{
				key: "handleError",
				value: function handleError(error)
				{
					this.errors.push(this.errorHandler.handle(error, "Health Check", false, true))
				}
			},
			{
				key: "checkPatterns",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var data, patternTitle, i, patternData, _i, templateData;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return this.savedObjectsClient.get("index-pattern", this.appState.getCurrentPattern());
							case 3:
								data = _context.sent;
								patternTitle = data.attributes.title;
								if (!this.checks.pattern)
								{
									_context.next = 11;
									break
								}
								i = this.results.map(function (item)
								{
									return item.id
								}).indexOf(2);
								_context.next = 9;
								return this.genericReq.request("GET", "/elastic/index-patterns/" + patternTitle);
							case 9:
								patternData = _context.sent;
								if (patternData.data.status)
								{
									this.processedChecks++;
									this.results[i].status = "Ready"
								}
								else
								{
									this.errors.push("The selected index-pattern is not present.");
									this.results[i].status = "Error"
								}
							case 11:
								if (!this.checks.template)
								{
									_context.next = 17;
									break
								}
								_i = this.results.map(function (item)
								{
									return item.id
								}).indexOf(3);
								_context.next = 15;
								return this.genericReq.request("GET", "/elastic/template/" + patternTitle);
							case 15:
								templateData = _context.sent;
								if (templateData.data.status)
								{
									this.processedChecks++;
									this.results[_i].status = "Ready"
								}
								else
								{
									this.errors.push("No template found for the selected index-pattern.");
									this.results[_i].status = "Error"
								}
							case 17:
								this.$scope.$$phase || this.$scope.$digest();
								return _context.abrupt("return");
							case 21:
								_context.prev = 21;
								_context.t0 = _context["catch"](0);
								this.handleError(_context.t0);
							case 24:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 21]
						])
					}));

					function checkPatterns()
					{
						return _ref.apply(this, arguments)
					}
					return checkPatterns
				}()
			},
			{
				key: "checkApiConnection",
				value: function ()
				{
					var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2()
					{
						var data, apiRaw, i, versionData, apiVersion, setupData, apiSplit, appSplit, _i2;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								if (!this.checks.api)
								{
									_context2.next = 29;
									break
								}
								_context2.next = 4;
								return this.testAPI.checkStored(JSON.parse(this.appState.getCurrentAPI()).id);
							case 4:
								data = _context2.sent;
								if (((data ||
									{}).data ||
									{}).idChanged)
								{
									apiRaw = JSON.parse(this.appState.getCurrentAPI());
									this.appState.setCurrentAPI(JSON.stringify(
									{
										name: apiRaw.name,
										id: data.data.idChanged
									}))
								}
								i = this.results.map(function (item)
								{
									return item.id
								}).indexOf(0);
								if (!(data.data.error || data.data.data.apiIsDown))
								{
									_context2.next = 12;
									break
								}
								this.errors.push("Error connecting to the API.");
								this.results[i].status = "Error";
								_context2.next = 27;
								break;
							case 12:
								this.processedChecks++;
								this.results[i].status = "Ready";
								if (!this.checks.setup)
								{
									_context2.next = 27;
									break
								}
								_context2.next = 17;
								return this.apiReq.request("GET", "/version",
								{});
							case 17:
								versionData = _context2.sent;
								apiVersion = versionData.data.data;
								_context2.next = 21;
								return this.genericReq.request("GET", "/elastic/setup");
							case 21:
								setupData = _context2.sent;
								if (!setupData.data.data["app-version"] || !apiVersion)
								{
									this.errorHandler.handle("Error fetching app version or API version", "Health Check");
									this.errors.push("Error fetching version")
								}
								apiSplit = apiVersion.split("v")[1].split(".");
								appSplit = setupData.data.data["app-version"].split(".");
								_i2 = this.results.map(function (item)
								{
									return item.id
								}).indexOf(1);
								if (apiSplit[0] !== appSplit[0] || apiSplit[1] !== appSplit[1])
								{
									this.errors.push("API version mismatch. Expected v" + setupData.data.data["app-version"]);
									this.results[_i2].status = "Error"
								}
								else
								{
									this.processedChecks++;
									this.results[_i2].status = "Ready"
								}
							case 27:
								_context2.next = 30;
								break;
							case 29:
								this.checks.setup && this.processedChecks++;
							case 30:
								this.$scope.$$phase || this.$scope.$digest();
								return _context2.abrupt("return");
							case 34:
								_context2.prev = 34;
								_context2.t0 = _context2["catch"](0);
								this.handleError(_context2.t0);
							case 37:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 34]
						])
					}));

					function checkApiConnection()
					{
						return _ref2.apply(this, arguments)
					}
					return checkApiConnection
				}()
			},
			{
				key: "load",
				value: function ()
				{
					var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3()
					{
						var configuration, key;
						return regeneratorRuntime.wrap(function _callee3$(_context3)
						{
							while (1) switch (_context3.prev = _context3.next)
							{
							case 0:
								_context3.prev = 0;
								configuration = this.wazuhConfig.getConfig();
								this.appState.setPatternSelector(configuration["ip.selector"]);
								this.checks.pattern = configuration["checks.pattern"];
								this.checks.template = configuration["checks.template"];
								this.checks.api = configuration["checks.api"];
								this.checks.setup = configuration["checks.setup"];
								this.results.push(
								{
									id: 0,
									description: "Check 1",
									status: this.checks.api ? "Checking..." : "disabled"
								},
								{
									id: 1,
									description: "Check 2",
									status: this.checks.setup ? "Checking..." : "disabled"
								},
								{
									id: 2,
									description: "Check 3",
									status: this.checks.pattern ? "Checking..." : "disabled"
								},
								{
									id: 3,
									description: "Check 4",
									status: this.checks.template ? "Checking..." : "disabled"
								},
								{
									id: 4,
									description: "Check 5",
									status: "Checking..."
								});
								for (key in this.checks) this.totalChecks += this.checks[key] ? 1 : 0;
								0 == this.totalChecks && (this.zeroChecks = true);
								_context3.next = 12;
								return Promise.all([this.checkPatterns(), this.checkApiConnection()]);
							case 12:
								this.checksDone = true;
								_context3.prev = 13;
								_context3.next = 16;
								return this.genericReq.request("GET", "/elastic/known-fields/all",
								{});
							case 16:
								this.results[this.results.length - 1].status = "Ready";
								_context3.next = 23;
								break;
							case 19:
								_context3.prev = 19;
								_context3.t0 = _context3["catch"](13);
								this.results[this.results.length - 1].status = "Error";
								this.handleError(_context3.t0);
							case 23:
								if (!(!this.errors || !this.errors.length))
								{
									_context3.next = 28;
									break
								}
								_context3.next = 26;
								return this.$timeout(800);
							case 26:
								this.$window.location.assign("/app/wazuh#" + this.$rootScope.previousLocation || "");
								return _context3.abrupt("return");
							case 28:
								this.$scope.$$phase || this.$scope.$digest();
								return _context3.abrupt("return");
							case 32:
								_context3.prev = 32;
								_context3.t1 = _context3["catch"](0);
								this.handleError(_context3.t1);
							case 35:
							case "end":
								return _context3.stop()
							}
						}, _callee3, this, [
							[0, 32],
							[13, 19]
						])
					}));

					function load()
					{
						return _ref3.apply(this, arguments)
					}
					return load
				}()
			},
			{
				key: "goApp",
				value: function goApp()
				{
					this.$window.location.assign("/app/wazuh#" + this.$rootScope.previousLocation || "")
				}
			}]);
			return HealthCheck
		}()
	},
	5358: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.BlankScreenController = function ()
		{
			function BlankScreenController($scope, $location, errorHandler, wzMisc)
			{
				_classCallCheck(this, BlankScreenController);
				this.$scope = $scope;
				this.$location = $location;
				this.errorHandler = errorHandler;
				this.wzMisc = wzMisc
			}
			_createClass(BlankScreenController, [
			{
				key: "$onInit",
				value: function $onInit()
				{
					var catchedError = this.wzMisc.getBlankScr();
					if (catchedError)
					{
						var parsed = null;
						try
						{
							parsed = this.errorHandler.handle(catchedError, "", false, true)
						}
						catch (error)
						{}
						this.errorToShow = parsed || catchedError;
						this.wzMisc.setBlankScr(false);
						this.$scope.$$phase || this.$scope.$digest()
					}
				}
			},
			{
				key: "goOverview",
				value: function goOverview()
				{
					this.$location.path("/overview")
				}
			}]);
			return BlankScreenController
		}()
	},
	5359: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _rawVisualizations = __webpack_require__(5360);
		var _loadedVisualizations = __webpack_require__(5361);
		var _tabVisualizations = __webpack_require__(5362);
		var _discoverPendingUpdates = __webpack_require__(5363);
		var _visHandlers = __webpack_require__(5364);
		var _vis2png = __webpack_require__(5365);
		var _shareAgent = __webpack_require__(5367);
		var _misc = __webpack_require__(5368);
		var _wazuhConfig = __webpack_require__(5369);
		var _modules = __webpack_require__(2);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.service("rawVisualizations", _rawVisualizations.RawVisualizations).service("loadedVisualizations", _loadedVisualizations.LoadedVisualizations).service("tabVisualizations", _tabVisualizations.TabVisualizations).service("discoverPendingUpdates", _discoverPendingUpdates.DiscoverPendingUpdates).service("visHandlers", _visHandlers.VisHandlers).service("vis2png", _vis2png.Vis2PNG).service("shareAgent", _shareAgent.ShareAgent).service("wzMisc", _misc.WzMisc).service("wazuhConfig", _wazuhConfig.WazuhConfig)
	},
	5360: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.RawVisualizations = function ()
		{
			function RawVisualizations()
			{
				_classCallCheck(this, RawVisualizations);
				this.list = []
			}
			_createClass(RawVisualizations, [
			{
				key: "addItem",
				value: function addItem(item)
				{
					this.list.push(item)
				}
			},
			{
				key: "assignItems",
				value: function assignItems(items)
				{
					this.list = Array.isArray(items) ? items : []
				}
			},
			{
				key: "getList",
				value: function getList()
				{
					return this.list
				}
			},
			{
				key: "removeAll",
				value: function removeAll()
				{
					this.list = []
				}
			}]);
			return RawVisualizations
		}()
	},
	5361: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.LoadedVisualizations = function ()
		{
			function LoadedVisualizations()
			{
				_classCallCheck(this, LoadedVisualizations);
				this.list = []
			}
			_createClass(LoadedVisualizations, [
			{
				key: "addItem",
				value: function addItem(item)
				{
					this.list.push(item)
				}
			},
			{
				key: "getList",
				value: function getList()
				{
					return this.list
				}
			},
			{
				key: "removeAll",
				value: function removeAll()
				{
					this.list = []
				}
			}]);
			return LoadedVisualizations
		}()
	},
	5362: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.TabVisualizations = function ()
		{
			function TabVisualizations()
			{
				_classCallCheck(this, TabVisualizations);
				this.agents = {
					welcome: 0,
					general: 7,
					fim: 7,
					pm: 4,
					vuls: 10,
					oscap: 13,
					ciscat: 11,
					audit: 15,
					gdpr: 3,
					pci: 3,
					virustotal: 6,
					configuration: 0,
					osquery: 5
				};
				this.overview = {
					welcome: 0,
					general: 11,
					fim: 8,
					pm: 5,
					vuls: 10,
					oscap: 11,
					ciscat: 11,
					audit: 15,
					pci: 6,
					gdpr: 6,
					aws: 6,
					virustotal: 7,
					osquery: 5
				};
				this.tabVisualizations = {};
				this.currentTab = ""
			}
			_createClass(TabVisualizations, [
			{
				key: "setTab",
				value: function setTab(tab)
				{
					this.currentTab = tab
				}
			},
			{
				key: "getTab",
				value: function getTab()
				{
					return this.currentTab
				}
			},
			{
				key: "getItem",
				value: function getItem(item)
				{
					return this.tabVisualizations[item]
				}
			},
			{
				key: "assign",
				value: function assign(tabs)
				{
					"object" === ("undefined" === typeof tabs ? "undefined" : _typeof(tabs)) ? this.tabVisualizations = tabs: "string" === typeof tabs && (this.tabVisualizations = "overview" === tabs ? this.overview : this.agents)
				}
			},
			{
				key: "removeAll",
				value: function removeAll()
				{
					this.tabVisualizations = {}
				}
			}]);
			return TabVisualizations
		}()
	},
	5363: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.DiscoverPendingUpdates = function ()
		{
			function DiscoverPendingUpdates()
			{
				_classCallCheck(this, DiscoverPendingUpdates);
				this.pendingUpdates = []
			}
			_createClass(DiscoverPendingUpdates, [
			{
				key: "addItem",
				value: function addItem(query, filters)
				{
					this.pendingUpdates.push(query, filters)
				}
			},
			{
				key: "getList",
				value: function getList()
				{
					return this.pendingUpdates
				}
			},
			{
				key: "removeAll",
				value: function removeAll()
				{
					this.pendingUpdates = []
				}
			}]);
			return DiscoverPendingUpdates
		}()
	},
	5364: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.VisHandlers = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _datemath = __webpack_require__(83);
		var _datemath2 = _interopRequireDefault(_datemath);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _toConsumableArray(arr)
		{
			if (Array.isArray(arr))
			{
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2
			}
			return Array.from(arr)
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.VisHandlers = function ()
		{
			function VisHandlers()
			{
				_classCallCheck(this, VisHandlers);
				this.list = []
			}
			_createClass(VisHandlers, [
			{
				key: "addItem",
				value: function addItem(item)
				{
					this.list.push(item)
				}
			},
			{
				key: "getList",
				value: function getList()
				{
					return this.list
				}
			},
			{
				key: "getAppliedFilters",
				value: function getAppliedFilters(syscollector)
				{
					var appliedFilters = {};
					if (syscollector)
					{
						Object.assign(appliedFilters,
						{
							filters: syscollector,
							time:
							{
								from: "now-1d/d",
								to: "now"
							},
							searchBar: false,
							tables: []
						});
						return appliedFilters
					}
					var tables = this.list.filter(function (item)
					{
						return "table" === (((item ||
						{}).vis ||
						{})._state ||
						{}).type
					}).map(function (item)
					{
						var columns = [];
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = void 0;
						try
						{
							for (var _step, _iterator = item.dataLoader.visData.tables[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
							{
								var table = _step.value;
								columns.push.apply(columns, _toConsumableArray(table.columns.map(function (t)
								{
									return t.title
								})))
							}
						}
						catch (err)
						{
							_didIteratorError = true;
							_iteratorError = err
						}
						finally
						{
							try
							{
								!_iteratorNormalCompletion && _iterator.return && _iterator.return()
							}
							finally
							{
								if (_didIteratorError) throw _iteratorError
							}
						}
						return !!(((item ||
						{}).vis ||
						{}).searchSource ||
						{}).rawResponse &&
						{
							rawResponse: item.vis.searchSource.rawResponse,
							title: item.vis.title || "Table",
							columns: columns
						}
					});
					if (this.list && this.list.length)
					{
						var visualization = this.list[0].vis;
						var filters = visualization.API.queryFilter.getFilters();
						var _visualization$API$ti = visualization.API.timeFilter.getTime(),
							from = _visualization$API$ti.from,
							to = _visualization$API$ti.to;
						var query = visualization.searchSource._fields.query.query;
						Object.assign(appliedFilters,
						{
							filters: filters,
							time:
							{
								from: _datemath2.default.parse(from),
								to: _datemath2.default.parse(to)
							},
							searchBar: query,
							tables: tables
						})
					}
					return appliedFilters
				}
			},
			{
				key: "hasData",
				value: function hasData()
				{
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = void 0;
					try
					{
						for (var _step2, _iterator2 = this.list[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true)
						{
							var item = _step2.value;
							if (item && item.vis && "Agents status" !== item.vis.title && item.vis.searchSource && item.vis.searchSource.rawResponse && item.vis.searchSource.rawResponse.hits && item.vis.searchSource.rawResponse.hits.total) return true
						}
					}
					catch (err)
					{
						_didIteratorError2 = true;
						_iteratorError2 = err
					}
					finally
					{
						try
						{
							!_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return()
						}
						finally
						{
							if (_didIteratorError2) throw _iteratorError2
						}
					}
					return false
				}
			},
			{
				key: "removeAll",
				value: function removeAll()
				{
					this.list = []
				}
			}]);
			return VisHandlers
		}()
	},
	5365: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.Vis2PNG = void 0;
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _domToImage = __webpack_require__(5366);
		var _domToImage2 = _interopRequireDefault(_domToImage);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.Vis2PNG = function ()
		{
			function Vis2PNG($rootScope)
			{
				_classCallCheck(this, Vis2PNG);
				this.$rootScope = $rootScope;
				this.rawArray = [];
				this.htmlObject = {};
				this.working = false
			}
			_createClass(Vis2PNG, [
			{
				key: "checkArray",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(visArray)
					{
						var _this = this;
						var len, currentCompleted;
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								this.working = true;
								len = visArray.length;
								currentCompleted = 0;
								_context2.next = 6;
								return Promise.all(visArray.map(function ()
								{
									var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee(currentValue)
									{
										var tmpNode, tmpResult;
										return regeneratorRuntime.wrap(function _callee$(_context)
										{
											while (1) switch (_context.prev = _context.next)
											{
											case 0:
												tmpNode = _this.htmlObject[currentValue];
												_context.prev = 1;
												_context.next = 4;
												return _domToImage2.default.toPng(tmpNode[0]);
											case 4:
												tmpResult = _context.sent;
												_this.rawArray.push(
												{
													element: tmpResult,
													width: tmpNode.width(),
													height: tmpNode.height(),
													id: currentValue
												});
												_context.next = 10;
												break;
											case 8:
												_context.prev = 8;
												_context.t0 = _context["catch"](1);
											case 10:
												currentCompleted++;
												_this.$rootScope.reportStatus = "Generating report..." + Math.round(currentCompleted / len * 100) + "%";
												_this.$rootScope.$$phase || _this.$rootScope.$digest();
											case 13:
											case "end":
												return _context.stop()
											}
										}, _callee, _this, [
											[1, 8]
										])
									}));
									return function (_x2)
									{
										return _ref2.apply(this, arguments)
									}
								}()));
							case 6:
								this.working = false;
								this.$rootScope.reportStatus = "Generating PDF document...";
								return _context2.abrupt("return", this.rawArray);
							case 11:
								_context2.prev = 11;
								_context2.t0 = _context2["catch"](0);
								this.working = false;
								return _context2.abrupt("return", Promise.reject(_context2.t0));
							case 15:
							case "end":
								return _context2.stop()
							}
						}, _callee2, this, [
							[0, 11]
						])
					}));

					function checkArray(_x)
					{
						return _ref.apply(this, arguments)
					}
					return checkArray
				}()
			},
			{
				key: "isWorking",
				value: function isWorking()
				{
					return this.working
				}
			},
			{
				key: "clear",
				value: function clear()
				{
					this.rawArray = [];
					this.htmlObject = {}
				}
			},
			{
				key: "assignHTMLItem",
				value: function assignHTMLItem(id, content)
				{
					this.htmlObject[id] = content
				}
			}]);
			return Vis2PNG
		}()
	},
	5366: function (module, exports, __webpack_require__)
	{
		(function (global)
		{
			"use strict";
			var util = newUtil();
			var inliner = newInliner();
			var fontFaces = newFontFaces();
			var images = newImages();
			var defaultOptions = {
				imagePlaceholder: void 0,
				cacheBust: false
			};
			var domtoimage = {
				toSvg: toSvg,
				toPng: toPng,
				toJpeg: toJpeg,
				toBlob: toBlob,
				toPixelData: toPixelData,
				impl:
				{
					fontFaces: fontFaces,
					images: images,
					util: util,
					inliner: inliner,
					options:
					{}
				}
			};
			true;
			module.exports = domtoimage;

			function toSvg(node, options)
			{
				options = options ||
				{};
				copyOptions(options);
				return Promise.resolve(node).then(function (node)
				{
					return cloneNode(node, options.filter, true)
				}).then(embedFonts).then(inlineImages).then(applyOptions).then(function (clone)
				{
					return makeSvgDataUri(clone, options.width || util.width(node), options.height || util.height(node))
				});

				function applyOptions(clone)
				{
					options.bgcolor && (clone.style.backgroundColor = options.bgcolor);
					options.width && (clone.style.width = options.width + "px");
					options.height && (clone.style.height = options.height + "px");
					options.style && Object.keys(options.style).forEach(function (property)
					{
						clone.style[property] = options.style[property]
					});
					return clone
				}
			}

			function toPixelData(node, options)
			{
				return draw(node, options ||
				{}).then(function (canvas)
				{
					return canvas.getContext("2d").getImageData(0, 0, util.width(node), util.height(node)).data
				})
			}

			function toPng(node, options)
			{
				return draw(node, options ||
				{}).then(function (canvas)
				{
					return canvas.toDataURL()
				})
			}

			function toJpeg(node, options)
			{
				options = options ||
				{};
				return draw(node, options).then(function (canvas)
				{
					return canvas.toDataURL("image/jpeg", options.quality || 1)
				})
			}

			function toBlob(node, options)
			{
				return draw(node, options ||
				{}).then(util.canvasToBlob)
			}

			function copyOptions(options)
			{
				"undefined" === typeof options.imagePlaceholder ? domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder : domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;
				"undefined" === typeof options.cacheBust ? domtoimage.impl.options.cacheBust = defaultOptions.cacheBust : domtoimage.impl.options.cacheBust = options.cacheBust
			}

			function draw(domNode, options)
			{
				return toSvg(domNode, options).then(util.makeImage).then(util.delay(100)).then(function (image)
				{
					var canvas = newCanvas(domNode);
					canvas.getContext("2d").drawImage(image, 0, 0);
					return canvas
				});

				function newCanvas(domNode)
				{
					var canvas = document.createElement("canvas");
					canvas.width = options.width || util.width(domNode);
					canvas.height = options.height || util.height(domNode);
					if (options.bgcolor)
					{
						var ctx = canvas.getContext("2d");
						ctx.fillStyle = options.bgcolor;
						ctx.fillRect(0, 0, canvas.width, canvas.height)
					}
					return canvas
				}
			}

			function cloneNode(node, filter, root)
			{
				if (!root && filter && !filter(node)) return Promise.resolve();
				return Promise.resolve(node).then(makeNodeCopy).then(function (clone)
				{
					return cloneChildren(node, clone, filter)
				}).then(function (clone)
				{
					return processClone(node, clone)
				});

				function makeNodeCopy(node)
				{
					if (node instanceof HTMLCanvasElement) return util.makeImage(node.toDataURL());
					return node.cloneNode(false)
				}

				function cloneChildren(original, clone, filter)
				{
					var children = original.childNodes;
					if (0 === children.length) return Promise.resolve(clone);
					return cloneChildrenInOrder(clone, util.asArray(children), filter).then(function ()
					{
						return clone
					});

					function cloneChildrenInOrder(parent, children, filter)
					{
						var done = Promise.resolve();
						children.forEach(function (child)
						{
							done = done.then(function ()
							{
								return cloneNode(child, filter)
							}).then(function (childClone)
							{
								childClone && parent.appendChild(childClone)
							})
						});
						return done
					}
				}

				function processClone(original, clone)
				{
					if (!(clone instanceof Element)) return clone;
					return Promise.resolve().then(cloneStyle).then(clonePseudoElements).then(copyUserInput).then(fixSvg).then(function ()
					{
						return clone
					});

					function cloneStyle()
					{
						copyStyle(window.getComputedStyle(original), clone.style);

						function copyStyle(source, target)
						{
							source.cssText ? target.cssText = source.cssText : copyProperties(source, target);

							function copyProperties(source, target)
							{
								util.asArray(source).forEach(function (name)
								{
									target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name))
								})
							}
						}
					}

					function clonePseudoElements()
					{
						[":before", ":after"].forEach(function (element)
						{
							clonePseudoElement(element)
						});

						function clonePseudoElement(element)
						{
							var style = window.getComputedStyle(original, element);
							var content = style.getPropertyValue("content");
							if ("" === content || "none" === content) return;
							var className = util.uid();
							clone.className = clone.className + " " + className;
							var styleElement = document.createElement("style");
							styleElement.appendChild(formatPseudoElementStyle(className, element, style));
							clone.appendChild(styleElement);

							function formatPseudoElementStyle(className, element, style)
							{
								var selector = "." + className + ":" + element;
								var cssText = style.cssText ? formatCssText(style) : formatCssProperties(style);
								return document.createTextNode(selector + "{" + cssText + "}");

								function formatCssText(style)
								{
									var content = style.getPropertyValue("content");
									return style.cssText + " content: " + content + ";"
								}

								function formatCssProperties(style)
								{
									return util.asArray(style).map(formatProperty).join("; ") + ";";

									function formatProperty(name)
									{
										return name + ": " + style.getPropertyValue(name) + (style.getPropertyPriority(name) ? " !important" : "")
									}
								}
							}
						}
					}

					function copyUserInput()
					{
						original instanceof HTMLTextAreaElement && (clone.innerHTML = original.value);
						original instanceof HTMLInputElement && clone.setAttribute("value", original.value)
					}

					function fixSvg()
					{
						if (!(clone instanceof SVGElement)) return;
						clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
						if (!(clone instanceof SVGRectElement)) return;
						["width", "height"].forEach(function (attribute)
						{
							var value = clone.getAttribute(attribute);
							if (!value) return;
							clone.style.setProperty(attribute, value)
						})
					}
				}
			}

			function embedFonts(node)
			{
				return fontFaces.resolveAll().then(function (cssText)
				{
					var styleNode = document.createElement("style");
					node.appendChild(styleNode);
					styleNode.appendChild(document.createTextNode(cssText));
					return node
				})
			}

			function inlineImages(node)
			{
				return images.inlineAll(node).then(function ()
				{
					return node
				})
			}

			function makeSvgDataUri(node, width, height)
			{
				return Promise.resolve(node).then(function (node)
				{
					node.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
					return (new XMLSerializer).serializeToString(node)
				}).then(util.escapeXhtml).then(function (xhtml)
				{
					return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml + "</foreignObject>"
				}).then(function (foreignObject)
				{
					return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' + foreignObject + "</svg>"
				}).then(function (svg)
				{
					return "data:image/svg+xml;charset=utf-8," + svg
				})
			}

			function newUtil()
			{
				return {
					escape: escape,
					parseExtension: parseExtension,
					mimeType: mimeType,
					dataAsUrl: dataAsUrl,
					isDataUrl: isDataUrl,
					canvasToBlob: canvasToBlob,
					resolveUrl: resolveUrl,
					getAndEncode: getAndEncode,
					uid: uid(),
					delay: delay,
					asArray: asArray,
					escapeXhtml: escapeXhtml,
					makeImage: makeImage,
					width: width,
					height: height
				};

				function mimes()
				{
					var WOFF = "application/font-woff";
					var JPEG = "image/jpeg";
					return {
						woff: WOFF,
						woff2: WOFF,
						ttf: "application/font-truetype",
						eot: "application/vnd.ms-fontobject",
						png: "image/png",
						jpg: JPEG,
						jpeg: JPEG,
						gif: "image/gif",
						tiff: "image/tiff",
						svg: "image/svg+xml"
					}
				}

				function parseExtension(url)
				{
					var match = /\.([^\.\/]*?)$/g.exec(url);
					return match ? match[1] : ""
				}

				function mimeType(url)
				{
					var extension = parseExtension(url).toLowerCase();
					return mimes()[extension] || ""
				}

				function isDataUrl(url)
				{
					return -1 !== url.search(/^(data:)/)
				}

				function toBlob(canvas)
				{
					return new Promise(function (resolve)
					{
						var binaryString = window.atob(canvas.toDataURL().split(",")[1]);
						var length = binaryString.length;
						var binaryArray = new Uint8Array(length);
						for (var i = 0; i < length; i++) binaryArray[i] = binaryString.charCodeAt(i);
						resolve(new Blob([binaryArray],
						{
							type: "image/png"
						}))
					})
				}

				function canvasToBlob(canvas)
				{
					if (canvas.toBlob) return new Promise(function (resolve)
					{
						canvas.toBlob(resolve)
					});
					return toBlob(canvas)
				}

				function resolveUrl(url, baseUrl)
				{
					var doc = document.implementation.createHTMLDocument();
					var base = doc.createElement("base");
					doc.head.appendChild(base);
					var a = doc.createElement("a");
					doc.body.appendChild(a);
					base.href = baseUrl;
					a.href = url;
					return a.href
				}

				function uid()
				{
					var index = 0;
					return function ()
					{
						return "u" + fourRandomChars() + index++;

						function fourRandomChars()
						{
							return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4)
						}
					}
				}

				function makeImage(uri)
				{
					return new Promise(function (resolve, reject)
					{
						var image = new Image;
						image.onload = function ()
						{
							resolve(image)
						};
						image.onerror = reject;
						image.src = uri
					})
				}

				function getAndEncode(url)
				{
					var TIMEOUT = 3e4;
					domtoimage.impl.options.cacheBust && (url += (/\?/.test(url) ? "&" : "?") + (new Date).getTime());
					return new Promise(function (resolve)
					{
						var request = new XMLHttpRequest;
						request.onreadystatechange = done;
						request.ontimeout = timeout;
						request.responseType = "blob";
						request.timeout = TIMEOUT;
						request.open("GET", url, true);
						request.send();
						var placeholder;
						if (domtoimage.impl.options.imagePlaceholder)
						{
							var split = domtoimage.impl.options.imagePlaceholder.split(/,/);
							split && split[1] && (placeholder = split[1])
						}

						function done()
						{
							if (4 !== request.readyState) return;
							if (200 !== request.status)
							{
								placeholder ? resolve(placeholder) : fail("cannot fetch resource: " + url + ", status: " + request.status);
								return
							}
							var encoder = new FileReader;
							encoder.onloadend = function ()
							{
								var content = encoder.result.split(/,/)[1];
								resolve(content)
							};
							encoder.readAsDataURL(request.response)
						}

						function timeout()
						{
							placeholder ? resolve(placeholder) : fail("timeout of " + TIMEOUT + "ms occured while fetching resource: " + url)
						}

						function fail(message)
						{
							console.error(message);
							resolve("")
						}
					})
				}

				function dataAsUrl(content, type)
				{
					return "data:" + type + ";base64," + content
				}

				function escape(string)
				{
					return string.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1")
				}

				function delay(ms)
				{
					return function (arg)
					{
						return new Promise(function (resolve)
						{
							setTimeout(function ()
							{
								resolve(arg)
							}, ms)
						})
					}
				}

				function asArray(arrayLike)
				{
					var array = [];
					var length = arrayLike.length;
					for (var i = 0; i < length; i++) array.push(arrayLike[i]);
					return array
				}

				function escapeXhtml(string)
				{
					return string.replace(/#/g, "%23").replace(/\n/g, "%0A")
				}

				function width(node)
				{
					var leftBorder = px(node, "border-left-width");
					var rightBorder = px(node, "border-right-width");
					return node.scrollWidth + leftBorder + rightBorder
				}

				function height(node)
				{
					var topBorder = px(node, "border-top-width");
					var bottomBorder = px(node, "border-bottom-width");
					return node.scrollHeight + topBorder + bottomBorder
				}

				function px(node, styleProperty)
				{
					var value = window.getComputedStyle(node).getPropertyValue(styleProperty);
					return parseFloat(value.replace("px", ""))
				}
			}

			function newInliner()
			{
				var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;
				return {
					inlineAll: inlineAll,
					shouldProcess: shouldProcess,
					impl:
					{
						readUrls: readUrls,
						inline: inline
					}
				};

				function shouldProcess(string)
				{
					return -1 !== string.search(URL_REGEX)
				}

				function readUrls(string)
				{
					var result = [];
					var match;
					while (null !== (match = URL_REGEX.exec(string))) result.push(match[1]);
					return result.filter(function (url)
					{
						return !util.isDataUrl(url)
					})
				}

				function inline(string, url, baseUrl, get)
				{
					return Promise.resolve(url).then(function (url)
					{
						return baseUrl ? util.resolveUrl(url, baseUrl) : url
					}).then(get || util.getAndEncode).then(function (data)
					{
						return util.dataAsUrl(data, util.mimeType(url))
					}).then(function (dataUrl)
					{
						return string.replace(urlAsRegex(url), "$1" + dataUrl + "$3")
					});

					function urlAsRegex(url)
					{
						return new RegExp("(url\\(['\"]?)(" + util.escape(url) + ")(['\"]?\\))", "g")
					}
				}

				function inlineAll(string, baseUrl, get)
				{
					if (nothingToInline()) return Promise.resolve(string);
					return Promise.resolve(string).then(readUrls).then(function (urls)
					{
						var done = Promise.resolve(string);
						urls.forEach(function (url)
						{
							done = done.then(function (string)
							{
								return inline(string, url, baseUrl, get)
							})
						});
						return done
					});

					function nothingToInline()
					{
						return !shouldProcess(string)
					}
				}
			}

			function newFontFaces()
			{
				return {
					resolveAll: resolveAll,
					impl:
					{
						readAll: readAll
					}
				};

				function resolveAll()
				{
					return readAll(document).then(function (webFonts)
					{
						return Promise.all(webFonts.map(function (webFont)
						{
							return webFont.resolve()
						}))
					}).then(function (cssStrings)
					{
						return cssStrings.join("\n")
					})
				}

				function readAll()
				{
					return Promise.resolve(util.asArray(document.styleSheets)).then(getCssRules).then(selectWebFontRules).then(function (rules)
					{
						return rules.map(newWebFont)
					});

					function selectWebFontRules(cssRules)
					{
						return cssRules.filter(function (rule)
						{
							return rule.type === CSSRule.FONT_FACE_RULE
						}).filter(function (rule)
						{
							return inliner.shouldProcess(rule.style.getPropertyValue("src"))
						})
					}

					function getCssRules(styleSheets)
					{
						var cssRules = [];
						styleSheets.forEach(function (sheet)
						{
							try
							{
								util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules))
							}
							catch (e)
							{
								console.log("Error while reading CSS rules from " + sheet.href, e.toString())
							}
						});
						return cssRules
					}

					function newWebFont(webFontRule)
					{
						return {
							resolve: function resolve()
							{
								var baseUrl = (webFontRule.parentStyleSheet ||
								{}).href;
								return inliner.inlineAll(webFontRule.cssText, baseUrl)
							},
							src: function ()
							{
								return webFontRule.style.getPropertyValue("src")
							}
						}
					}
				}
			}

			function newImages()
			{
				return {
					inlineAll: inlineAll,
					impl:
					{
						newImage: newImage
					}
				};

				function newImage(element)
				{
					return {
						inline: inline
					};

					function inline(get)
					{
						if (util.isDataUrl(element.src)) return Promise.resolve();
						return Promise.resolve(element.src).then(get || util.getAndEncode).then(function (data)
						{
							return util.dataAsUrl(data, util.mimeType(element.src))
						}).then(function (dataUrl)
						{
							return new Promise(function (resolve, reject)
							{
								element.onload = resolve;
								element.onerror = reject;
								element.src = dataUrl
							})
						})
					}
				}

				function inlineAll(node)
				{
					if (!(node instanceof Element)) return Promise.resolve(node);
					return inlineBackground(node).then(function ()
					{
						return node instanceof HTMLImageElement ? newImage(node).inline() : Promise.all(util.asArray(node.childNodes).map(function (child)
						{
							return inlineAll(child)
						}))
					});

					function inlineBackground(node)
					{
						var background = node.style.getPropertyValue("background");
						if (!background) return Promise.resolve(node);
						return inliner.inlineAll(background).then(function (inlined)
						{
							node.style.setProperty("background", inlined, node.style.getPropertyPriority("background"))
						}).then(function ()
						{
							return node
						})
					}
				}
			}
		})()
	},
	5367: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.ShareAgent = function ()
		{
			function ShareAgent()
			{
				_classCallCheck(this, ShareAgent);
				this.agent = null;
				this.selectedGroup = null;
				this.targetLocation = null
			}
			_createClass(ShareAgent, [
			{
				key: "getAgent",
				value: function getAgent()
				{
					return this.agent
				}
			},
			{
				key: "getSelectedGroup",
				value: function getSelectedGroup()
				{
					if (this.agent && this.agent.group && (this.selectedGroup || 0 === this.selectedGroup)) return this.agent.group[this.selectedGroup];
					return null
				}
			},
			{
				key: "setAgent",
				value: function setAgent(ag, group)
				{
					this.agent = ag;
					this.selectedGroup = group
				}
			},
			{
				key: "deleteAgent",
				value: function deleteAgent()
				{
					this.agent = null;
					this.selectedGroup = null
				}
			},
			{
				key: "getTargetLocation",
				value: function getTargetLocation()
				{
					return this.targetLocation
				}
			},
			{
				key: "setTargetLocation",
				value: function setTargetLocation(loc)
				{
					if (!loc || "object" !== ("undefined" === typeof loc ? "undefined" : _typeof(loc))) return;
					this.targetLocation = {};
					Object.assign(this.targetLocation, loc)
				}
			},
			{
				key: "deleteTargetLocation",
				value: function deleteTargetLocation()
				{
					this.targetLocation = null
				}
			}]);
			return ShareAgent
		}()
	},
	5368: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.WzMisc = function ()
		{
			function WzMisc()
			{
				_classCallCheck(this, WzMisc);
				this.state = {
					apiIsDown: false,
					comeFromWizard: false,
					blankScreenError: false,
					lastRestart: null
				}
			}
			_createClass(WzMisc, [
			{
				key: "setApiIsDown",
				value: function setApiIsDown(value)
				{
					this.state.apiIsDown = value
				}
			},
			{
				key: "getApiIsDown",
				value: function getApiIsDown()
				{
					return this.state.apiIsDown
				}
			},
			{
				key: "setWizard",
				value: function setWizard(value)
				{
					this.state.comeFromWizard = value
				}
			},
			{
				key: "getWizard",
				value: function getWizard()
				{
					return this.state.comeFromWizard
				}
			},
			{
				key: "setBlankScr",
				value: function setBlankScr(value)
				{
					this.state.blankScreenError = value
				}
			},
			{
				key: "getBlankScr",
				value: function getBlankScr()
				{
					return this.state.blankScreenError
				}
			},
			{
				key: "setLastRestart",
				value: function setLastRestart(value)
				{
					this.state.lastRestart = value
				}
			},
			{
				key: "getLastRestart",
				value: function getLastRestart()
				{
					return this.state.lastRestart
				}
			}]);
			return WzMisc
		}()
	},
	5369: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.WazuhConfig = function ()
		{
			function WazuhConfig()
			{
				_classCallCheck(this, WazuhConfig);
				this.config = {}
			}
			_createClass(WazuhConfig, [
			{
				key: "setConfig",
				value: function setConfig(cfg)
				{
					Object.assign(this.config, cfg)
				}
			},
			{
				key: "getConfig",
				value: function getConfig()
				{
					return this.config
				}
			}]);
			return WazuhConfig
		}()
	},
	5370: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(5371);
		__webpack_require__(5372);
		__webpack_require__(5373);
		__webpack_require__(5375);
		__webpack_require__(5376);
		__webpack_require__(5387);
		__webpack_require__(5390);
		__webpack_require__(5392);
		__webpack_require__(5394);
		__webpack_require__(5396);
		__webpack_require__(5397);
		__webpack_require__(5399);
		__webpack_require__(5400);
		__webpack_require__(5402);
		__webpack_require__(5404);
		__webpack_require__(5405);
		__webpack_require__(5407)
	},
	5371: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzDynamic", function ($compile)
		{
			return {
				restrict: "A",
				replace: true,
				link: function link(scope, ele, attrs)
				{
					scope.$watch(attrs.wzDynamic, function (html)
					{
						ele.html(html);
						$compile(ele.contents())(scope)
					})
				}
			}
		})
	},
	5372: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _modules = __webpack_require__(2);
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzEnter", function ()
		{
			return function (scope, element, attrs)
			{
				element.bind("keydown keypress", function (event)
				{
					if (13 === event.which)
					{
						scope.$apply(function ()
						{
							scope.$eval(attrs.wzEnter)
						});
						event.preventDefault()
					}
				})
			}
		})
	},
	5373: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _wzMenu = __webpack_require__(5374);
		var _wzMenu2 = _interopRequireDefault(_wzMenu);
		var _modules = __webpack_require__(2);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		var WzMenu = function ()
		{
			function WzMenu()
			{
				_classCallCheck(this, WzMenu);
				this.template = _wzMenu2.default
			}
			_createClass(WzMenu, [
			{
				key: "controller",
				value: function controller($scope, $window, $rootScope, appState, patternHandler, indexPatterns, errorHandler, wazuhConfig)
				{
					var _this = this;
					$rootScope.showSelector = appState.getPatternSelector();
					$rootScope.$$phase || $rootScope.$digest();
					if (appState.getCurrentAPI())
					{
						$scope.theresAPI = true;
						$scope.currentAPI = JSON.parse(appState.getCurrentAPI()).name
					}
					else $scope.theresAPI = false;
					$scope.goToClick = function (path)
					{
						$window.location.href = path
					};
					var load = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var list, config, filtered, data;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return patternHandler.getPatternList();
							case 3:
								list = _context.sent;
								if (list)
								{
									_context.next = 6;
									break
								}
								return _context.abrupt("return");
							case 6:
								config = wazuhConfig.getConfig();
								appState.setPatternSelector(config["ip.selector"]);
								if (appState.getPatternSelector())
								{
									_context.next = 10;
									break
								}
								return _context.abrupt("return");
							case 10:
								$rootScope.showSelector = true;
								filtered = false;
								if (appState.getCurrentPattern())
								{
									filtered = list.filter(function (item)
									{
										return item.id.includes(appState.getCurrentPattern())
									});
									filtered.length || appState.setCurrentPattern(list[0].id)
								}
								else appState.setCurrentPattern(list[0].id);
								if (!filtered)
								{
									_context.next = 17;
									break
								}
								_context.t0 = filtered;
								_context.next = 20;
								break;
							case 17:
								_context.next = 19;
								return indexPatterns.get(appState.getCurrentPattern());
							case 19:
								_context.t0 = _context.sent;
							case 20:
								data = _context.t0;
								$scope.theresPattern = true;
								$scope.currentPattern = data.title;
								if (list)
								{
									$scope.patternList = list;
									$scope.currentSelectedPattern = appState.getCurrentPattern()
								}
								$scope.$$phase || $scope.$digest();
								$rootScope.$$phase || $rootScope.$digest();
								return _context.abrupt("return");
							case 29:
								_context.prev = 29;
								_context.t1 = _context["catch"](0);
								errorHandler.handle(_context.t1, "Directives - Menu");
								$scope.theresPattern = false;
							case 33:
							case "end":
								return _context.stop()
							}
						}, _callee, _this, [
							[0, 29]
						])
					})), function load()
					{
						return _ref.apply(this, arguments)
					});
					var _ref;
					load();
					$scope.changePattern = (_ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(selectedPattern)
					{
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								_context2.prev = 0;
								if (appState.getPatternSelector())
								{
									_context2.next = 3;
									break
								}
								return _context2.abrupt("return");
							case 3:
								_context2.next = 5;
								return patternHandler.changePattern(selectedPattern);
							case 5:
								$scope.currentSelectedPattern = _context2.sent;
								$scope.$$phase || $scope.$digest();
								$window.location.reload();
								return _context2.abrupt("return");
							case 11:
								_context2.prev = 11;
								_context2.t0 = _context2["catch"](0);
								errorHandler.handle(_context2.t0, "Directives - Menu");
							case 14:
							case "end":
								return _context2.stop()
							}
						}, _callee2, _this, [
							[0, 11]
						])
					})), function (_x)
					{
						return _ref2.apply(this, arguments)
					});
					var _ref2;
					$scope.$on("updateAPI", function (evt, params)
					{
						var current = appState.getCurrentAPI();
						if (current)
						{
							var parsed = JSON.parse(current);
							if (params && params.cluster_info)
							{
								"enabled" === params.cluster_info.status ? parsed.name = params.cluster_info.cluster : parsed.name = params.cluster_info.manager;
								appState.setCurrentAPI(JSON.stringify(parsed))
							}
							$scope.theresAPI = true;
							$scope.currentAPI = parsed.name
						}
						else $scope.theresAPI = false
					});
					$scope.$on("updatePattern", function ()
					{
						if (!appState.getPatternSelector()) return;
						indexPatterns.get(appState.getCurrentPattern()).then(function ()
						{
							$scope.theresPattern = true;
							$scope.currentSelectedPattern = appState.getCurrentPattern()
						}).catch(function (error)
						{
							errorHandler.handle(error, "Directives - Menu");
							$scope.theresPattern = false
						})
					})
				}
			}]);
			return WzMenu
		}();
		app.directive("wzMenu", function ()
		{
			return new WzMenu
		})
	},
	5374: function (module, exports)
	{
		module.exports = '<md-toolbar class="wz-menu">\n\n    <!-- Main toolbar content -->\n    <div class="md-toolbar-tools wz-menu-content">\n\n        <!-- Main Wazuh app navigation buttons -->\n        <md-button class="wz-menu-button" ng-href="#/overview" ng-class="{\'wz-menu-active\': menuNavItem === \'overview\' }" aria-label="Overview tab">\n            <i class="fa fa-fw fa-bar-chart" aria-hidden="true"></i> Overview\n        </md-button>\n\n        <!--md-button class="wz-menu-button" ng-href="#/manager" ng-class="{\'wz-menu-active\': menuNavItem === \'manager\' }" aria-label="Cluster tab">\n            <i class="fa fa-fw fa-server" aria-hidden="true"></i> a_Management\n        </md-button-->\n\n        <md-button class="wz-menu-button" ng-href="#/agents-preview" ng-class="{\'wz-menu-active\': menuNavItem === \'agents\' }" aria-label="Agents tab">\n            <i class="fa fa-fw fa-tv" aria-hidden="true"></i> Agents\n        </md-button>\n\n        <md-button class="wz-menu-button" ng-href="#/wazuh-discover" ng-class="{\'wz-menu-active\': menuNavItem === \'discover\' }" aria-label="Discover tab">\n            <i class="fa fa-fw fa-compass" aria-hidden="true"></i> Discover\n        </md-button>\n\n    <!-- Fill up the space between left and right area -->\n        <span flex></span>\n\n        <!-- API/Index pattern section -->\n        <!-- Case 1a - There\'s API -->\n        <span ng-show="theresAPI" class="small" tooltip="Selected API" tooltip-placement="bottom">\n            <i class="fa fa-star fa-fw wz-color-orange" aria-hidden="true"></i>{{currentAPI}}<span ng-if="showSelector">&nbsp;&ndash;&nbsp;</span>\n        </span>\n\n        <!-- Case 1b - There\'s no API -->\n        <span ng-show="!theresAPI" class="small" tooltip="No API credentials inserted" tooltip-placement="bottom">\n            No API<span ng-if="showSelector">&nbsp;&ndash;&nbsp;</span>\n        </span>\n\n        <!-- Case 2a - There\'s pattern and there\'s more than one -->\n        <span ng-if="showSelector" ng-show="theresPattern && patternList && patternList.length > 1" class="small" tooltip="Selected index pattern" tooltip-placement="bottom">\n            <select class="wz-menu-select" ng-model="currentSelectedPattern" ng-change="changePattern(currentSelectedPattern)" aria-label="Index pattern selector" placeholder="Index pattern">\n                <option class="wz-menu-select-option" ng-repeat="pattern in patternList | orderObjectBy:\'title\'" value="{{pattern.id}}">\n                    {{pattern.title}}\n                </option>\n            </select>\n        </span>\n\n        <!-- Case 2b - There\'s pattern and there\'s only one-->\n        <span ng-if="showSelector" ng-show="theresPattern && patternList && patternList.length === 1" class="small" tooltip="Selected index pattern" tooltip-placement="bottom">\n            {{patternList[0].title}}\n        </span>\n\n  </div>\n\n</md-toolbar>\n'
	},
	5375: function (module, exports) {},
	5376: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(1712);
		__webpack_require__(5377)
	},
	5377: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _wzTable = __webpack_require__(5378);
		var _wzTable2 = _interopRequireDefault(_wzTable);
		var _modules = __webpack_require__(2);
		var _dataFactory = __webpack_require__(5379);
		var _csvKeyEquivalence = __webpack_require__(1713);
		var _rows = __webpack_require__(1714);
		var _parseValue = __webpack_require__(5380);
		var _pagination = __webpack_require__(1715);
		var pagination = _interopRequireWildcard(_pagination);
		var _sort = __webpack_require__(5382);
		var _listeners = __webpack_require__(5383);
		var listeners = _interopRequireWildcard(_listeners);
		var _data = __webpack_require__(5384);
		var _clickAction = __webpack_require__(5385);
		var _init = __webpack_require__(5386);
		var _checkGap = __webpack_require__(1716);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzTable", function ()
		{
			return {
				restrict: "E",
				scope:
				{
					path: "=path",
					keys: "=keys",
					allowClick: "=allowClick",
					implicitFilter: "=implicitFilter",
					rowSizes: "=rowSizes",
					extraLimit: "=extraLimit"
				},
				controller: function controller($scope, apiReq, $timeout, shareAgent, $location, errorHandler, wzTableFilter, $window, appState, globalState, groupHandler, wazuhConfig)
				{
					var _this = this;
					var realTime = false;
					var instance = new _dataFactory.DataFactory(apiReq, $scope.path, $scope.implicitFilter);
					$scope.keyEquivalence = _csvKeyEquivalence.KeyEquivalenece;
					$scope.totalItems = 0;
					$scope.wazuh_table_loading = true;
					$scope.items = [];
					var configuration = wazuhConfig.getConfig();
					$scope.adminMode = !!(configuration ||
					{}).admin;
					var rowSizes = $scope.rowSizes || [15, 13, 11];
					var doit = void 0;
					var resizing = false;
					$window.onresize = function ()
					{
						if (resizing) return;
						resizing = true;
						clearTimeout(doit);
						doit = setTimeout(function ()
						{
							$scope.rowsPerPage = (0, _rows.calcTableRows)($window.innerHeight, rowSizes);
							$scope.itemsPerPage = $scope.rowsPerPage;
							init().then(function ()
							{
								return resizing = false
							}).catch(function ()
							{
								return resizing = false
							})
						}, 150)
					};
					$scope.rowsPerPage = (0, _rows.calcTableRows)($window.innerHeight, rowSizes);
					$scope.clickAction = function (item)
					{
						var openAction = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						return (0, _clickAction.clickAction)(item, openAction, instance, shareAgent, $location, $scope)
					};
					var fetch = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
						{};
						var result;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								_context.next = 3;
								return instance.fetch(options);
							case 3:
								result = _context.sent;
								items = options.realTime ? result.items.slice(0, 10) : result.items;
								$scope.time = result.time;
								$scope.totalItems = items.length;
								$scope.items = items;
								(0, _checkGap.checkGap)($scope, items);
								$scope.searchTable();
								return _context.abrupt("return");
							case 13:
								_context.prev = 13;
								_context.t0 = _context["catch"](0);
								if (!(_context.t0 && !_context.t0.data && -1 === _context.t0.status && "abort" === _context.t0.xhrStatus))
								{
									_context.next = 17;
									break
								}
								return _context.abrupt("return", Promise.reject("Request took too long, aborted"));
							case 17:
								return _context.abrupt("return", Promise.reject(_context.t0));
							case 18:
							case "end":
								return _context.stop()
							}
						}, _callee, _this, [
							[0, 13]
						])
					})), function fetch()
					{
						return _ref.apply(this, arguments)
					});
					var _ref;
					$scope.sort = (_ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(field)
					{
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								return _context2.abrupt("return", (0, _sort.sort)(field, $scope, instance, fetch, errorHandler));
							case 1:
							case "end":
								return _context2.stop()
							}
						}, _callee2, _this)
					})), function (_x3)
					{
						return _ref2.apply(this, arguments)
					});
					var _ref2;
					var search = (_ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(term, removeFilters)
					{
						return regeneratorRuntime.wrap(function _callee3$(_context3)
						{
							while (1) switch (_context3.prev = _context3.next)
							{
							case 0:
								return _context3.abrupt("return", (0, _data.searchData)(term, removeFilters, $scope, instance, fetch, wzTableFilter, errorHandler));
							case 1:
							case "end":
								return _context3.stop()
							}
						}, _callee3, _this)
					})), function search(_x4, _x5)
					{
						return _ref3.apply(this, arguments)
					});
					var _ref3;
					var filter = (_ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(_filter)
					{
						return regeneratorRuntime.wrap(function _callee4$(_context4)
						{
							while (1) switch (_context4.prev = _context4.next)
							{
							case 0:
								return _context4.abrupt("return", (0, _data.filterData)(_filter, $scope, instance, wzTableFilter, fetch, errorHandler));
							case 1:
							case "end":
								return _context4.stop()
							}
						}, _callee4, _this)
					})), function filter(_x6)
					{
						return _ref4.apply(this, arguments)
					});
					var _ref4;
					var query = (_ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(_query, search)
					{
						return regeneratorRuntime.wrap(function _callee5$(_context5)
						{
							while (1) switch (_context5.prev = _context5.next)
							{
							case 0:
								return _context5.abrupt("return", (0, _data.queryData)(_query, search, instance, wzTableFilter, $scope, fetch, errorHandler));
							case 1:
							case "end":
								return _context5.stop()
							}
						}, _callee5, _this)
					})), function query(_x7, _x8)
					{
						return _ref5.apply(this, arguments)
					});
					var _ref5;
					var realTimeFunction = (_ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6()
					{
						return regeneratorRuntime.wrap(function _callee6$(_context6)
						{
							while (1) switch (_context6.prev = _context6.next)
							{
							case 0:
								_context6.prev = 0;
								$scope.error = false;
							case 2:
								if (!realTime)
								{
									_context6.next = 10;
									break
								}
								_context6.next = 5;
								return fetch(
								{
									realTime: true,
									limit: 10
								});
							case 5:
								$scope.$$phase || $scope.$digest();
								_context6.next = 8;
								return $timeout(1e3);
							case 8:
								_context6.next = 2;
								break;
							case 10:
								_context6.next = 17;
								break;
							case 12:
								_context6.prev = 12;
								_context6.t0 = _context6["catch"](0);
								realTime = false;
								$scope.error = "Real time feature aborted - " + (_context6.t0.message || _context6.t0) + ".";
								errorHandler.handle("Real time feature aborted. " + (_context6.t0.message || _context6.t0), "Data factory");
							case 17:
								return _context6.abrupt("return");
							case 18:
							case "end":
								return _context6.stop()
							}
						}, _callee6, _this, [
							[0, 12]
						])
					})), function realTimeFunction()
					{
						return _ref6.apply(this, arguments)
					});
					var _ref6;
					$scope.parseValue = function (key, item)
					{
						return (0, _parseValue.parseValue)(key, item, instance.path)
					};
					var init = (_ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7()
					{
						return regeneratorRuntime.wrap(function _callee7$(_context7)
						{
							while (1) switch (_context7.prev = _context7.next)
							{
							case 0:
								return _context7.abrupt("return", (0, _init.initTable)($scope, fetch, wzTableFilter, instance, errorHandler, appState, globalState, $window));
							case 1:
							case "end":
								return _context7.stop()
							}
						}, _callee7, _this)
					})), function init()
					{
						return _ref7.apply(this, arguments)
					});
					var _ref7;
					$scope.itemsPerPage = $scope.rowsPerPage || 10;
					$scope.pagedItems = [];
					$scope.currentPage = 0;
					var items = [];
					$scope.gap = 0;
					$scope.searchTable = function ()
					{
						return pagination.searchTable($scope, items)
					};
					$scope.groupToPages = function ()
					{
						return pagination.groupToPages($scope)
					};
					$scope.range = function (size, start, end)
					{
						return pagination.range(size, start, end, $scope.gap)
					};
					$scope.prevPage = function ()
					{
						return pagination.prevPage($scope)
					};
					$scope.nextPage = (_ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8(currentPage)
					{
						return regeneratorRuntime.wrap(function _callee8$(_context8)
						{
							while (1) switch (_context8.prev = _context8.next)
							{
							case 0:
								return _context8.abrupt("return", pagination.nextPage(currentPage, $scope, errorHandler, fetch));
							case 1:
							case "end":
								return _context8.stop()
							}
						}, _callee8, _this)
					})), function (_x9)
					{
						return _ref8.apply(this, arguments)
					});
					var _ref8;
					$scope.setPage = function ()
					{
						$scope.currentPage = this.n;
						$scope.nextPage(this.n)
					};
					$scope.$on("wazuhUpdateInstancePath", function (event, parameters)
					{
						return listeners.wazuhUpdateInstancePath(parameters, instance, init)
					});
					$scope.$on("wazuhFilter", function (event, parameters)
					{
						return listeners.wazuhFilter(parameters, filter)
					});
					$scope.$on("wazuhSearch", function (event, parameters)
					{
						return listeners.wazuhSearch(parameters, instance, search)
					});
					$scope.$on("wazuhQuery", function (event, parameters)
					{
						return listeners.wazuhQuery(parameters, query)
					});
					$scope.$on("wazuhRemoveFilter", function (event, parameters)
					{
						return listeners.wazuhRemoveFilter(parameters, instance, wzTableFilter, init)
					});
					$scope.$on("wazuhPlayRealTime", function ()
					{
						realTime = true;
						return realTimeFunction()
					});
					$scope.$on("wazuhStopRealTime", function ()
					{
						realTime = false;
						return init()
					});
					$scope.$on("$destroy", function ()
					{
						$window.onresize = null;
						realTime = null;
						wzTableFilter.set([])
					});
					init();
					$scope.isLookingGroup = function ()
					{
						try
						{
							var regexp = new RegExp(/^\/agents\/groups\/[a-zA-Z0-9_\-.]*$/);
							$scope.isLookingDefaultGroup = "default" === instance.path.split("/").pop();
							return regexp.test(instance.path)
						}
						catch (error)
						{
							return false
						}
					};
					$scope.showConfirmRemoveGroup = function (ev, group)
					{
						$scope.removingGroup = $scope.removingGroup === group.name ? null : group.name
					};
					$scope.showConfirmRemoveAgentFromGroup = function (ev, agent)
					{
						$scope.removingAgent = $scope.removingAgent === agent.id ? null : agent.id
					};
					$scope.cancelRemoveAgent = function ()
					{
						$scope.removingAgent = null
					};
					$scope.cancelRemoveGroup = function ()
					{
						$scope.removingGroup = null
					};
					$scope.confirmRemoveAgent = (_ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(agent)
					{
						var group;
						return regeneratorRuntime.wrap(function _callee9$(_context9)
						{
							while (1) switch (_context9.prev = _context9.next)
							{
							case 0:
								_context9.prev = 0;
								group = instance.path.split("/").pop();
								_context9.next = 4;
								return groupHandler.removeAgentFromGroup(group, agent);
							case 4:
								errorHandler.info("Success. Agent " + agent + " has been removed from " + group, "");
								_context9.next = 10;
								break;
							case 7:
								_context9.prev = 7;
								_context9.t0 = _context9["catch"](0);
								errorHandler.handle("" + (_context9.t0.message || _context9.t0), "");
							case 10:
								$scope.removingAgent = null;
								return _context9.abrupt("return", init());
							case 12:
							case "end":
								return _context9.stop()
							}
						}, _callee9, _this, [
							[0, 7]
						])
					})), function (_x10)
					{
						return _ref9.apply(this, arguments)
					});
					var _ref9;
					$scope.confirmRemoveGroup = (_ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(group)
					{
						return regeneratorRuntime.wrap(function _callee10$(_context10)
						{
							while (1) switch (_context10.prev = _context10.next)
							{
							case 0:
								_context10.prev = 0;
								_context10.next = 3;
								return groupHandler.removeGroup(group);
							case 3:
								errorHandler.info("Success. Group " + group + " has been removed", "");
								_context10.next = 9;
								break;
							case 6:
								_context10.prev = 6;
								_context10.t0 = _context10["catch"](0);
								errorHandler.handle("" + (_context10.t0.message || _context10.t0), "");
							case 9:
								$scope.removingGroup = null;
								return _context10.abrupt("return", init());
							case 11:
							case "end":
								return _context10.stop()
							}
						}, _callee10, _this, [
							[0, 6]
						])
					})), function (_x11)
					{
						return _ref10.apply(this, arguments)
					});
					var _ref10
				},
				template: _wzTable2.default
			}
		})
	},
	5378: function (module, exports)
	{
		module.exports = '<div layout="row" class="md-padding" ng-show="wazuh_table_loading">\n    <div class=\'uil-ring-css\'>\n        <div></div>\n    </div>\n</div>\n<div layout="row" ng-show="!error && !wazuh_table_loading && items.length">\n    <table class="table table-striped table-condensed table-hover" style="table-layout: fixed !important" id="wz_table">\n        <thead class="wz-text-bold">\n            <th ng-repeat="key in keys" class="wz-text-left" ng-class="{ \'cursor-pointer\' : !key.nosortable, \'col-lg-1\' : !key.size, \'col-lg-{{key.size}}\' : key.size }"\n                ng-click="!key.nosortable && sort(key)">\n                {{ path === \'/agents/groups\' && (key.value || key) === \'count\' ? \'Agents\' : keyEquivalence[key.value ||\n                key] || key.value || key }}\n                <i ng-if="!key.nosortable" class="fa wz-theader-sort-icon" ng-class="sortValue === (key.value || key) ? (sortDir ? \'fa-sort-asc\' : \'fa-sort-desc\') : \'fa-sort\'"\n                    aria-hidden="true"></i>\n            </th>\n            <th ng-if="(path === \'/agents\' || (path === \'/agents/groups\' && adminMode) || (isLookingGroup() && adminMode)) && !isLookingDefaultGroup"\n                class="wz-text-left" ng-class="{\'col-lg-2\': path !== \'/agents\', \'col-lg-1\': path === \'/agents\'}">Actions</th>\n        </thead>\n        <tbody>\n            <tr ng-class="allowClick ? \'cursor-pointer\' : \'\'" class="wz-word-wrap" ng-repeat="item in pagedItems[currentPage] | filter:{item:\'!\'}"\n                ng-click="clickAction(item)">\n                <td ng-repeat="key in keys">\n                    {{\n                    parseValue(key,item) | limitTo: extraLimit ? 100 : 25\n                    }}\n                    <span ng-if="parseValue(key,item).length > (extraLimit ? 100 : 25)">...</span>\n                    <md-tooltip ng-if="parseValue(key,item).length > (extraLimit ? 100 : 25)" md-direction="bottom"\n                        class="wz-tooltip">\n                        {{ parseValue(key,item) }}\n                    </md-tooltip>\n                </td>\n                <td ng-if="path === \'/agents\'" ng-click="$event.stopPropagation()" class="cursor-default action-btn-td">\n                    <i ng-click="clickAction(item, \'discover\'); $event.stopPropagation()" class="fa fa-fw fa-compass cursor-pointer"\n                        tooltip="Open Discover panel for this agent" tooltip-placement="left" aria-hidden="true"></i>\n                    <i ng-click="clickAction(item, \'configuration\'); $event.stopPropagation()" class=""\n                        tooltip="Open configuration for this agent" tooltip-placement="left" aria-hidden="true"></i>\n                </td>\n                <td ng-if="path === \'/agents/groups\' && adminMode" ng-click="$event.stopPropagation()" class="cursor-default action-btn-td">\n                    <i ng-if="removingGroup !== item.name && item.name !== \'default\'" ng-click="showConfirmRemoveGroup($event, item); $event.stopPropagation()"\n                        class="fa fa-fw fa-trash cursor-pointer" tooltip="Remove this group" tooltip-placement="left"\n                        aria-hidden="true"></i>\n                        <span class="wz-padding-left-8" ng-if="removingGroup !== item.name && item.name === \'default\'">-</span>\n                    <div ng-if="removingGroup === item.name && item.name !== \'default\'">\n                        <div layout="row">\n                       <!--     <span class="euiToastHeader__title font-size-12">Group {{item.name}} will be removed</span>\n          -->              </div>\n                        <div layout="row">\n                            <md-button class="cancelBtn" type="button" ng-click="cancelRemoveGroup()"><i aria-hidden=\'true\'\n                                    class=\'fa fa-fw fa-close\'></i> Cancel</md-button>\n                            <md-button class="agreeBtn" type="button" ng-click="confirmRemoveGroup(item.name)"><i\n                                    aria-hidden=\'true\' class=\'fa fa-fw fa-check\'></i> Confirm</md-button>\n                        </div>\n                    </div>\n                </td>\n                <td ng-if="isLookingGroup() && adminMode && !isLookingDefaultGroup" ng-click="$event.stopPropagation()"\n                    class="cursor-default action-btn-td">\n                    <i ng-if="removingAgent !== item.id && adminMode" ng-click="showConfirmRemoveAgentFromGroup($event, item); $event.stopPropagation()"\n                        class="fa fa-fw fa-trash cursor-pointer" tooltip="Remove this agent from the group"\n                        tooltip-placement="left" aria-hidden="true"></i>\n                    <div ng-if="removingAgent === item.id">\n                        <div layout="row">\n                     <!--       <span class="euiToastHeader__title font-size-12">The agent {{item.id}} will be removed from this group</span>\n      -->                  </div>\n                        <div layout="row">\n                            <md-button class="cancelBtn" type="button" ng-click="cancelRemoveAgent()"><i\n                                    aria-hidden=\'true\' class=\'fa fa-fw fa-close\'></i> Cancel</md-button>\n                            <md-button class="agreeBtn" type="button" ng-click="confirmRemoveAgent(item.id)"><i\n                                    aria-hidden=\'true\' class=\'fa fa-fw fa-check\'></i> Confirm</md-button>\n                        </div>\n                    </div>\n                </td>\n            </tr>\n        </tbody>\n        <tfoot>\n            <td colspan="{{ (path === \'/agents\' || (path === \'/agents/groups\' && adminMode) || (isLookingGroup() && adminMode)) && !isLookingDefaultGroup ? keys.length + 1 : keys.length}}">\n                <span ng-show="!wazuh_table_loading" class="color-grey">{{ totalItems }} items ({{time | number: 2}}\n                    seconds)</span>\n                <div ng-show="items.length >= itemsPerPage" class="pagination pull-right" style="margin:0 !important">\n                    <ul layout="row">\n                        <li ng-show="currentPage" class="md-padding">\n                            <a href ng-click="prevPage()"> Prev</a>\n                        </li>\n\n                        <li ng-repeat="n in range(pagedItems.length, currentPage, currentPage + gap) " ng-class="{\'wz-text-active\': n == currentPage}"\n                            ng-click="setPage()" class="md-padding">\n                            <a href ng-bind="n + 1">1</a>\n                        </li>\n\n                        <li ng-show="currentPage < pagedItems.length - 1" class="md-padding">\n                            <a href ng-click="nextPage()">Next </a>\n                        </li>\n                    </ul>\n                </div>\n            </td>\n        </tfoot>\n    </table>\n</div>\n\n<div layout="row" ng-if="!error && !wazuh_table_loading && !totalItems">\n    <div flex class="euiCallOut euiCallOut--warning">\n        <div class="euiCallOutHeader">\n            <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"\n                xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16">\n                <defs>\n                    <path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path>\n                </defs>\n                <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use>\n            </svg>\n            <span class="euiCallOutHeader__title">No results match your search criteria</span>\n        </div>\n    </div>\n</div>\n\n<div layout="row" ng-if="error" class="wz-margin-bottom-45">\n    <div flex class="euiCallOut euiCallOut--warning">\n        <div class="euiCallOutHeader">\n            <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"\n                xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16">\n                <defs>\n                    <path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path>\n                </defs>\n                <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use>\n            </svg>\n            <span class="euiCallOutHeader__title">{{error}}</span>\n        </div>\n    </div>\n</div>\n\n\n<div layout="row" ng-if="!wazuh_table_loading && !totalItems" class="wz-margin-top-10">\n    <span class="color-grey">0 items ({{time | number: 2}} seconds)</span>\n</div>'
	},
	5379: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _toConsumableArray(arr)
		{
			if (Array.isArray(arr))
			{
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2
			}
			return Array.from(arr)
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.DataFactory = function ()
		{
			function DataFactory(httpClient, path, implicitFilter)
			{
				var _filters;
				_classCallCheck(this, DataFactory);
				this.implicitFilter = implicitFilter || false;
				this.httpClient = httpClient;
				this.items = [];
				this.path = path;
				this.filters = [];
				this.sortValue = false;
				this.sortDir = false;
				this.sortValue = false;
				this.busy = false;
				this.implicitFilter && (_filters = this.filters).push.apply(_filters, _toConsumableArray(this.implicitFilter))
			}
			_createClass(DataFactory, [
			{
				key: "addSorting",
				value: function addSorting(value)
				{
					this.sortValue = value;
					this.sortDir = !this.sortDir
				}
			},
			{
				key: "removeFilters",
				value: function removeFilters()
				{
					var _filters2;
					this.filters = [];
					this.implicitFilter && (_filters2 = this.filters).push.apply(_filters2, _toConsumableArray(this.implicitFilter))
				}
			},
			{
				key: "serializeFilters",
				value: function serializeFilters(parameters)
				{
					this.sortValue && (parameters.sort = this.sortDir ? "-" + this.sortValue : this.sortValue);
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = void 0;
					try
					{
						for (var _step, _iterator = this.filters[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
						{
							var filter = _step.value;
							"" !== filter.value && (parameters[filter.name] = filter.value)
						}
					}
					catch (err)
					{
						_didIteratorError = true;
						_iteratorError = err
					}
					finally
					{
						try
						{
							!_iteratorNormalCompletion && _iterator.return && _iterator.return()
						}
						finally
						{
							if (_didIteratorError) throw _iteratorError
						}
					}
				}
			},
			{
				key: "addFilter",
				value: function addFilter(filterName, value)
				{
					this.filters = this.filters.filter(function (filter)
					{
						return filter.name !== filterName
					});
					"undefined" !== typeof value && this.filters.push(
					{
						name: filterName,
						value: value
					})
				}
			},
			{
				key: "fetch",
				value: function ()
				{
					var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
						{};
						var _items, _items2, start, offset, limit, parameters, firstPage, totalItems, remaining, end, elapsed;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								if (!this.busy)
								{
									_context.next = 3;
									break
								}
								return _context.abrupt("return",
								{
									items: this.items,
									time: 0
								});
							case 3:
								this.busy = true;
								start = new Date;
								options.offset || (this.items = []);
								offset = options.offset || 0;
								limit = options.limit || 500;
								parameters = {
									limit: limit,
									offset: offset
								};
								this.serializeFilters(parameters);
								_context.next = 12;
								return this.httpClient.request("GET", this.path, parameters);
							case 12:
								firstPage = _context.sent;
								this.items = this.items.filter(function (item)
								{
									return !!item
								});
								(_items = this.items).push.apply(_items, _toConsumableArray(firstPage.data.data.items));
								totalItems = firstPage.data.data.totalItems;
								remaining = this.items.length === totalItems ? 0 : totalItems - this.items.length;
								"/agents" === this.path && (this.items = this.items.filter(function (item)
								{
									return "000" !== item.id
								}));
								options && options.nonull || !(remaining > 0) || (_items2 = this.items).push.apply(_items2, _toConsumableArray(Array(remaining).fill(null)));
								end = new Date;
								elapsed = (end - start) / 1e3;
								this.busy = false;
								return _context.abrupt("return",
								{
									items: this.items,
									time: elapsed
								});
							case 25:
								_context.prev = 25;
								_context.t0 = _context["catch"](0);
								this.busy = false;
								return _context.abrupt("return", Promise.reject(_context.t0));
							case 29:
							case "end":
								return _context.stop()
							}
						}, _callee, this, [
							[0, 25]
						])
					}));

					function fetch()
					{
						return _ref.apply(this, arguments)
					}
					return fetch
				}()
			},
			{
				key: "reset",
				value: function reset()
				{
					var _filters3;
					this.items = [];
					this.filters = [];
					this.implicitFilter && (_filters3 = this.filters).push.apply(_filters3, _toConsumableArray(this.implicitFilter));
					this.sortValue = false;
					this.sortDir = false;
					this.sortValue = false
				}
			}]);
			return DataFactory
		}()
	},
	5380: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _slicedToArray = function ()
		{
			function sliceIterator(arr, i)
			{
				var _arr = [];
				var _n = true;
				var _d = false;
				var _e = void 0;
				try
				{
					for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true)
					{
						_arr.push(_s.value);
						if (i && _arr.length === i) break
					}
				}
				catch (err)
				{
					_d = true;
					_e = err
				}
				finally
				{
					try
					{
						!_n && _i["return"] && _i["return"]()
					}
					finally
					{
						if (_d) throw _e
					}
				}
				return _arr
			}
			return function (arr, i)
			{
				if (Array.isArray(arr)) return arr;
				if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
				throw new TypeError("Invalid attempt to destructure non-iterable instance")
			}
		}();
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		exports.parseValue = parseValue;
		var _processStateEquivalence = __webpack_require__(5381);
		var _processStateEquivalence2 = _interopRequireDefault(_processStateEquivalence);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		var splitArray = function splitArray(array)
		{
			if (Array.isArray(array))
			{
				if (!array.length) return false;
				var str = "";
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = void 0;
				try
				{
					for (var _step, _iterator = array[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
					{
						var item = _step.value;
						str += item + ", "
					}
				}
				catch (err)
				{
					_didIteratorError = true;
					_iteratorError = err
				}
				finally
				{
					try
					{
						!_iteratorNormalCompletion && _iterator.return && _iterator.return()
					}
					finally
					{
						if (_didIteratorError) throw _iteratorError
					}
				}
				str = str.substring(0, str.length - 2);
				return str
			}
			return array
		};
		var checkIfArray = function checkIfArray(item)
		{
			return "object" === ("undefined" === typeof item ? "undefined" : _typeof(item)) ? splitArray(item) : 0 === item ? "0" : item
		};

		function parseValue(key, item, instancePath)
		{
			if ("state" === key && instancePath.includes("processes")) return _processStateEquivalence2.default[item.state] || "Unknown";
			if (("description" === key || key.value && "description" === key.value) && !item.description) return "-";
			var isComposedString = "string" === typeof key && key.includes(".");
			var isComposedObject = "object" === ("undefined" === typeof key ? "undefined" : _typeof(key)) && key.value && key.value.includes(".");
			if (isComposedString || isComposedObject)
			{
				var split = isComposedString ? key.split(".") : key.value.split(".");
				var _split = _slicedToArray(split, 2),
					first = _split[0],
					second = _split[1];
				return item[first] && item[first][second] ? item[first][second] : "-"
			}
			return checkIfArray(item[key.value || key]) || "-"
		}
	},
	5381: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.default = {
			t: "tracing stop",
			P: "Parked",
			I: "Idle",
			D: "Uninterruptible sleep (usually IO)",
			R: "Running or runnable (on run queue)",
			S: "Interruptible sleep (waiting for an event to complete)",
			T: "Stopped, either by a job control signal or because it is being traced.",
			W: "paging (not valid since the 2.6.xx kernel)",
			X: "Dead (should never be seen)",
			Z: 'Defunct ("zombie") process, terminated but not reaped by its parent.',
			"<": "High-priority (not nice to other users)",
			N: "Low-priority (nice to other users)",
			L: "Has pages locked into memory (for real-time and custom IO)",
			s: "Is a session leader",
			l: "Is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)",
			"+": "Is in the foreground process group"
		};
		module.exports = exports["default"]
	},
	5382: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.sort = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(field, $scope, instance, fetch, errorHandler)
		{
			return regeneratorRuntime.wrap(function _callee$(_context)
			{
				while (1) switch (_context.prev = _context.next)
				{
				case 0:
					_context.prev = 0;
					$scope.error = false;
					$scope.wazuh_table_loading = true;
					instance.addSorting(field.value || field);
					$scope.sortValue = instance.sortValue;
					$scope.sortDir = instance.sortDir;
					_context.next = 8;
					return fetch();
				case 8:
					$scope.wazuh_table_loading = false;
					_context.next = 16;
					break;
				case 11:
					_context.prev = 11;
					_context.t0 = _context["catch"](0);
					$scope.wazuh_table_loading = false;
					$scope.error = "Error sorting table by " + (field ? field.value : "undefined") + " - " + (_context.t0.message || _context.t0) + ".";
					errorHandler.handle("Error sorting table by " + (field ? field.value : "undefined") + ". " + (_context.t0.message || _context.t0), "Data factory");
				case 16:
					$scope.$$phase || $scope.$digest();
					return _context.abrupt("return");
				case 18:
				case "end":
					return _context.stop()
				}
			}, _callee, this, [
				[0, 11]
			])
		})), function sort(_x, _x2, _x3, _x4, _x5)
		{
			return _ref.apply(this, arguments)
		});
		var _ref;

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
	},
	5383: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.wazuhUpdateInstancePath = wazuhUpdateInstancePath;
		exports.wazuhFilter = wazuhFilter;
		exports.wazuhQuery = wazuhQuery;
		exports.wazuhSearch = wazuhSearch;
		exports.wazuhRemoveFilter = wazuhRemoveFilter;

		function wazuhUpdateInstancePath(parameters, instance, init)
		{
			instance.filters = [];
			instance.path = parameters.path;
			return init()
		}

		function wazuhFilter(parameters, filter)
		{
			return filter(parameters.filter)
		}

		function wazuhQuery(parameters, query)
		{
			return query(parameters.query, parameters.search)
		}

		function wazuhSearch(parameters, instance, search)
		{
			try
			{
				var matchesSpecificPath = parameters && parameters.specificPath && !instance.path.includes(parameters.specificPath);
				var matchesSpecificFilter = parameters && parameters.specificFilter && !instance.filters.filter(function (filter)
				{
					return filter.name === parameters.specificFilter.name && filter.value === parameters.specificFilter.value
				}).length;
				if (matchesSpecificPath || matchesSpecificFilter) return;
				return search(parameters.term, parameters.removeFilters)
			}
			catch (error)
			{
				return
			}
		}

		function wazuhRemoveFilter(parameters, instance, wzTableFilter, init)
		{
			instance.filters = instance.filters.filter(function (item)
			{
				return item.name !== parameters.filterName
			});
			wzTableFilter.set(instance.filters);
			return init()
		}
	},
	5384: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.searchData = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(term, removeFilters, $scope, instance, fetch, wzTableFilter, errorHandler)
		{
			return regeneratorRuntime.wrap(function _callee$(_context)
			{
				while (1) switch (_context.prev = _context.next)
				{
				case 0:
					_context.prev = 0;
					$scope.error = false;
					$scope.wazuh_table_loading = true;
					removeFilters && instance.removeFilters();
					instance.addFilter("search", term);
					wzTableFilter.set(instance.filters);
					_context.next = 8;
					return fetch();
				case 8:
					$scope.wazuh_table_loading = false;
					_context.next = 16;
					break;
				case 11:
					_context.prev = 11;
					_context.t0 = _context["catch"](0);
					$scope.wazuh_table_loading = false;
					$scope.error = "Error searching - " + (_context.t0.message || _context.t0) + ".";
					errorHandler.handle("Error searching. " + (_context.t0.message || _context.t0), "Data factory");
				case 16:
					$scope.$$phase || $scope.$digest();
					return _context.abrupt("return");
				case 18:
				case "end":
					return _context.stop()
				}
			}, _callee, this, [
				[0, 11]
			])
		})), function searchData(_x, _x2, _x3, _x4, _x5, _x6, _x7)
		{
			return _ref.apply(this, arguments)
		});
		var _ref;
		exports.filterData = (_ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(filter, $scope, instance, wzTableFilter, fetch, errorHandler)
		{
			var platform, version;
			return regeneratorRuntime.wrap(function _callee2$(_context2)
			{
				while (1) switch (_context2.prev = _context2.next)
				{
				case 0:
					_context2.prev = 0;
					$scope.error = false;
					$scope.wazuh_table_loading = true;
					if ("platform" === filter.name && "/agents" === instance.path)
					{
						platform = filter.value.split(" - ")[0];
						version = filter.value.split(" - ")[1];
						instance.addFilter("os.platform", platform);
						instance.addFilter("os.version", version)
					}
					else instance.addFilter(filter.name, filter.value);
					wzTableFilter.set(instance.filters);
					_context2.next = 7;
					return fetch();
				case 7:
					$scope.wazuh_table_loading = false;
					_context2.next = 15;
					break;
				case 10:
					_context2.prev = 10;
					_context2.t0 = _context2["catch"](0);
					$scope.wazuh_table_loading = false;
					$scope.error = "Error filtering by " + (filter ? filter.value : "undefined") + " - " + (_context2.t0.message || _context2.t0) + ".";
					errorHandler.handle("Error filtering by " + (filter ? filter.value : "undefined") + ". " + (_context2.t0.message || _context2.t0), "Data factory");
				case 15:
					$scope.$$phase || $scope.$digest();
					return _context2.abrupt("return");
				case 17:
				case "end":
					return _context2.stop()
				}
			}, _callee2, this, [
				[0, 10]
			])
		})), function filterData(_x8, _x9, _x10, _x11, _x12, _x13)
		{
			return _ref2.apply(this, arguments)
		});
		var _ref2;
		exports.queryData = (_ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(query, term, instance, wzTableFilter, $scope, fetch, errorHandler)
		{
			return regeneratorRuntime.wrap(function _callee3$(_context3)
			{
				while (1) switch (_context3.prev = _context3.next)
				{
				case 0:
					_context3.prev = 0;
					$scope.error = false;
					$scope.wazuh_table_loading = true;
					instance.removeFilters();
					term && instance.addFilter("search", term);
					query && instance.addFilter("q", query);
					wzTableFilter.set(instance.filters);
					_context3.next = 9;
					return fetch();
				case 9:
					$scope.wazuh_table_loading = false;
					_context3.next = 17;
					break;
				case 12:
					_context3.prev = 12;
					_context3.t0 = _context3["catch"](0);
					$scope.wazuh_table_loading = false;
					$scope.error = "Query error " + (query ? query.value : "undefined") + " - " + (_context3.t0.message || _context3.t0) + ".";
					errorHandler.handle("Query error " + (query ? query.value : "undefined") + ". " + (_context3.t0.message || _context3.t0), "Data factory");
				case 17:
					$scope.$$phase || $scope.$digest();
					return _context3.abrupt("return");
				case 19:
				case "end":
					return _context3.stop()
				}
			}, _callee3, this, [
				[0, 12]
			])
		})), function queryData(_x14, _x15, _x16, _x17, _x18, _x19, _x20)
		{
			return _ref3.apply(this, arguments)
		});
		var _ref3;

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
	},
	5385: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.clickAction = clickAction;

		function clickAction(item)
		{
			var openAction = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
			var instance = arguments[2];
			var shareAgent = arguments[3];
			var $location = arguments[4];
			var $scope = arguments[5];
			if ("/agents" === instance.path || new RegExp(/^\/agents\/groups\/[a-zA-Z0-9_\-.]*$/).test(instance.path))
			{
				shareAgent.setAgent(item);
				switch (openAction)
				{
				case "configuration":
					shareAgent.setTargetLocation(
					{
						tab: "configuration",
						subTab: "panels"
					});
					break;
				case "discover":
					shareAgent.setTargetLocation(
					{
						tab: "general",
						subTab: "discover"
					});
					break;
				default:
					shareAgent.setTargetLocation(
					{
						tab: "welcome",
						subTab: "panels"
					})
				}
				$location.path("/agents")
			}
			else "/agents/groups" === instance.path ? $scope.$emit("wazuhShowGroup",
			{
				group: item
			}) : new RegExp(/^\/agents\/groups\/[a-zA-Z0-9_\-.]*\/files$/).test(instance.path) ? $scope.$emit("wazuhShowGroupFile",
			{
				groupName: instance.path.split("groups/")[1].split("/files")[0],
				fileName: item.filename
			}) : "/rules" === instance.path ? $scope.$emit("wazuhShowRule",
			{
				rule: item
			}) : instance.path.includes("/decoders") ? $scope.$emit("wazuhShowDecoder",
			{
				decoder: item
			}) : "/cluster/nodes" === instance.path && $scope.$emit("wazuhShowClusterNode",
			{
				node: item
			})
		}
	},
	5386: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.initTable = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee($scope, fetch, wzTableFilter, instance, errorHandler)
		{
			return regeneratorRuntime.wrap(function _callee$(_context)
			{
				while (1) switch (_context.prev = _context.next)
				{
				case 0:
					_context.prev = 0;
					$scope.error = false;
					$scope.wazuh_table_loading = true;
					_context.next = 5;
					return fetch();
				case 5:
					wzTableFilter.set(instance.filters);
					$scope.wazuh_table_loading = false;
					_context.next = 14;
					break;
				case 9:
					_context.prev = 9;
					_context.t0 = _context["catch"](0);
					$scope.wazuh_table_loading = false;
					$scope.error = "Error while init table - " + (_context.t0.message || _context.t0) + ".";
					errorHandler.handle("Error while init table. " + (_context.t0.message || _context.t0), "Data factory");
				case 14:
					$scope.$$phase || $scope.$digest();
					return _context.abrupt("return");
				case 16:
				case "end":
					return _context.stop()
				}
			}, _callee, this, [
				[0, 9]
			])
		})), function initTable(_x, _x2, _x3, _x4, _x5)
		{
			return _ref.apply(this, arguments)
		});
		var _ref;

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
	},
	5387: function (module, exports, __webpack_require__)
	{
		"use strict";
		__webpack_require__(1712);
		__webpack_require__(5388)
	},
	5388: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _wzDataTable = __webpack_require__(5389);
		var _wzDataTable2 = _interopRequireDefault(_wzDataTable);
		var _modules = __webpack_require__(2);
		var _csvKeyEquivalence = __webpack_require__(1713);
		var _rows = __webpack_require__(1714);
		var _pagination = __webpack_require__(1715);
		var pagination = _interopRequireWildcard(_pagination);
		var _checkGap = __webpack_require__(1716);

		function _interopRequireWildcard(obj)
		{
			if (obj && obj.__esModule) return obj;
			var newObj = {};
			if (null != obj)
				for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
			newObj.default = obj;
			return newObj
		}

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzDataTable", function ()
		{
			return {
				restrict: "E",
				scope:
				{
					rowSizes: "=rowSizes",
					data: "="
				},
				controller: function controller($scope, $filter, errorHandler, $window)
				{
					var _this = this;
					$scope.keyEquivalence = _csvKeyEquivalence.KeyEquivalenece;
					$scope.totalItems = 0;
					$scope.wazuh_table_loading = true;
					$scope.items = [];
					var rowSizes = $scope.rowSizes || [15, 13, 11];
					var doit = void 0;
					var resizing = false;
					$window.onresize = function ()
					{
						if (resizing) return;
						resizing = true;
						clearTimeout(doit);
						doit = setTimeout(function ()
						{
							$scope.rowsPerPage = (0, _rows.calcTableRows)($window.innerHeight, rowSizes);
							$scope.itemsPerPage = $scope.rowsPerPage;
							init().then(function ()
							{
								return resizing = false
							}).catch(function ()
							{
								return resizing = false
							})
						}, 150)
					};
					$scope.rowsPerPage = (0, _rows.calcTableRows)($window.innerHeight, rowSizes);
					var fetch = function fetch()
					{
						try
						{
							$scope.filterTable();
							$scope.keys = Object.keys(items[0]);
							return
						}
						catch (error)
						{
							errorHandler.handle(error, "Error loading table")
						}
						return
					};
					$scope.sortValue = "";
					$scope.sortReverse = false;
					$scope.searchTerm = "";
					$scope.sort = function (key)
					{
						key !== $scope.sortValue && ($scope.sortReverse = false);
						$scope.sortValue = key;
						$scope.sortReverse = !$scope.sortReverse;
						$scope.filterTable()
					};
					$scope.filterTable = function ()
					{
						items = $filter("orderBy")($filter("filter")($scope.data, $scope.searchTerm), $scope.sortValue, $scope.sortReverse);
						$scope.totalItems = items.length;
						$scope.items = items;
						(0, _checkGap.checkGap)($scope, items);
						$scope.searchTable()
					};
					var init = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								$scope.error = false;
								$scope.wazuh_table_loading = true;
								_context.next = 4;
								return fetch();
							case 4:
								$scope.wazuh_table_loading = false;
							case 5:
							case "end":
								return _context.stop()
							}
						}, _callee, _this)
					})), function init()
					{
						return _ref.apply(this, arguments)
					});
					var _ref;
					$scope.itemsPerPage = $scope.rowsPerPage || 10;
					$scope.pagedItems = [];
					$scope.currentPage = 0;
					var items = [];
					$scope.gap = 0;
					$scope.searchTable = function ()
					{
						return pagination.searchTable($scope, items)
					};
					$scope.groupToPages = function ()
					{
						return pagination.groupToPages($scope)
					};
					$scope.range = function (size, start, end)
					{
						return pagination.range(size, start, end, $scope.gap)
					};
					$scope.prevPage = function ()
					{
						return pagination.prevPage($scope)
					};
					$scope.nextPage = (_ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(currentPage)
					{
						return regeneratorRuntime.wrap(function _callee2$(_context2)
						{
							while (1) switch (_context2.prev = _context2.next)
							{
							case 0:
								return _context2.abrupt("return", pagination.nextPage(currentPage, $scope, errorHandler, fetch));
							case 1:
							case "end":
								return _context2.stop()
							}
						}, _callee2, _this)
					})), function (_x)
					{
						return _ref2.apply(this, arguments)
					});
					var _ref2;
					$scope.setPage = function ()
					{
						$scope.currentPage = this.n;
						$scope.nextPage(this.n)
					};
					$scope.$on("$destroy", function ()
					{
						$window.onresize = null
					});
					init()
				},
				template: _wzDataTable2.default
			}
		})
	},
	5389: function (module, exports)
	{
		module.exports = '<div layout="row" class="md-padding" ng-show="wazuh_table_loading">\n    <div class=\'uil-ring-css\'>\n        <div></div>\n    </div>\n</div>\n<div ng-show="!error && !wazuh_table_loading" layout="row" class="wz-margin-top-17">\n    <input placeholder="Filter..." ng-model="searchTerm" ng-change="filterTable()" type="text" class="kuiLocalSearchInput ng-empty ng-pristine ng-scope ng-touched ng-valid">\n    <button class="kuiLocalSearchButton height-40"><span class="fa fa-search" aria-hidden="true"></span> </button>\n</div>\n<div ng-show="!error && !wazuh_table_loading && items.length">\n    <table class="table table-striped table-condensed wz-margin-top-17" style="table-layout: fixed !important" id="wz_table">\n        <thead class="wz-text-bold">\n            <th ng-repeat="key in keys" class="wz-text-left" ng-class="{ \'cursor-pointer\' : !key.nosortable, \'col-lg-1\' : !key.size, \'col-lg-{{key.size}}\' : key.size }"\n                ng-click="!key.nosortable && sort(key)">\n                {{ keyEquivalence[key.value || key] || key.value || key }}\n                <i ng-if="!key.nosortable" class="fa wz-theader-sort-icon" ng-class="sortValue === (key.value || key) ? (!sortReverse ? \'fa-sort-asc\' : \'fa-sort-desc\') : \'fa-sort\'"\n                    aria-hidden="true"></i>\n            </th>\n        </thead>\n        <tbody>\n            <tr ng-class="allowClick ? \'cursor-pointer\' : \'\'" class="wz-word-wrap" ng-repeat="item in pagedItems[currentPage] | filter:{item:\'!\'}"\n                ng-click="clickAction(item)">\n                <td ng-repeat="key in keys">\n                    {{item[key] | limitTo: 25}}\n                </td>\n            </tr>\n        </tbody>\n        <tfoot>\n            <td colspan="{{keys.length}}">\n                <span ng-show="!wazuh_table_loading" class="color-grey">{{ totalItems }} items</span>\n                <div ng-show="items.length >= itemsPerPage" class="pagination pull-right" style="margin:0 !important">\n                    <ul layout="row">\n                        <li ng-show="currentPage" class="md-padding">\n                            <a href ng-click="prevPage()"> Prev</a>\n                        </li>\n\n                        <li ng-repeat="n in range(pagedItems.length, currentPage, currentPage + gap) " ng-class="{\'wz-text-active\': n == currentPage}"\n                            ng-click="setPage()" class="md-padding">\n                            <a href ng-bind="n + 1">1</a>\n                        </li>\n\n                        <li ng-show="currentPage < pagedItems.length - 1" class="md-padding">\n                            <a href ng-click="nextPage()">Next </a>\n                        </li>\n                    </ul>\n                </div>\n            </td>\n        </tfoot>\n    </table>\n</div>\n\n<div layout="row" ng-if="!error && !wazuh_table_loading && !totalItems">\n    <div flex class="euiCallOut euiCallOut--warning wz-margin-top-17">\n        <div class="euiCallOutHeader">\n            <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"\n                xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16">\n                <defs>\n                    <path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path>\n                </defs>\n                <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use>\n            </svg>\n            <span class="euiCallOutHeader__title">No results match your search criteria</span>\n        </div>\n    </div>\n</div>\n\n<div layout="row" ng-if="error" class="wz-margin-bottom-45">\n    <div flex class="euiCallOut euiCallOut--warning wz-margin-top-17">\n        <div class="euiCallOutHeader">\n            <svg class="euiIcon euiIcon--medium euiCallOutHeader__icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"\n                xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" viewBox="0 0 16 16">\n                <defs>\n                    <path id="help-a" d="M13.6 12.186l-1.357-1.358c-.025-.025-.058-.034-.084-.056.53-.794.84-1.746.84-2.773a4.977 4.977 0 0 0-.84-2.772c.026-.02.059-.03.084-.056L13.6 3.813a6.96 6.96 0 0 1 0 8.373zM8 15A6.956 6.956 0 0 1 3.814 13.6l1.358-1.358c.025-.025.034-.057.055-.084C6.02 12.688 6.974 13 8 13a4.978 4.978 0 0 0 2.773-.84c.02.026.03.058.056.083l1.357 1.358A6.956 6.956 0 0 1 8 15zm-5.601-2.813a6.963 6.963 0 0 1 0-8.373l1.359 1.358c.024.025.057.035.084.056A4.97 4.97 0 0 0 3 8c0 1.027.31 1.98.842 2.773-.027.022-.06.031-.084.056l-1.36 1.358zm5.6-.187A4 4 0 1 1 8 4a4 4 0 0 1 0 8zM8 1c1.573 0 3.019.525 4.187 1.4l-1.357 1.358c-.025.025-.035.057-.056.084A4.979 4.979 0 0 0 8 3a4.979 4.979 0 0 0-2.773.842c-.021-.027-.03-.059-.055-.084L3.814 2.4A6.957 6.957 0 0 1 8 1zm0-1a8.001 8.001 0 1 0 .003 16.002A8.001 8.001 0 0 0 8 0z"></path>\n                </defs>\n                <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#help-a" fill-rule="evenodd"></use>\n            </svg>\n            <span class="euiCallOutHeader__title">{{error}}</span>\n        </div>\n    </div>\n</div>\n\n\n<div layout="row" ng-if="!wazuh_table_loading && !totalItems" class="wz-margin-top-10">\n    <span class="color-grey">0 items</span>\n</div>'
	},
	5390: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		var __importDefault = (void 0, function (mod)
		{
			return mod && mod.__esModule ? mod :
			{
				default: mod
			}
		});
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var wz_welcome_card_html_1 = __importDefault(__webpack_require__(5391));
		var modules_1 = __webpack_require__(2);
		var app = modules_1.uiModules.get("app/wazuh", []);
		var WzWelcomeCard = function ()
		{
			function WzWelcomeCard()
			{
				_classCallCheck(this, WzWelcomeCard);
				this.restrict = "E";
				this.scope = {
					title: "=title",
					description: "=description",
					logo: "=logo",
					switchTab: "&",
					currentTab: "=currentTab",
					wzLogo: "=wzLogo"
				};
				this.replace = true;
				this.template = wz_welcome_card_html_1.default
			}
			_createClass(WzWelcomeCard, [
			{
				key: "link",
				value: function link(scope, elm, attrs)
				{
					scope.callSwitchTab = function ()
					{
						return scope.switchTab()
					}
				}
			}]);
			return WzWelcomeCard
		}();
		app.directive("wzWelcomeCard", function ()
		{
			return new WzWelcomeCard
		})
	},
	5391: function (module, exports)
	{
		module.exports = '<div class="euiFlexItem" style="min-height: 64px;">\n    <div class="synopsis">\n        <div class="euiFlexGroup euiFlexGroup--gutterLarge euiFlexGroup--responsive">\n            <div class="euiFlexItem euiFlexItem--flexGrowZero">\n                <img class="synopsisIcon" ng-src="/plugins/wazuh/img/{{logo || wzLogo}}" alt="">\n            </div>\n            <div class="euiFlexItem synopsisContent " ng-click="callSwitchTab()">\n                <h4 class="euiTitle euiTitle--small synopsisTitle wz-text-link">{{ title }}</h4>\n                <div class="euiText synopsisBody cursor-pointer" ng-if="description">\n                    <p>\n                        <span class="euiTextColor euiTextColor--subdued">{{ description }}</span>\n                    </p>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n'
	},
	5392: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _wzNoConfig = __webpack_require__(5393);
		var _wzNoConfig2 = _interopRequireDefault(_wzNoConfig);
		var _modules = __webpack_require__(2);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzNoConfig", function ()
		{
			return {
				restrict: "E",
				scope:
				{
					error: "=error"
				},
				template: _wzNoConfig2.default
			}
		})
	},
	5393: function (module, exports)
	{
		module.exports = '<div layout="column">\n\n    <!-- No configuration card -->\n    <md-card class="wz-md-card">\n        <md-card-content class="wz-text-center">\n            <i class="fa fa-fw fa-info-circle" aria-hidden="true"></i> <span class="wz-headline-title">Configuration not available</span>\n            <md-divider class="wz-margin-top-10"></md-divider>\n            <div layout="column" class="wz-padding-top-10">\n                <p ng-if="error === \'not-present\'">This section is not present on the configuration file.</p>\n                <p ng-if="error !== \'not-present\'">There was a problem while fetching the configuration for this section.</p>\n            </div>\n            <div layout="column" class="wz-padding-top-10">\n                <p ng-if="error === \'not-present\'">Check the links on the right sidebar to learn more about how to configure it.</p>\n                <span ng-if="error !== \'not-present\'" class="md-subheader small wz-text-red">{{ error }}<span>\n            </div>\n            <div layout="column" class="wz-padding-top-10">\n                <p>Click on the <i class="fa fa-fw fa-question-circle-o" aria-hidden="true"></i> icon on the top right corner to send feedback or ask for help.</p>\n            </div>\n        </md-card-content>\n    </md-card>\n    <!-- End no configuration card -->\n\n</div>\n'
	},
	5394: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _wzConfigItem = __webpack_require__(5395);
		var _wzConfigItem2 = _interopRequireDefault(_wzConfigItem);
		var _modules = __webpack_require__(2);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzConfigItem", function ()
		{
			return {
				restrict: "E",
				scope:
				{
					label: "@label",
					value: "=value",
					isArray: "=isArray"
				},
				template: _wzConfigItem2.default
			}
		})
	},
	5395: function (module, exports)
	{
		module.exports = '<div ng-if="value || value === 0" layout="column" layout-gt-md="row" layout-align-gt-md="start center" class="wz-configuration-item">\n    <div flex-gt-md="30" class="wz-configuration-label">\n        {{ label }}\n    </div>\n    <div ng-if="!isArray" flex-gt-md="50" class="wz-configuration-value">\n        {{ value }}\n    </div>\n    <div ng-if="isArray" flex-gt-md="50" class="wz-configuration-value">\n        <ul>\n            <li ng-repeat="item in value">{{ item }}</li>\n        </ul>\n    </div>\n</div>\n'
	},
	5396: function (module, exports) {},
	5397: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _wzTagFilter = __webpack_require__(5398);
		var _wzTagFilter2 = _interopRequireDefault(_wzTagFilter);
		var _modules = __webpack_require__(2);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}

		function _toConsumableArray(arr)
		{
			if (Array.isArray(arr))
			{
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2
			}
			return Array.from(arr)
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzTagFilter", function ()
		{
			return {
				restrict: "E",
				scope:
				{
					path: "=path",
					queryFn: "&",
					fieldsModel: "="
				},
				controller: function controller($scope, $timeout, apiReq, $document, errorHandler)
				{
					var _this = this;
					$scope.tagList = [];
					$scope.groupedTagList = [];
					$scope.newTag = "";
					$scope.isAutocomplete = false;
					$scope.dataModel = [];
					$scope.addTag = function ()
					{
						var flag = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						try
						{
							var input = $document[0].getElementById("wz-search-filter-bar-input");
							input.blur();
							var term = $scope.newTag.split(":");
							var obj = {
								name: term[0].trim(),
								value: term[1] ? term[1].trim() : ""
							};
							var isFilter = obj.value;
							if (isFilter && $scope.fieldsModel && -1 === Object.keys($scope.fieldsModel).indexOf(obj.name) || !isFilter && (!obj.name || /^\s*$/.test(obj.name)))
							{
								$scope.showAutocomplete(flag);
								$scope.newTag = ""
							}
							else
							{
								var tag = {
									id: generateUID(),
									key: obj.name,
									value: obj,
									type: isFilter ? "filter" : "search"
								};
								var idxSearch = $scope.tagList.find(function (x)
								{
									return "search" === x.type
								});
								!isFilter && idxSearch && $scope.removeTag(idxSearch.id, false);
								if (!$scope.tagList.find(function (x)
									{
										return "filter" === x.type && x.key === tag.key && x.value.value.toUpperCase() === tag.value.value.toUpperCase()
									}))
								{
									$scope.tagList.push(tag);
									$scope.groupedTagList = groupBy($scope.tagList, "key");
									buildQuery($scope.groupedTagList)
								}
								$scope.showAutocomplete(flag);
								$scope.newTag = ""
							}
						}
						catch (error)
						{
							errorHandler.handle(error, "Error adding filter")
						}
					};
					var buildQuery = function buildQuery(groups)
					{
						try
						{
							(function ()
							{
								var queryObj = {
									query: "",
									search: ""
								};
								var first = true;
								var _loop = function _loop(group)
								{
									var search = group.find(function (x)
									{
										return "search" === x.type
									});
									if (search) queryObj.search = search.value.name;
									else
									{
										first || (queryObj.query += ";");
										var twoOrMoreElements = group.length > 1;
										twoOrMoreElements && (queryObj.query += "(");
										group.filter(function (x)
										{
											return "filter" === x.type
										}).forEach(function (tag, idx2)
										{
											queryObj.query += tag.key + "=" + tag.value.value;
											idx2 != group.length - 1 && (queryObj.query += ",")
										});
										twoOrMoreElements && (queryObj.query += ")");
										first = false
									}
								};
								var _iteratorNormalCompletion = true;
								var _didIteratorError = false;
								var _iteratorError = void 0;
								try
								{
									for (var _step, _iterator = groups[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
									{
										var group = _step.value;
										_loop(group)
									}
								}
								catch (err)
								{
									_didIteratorError = true;
									_iteratorError = err
								}
								finally
								{
									try
									{
										!_iteratorNormalCompletion && _iterator.return && _iterator.return()
									}
									finally
									{
										if (_didIteratorError) throw _iteratorError
									}
								}
								$scope.queryFn(
								{
									q: queryObj.query,
									search: queryObj.search
								})
							})()
						}
						catch (error)
						{
							errorHandler.handle(error, "Error in query request")
						}
					};
					var groupBy = function groupBy(collection, property)
					{
						var values = [];
						var result = [];
						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = void 0;
						try
						{
							for (var _step2, _iterator2 = collection[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true)
							{
								var item = _step2.value;
								var index = values.indexOf(item[property]);
								if (index > -1 && "filter" === item.type) result[index].push(item);
								else
								{
									values.push(item[property]);
									result.push([item])
								}
							}
						}
						catch (err)
						{
							_didIteratorError2 = true;
							_iteratorError2 = err
						}
						finally
						{
							try
							{
								!_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return()
							}
							finally
							{
								if (_didIteratorError2) throw _iteratorError2
							}
						}
						return result
					};
					$scope.addTagKey = function (key)
					{
						$scope.newTag = key + ":";
						$scope.showAutocomplete(true)
					};
					$scope.addTagValue = function (value)
					{
						$scope.newTag = $scope.newTag.substring(0, $scope.newTag.indexOf(":") + 1);
						$scope.newTag += value;
						$scope.addTag()
					};
					$scope.removeTag = function (id, deleteGroup)
					{
						deleteGroup ? $scope.tagList = $scope.tagList.filter(function (x)
						{
							return x.key !== id
						}) : $scope.tagList.splice($scope.tagList.findIndex(function (x)
						{
							return x.id === id
						}), 1);
						$scope.groupedTagList = groupBy($scope.tagList, "key");
						buildQuery($scope.groupedTagList);
						$scope.showAutocomplete(false)
					};
					$scope.showAutocomplete = function (flag)
					{
						flag && $scope.getAutocompleteContent();
						$scope.isAutocomplete = flag;
						indexAutocomplete(flag)
					};
					$scope.getAutocompleteContent = function ()
					{
						var term = $scope.newTag.split(":");
						var isKey = !term[1] && -1 === $scope.newTag.indexOf(":");
						$scope.autocompleteContent = {
							title: "",
							isKey: isKey,
							list: []
						};
						$scope.autocompleteContent.title = isKey ? "Filter keys" : "Values";
						if (isKey && $scope.fieldsModel)
							for (var key in $scope.fieldsModel) key.toUpperCase().includes(term[0].trim().toUpperCase()) && $scope.autocompleteContent.list.push(key);
						else
						{
							var model = $scope.dataModel.find(function (x)
							{
								return x.key === $scope.newTag.split(":")[0].trim()
							});
							model && ($scope.autocompleteContent.list = [].concat(_toConsumableArray(new Set(model.list.filter(function (x)
							{
								return x.toUpperCase().includes(term[1].trim().toUpperCase())
							})))))
						}
					};
					$scope.addSearchKey = function ()
					{
						$scope.autocompleteEnter && ($scope.autocompleteEnter = false);
						$scope.getAutocompleteContent()
					};
					var indexAutocomplete = function indexAutocomplete()
					{
						var flag = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
						$timeout(function ()
						{
							var bar = $document[0].getElementById("wz-search-filter-bar");
							var autocomplete = $document[0].getElementById("wz-search-filter-bar-autocomplete");
							var input = $document[0].getElementById("wz-search-filter-bar-input");
							autocomplete.style.left = input.offsetLeft - bar.scrollLeft + "px";
							flag && input.focus();
							$("#wz-search-filter-bar-autocomplete-list li").removeClass("selected")
						}, 100)
					};
					var load = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee()
					{
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								$scope.fieldsModel && Object.keys($scope.fieldsModel).forEach(function (key)
								{
									var list = $scope.fieldsModel[key];
									$scope.dataModel.push(
									{
										key: key,
										list: list
									})
								});
								return _context.abrupt("return");
							case 5:
								_context.prev = 5;
								_context.t0 = _context["catch"](0);
								return _context.abrupt("return", Promise.reject(_context.t0));
							case 8:
							case "end":
								return _context.stop()
							}
						}, _callee, _this, [
							[0, 5]
						])
					})), function load()
					{
						return _ref.apply(this, arguments)
					});
					var _ref;
					var generateUID = function generateUID()
					{
						var firstPart = 46656 * Math.random() | 0;
						var secondPart = 46656 * Math.random() | 0;
						firstPart = ("000" + firstPart.toString(36)).slice(-3);
						secondPart = ("000" + secondPart.toString(36)).slice(-3);
						return firstPart + secondPart
					};
					$("#wz-search-filter-bar-input").bind("keydown", function (e)
					{
						var $current = $("#wz-search-filter-bar-autocomplete-list li.selected");
						if (0 !== $current.length || 38 !== e.keyCode && 40 !== e.keyCode)
						{
							var $next = void 0;
							switch (e.keyCode)
							{
							case 13:
								if ($current.text().trim() && !/^\s*$/.test($current.text().trim()))
								{
									$scope.autocompleteEnter = true;
									$scope.autocompleteContent.isKey ? $scope.addTagKey($current.text().trim()) : $scope.addTagValue($current.text().trim())
								}
								break;
							case 38:
								$next = $current.prev();
								break;
							case 40:
								$next = $current.next()
							}
							if ($next && $next.length > 0 && (38 === e.keyCode || 40 === e.keyCode))
							{
								var input = $document[0].getElementById("wz-search-filter-bar-input");
								input.focus();
								$("#wz-search-filter-bar-autocomplete-list li").removeClass("selected");
								$next.addClass("selected")
							}
						}
						else
						{
							$("#wz-search-filter-bar-autocomplete-list li").first().addClass("selected");
							$current = $("#wz-search-filter-bar-autocomplete-list li.selected")
						}
					});
					$("#wz-search-filter-bar-input").attr("autocomplete", "off");
					load()
				},
				template: _wzTagFilter2.default
			}
		})
	},
	5398: function (module, exports)
	{
		module.exports = "<div id='wz-search-filter-bar' class='kuiLocalSearchInput'>\n    <span class='fa fa-search' aria-hidden='true'></span>\n    <div class='wz-tags' ng-class='{focused: hasFocus}'>\n        <ul class='tag-list'>\n            <li ng-repeat='group in groupedTagList track by $index'>\n                <div ng-class='{grouped: group.length > 1}'>\n                    <div ng-repeat='tag in group track by $index'>\n                        <div class='wz-tag-item'>\n                            <span class='wz-tag-remove-button fa' ng-class='(tag.type === \"filter\") ? \"fa-filter\" : \"fa-search\"'></span>\n                            <span class=''>{{tag.value.name}} <span ng-show='tag.type === \"filter\"'>:\n                                    {{tag.value.value}}</span></span>\n                            <a class='wz-tag-remove-button' ng-click='removeTag(tag.id, false)'></a>\n                        </div>\n                        <span class='wz-tag-item-connector' ng-show='$index != group.length - 1'>OR</span>\n                    </div>\n                    <a ng-show='group.length > 1' class='wz-tag-remove-button-group' ng-click='removeTag(group[0].key, true)'></a>\n                </div>\n                <span class='wz-tag-item-connector' ng-show='$index != groupedTagList.length - 1'> AND </span>\n            </li>\n        </ul>\n        <input id='wz-search-filter-bar-input' class='wz-search-filter-bar-input input' type='text' ng-model='newTag'\n            ng-focus='showAutocomplete(true)' ng-blur='showAutocomplete(false)'\n            placeholder='Add filter or search' ng-keyup='!autocompleteEnter && $event.keyCode == 13 ? addTag(true) : addSearchKey($event)' />\n        <div id='wz-search-filter-bar-autocomplete' class='wz-search-filter-bar-autocomplete' ng-show='isAutocomplete && autocompleteContent.list.length > 0'>\n            <p><b>{{autocompleteContent.title}}</b></p>\n            <ul id='wz-search-filter-bar-autocomplete-list'>\n                <li ng-repeat='element in autocompleteContent.list track by $index' ng-mousedown='autocompleteContent.isKey ? addTagKey(element) : addTagValue(element)'>\n                    <span ng-if='element'>{{element}}</span>\n                </li>\n            </ul>\n        </div>\n    </div>\n</div>"
	},
	5399: function (module, exports) {},
	5400: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();
		var _wzConfigViewer = __webpack_require__(5401);
		var _wzConfigViewer2 = _interopRequireDefault(_wzConfigViewer);
		var _modules = __webpack_require__(2);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		var WzConfigViewer = function ()
		{
			function WzConfigViewer()
			{
				_classCallCheck(this, WzConfigViewer);
				this.restrict = "E";
				this.scope = {
					getjson: "&",
					getxml: "&",
					jsoncontent: "=jsoncontent",
					xmlcontent: "=xmlcontent"
				};
				this.replace = true;
				this.template = _wzConfigViewer2.default
			}
			_createClass(WzConfigViewer, [
			{
				key: "link",
				value: function link(scope)
				{
					scope.callgetjson = function ()
					{
						scope.getjson()
					};
					scope.callgetxml = function ()
					{
						return scope.getxml()
					}
				}
			}]);
			return WzConfigViewer
		}();
		app.directive("wzConfigViewer", function ()
		{
			return new WzConfigViewer
		})
	},
	5401: function (module, exports)
	{
		module.exports = '<div layout="row">\n<!-- JSON card -->\n<md-card flex="auto" class="wz-md-card" ng-if="jsoncontent">\n    <md-card-content flex layout="column">\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">JSON viewer</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">View this configuration in raw JSON format</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="jsoncontent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="callgetjson()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="xmlcontent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="callgetxml()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- The JSON viewer -->\n        <div flex="auto" class="wz-margin-top-10 wz-code-viewer">\n            <pre><code wz-dynamic="jsoncontent"></code></pre>\n        </div>\n        <!-- End JSON viewer -->\n    </md-card-content>\n</md-card>\n<!-- End JSON card -->\n\n<!-- XML card -->\n<md-card flex="auto" class="wz-md-card" ng-if="xmlcontent">\n    <md-card-content flex layout="column">\n        <div layout="row" layout-align="start center">\n            <div>\n                <span class="font-size-16">XML viewer</span>\n                <div class="wz-margin-top-10">\n                    <span class="md-subheader small">View this configuration in raw XML format</span>\n                </div>\n            </div>\n            <span flex></span>\n            <span ng-class="jsoncontent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="callgetjson()">JSON</span>\n            <span class="small">&nbsp;&centerdot;&nbsp;</span>\n            <span ng-class="xmlcontent ? \'wz-text-active\' : \'\'" class="wz-text-link small" ng-click="callgetxml()">XML</span>\n        </div>\n        <md-divider class="wz-margin-top-10"></md-divider>\n\n        <!-- The XML viewer -->\n        <div flex="auto" class="wz-margin-top-10 wz-code-viewer">\n            <pre>{{ xmlcontent }}</pre>\n        </div>\n        <!-- End XML viewer -->\n    </md-card-content>\n</md-card>\n<!-- End XML card -->\n</div>'
	},
	5402: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _wzXmlFileEditor = __webpack_require__(5403);
		var _wzXmlFileEditor2 = _interopRequireDefault(_wzXmlFileEditor);
		var _codemirror = __webpack_require__(58);
		var _codemirror2 = _interopRequireDefault(_codemirror);
		var _modules = __webpack_require__(2);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}

		function _asyncToGenerator(fn)
		{
			return function ()
			{
				var gen = fn.apply(this, arguments);
				return new Promise(function (resolve, reject)
				{
					function step(key, arg)
					{
						try
						{
							var info = gen[key](arg);
							var value = info.value
						}
						catch (error)
						{
							reject(error);
							return
						}
						if (!info.done) return Promise.resolve(value).then(function (value)
						{
							step("next", value)
						}, function (err)
						{
							step("throw", err)
						});
						resolve(value)
					}
					return step("next")
				})
			}
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzXmlFileEditor", function ()
		{
			return {
				restrict: "E",
				scope:
				{
					fileName: "@fileName",
					validFn: "&",
					data: "=data",
					targetName: "=targetName"
				},
				controller: function controller($scope, $document, errorHandler, groupHandler)
				{
					var _this = this;
					String.prototype.xmlReplace = function (str, newstr)
					{
						return this.split(str).join(newstr)
					};
					var firstTime = true;
					var parser = new DOMParser;
					var replaceIllegalXML = function replaceIllegalXML(text)
					{
						var oDOM = parser.parseFromString(text, "text/html");
						var lines = oDOM.documentElement.textContent.split("\n");
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = void 0;
						try
						{
							for (var _step, _iterator = lines[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)
							{
								var line = _step.value;
								var sanitized = line.trim().xmlReplace("&", "&amp;");
								line.includes(sanitized) || (text = text.xmlReplace(line.trim(), sanitized))
							}
						}
						catch (err)
						{
							_didIteratorError = true;
							_iteratorError = err
						}
						finally
						{
							try
							{
								!_iteratorNormalCompletion && _iterator.return && _iterator.return()
							}
							finally
							{
								if (_didIteratorError) throw _iteratorError
							}
						}
						return text
					};
					var checkingXmlError = false;
					var checkXmlParseError = function checkXmlParseError()
					{
						if (checkingXmlError) return;
						checkingXmlError = true;
						try
						{
							var text = $scope.xmlCodeBox.getValue();
							var xml = replaceIllegalXML(text);
							var xmlDoc = parser.parseFromString("<file>" + xml + "</file>", "text/xml");
							$scope.validFn(
							{
								valid: !!xmlDoc.getElementsByTagName("parsererror").length || !xml || !xml.length
							})
						}
						catch (error)
						{
							errorHandler.handle(error, "Error validating XML")
						}
						checkingXmlError = false;
						$scope.$$phase || $scope.$digest();
						return
					};
					var autoFormat = function autoFormat(xml)
					{
						var reg = /(>)\s*(<)(\/*)/g;
						var wsexp = / *(.*) +\n/g;
						var contexp = /(<.+>)(.+\n)/g;
						xml = xml.replace(reg, "$1\n$2$3").replace(wsexp, "$1\n").replace(contexp, "$1\n$2");
						var formatted = "";
						var lines = xml.split("\n");
						var indent = 0;
						var lastType = "other";
						var transitions = {
							"single->single": 0,
							"single->closing": -1,
							"single->opening": 0,
							"single->other": 0,
							"closing->single": 0,
							"closing->closing": -1,
							"closing->opening": 0,
							"closing->other": 0,
							"opening->single": 1,
							"opening->closing": 0,
							"opening->opening": 1,
							"opening->other": 1,
							"other->single": 0,
							"other->closing": -1,
							"other->opening": 0,
							"other->other": 0
						};
						for (var i = 0; i < lines.length; i++)
						{
							var ln = lines[i];
							if (ln.match(/\s*<\?xml/))
							{
								formatted += ln + "\n";
								continue
							}
							var single = Boolean(ln.match(/<.+\/>/));
							var closing = Boolean(ln.match(/<\/.+>/));
							var opening = Boolean(ln.match(/<[^!].*>/));
							var type = single ? "single" : closing ? "closing" : opening ? "opening" : "other";
							var fromTo = lastType + "->" + type;
							lastType = type;
							var padding = "";
							indent += transitions[fromTo];
							for (var j = 0; j < indent; j++) padding += "\t";
							"opening->closing" == fromTo ? formatted = formatted.substr(0, formatted.length - 1) + ln + "\n" : formatted += padding + ln + "\n"
						}
						return formatted.trim()
					};
					var saveFile = (_ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(params)
					{
						var text, xml;
						return regeneratorRuntime.wrap(function _callee$(_context)
						{
							while (1) switch (_context.prev = _context.next)
							{
							case 0:
								_context.prev = 0;
								text = $scope.xmlCodeBox.getValue();
								xml = replaceIllegalXML(text);
								_context.next = 5;
								return groupHandler.sendConfiguration(params.group, xml);
							case 5:
								errorHandler.info("Success. Group has been updated", "");
								_context.next = 11;
								break;
							case 8:
								_context.prev = 8;
								_context.t0 = _context["catch"](0);
								errorHandler.handle(_context.t0, "Send file error");
							case 11:
								return _context.abrupt("return");
							case 12:
							case "end":
								return _context.stop()
							}
						}, _callee, _this, [
							[0, 8]
						])
					})), function saveFile(_x)
					{
						return _ref.apply(this, arguments)
					});
					var _ref;
					$scope.xmlCodeBox = _codemirror2.default.fromTextArea($document[0].getElementById("xml_box"),
					{
						lineNumbers: true,
						matchClosing: true,
						matchBrackets: true,
						mode: "text/xml",
						theme: "ttcn",
						foldGutter: true,
						styleSelectedText: true,
						gutters: ["CodeMirror-foldgutter"]
					});
					var init = function init()
					{
						var data = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						try
						{
							$scope.xmlCodeBox.setValue(autoFormat(data || $scope.data));
							firstTime = false;
							$scope.xmlCodeBox.refresh()
						}
						catch (error)
						{
							errorHandler.handle(error, "Fetching original file")
						}
					};
					init();
					$scope.$on("fetchedFile", function (ev, params)
					{
						firstTime || init(params.data)
					});
					$scope.xmlCodeBox.on("change", function ()
					{
						checkXmlParseError()
					});
					$scope.$on("saveXmlFile", function (ev, params)
					{
						return saveFile(params)
					})
				},
				template: _wzXmlFileEditor2.default
			}
		})
	},
	5403: function (module, exports)
	{
		module.exports = "<div class='wzXmlEditor'>\n    <div class='wzXmlEditorHeader'>\n        <span>Edit <b>configuration</b> of <b>{{targetName}}</b> group</span>\n    </div>\n    <div class='wzXmlEditorBody'>\n        <div ng-show='!loadingFile'>\n            <textarea id='xml_box'></textarea>\n        </div>\n    </div>\n</div>"
	},
	5404: function (module, exports) {},
	5405: function (module, exports, __webpack_require__)
	{
		"use strict";
		var _wzMultipleSelector = __webpack_require__(5406);
		var _wzMultipleSelector2 = _interopRequireDefault(_wzMultipleSelector);
		var _modules = __webpack_require__(2);

		function _interopRequireDefault(obj)
		{
			return obj && obj.__esModule ? obj :
			{
				default: obj
			}
		}
		var app = _modules.uiModules.get("app/wazuh", []);
		app.directive("wzMultipleSelector", function ()
		{
			return {
				restrict: "E",
				scope:
				{
					availableItems: "=",
					selectedItems: "=",
					limit: "=",
					loading: "=",
					titleSelectedItems: "@",
					titleAvailableItems: "@",
					totalSelectedItems: "=",
					reloadScroll: "&"
				},
				controller: function controller($scope)
				{
					$scope.moveItem = function (item, from, to, type)
					{
						if (item.length) item.forEach(function (elem)
						{
							return $scope.moveItem(elem, from, to, type)
						});
						else
						{
							var idx = from.findIndex(function (x)
							{
								return x.key === item.key
							});
							if (-1 !== idx)
							{
								from.splice(idx, 1);
								item.type = item.type ? "" : type;
								to.push(item)
							}
						}
					};
					$scope.moveAll = function (from, to, type)
					{
						from.forEach(function (item)
						{
							item.type = item.type ? "" : type;
							to.push(item)
						});
						from.length = 0
					};
					$scope.doCheckLimit = function ()
					{
						$scope.checkLimit && $scope.checkLimit()
					};
					$scope.sort = function (a)
					{
						return parseInt(a.key)
					};
					$("#wzMultipleSelector select").scroll(function (ev)
					{
						scrollList(ev.currentTarget)
					});
					$scope.doReload = function (element, searchTerm)
					{
						var start = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
						$scope.reloadScroll(
						{
							element: element,
							searchTerm: searchTerm,
							start: start
						})
					};
					var scrollList = function scrollList(target)
					{
						var pos = target.scrollTop + target.offsetHeight;
						var max = target.scrollHeight;
						pos >= max && ("wzMultipleSelectorLeft" === target.parentElement.parentElement.parentElement.className ? $scope.doReload("left") : $scope.doReload("right"))
					}
				},
				template: _wzMultipleSelector2.default
			}
		})
	},
	5406: function (module, exports)
	{
		module.exports = "<div flex class='row flex'>\n    <div class='uil-ring-css' ng-show='loading'>\n        <div></div>\n    </div>\n    <div id='wzMultipleSelector' ng-show='!loading'>\n        <div class='wzMultipleSelectorLeft'>\n            <div class='panel panel-primary'>\n                <div class='panel-heading text-center'>{{titleAvailableItems}}<span ng-click='doReload(\"left\", availableFilter, true)'\n                        class='pull-right cursor-pointer'><span class='fa fa-refresh' aria-hidden='true'></span></span></div>\n                <div class='panel-body'>\n                    <div layout=\"row\">\n                        <input placeholder='Filter...' ng-model='availableFilter' type='text' class='kuiLocalSearchInput'\n                            wz-enter='doReload(\"left\", availableFilter, true)' ng-change='availableItem=null'>\n                        <button type='submit' class='kuiLocalSearchButton height-40' ng-click='doReload(\"left\", availableFilter, true)'>\n                            <span class='fa fa-search' aria-hidden='true'></span>\n                        </button>\n                    </div>\n                    <select size='10' multiple ng-model='availableItem' ng-change='selectedElement=null;doCheckLimit()'\n                        class='width-100' ng-dblclick='moveItem(availableItem, availableItems, selectedItems);availableItem=null'>\n                        <option ng-repeat='item in availableItems | orderBy:sort' ng-style='{\"background-color\":(item.type === \"a\" ? \"#c6ffc6\": item.type === \"r\" ? \"#ffe7e7\" : \"\")}'\n                            ng-value=\"{{item}}\">{{item.key + \" - \" + item.value}}</option>\n                    </select>\n                </div>\n            </div>\n        </div>\n        <div class='wzMultipleSelectorButtons'>\n            <button ng-disabled='availableItems.length === 0 || availableItems.length > 500' type='button' class='btn btn-primary' tooltip='Add all items'\n                tooltip-placement='top' ng-click='moveAll(availableItems, selectedItems, \"a\");\n                availableItem=null;availableFilter=\"\" ;doReload(\"left\", availableFilter, true)'>\n                <span><i class='fa fa-forward'></i></span>\n            </button>\n            <button ng-disabled='!availableItem || availableItem.length > 500' type='button' class='btn btn-primary' tooltip='Add selected items'\n                tooltip-placement='top' ng-click='moveItem(availableItem, availableItems, selectedItems, \"a\");availableItem=null;availableFilter=\"\"'>\n                <span><i class='fa fa-arrow-right'></i></span>\n            </button>\n            <button ng-disabled='!selectedElement || selectedElement.length > 500' type='button' class='btn btn-primary' tooltip='Remove selected items'\n                tooltip-placement='top' ng-click='moveItem(selectedElement, selectedItems, availableItems, \"r\");selectedFilter=\"\";selectedElement=null'>\n                <span><i class='fa fa-arrow-left'></i></span>\n            </button>\n            <button ng-disabled='selectedItems.length === 0 || selectedItems.length > 500' type='button' class='btn btn-primary' tooltip='Remove all items'\n                tooltip-placement='top' ng-click='moveAll(selectedItems, availableItems, \"r\");selectedElement=null;selectedFilter=\"\";doReload(\"right\")'>\n                <span><i class='fa fa-backward'></i></span>\n            </button>\n        </div>\n        <div class='wzMultipleSelectorRight'>\n            <div class='panel panel-primary'>\n                <div class='panel-heading text-center'>{{titleSelectedItems}} ({{totalSelectedItems}})</div>\n                <div class='panel-body'>\n                    <input placeholder='Filter...' ng-model='selectedFilter' type='text' class='kuiLocalSearchInput'\n                        ng-change='selectedElement=null' style='padding: 8px 15px'>\n                    <select size='10' multiple ng-model='selectedElement' ng-change='availableItem=null;doCheckLimit()'\n                        class='width-100' ng-dblclick='moveItem(selectedElement, selectedItems, availableItems);selectedElement=null'>\n                        <option ng-repeat='item in selectedItems | filter: selectedFilter | orderBy:sort' ng-style='{\"background-color\":(item.type === \"a\" ? \"#c6ffc6\": item.type === \"r\" ? \"#ffe7e7\" : \"\")}'\n                            ng-value=\"{{item}}\">{{item.key + \" - \" + item.value}}</option>\n                    </select>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>"
	},
	5407: function (module, exports) {},
	58: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
		var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function (obj)
		{
			return typeof obj
		} : function (obj)
		{
			return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
		};
		0, factory = function ()
		{
			var userAgent = navigator.userAgent;
			var platform = navigator.platform;
			var gecko = /gecko\/\d/i.test(userAgent);
			var ie_upto10 = /MSIE \d/.test(userAgent);
			var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
			var edge = /Edge\/(\d+)/.exec(userAgent);
			var ie = ie_upto10 || ie_11up || edge;
			var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
			var webkit = !edge && /WebKit\//.test(userAgent);
			var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
			var chrome = !edge && /Chrome\//.test(userAgent);
			var presto = /Opera\//.test(userAgent);
			var safari = /Apple Computer/.test(navigator.vendor);
			var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
			var phantom = /PhantomJS/.test(userAgent);
			var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
			var android = /Android/.test(userAgent);
			var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
			var mac = ios || /Mac/.test(platform);
			var chromeOS = /\bCrOS\b/.test(userAgent);
			var windows = /win/i.test(platform);
			var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
			presto_version && (presto_version = Number(presto_version[1]));
			if (presto_version && presto_version >= 15)
			{
				presto = false;
				webkit = true
			}
			var flipCtrlCmd = mac && (qtwebkit || presto && (null == presto_version || presto_version < 12.11));
			var captureRightClick = gecko || ie && ie_version >= 9;

			function classTest(cls)
			{
				return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*")
			}
			var rmClass = function rmClass(node, cls)
			{
				var current = node.className;
				var match = classTest(cls).exec(current);
				if (match)
				{
					var after = current.slice(match.index + match[0].length);
					node.className = current.slice(0, match.index) + (after ? match[1] + after : "")
				}
			};

			function removeChildren(e)
			{
				for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
				return e
			}

			function removeChildrenAndAdd(parent, e)
			{
				return removeChildren(parent).appendChild(e)
			}

			function elt(tag, content, className, style)
			{
				var e = document.createElement(tag);
				className && (e.className = className);
				style && (e.style.cssText = style);
				if ("string" == typeof content) e.appendChild(document.createTextNode(content));
				else if (content)
					for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
				return e
			}

			function eltP(tag, content, className, style)
			{
				var e = elt(tag, content, className, style);
				e.setAttribute("role", "presentation");
				return e
			}
			var range;
			range = document.createRange ? function range(node, start, end, endNode)
			{
				var r = document.createRange();
				r.setEnd(endNode || node, end);
				r.setStart(node, start);
				return r
			} : function range(node, start, end)
			{
				var r = document.body.createTextRange();
				try
				{
					r.moveToElementText(node.parentNode)
				}
				catch (e)
				{
					return r
				}
				r.collapse(true);
				r.moveEnd("character", end);
				r.moveStart("character", start);
				return r
			};

			function contains(parent, child)
			{
				3 == child.nodeType && (child = child.parentNode);
				if (parent.contains) return parent.contains(child);
				do {
					11 == child.nodeType && (child = child.host);
					if (child == parent) return true
				} while (child = child.parentNode)
			}

			function activeElt()
			{
				var activeElement;
				try
				{
					activeElement = document.activeElement
				}
				catch (e)
				{
					activeElement = document.body || null
				}
				while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) activeElement = activeElement.shadowRoot.activeElement;
				return activeElement
			}

			function addClass(node, cls)
			{
				var current = node.className;
				classTest(cls).test(current) || (node.className += (current ? " " : "") + cls)
			}

			function joinClasses(a, b)
			{
				var as = a.split(" ");
				for (var i = 0; i < as.length; i++) as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
				return b
			}
			var selectInput = function selectInput(node)
			{
				node.select()
			};
			ios ? selectInput = function selectInput(node)
			{
				node.selectionStart = 0;
				node.selectionEnd = node.value.length
			} : ie && (selectInput = function selectInput(node)
			{
				try
				{
					node.select()
				}
				catch (_e)
				{}
			});

			function bind(f)
			{
				var args = Array.prototype.slice.call(arguments, 1);
				return function ()
				{
					return f.apply(null, args)
				}
			}

			function copyObj(obj, target, overwrite)
			{
				target || (target = {});
				for (var prop in obj) !obj.hasOwnProperty(prop) || false === overwrite && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
				return target
			}

			function countColumn(string, end, tabSize, startIndex, startValue)
			{
				if (null == end)
				{
					end = string.search(/[^\s\u00a0]/); - 1 == end && (end = string.length)
				}
				for (var i = startIndex || 0, n = startValue || 0;;)
				{
					var nextTab = string.indexOf("\t", i);
					if (nextTab < 0 || nextTab >= end) return n + (end - i);
					n += nextTab - i;
					n += tabSize - n % tabSize;
					i = nextTab + 1
				}
			}
			var Delayed = function Delayed()
			{
				this.id = null
			};
			Delayed.prototype.set = function (ms, f)
			{
				clearTimeout(this.id);
				this.id = setTimeout(f, ms)
			};

			function indexOf(array, elt)
			{
				for (var i = 0; i < array.length; ++i)
					if (array[i] == elt) return i;
				return -1
			}
			var scrollerGap = 30;
			var Pass = {
				toString: function toString()
				{
					return "CodeMirror.Pass"
				}
			};
			var sel_dontScroll = {
				scroll: false
			};
			var sel_mouse = {
				origin: "*mouse"
			};
			var sel_move = {
				origin: "+move"
			};

			function findColumn(string, goal, tabSize)
			{
				for (var pos = 0, col = 0;;)
				{
					var nextTab = string.indexOf("\t", pos); - 1 == nextTab && (nextTab = string.length);
					var skipped = nextTab - pos;
					if (nextTab == string.length || col + skipped >= goal) return pos + Math.min(skipped, goal - col);
					col += nextTab - pos;
					col += tabSize - col % tabSize;
					pos = nextTab + 1;
					if (col >= goal) return pos
				}
			}
			var spaceStrs = [""];

			function spaceStr(n)
			{
				while (spaceStrs.length <= n) spaceStrs.push(lst(spaceStrs) + " ");
				return spaceStrs[n]
			}

			function lst(arr)
			{
				return arr[arr.length - 1]
			}

			function map(array, f)
			{
				var out = [];
				for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
				return out
			}

			function insertSorted(array, value, score)
			{
				var pos = 0,
					priority = score(value);
				while (pos < array.length && score(array[pos]) <= priority) pos++;
				array.splice(pos, 0, value)
			}

			function nothing()
			{}

			function createObj(base, props)
			{
				var inst;
				if (Object.create) inst = Object.create(base);
				else
				{
					nothing.prototype = base;
					inst = new nothing
				}
				props && copyObj(props, inst);
				return inst
			}
			var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

			function isWordCharBasic(ch)
			{
				return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
			}

			function isWordChar(ch, helper)
			{
				if (!helper) return isWordCharBasic(ch);
				if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
				return helper.test(ch)
			}

			function isEmpty(obj)
			{
				for (var n in obj)
					if (obj.hasOwnProperty(n) && obj[n]) return false;
				return true
			}
			var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

			function isExtendingChar(ch)
			{
				return ch.charCodeAt(0) >= 768 && extendingChars.test(ch)
			}

			function skipExtendingChars(str, pos, dir)
			{
				while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) pos += dir;
				return pos
			}

			function findFirst(pred, from, to)
			{
				var dir = from > to ? -1 : 1;
				for (;;)
				{
					if (from == to) return from;
					var midF = (from + to) / 2,
						mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
					if (mid == from) return pred(mid) ? from : to;
					pred(mid) ? to = mid : from = mid + dir
				}
			}

			function Display(place, doc, input)
			{
				var d = this;
				this.input = input;
				d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
				d.scrollbarFiller.setAttribute("cm-not-content", "true");
				d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
				d.gutterFiller.setAttribute("cm-not-content", "true");
				d.lineDiv = eltP("div", null, "CodeMirror-code");
				d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
				d.cursorDiv = elt("div", null, "CodeMirror-cursors");
				d.measure = elt("div", null, "CodeMirror-measure");
				d.lineMeasure = elt("div", null, "CodeMirror-measure");
				d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
				var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
				d.mover = elt("div", [lines], null, "position: relative");
				d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
				d.sizerWidth = null;
				d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
				d.gutters = elt("div", null, "CodeMirror-gutters");
				d.lineGutter = null;
				d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
				d.scroller.setAttribute("tabIndex", "-1");
				d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
				if (ie && ie_version < 8)
				{
					d.gutters.style.zIndex = -1;
					d.scroller.style.paddingRight = 0
				}
				webkit || gecko && mobile || (d.scroller.draggable = true);
				place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper));
				d.viewFrom = d.viewTo = doc.first;
				d.reportedViewFrom = d.reportedViewTo = doc.first;
				d.view = [];
				d.renderedView = null;
				d.externalMeasured = null;
				d.viewOffset = 0;
				d.lastWrapHeight = d.lastWrapWidth = 0;
				d.updateLineNumbers = null;
				d.nativeBarWidth = d.barHeight = d.barWidth = 0;
				d.scrollbarsClipped = false;
				d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
				d.alignWidgets = false;
				d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
				d.maxLine = null;
				d.maxLineLength = 0;
				d.maxLineChanged = false;
				d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
				d.shift = false;
				d.selForContextMenu = null;
				d.activeTouch = null;
				input.init(d)
			}

			function getLine(doc, n)
			{
				n -= doc.first;
				if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
				var chunk = doc;
				while (!chunk.lines)
					for (var i = 0;; ++i)
					{
						var child = chunk.children[i],
							sz = child.chunkSize();
						if (n < sz)
						{
							chunk = child;
							break
						}
						n -= sz
					}
				return chunk.lines[n]
			}

			function getBetween(doc, start, end)
			{
				var out = [],
					n = start.line;
				doc.iter(start.line, end.line + 1, function (line)
				{
					var text = line.text;
					n == end.line && (text = text.slice(0, end.ch));
					n == start.line && (text = text.slice(start.ch));
					out.push(text);
					++n
				});
				return out
			}

			function getLines(doc, from, to)
			{
				var out = [];
				doc.iter(from, to, function (line)
				{
					out.push(line.text)
				});
				return out
			}

			function updateLineHeight(line, height)
			{
				var diff = height - line.height;
				if (diff)
					for (var n = line; n; n = n.parent) n.height += diff
			}

			function lineNo(line)
			{
				if (null == line.parent) return null;
				var cur = line.parent,
					no = indexOf(cur.lines, line);
				for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent)
					for (var i = 0;; ++i)
					{
						if (chunk.children[i] == cur) break;
						no += chunk.children[i].chunkSize()
					}
				return no + cur.first
			}

			function _lineAtHeight(chunk, h)
			{
				var n = chunk.first;
				outer: do {
					for (var i$1 = 0; i$1 < chunk.children.length; ++i$1)
					{
						var child = chunk.children[i$1],
							ch = child.height;
						if (h < ch)
						{
							chunk = child;
							continue outer
						}
						h -= ch;
						n += child.chunkSize()
					}
					return n
				} while (!chunk.lines);
				var i = 0;
				for (; i < chunk.lines.length; ++i)
				{
					var line = chunk.lines[i],
						lh = line.height;
					if (h < lh) break;
					h -= lh
				}
				return n + i
			}

			function isLine(doc, l)
			{
				return l >= doc.first && l < doc.first + doc.size
			}

			function lineNumberFor(options, i)
			{
				return String(options.lineNumberFormatter(i + options.firstLineNumber))
			}

			function Pos(line, ch, sticky)
			{
				void 0 === sticky && (sticky = null);
				if (!(this instanceof Pos)) return new Pos(line, ch, sticky);
				this.line = line;
				this.ch = ch;
				this.sticky = sticky
			}

			function cmp(a, b)
			{
				return a.line - b.line || a.ch - b.ch
			}

			function equalCursorPos(a, b)
			{
				return a.sticky == b.sticky && 0 == cmp(a, b)
			}

			function copyPos(x)
			{
				return Pos(x.line, x.ch)
			}

			function maxPos(a, b)
			{
				return cmp(a, b) < 0 ? b : a
			}

			function minPos(a, b)
			{
				return cmp(a, b) < 0 ? a : b
			}

			function clipLine(doc, n)
			{
				return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))
			}

			function _clipPos(doc, pos)
			{
				if (pos.line < doc.first) return Pos(doc.first, 0);
				var last = doc.first + doc.size - 1;
				if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
				return clipToLen(pos, getLine(doc, pos.line).text.length)
			}

			function clipToLen(pos, linelen)
			{
				var ch = pos.ch;
				return null == ch || ch > linelen ? Pos(pos.line, linelen) : ch < 0 ? Pos(pos.line, 0) : pos
			}

			function clipPosArray(doc, array)
			{
				var out = [];
				for (var i = 0; i < array.length; i++) out[i] = _clipPos(doc, array[i]);
				return out
			}
			var sawReadOnlySpans = false;
			var sawCollapsedSpans = false;

			function seeReadOnlySpans()
			{
				sawReadOnlySpans = true
			}

			function seeCollapsedSpans()
			{
				sawCollapsedSpans = true
			}

			function MarkedSpan(marker, from, to)
			{
				this.marker = marker;
				this.from = from;
				this.to = to
			}

			function getMarkedSpanFor(spans, marker)
			{
				if (spans)
					for (var i = 0; i < spans.length; ++i)
					{
						var span = spans[i];
						if (span.marker == marker) return span
					}
			}

			function removeMarkedSpan(spans, span)
			{
				var r;
				for (var i = 0; i < spans.length; ++i) spans[i] != span && (r || (r = [])).push(spans[i]);
				return r
			}

			function addMarkedSpan(line, span)
			{
				line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
				span.marker.attachLine(line)
			}

			function markedSpansBefore(old, startCh, isInsert)
			{
				var nw;
				if (old)
					for (var i = 0; i < old.length; ++i)
					{
						var span = old[i],
							marker = span.marker;
						var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
						if (startsBefore || span.from == startCh && "bookmark" == marker.type && (!isInsert || !span.marker.insertLeft))
						{
							var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
							(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))
						}
					}
				return nw
			}

			function markedSpansAfter(old, endCh, isInsert)
			{
				var nw;
				if (old)
					for (var i = 0; i < old.length; ++i)
					{
						var span = old[i],
							marker = span.marker;
						var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
						if (endsAfter || span.from == endCh && "bookmark" == marker.type && (!isInsert || span.marker.insertLeft))
						{
							var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
							(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, null == span.to ? null : span.to - endCh))
						}
					}
				return nw
			}

			function stretchSpansOverChange(doc, change)
			{
				if (change.full) return null;
				var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
				var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
				if (!oldFirst && !oldLast) return null;
				var startCh = change.from.ch,
					endCh = change.to.ch,
					isInsert = 0 == cmp(change.from, change.to);
				var first = markedSpansBefore(oldFirst, startCh, isInsert);
				var last = markedSpansAfter(oldLast, endCh, isInsert);
				var sameLine = 1 == change.text.length,
					offset = lst(change.text).length + (sameLine ? startCh : 0);
				if (first)
					for (var i = 0; i < first.length; ++i)
					{
						var span = first[i];
						if (null == span.to)
						{
							var found = getMarkedSpanFor(last, span.marker);
							found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh
						}
					}
				if (last)
					for (var i$1 = 0; i$1 < last.length; ++i$1)
					{
						var span$1 = last[i$1];
						null != span$1.to && (span$1.to += offset);
						if (null == span$1.from)
						{
							var found$1 = getMarkedSpanFor(first, span$1.marker);
							if (!found$1)
							{
								span$1.from = offset;
								sameLine && (first || (first = [])).push(span$1)
							}
						}
						else
						{
							span$1.from += offset;
							sameLine && (first || (first = [])).push(span$1)
						}
					}
				first && (first = clearEmptySpans(first));
				last && last != first && (last = clearEmptySpans(last));
				var newMarkers = [first];
				if (!sameLine)
				{
					var gapMarkers, gap = change.text.length - 2;
					if (gap > 0 && first)
						for (var i$2 = 0; i$2 < first.length; ++i$2) null == first[i$2].to && (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
					for (var i$3 = 0; i$3 < gap; ++i$3) newMarkers.push(gapMarkers);
					newMarkers.push(last)
				}
				return newMarkers
			}

			function clearEmptySpans(spans)
			{
				for (var i = 0; i < spans.length; ++i)
				{
					var span = spans[i];
					null != span.from && span.from == span.to && false !== span.marker.clearWhenEmpty && spans.splice(i--, 1)
				}
				if (!spans.length) return null;
				return spans
			}

			function removeReadOnlyRanges(doc, from, to)
			{
				var markers = null;
				doc.iter(from.line, to.line + 1, function (line)
				{
					if (line.markedSpans)
						for (var i = 0; i < line.markedSpans.length; ++i)
						{
							var mark = line.markedSpans[i].marker;
							!mark.readOnly || markers && -1 != indexOf(markers, mark) || (markers || (markers = [])).push(mark)
						}
				});
				if (!markers) return null;
				var parts = [
				{
					from: from,
					to: to
				}];
				for (var i = 0; i < markers.length; ++i)
				{
					var mk = markers[i],
						m = mk.find(0);
					for (var j = 0; j < parts.length; ++j)
					{
						var p = parts[j];
						if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
						var newParts = [j, 1],
							dfrom = cmp(p.from, m.from),
							dto = cmp(p.to, m.to);
						(dfrom < 0 || !mk.inclusiveLeft && !dfrom) && newParts.push(
						{
							from: p.from,
							to: m.from
						});
						(dto > 0 || !mk.inclusiveRight && !dto) && newParts.push(
						{
							from: m.to,
							to: p.to
						});
						parts.splice.apply(parts, newParts);
						j += newParts.length - 3
					}
				}
				return parts
			}

			function detachMarkedSpans(line)
			{
				var spans = line.markedSpans;
				if (!spans) return;
				for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
				line.markedSpans = null
			}

			function attachMarkedSpans(line, spans)
			{
				if (!spans) return;
				for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
				line.markedSpans = spans
			}

			function extraLeft(marker)
			{
				return marker.inclusiveLeft ? -1 : 0
			}

			function extraRight(marker)
			{
				return marker.inclusiveRight ? 1 : 0
			}

			function compareCollapsedMarkers(a, b)
			{
				var lenDiff = a.lines.length - b.lines.length;
				if (0 != lenDiff) return lenDiff;
				var aPos = a.find(),
					bPos = b.find();
				var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
				if (fromCmp) return -fromCmp;
				var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
				if (toCmp) return toCmp;
				return b.id - a.id
			}

			function collapsedSpanAtSide(line, start)
			{
				var found, sps = sawCollapsedSpans && line.markedSpans;
				if (sps)
					for (var sp = void 0, i = 0; i < sps.length; ++i)
					{
						sp = sps[i];
						sp.marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker)
					}
				return found
			}

			function collapsedSpanAtStart(line)
			{
				return collapsedSpanAtSide(line, true)
			}

			function collapsedSpanAtEnd(line)
			{
				return collapsedSpanAtSide(line, false)
			}

			function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker)
			{
				var line = getLine(doc, lineNo$$1);
				var sps = sawCollapsedSpans && line.markedSpans;
				if (sps)
					for (var i = 0; i < sps.length; ++i)
					{
						var sp = sps[i];
						if (!sp.marker.collapsed) continue;
						var found = sp.marker.find(0);
						var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
						var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
						if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
						if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) return true
					}
			}

			function visualLine(line)
			{
				var merged;
				while (merged = collapsedSpanAtStart(line)) line = merged.find(-1, true).line;
				return line
			}

			function visualLineEnd(line)
			{
				var merged;
				while (merged = collapsedSpanAtEnd(line)) line = merged.find(1, true).line;
				return line
			}

			function visualLineContinued(line)
			{
				var merged, lines;
				while (merged = collapsedSpanAtEnd(line))
				{
					line = merged.find(1, true).line;
					(lines || (lines = [])).push(line)
				}
				return lines
			}

			function visualLineNo(doc, lineN)
			{
				var line = getLine(doc, lineN),
					vis = visualLine(line);
				if (line == vis) return lineN;
				return lineNo(vis)
			}

			function visualLineEndNo(doc, lineN)
			{
				if (lineN > doc.lastLine()) return lineN;
				var merged, line = getLine(doc, lineN);
				if (!lineIsHidden(doc, line)) return lineN;
				while (merged = collapsedSpanAtEnd(line)) line = merged.find(1, true).line;
				return lineNo(line) + 1
			}

			function lineIsHidden(doc, line)
			{
				var sps = sawCollapsedSpans && line.markedSpans;
				if (sps)
					for (var sp = void 0, i = 0; i < sps.length; ++i)
					{
						sp = sps[i];
						if (!sp.marker.collapsed) continue;
						if (null == sp.from) return true;
						if (sp.marker.widgetNode) continue;
						if (0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return true
					}
			}

			function lineIsHiddenInner(doc, line, span)
			{
				if (null == span.to)
				{
					var end = span.marker.find(1, true);
					return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
				}
				if (span.marker.inclusiveRight && span.to == line.text.length) return true;
				for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i)
				{
					sp = line.markedSpans[i];
					if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return true
				}
			}

			function _heightAtLine(lineObj)
			{
				lineObj = visualLine(lineObj);
				var h = 0,
					chunk = lineObj.parent;
				for (var i = 0; i < chunk.lines.length; ++i)
				{
					var line = chunk.lines[i];
					if (line == lineObj) break;
					h += line.height
				}
				for (var p = chunk.parent; p; chunk = p, p = chunk.parent)
					for (var i$1 = 0; i$1 < p.children.length; ++i$1)
					{
						var cur = p.children[i$1];
						if (cur == chunk) break;
						h += cur.height
					}
				return h
			}

			function lineLength(line)
			{
				if (0 == line.height) return 0;
				var merged, len = line.text.length,
					cur = line;
				while (merged = collapsedSpanAtStart(cur))
				{
					var found = merged.find(0, true);
					cur = found.from.line;
					len += found.from.ch - found.to.ch
				}
				cur = line;
				while (merged = collapsedSpanAtEnd(cur))
				{
					var found$1 = merged.find(0, true);
					len -= cur.text.length - found$1.from.ch;
					cur = found$1.to.line;
					len += cur.text.length - found$1.to.ch
				}
				return len
			}

			function findMaxLine(cm)
			{
				var d = cm.display,
					doc = cm.doc;
				d.maxLine = getLine(doc, doc.first);
				d.maxLineLength = lineLength(d.maxLine);
				d.maxLineChanged = true;
				doc.iter(function (line)
				{
					var len = lineLength(line);
					if (len > d.maxLineLength)
					{
						d.maxLineLength = len;
						d.maxLine = line
					}
				})
			}

			function iterateBidiSections(order, from, to, f)
			{
				if (!order) return f(from, to, "ltr", 0);
				var found = false;
				for (var i = 0; i < order.length; ++i)
				{
					var part = order[i];
					if (part.from < to && part.to > from || from == to && part.to == from)
					{
						f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr", i);
						found = true
					}
				}
				found || f(from, to, "ltr")
			}
			var bidiOther = null;

			function getBidiPartAt(order, ch, sticky)
			{
				var found;
				bidiOther = null;
				for (var i = 0; i < order.length; ++i)
				{
					var cur = order[i];
					if (cur.from < ch && cur.to > ch) return i;
					cur.to == ch && (cur.from != cur.to && "before" == sticky ? found = i : bidiOther = i);
					cur.from == ch && (cur.from != cur.to && "before" != sticky ? found = i : bidiOther = i)
				}
				return null != found ? found : bidiOther
			}
			var bidiOrdering = function ()
			{
				var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
				var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

				function charType(code)
				{
					return code <= 247 ? lowTypes.charAt(code) : 1424 <= code && code <= 1524 ? "R" : 1536 <= code && code <= 1785 ? arabicTypes.charAt(code - 1536) : 1774 <= code && code <= 2220 ? "r" : 8192 <= code && code <= 8203 ? "w" : 8204 == code ? "b" : "L"
				}
				var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
				var isNeutral = /[stwN]/,
					isStrong = /[LRr]/,
					countsAsLeft = /[Lb1n]/,
					countsAsNum = /[1n]/;

				function BidiSpan(level, from, to)
				{
					this.level = level;
					this.from = from;
					this.to = to
				}
				return function (str, direction)
				{
					var outerType = "ltr" == direction ? "L" : "R";
					if (0 == str.length || "ltr" == direction && !bidiRE.test(str)) return false;
					var len = str.length,
						types = [];
					for (var i = 0; i < len; ++i) types.push(charType(str.charCodeAt(i)));
					for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1)
					{
						var type = types[i$1];
						"m" == type ? types[i$1] = prev : prev = type
					}
					for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2)
					{
						var type$1 = types[i$2];
						if ("1" == type$1 && "r" == cur) types[i$2] = "n";
						else if (isStrong.test(type$1))
						{
							cur = type$1;
							"r" == type$1 && (types[i$2] = "R")
						}
					}
					for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3)
					{
						var type$2 = types[i$3];
						"+" == type$2 && "1" == prev$1 && "1" == types[i$3 + 1] ? types[i$3] = "1" : "," != type$2 || prev$1 != types[i$3 + 1] || "1" != prev$1 && "n" != prev$1 || (types[i$3] = prev$1);
						prev$1 = type$2
					}
					for (var i$4 = 0; i$4 < len; ++i$4)
					{
						var type$3 = types[i$4];
						if ("," == type$3) types[i$4] = "N";
						else if ("%" == type$3)
						{
							var end = void 0;
							for (end = i$4 + 1; end < len && "%" == types[end]; ++end);
							var replace = i$4 && "!" == types[i$4 - 1] || end < len && "1" == types[end] ? "1" : "N";
							for (var j = i$4; j < end; ++j) types[j] = replace;
							i$4 = end - 1
						}
					}
					for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5)
					{
						var type$4 = types[i$5];
						"L" == cur$1 && "1" == type$4 ? types[i$5] = "L" : isStrong.test(type$4) && (cur$1 = type$4)
					}
					for (var i$6 = 0; i$6 < len; ++i$6)
						if (isNeutral.test(types[i$6]))
						{
							var end$1 = void 0;
							for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1);
							var before = "L" == (i$6 ? types[i$6 - 1] : outerType);
							var after = "L" == (end$1 < len ? types[end$1] : outerType);
							var replace$1 = before == after ? before ? "L" : "R" : outerType;
							for (var j$1 = i$6; j$1 < end$1; ++j$1) types[j$1] = replace$1;
							i$6 = end$1 - 1
						}
					var m, order = [];
					for (var i$7 = 0; i$7 < len;)
						if (countsAsLeft.test(types[i$7]))
						{
							var start = i$7;
							for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7);
							order.push(new BidiSpan(0, start, i$7))
						}
					else
					{
						var pos = i$7,
							at = order.length;
						for (++i$7; i$7 < len && "L" != types[i$7]; ++i$7);
						for (var j$2 = pos; j$2 < i$7;)
							if (countsAsNum.test(types[j$2]))
							{
								pos < j$2 && order.splice(at, 0, new BidiSpan(1, pos, j$2));
								var nstart = j$2;
								for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2);
								order.splice(at, 0, new BidiSpan(2, nstart, j$2));
								pos = j$2
							}
						else ++j$2;
						pos < i$7 && order.splice(at, 0, new BidiSpan(1, pos, i$7))
					}
					if ("ltr" == direction)
					{
						if (1 == order[0].level && (m = str.match(/^\s+/)))
						{
							order[0].from = m[0].length;
							order.unshift(new BidiSpan(0, 0, m[0].length))
						}
						if (1 == lst(order).level && (m = str.match(/\s+$/)))
						{
							lst(order).to -= m[0].length;
							order.push(new BidiSpan(0, len - m[0].length, len))
						}
					}
					return "rtl" == direction ? order.reverse() : order
				}
			}();

			function getOrder(line, direction)
			{
				var order = line.order;
				null == order && (order = line.order = bidiOrdering(line.text, direction));
				return order
			}
			var noHandlers = [];
			var on = function on(emitter, type, f)
			{
				if (emitter.addEventListener) emitter.addEventListener(type, f, false);
				else if (emitter.attachEvent) emitter.attachEvent("on" + type, f);
				else
				{
					var map$$1 = emitter._handlers || (emitter._handlers = {});
					map$$1[type] = (map$$1[type] || noHandlers).concat(f)
				}
			};

			function getHandlers(emitter, type)
			{
				return emitter._handlers && emitter._handlers[type] || noHandlers
			}

			function off(emitter, type, f)
			{
				if (emitter.removeEventListener) emitter.removeEventListener(type, f, false);
				else if (emitter.detachEvent) emitter.detachEvent("on" + type, f);
				else
				{
					var map$$1 = emitter._handlers,
						arr = map$$1 && map$$1[type];
					if (arr)
					{
						var index = indexOf(arr, f);
						index > -1 && (map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)))
					}
				}
			}

			function signal(emitter, type)
			{
				var handlers = getHandlers(emitter, type);
				if (!handlers.length) return;
				var args = Array.prototype.slice.call(arguments, 2);
				for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args)
			}

			function signalDOMEvent(cm, e, override)
			{
				"string" == typeof e && (e = {
					type: e,
					preventDefault: function preventDefault()
					{
						this.defaultPrevented = true
					}
				});
				signal(cm, override || e.type, cm, e);
				return e_defaultPrevented(e) || e.codemirrorIgnore
			}

			function signalCursorActivity(cm)
			{
				var arr = cm._handlers && cm._handlers.cursorActivity;
				if (!arr) return;
				var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
				for (var i = 0; i < arr.length; ++i) - 1 == indexOf(set, arr[i]) && set.push(arr[i])
			}

			function hasHandler(emitter, type)
			{
				return getHandlers(emitter, type).length > 0
			}

			function eventMixin(ctor)
			{
				ctor.prototype.on = function (type, f)
				{
					on(this, type, f)
				};
				ctor.prototype.off = function (type, f)
				{
					off(this, type, f)
				}
			}

			function e_preventDefault(e)
			{
				e.preventDefault ? e.preventDefault() : e.returnValue = false
			}

			function e_stopPropagation(e)
			{
				e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true
			}

			function e_defaultPrevented(e)
			{
				return null != e.defaultPrevented ? e.defaultPrevented : false == e.returnValue
			}

			function e_stop(e)
			{
				e_preventDefault(e);
				e_stopPropagation(e)
			}

			function e_target(e)
			{
				return e.target || e.srcElement
			}

			function e_button(e)
			{
				var b = e.which;
				null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2));
				mac && e.ctrlKey && 1 == b && (b = 3);
				return b
			}
			var dragAndDrop = function ()
			{
				if (ie && ie_version < 9) return false;
				var div = elt("div");
				return "draggable" in div || "dragDrop" in div
			}();
			var zwspSupported;

			function zeroWidthElement(measure)
			{
				if (null == zwspSupported)
				{
					var test = elt("span", "");
					removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
					0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8))
				}
				var node = zwspSupported ? elt("span", "") : elt("span", "", null, "display: inline-block; width: 1px; margin-right: -1px");
				node.setAttribute("cm-text", "");
				return node
			}
			var badBidiRects;

			function hasBadBidiRects(measure)
			{
				if (null != badBidiRects) return badBidiRects;
				var txt = removeChildrenAndAdd(measure, document.createTextNode("AA"));
				var r0 = range(txt, 0, 1).getBoundingClientRect();
				var r1 = range(txt, 1, 2).getBoundingClientRect();
				removeChildren(measure);
				if (!r0 || r0.left == r0.right) return false;
				return badBidiRects = r1.right - r0.right < 3
			}
			var splitLinesAuto = 3 != "\n\nb".split(/\n/).length ? function (string)
			{
				var pos = 0,
					result = [],
					l = string.length;
				while (pos <= l)
				{
					var nl = string.indexOf("\n", pos); - 1 == nl && (nl = string.length);
					var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl);
					var rt = line.indexOf("\r");
					if (-1 != rt)
					{
						result.push(line.slice(0, rt));
						pos += rt + 1
					}
					else
					{
						result.push(line);
						pos = nl + 1
					}
				}
				return result
			} : function (string)
			{
				return string.split(/\r\n?|\n/)
			};
			var hasSelection = window.getSelection ? function (te)
			{
				try
				{
					return te.selectionStart != te.selectionEnd
				}
				catch (e)
				{
					return false
				}
			} : function (te)
			{
				var range$$1;
				try
				{
					range$$1 = te.ownerDocument.selection.createRange()
				}
				catch (e)
				{}
				if (!range$$1 || range$$1.parentElement() != te) return false;
				return 0 != range$$1.compareEndPoints("StartToEnd", range$$1)
			};
			var hasCopyEvent = function ()
			{
				var e = elt("div");
				if ("oncopy" in e) return true;
				e.setAttribute("oncopy", "return;");
				return "function" == typeof e.oncopy
			}();
			var badZoomedRects = null;

			function hasBadZoomedRects(measure)
			{
				if (null != badZoomedRects) return badZoomedRects;
				var node = removeChildrenAndAdd(measure, elt("span", "x"));
				var normal = node.getBoundingClientRect();
				var fromRange = range(node, 0, 1).getBoundingClientRect();
				return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
			}
			var modes = {};
			var mimeModes = {};

			function defineMode(name, mode)
			{
				arguments.length > 2 && (mode.dependencies = Array.prototype.slice.call(arguments, 2));
				modes[name] = mode
			}

			function defineMIME(mime, spec)
			{
				mimeModes[mime] = spec
			}

			function resolveMode(spec)
			{
				if ("string" == typeof spec && mimeModes.hasOwnProperty(spec)) spec = mimeModes[spec];
				else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name))
				{
					var found = mimeModes[spec.name];
					"string" == typeof found && (found = {
						name: found
					});
					spec = createObj(found, spec);
					spec.name = found.name
				}
				else
				{
					if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) return resolveMode("application/xml");
					if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) return resolveMode("application/json")
				}
				return "string" == typeof spec ?
				{
					name: spec
				} : spec ||
				{
					name: "null"
				}
			}

			function getMode(options, spec)
			{
				spec = resolveMode(spec);
				var mfactory = modes[spec.name];
				if (!mfactory) return getMode(options, "text/plain");
				var modeObj = mfactory(options, spec);
				if (modeExtensions.hasOwnProperty(spec.name))
				{
					var exts = modeExtensions[spec.name];
					for (var prop in exts)
					{
						if (!exts.hasOwnProperty(prop)) continue;
						modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]);
						modeObj[prop] = exts[prop]
					}
				}
				modeObj.name = spec.name;
				spec.helperType && (modeObj.helperType = spec.helperType);
				if (spec.modeProps)
					for (var prop$1 in spec.modeProps) modeObj[prop$1] = spec.modeProps[prop$1];
				return modeObj
			}
			var modeExtensions = {};

			function extendMode(mode, properties)
			{
				var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
				copyObj(properties, exts)
			}

			function copyState(mode, state)
			{
				if (true === state) return state;
				if (mode.copyState) return mode.copyState(state);
				var nstate = {};
				for (var n in state)
				{
					var val = state[n];
					val instanceof Array && (val = val.concat([]));
					nstate[n] = val
				}
				return nstate
			}

			function innerMode(mode, state)
			{
				var info;
				while (mode.innerMode)
				{
					info = mode.innerMode(state);
					if (!info || info.mode == mode) break;
					state = info.state;
					mode = info.mode
				}
				return info ||
				{
					mode: mode,
					state: state
				}
			}

			function startState(mode, a1, a2)
			{
				return !mode.startState || mode.startState(a1, a2)
			}
			var StringStream = function StringStream(string, tabSize, lineOracle)
			{
				this.pos = this.start = 0;
				this.string = string;
				this.tabSize = tabSize || 8;
				this.lastColumnPos = this.lastColumnValue = 0;
				this.lineStart = 0;
				this.lineOracle = lineOracle
			};
			StringStream.prototype.eol = function ()
			{
				return this.pos >= this.string.length
			};
			StringStream.prototype.sol = function ()
			{
				return this.pos == this.lineStart
			};
			StringStream.prototype.peek = function ()
			{
				return this.string.charAt(this.pos) || void 0
			};
			StringStream.prototype.next = function ()
			{
				if (this.pos < this.string.length) return this.string.charAt(this.pos++)
			};
			StringStream.prototype.eat = function (match)
			{
				var ch = this.string.charAt(this.pos);
				var ok;
				ok = "string" == typeof match ? ch == match : ch && (match.test ? match.test(ch) : match(ch));
				if (ok)
				{
					++this.pos;
					return ch
				}
			};
			StringStream.prototype.eatWhile = function (match)
			{
				var start = this.pos;
				while (this.eat(match));
				return this.pos > start
			};
			StringStream.prototype.eatSpace = function ()
			{
				var this$1 = this;
				var start = this.pos;
				while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this$1.pos;
				return this.pos > start
			};
			StringStream.prototype.skipToEnd = function ()
			{
				this.pos = this.string.length
			};
			StringStream.prototype.skipTo = function (ch)
			{
				var found = this.string.indexOf(ch, this.pos);
				if (found > -1)
				{
					this.pos = found;
					return true
				}
			};
			StringStream.prototype.backUp = function (n)
			{
				this.pos -= n
			};
			StringStream.prototype.column = function ()
			{
				if (this.lastColumnPos < this.start)
				{
					this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
					this.lastColumnPos = this.start
				}
				return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
			};
			StringStream.prototype.indentation = function ()
			{
				return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
			};
			StringStream.prototype.match = function (pattern, consume, caseInsensitive)
			{
				if ("string" != typeof pattern)
				{
					var match = this.string.slice(this.pos).match(pattern);
					if (match && match.index > 0) return null;
					match && false !== consume && (this.pos += match[0].length);
					return match
				}
				var cased = function cased(str)
				{
					return caseInsensitive ? str.toLowerCase() : str
				};
				var substr = this.string.substr(this.pos, pattern.length);
				if (cased(substr) == cased(pattern))
				{
					false !== consume && (this.pos += pattern.length);
					return true
				}
			};
			StringStream.prototype.current = function ()
			{
				return this.string.slice(this.start, this.pos)
			};
			StringStream.prototype.hideFirstChars = function (n, inner)
			{
				this.lineStart += n;
				try
				{
					return inner()
				}
				finally
				{
					this.lineStart -= n
				}
			};
			StringStream.prototype.lookAhead = function (n)
			{
				var oracle = this.lineOracle;
				return oracle && oracle.lookAhead(n)
			};
			StringStream.prototype.baseToken = function ()
			{
				var oracle = this.lineOracle;
				return oracle && oracle.baseToken(this.pos)
			};
			var SavedContext = function SavedContext(state, lookAhead)
			{
				this.state = state;
				this.lookAhead = lookAhead
			};
			var Context = function Context(doc, state, line, lookAhead)
			{
				this.state = state;
				this.doc = doc;
				this.line = line;
				this.maxLookAhead = lookAhead || 0;
				this.baseTokens = null;
				this.baseTokenPos = 1
			};
			Context.prototype.lookAhead = function (n)
			{
				var line = this.doc.getLine(this.line + n);
				null != line && n > this.maxLookAhead && (this.maxLookAhead = n);
				return line
			};
			Context.prototype.baseToken = function (n)
			{
				var this$1 = this;
				if (!this.baseTokens) return null;
				while (this.baseTokens[this.baseTokenPos] <= n) this$1.baseTokenPos += 2;
				var type = this.baseTokens[this.baseTokenPos + 1];
				return {
					type: type && type.replace(/( |^)overlay .*/, ""),
					size: this.baseTokens[this.baseTokenPos] - n
				}
			};
			Context.prototype.nextLine = function ()
			{
				this.line++;
				this.maxLookAhead > 0 && this.maxLookAhead--
			};
			Context.fromSaved = function (doc, saved, line)
			{
				return saved instanceof SavedContext ? new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) : new Context(doc, copyState(doc.mode, saved), line)
			};
			Context.prototype.save = function (copy)
			{
				var state = false !== copy ? copyState(this.doc.mode, this.state) : this.state;
				return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
			};

			function highlightLine(cm, line, context, forceToEnd)
			{
				var st = [cm.state.modeGen],
					lineClasses = {};
				runMode(cm, line.text, cm.doc.mode, context, function (end, style)
				{
					return st.push(end, style)
				}, lineClasses, forceToEnd);
				var state = context.state;
				var loop = function loop(o)
				{
					context.baseTokens = st;
					var overlay = cm.state.overlays[o],
						i = 1,
						at = 0;
					context.state = true;
					runMode(cm, line.text, overlay.mode, context, function (end, style)
					{
						var start = i;
						while (at < end)
						{
							var i_end = st[i];
							i_end > end && st.splice(i, 1, end, st[i + 1], i_end);
							i += 2;
							at = Math.min(end, i_end)
						}
						if (!style) return;
						if (overlay.opaque)
						{
							st.splice(start, i - start, end, "overlay " + style);
							i = start + 2
						}
						else
							for (; start < i; start += 2)
							{
								var cur = st[start + 1];
								st[start + 1] = (cur ? cur + " " : "") + "overlay " + style
							}
					}, lineClasses);
					context.state = state;
					context.baseTokens = null;
					context.baseTokenPos = 1
				};
				for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);
				return {
					styles: st,
					classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
				}
			}

			function getLineStyles(cm, line, updateFrontier)
			{
				if (!line.styles || line.styles[0] != cm.state.modeGen)
				{
					var context = getContextBefore(cm, lineNo(line));
					var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
					var result = highlightLine(cm, line, context);
					resetState && (context.state = resetState);
					line.stateAfter = context.save(!resetState);
					line.styles = result.styles;
					result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null);
					updateFrontier === cm.doc.highlightFrontier && (cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier))
				}
				return line.styles
			}

			function getContextBefore(cm, n, precise)
			{
				var doc = cm.doc,
					display = cm.display;
				if (!doc.mode.startState) return new Context(doc, true, n);
				var start = findStartLine(cm, n, precise);
				var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
				var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
				doc.iter(start, n, function (line)
				{
					processLine(cm, line.text, context);
					var pos = context.line;
					line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
					context.nextLine()
				});
				precise && (doc.modeFrontier = context.line);
				return context
			}

			function processLine(cm, text, context, startAt)
			{
				var mode = cm.doc.mode;
				var stream = new StringStream(text, cm.options.tabSize, context);
				stream.start = stream.pos = startAt || 0;
				"" == text && callBlankLine(mode, context.state);
				while (!stream.eol())
				{
					readToken(mode, stream, context.state);
					stream.start = stream.pos
				}
			}

			function callBlankLine(mode, state)
			{
				if (mode.blankLine) return mode.blankLine(state);
				if (!mode.innerMode) return;
				var inner = innerMode(mode, state);
				if (inner.mode.blankLine) return inner.mode.blankLine(inner.state)
			}

			function readToken(mode, stream, state, inner)
			{
				for (var i = 0; i < 10; i++)
				{
					inner && (inner[0] = innerMode(mode, state).mode);
					var style = mode.token(stream, state);
					if (stream.pos > stream.start) return style
				}
				throw new Error("Mode " + mode.name + " failed to advance stream.")
			}
			var Token = function Token(stream, type, state)
			{
				this.start = stream.start;
				this.end = stream.pos;
				this.string = stream.current();
				this.type = type || null;
				this.state = state
			};

			function takeToken(cm, pos, precise, asArray)
			{
				var style, doc = cm.doc,
					mode = doc.mode;
				pos = _clipPos(doc, pos);
				var line = getLine(doc, pos.line),
					context = getContextBefore(cm, pos.line, precise);
				var tokens, stream = new StringStream(line.text, cm.options.tabSize, context);
				asArray && (tokens = []);
				while ((asArray || stream.pos < pos.ch) && !stream.eol())
				{
					stream.start = stream.pos;
					style = readToken(mode, stream, context.state);
					asArray && tokens.push(new Token(stream, style, copyState(doc.mode, context.state)))
				}
				return asArray ? tokens : new Token(stream, style, context.state)
			}

			function extractLineClasses(type, output)
			{
				if (type)
					for (;;)
					{
						var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
						if (!lineClass) break;
						type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
						var prop = lineClass[1] ? "bgClass" : "textClass";
						null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(output[prop]) || (output[prop] += " " + lineClass[2])
					}
				return type
			}

			function runMode(cm, text, mode, context, f, lineClasses, forceToEnd)
			{
				var flattenSpans = mode.flattenSpans;
				null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
				var curStart = 0,
					curStyle = null;
				var style, stream = new StringStream(text, cm.options.tabSize, context);
				var inner = cm.options.addModeClass && [null];
				"" == text && extractLineClasses(callBlankLine(mode, context.state), lineClasses);
				while (!stream.eol())
				{
					if (stream.pos > cm.options.maxHighlightLength)
					{
						flattenSpans = false;
						forceToEnd && processLine(cm, text, context, stream.pos);
						stream.pos = text.length;
						style = null
					}
					else style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
					if (inner)
					{
						var mName = inner[0].name;
						mName && (style = "m-" + (style ? mName + " " + style : mName))
					}
					if (!flattenSpans || curStyle != style)
					{
						while (curStart < stream.start)
						{
							curStart = Math.min(stream.start, curStart + 5e3);
							f(curStart, curStyle)
						}
						curStyle = style
					}
					stream.start = stream.pos
				}
				while (curStart < stream.pos)
				{
					var pos = Math.min(stream.pos, curStart + 5e3);
					f(pos, curStyle);
					curStart = pos
				}
			}

			function findStartLine(cm, n, precise)
			{
				var minindent, minline, doc = cm.doc;
				var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
				for (var search = n; search > lim; --search)
				{
					if (search <= doc.first) return doc.first;
					var line = getLine(doc, search - 1),
						after = line.stateAfter;
					if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) return search;
					var indented = countColumn(line.text, null, cm.options.tabSize);
					if (null == minline || minindent > indented)
					{
						minline = search - 1;
						minindent = indented
					}
				}
				return minline
			}

			function retreatFrontier(doc, n)
			{
				doc.modeFrontier = Math.min(doc.modeFrontier, n);
				if (doc.highlightFrontier < n - 10) return;
				var start = doc.first;
				for (var line = n - 1; line > start; line--)
				{
					var saved = getLine(doc, line).stateAfter;
					if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n))
					{
						start = line + 1;
						break
					}
				}
				doc.highlightFrontier = Math.min(doc.highlightFrontier, start)
			}
			var Line = function Line(text, markedSpans, estimateHeight)
			{
				this.text = text;
				attachMarkedSpans(this, markedSpans);
				this.height = estimateHeight ? estimateHeight(this) : 1
			};
			Line.prototype.lineNo = function ()
			{
				return lineNo(this)
			};
			eventMixin(Line);

			function updateLine(line, text, markedSpans, estimateHeight)
			{
				line.text = text;
				line.stateAfter && (line.stateAfter = null);
				line.styles && (line.styles = null);
				null != line.order && (line.order = null);
				detachMarkedSpans(line);
				attachMarkedSpans(line, markedSpans);
				var estHeight = estimateHeight ? estimateHeight(line) : 1;
				estHeight != line.height && updateLineHeight(line, estHeight)
			}

			function cleanUpLine(line)
			{
				line.parent = null;
				detachMarkedSpans(line)
			}
			var styleToClassCache = {};
			var styleToClassCacheWithMode = {};

			function interpretTokenStyle(style, options)
			{
				if (!style || /^\s*$/.test(style)) return null;
				var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
				return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"))
			}

			function buildLineContent(cm, lineView)
			{
				var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
				var builder = {
					pre: eltP("pre", [content], "CodeMirror-line"),
					content: content,
					col: 0,
					pos: 0,
					cm: cm,
					trailingSpace: false,
					splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
				};
				lineView.measure = {};
				for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++)
				{
					var line = i ? lineView.rest[i - 1] : lineView.line,
						order = void 0;
					builder.pos = 0;
					builder.addToken = buildToken;
					hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)) && (builder.addToken = buildTokenBadBidi(builder.addToken, order));
					builder.map = [];
					var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
					insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
					if (line.styleClasses)
					{
						line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""));
						line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))
					}
					0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
					if (0 == i)
					{
						lineView.measure.map = builder.map;
						lineView.measure.cache = {}
					}
					else
					{
						(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
						(lineView.measure.caches || (lineView.measure.caches = [])).push(
						{})
					}
				}
				if (webkit)
				{
					var last = builder.content.lastChild;
					(/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) && (builder.content.className = "cm-tab-wrap-hack")
				}
				signal(cm, "renderLine", cm, lineView.line, builder.pre);
				builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""));
				return builder
			}

			function defaultSpecialCharPlaceholder(ch)
			{
				var token = elt("span", "", "cm-invalidchar");
				token.title = "\\u" + ch.charCodeAt(0).toString(16);
				token.setAttribute("aria-label", token.title);
				return token
			}

			function buildToken(builder, text, style, startStyle, endStyle, title, css)
			{
				if (!text) return;
				var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
				var special = builder.cm.state.specialChars,
					mustWrap = false;
				var content;
				if (special.test(text))
				{
					content = document.createDocumentFragment();
					var pos = 0;
					while (true)
					{
						special.lastIndex = pos;
						var m = special.exec(text);
						var skipped = m ? m.index - pos : text.length - pos;
						if (skipped)
						{
							var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
							ie && ie_version < 9 ? content.appendChild(elt("span", [txt])) : content.appendChild(txt);
							builder.map.push(builder.pos, builder.pos + skipped, txt);
							builder.col += skipped;
							builder.pos += skipped
						}
						if (!m) break;
						pos += skipped + 1;
						var txt$1 = void 0;
						if ("\t" == m[0])
						{
							var tabSize = builder.cm.options.tabSize,
								tabWidth = tabSize - builder.col % tabSize;
							txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
							txt$1.setAttribute("role", "presentation");
							txt$1.setAttribute("cm-text", "\t");
							builder.col += tabWidth
						}
						else if ("\r" == m[0] || "\n" == m[0])
						{
							txt$1 = content.appendChild(elt("span", "\r" == m[0] ? "" : "", "cm-invalidchar"));
							txt$1.setAttribute("cm-text", m[0]);
							builder.col += 1
						}
						else
						{
							txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
							txt$1.setAttribute("cm-text", m[0]);
							ie && ie_version < 9 ? content.appendChild(elt("span", [txt$1])) : content.appendChild(txt$1);
							builder.col += 1
						}
						builder.map.push(builder.pos, builder.pos + 1, txt$1);
						builder.pos++
					}
				}
				else
				{
					builder.col += text.length;
					content = document.createTextNode(displayText);
					builder.map.push(builder.pos, builder.pos + text.length, content);
					ie && ie_version < 9 && (mustWrap = true);
					builder.pos += text.length
				}
				builder.trailingSpace = 32 == displayText.charCodeAt(text.length - 1);
				if (style || startStyle || endStyle || mustWrap || css)
				{
					var fullStyle = style || "";
					startStyle && (fullStyle += startStyle);
					endStyle && (fullStyle += endStyle);
					var token = elt("span", [content], fullStyle, css);
					title && (token.title = title);
					return builder.content.appendChild(token)
				}
				builder.content.appendChild(content)
			}

			function splitSpaces(text, trailingBefore)
			{
				if (text.length > 1 && !/  /.test(text)) return text;
				var spaceBefore = trailingBefore,
					result = "";
				for (var i = 0; i < text.length; i++)
				{
					var ch = text.charAt(i);
					" " != ch || !spaceBefore || i != text.length - 1 && 32 != text.charCodeAt(i + 1) || (ch = "");
					result += ch;
					spaceBefore = " " == ch
				}
				return result
			}

			function buildTokenBadBidi(inner, order)
			{
				return function (builder, text, style, startStyle, endStyle, title, css)
				{
					style = style ? style + " cm-force-border" : "cm-force-border";
					var start = builder.pos,
						end = start + text.length;
					for (;;)
					{
						var part = void 0;
						for (var i = 0; i < order.length; i++)
						{
							part = order[i];
							if (part.to > start && part.from <= start) break
						}
						if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
						inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
						startStyle = null;
						text = text.slice(part.to - start);
						start = part.to
					}
				}
			}

			function buildCollapsedSpan(builder, size, marker, ignoreWidget)
			{
				var widget = !ignoreWidget && marker.widgetNode;
				widget && builder.map.push(builder.pos, builder.pos + size, widget);
				if (!ignoreWidget && builder.cm.display.input.needsContentAttribute)
				{
					widget || (widget = builder.content.appendChild(document.createElement("span")));
					widget.setAttribute("cm-marker", marker.id)
				}
				if (widget)
				{
					builder.cm.display.input.setUneditable(widget);
					builder.content.appendChild(widget)
				}
				builder.pos += size;
				builder.trailingSpace = false
			}

			function insertLineContent(line, builder, styles)
			{
				var spans = line.markedSpans,
					allText = line.text,
					at = 0;
				if (!spans)
				{
					for (var i$1 = 1; i$1 < styles.length; i$1 += 2) builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
					return
				}
				var style, css, len = allText.length,
					pos = 0,
					i = 1,
					text = "";
				var spanStyle, spanEndStyle, spanStartStyle, title, collapsed, nextChange = 0;
				for (;;)
				{
					if (nextChange == pos)
					{
						spanStyle = spanEndStyle = spanStartStyle = title = css = "";
						collapsed = null;
						nextChange = Infinity;
						var foundBookmarks = [],
							endStyles = void 0;
						for (var j = 0; j < spans.length; ++j)
						{
							var sp = spans[j],
								m = sp.marker;
							if ("bookmark" == m.type && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
							else if (sp.from <= pos && (null == sp.to || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos))
							{
								if (null != sp.to && sp.to != pos && nextChange > sp.to)
								{
									nextChange = sp.to;
									spanEndStyle = ""
								}
								m.className && (spanStyle += " " + m.className);
								m.css && (css = (css ? css + ";" : "") + m.css);
								m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle);
								m.endStyle && sp.to == nextChange && (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
								m.title && !title && (title = m.title);
								m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp)
							}
							else sp.from > pos && nextChange > sp.from && (nextChange = sp.from)
						}
						if (endStyles)
							for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) endStyles[j$1 + 1] == nextChange && (spanEndStyle += " " + endStyles[j$1]);
						if (!collapsed || collapsed.from == pos)
							for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
						if (collapsed && (collapsed.from || 0) == pos)
						{
							buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from);
							if (null == collapsed.to) return;
							collapsed.to == pos && (collapsed = false)
						}
					}
					if (pos >= len) break;
					var upto = Math.min(len, nextChange);
					while (true)
					{
						if (text)
						{
							var end = pos + text.length;
							if (!collapsed)
							{
								var tokenText = end > upto ? text.slice(0, upto - pos) : text;
								builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css)
							}
							if (end >= upto)
							{
								text = text.slice(upto - pos);
								pos = upto;
								break
							}
							pos = end;
							spanStartStyle = ""
						}
						text = allText.slice(at, at = styles[i++]);
						style = interpretTokenStyle(styles[i++], builder.cm.options)
					}
				}
			}

			function LineView(doc, line, lineN)
			{
				this.line = line;
				this.rest = visualLineContinued(line);
				this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
				this.node = this.text = null;
				this.hidden = lineIsHidden(doc, line)
			}

			function buildViewArray(cm, from, to)
			{
				var nextPos, array = [];
				for (var pos = from; pos < to; pos = nextPos)
				{
					var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
					nextPos = pos + view.size;
					array.push(view)
				}
				return array
			}
			var operationGroup = null;

			function pushOperation(op)
			{
				operationGroup ? operationGroup.ops.push(op) : op.ownsGroup = operationGroup = {
					ops: [op],
					delayedCallbacks: []
				}
			}

			function fireCallbacksForOps(group)
			{
				var callbacks = group.delayedCallbacks,
					i = 0;
				do {
					for (; i < callbacks.length; i++) callbacks[i].call(null);
					for (var j = 0; j < group.ops.length; j++)
					{
						var op = group.ops[j];
						if (op.cursorActivityHandlers)
							while (op.cursorActivityCalled < op.cursorActivityHandlers.length) op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm)
					}
				} while (i < callbacks.length)
			}

			function finishOperation(op, endCb)
			{
				var group = op.ownsGroup;
				if (!group) return;
				try
				{
					fireCallbacksForOps(group)
				}
				finally
				{
					operationGroup = null;
					endCb(group)
				}
			}
			var orphanDelayedCallbacks = null;

			function signalLater(emitter, type)
			{
				var arr = getHandlers(emitter, type);
				if (!arr.length) return;
				var list, args = Array.prototype.slice.call(arguments, 2);
				if (operationGroup) list = operationGroup.delayedCallbacks;
				else if (orphanDelayedCallbacks) list = orphanDelayedCallbacks;
				else
				{
					list = orphanDelayedCallbacks = [];
					setTimeout(fireOrphanDelayed, 0)
				}
				var loop = function loop(i)
				{
					list.push(function ()
					{
						return arr[i].apply(null, args)
					})
				};
				for (var i = 0; i < arr.length; ++i) loop(i)
			}

			function fireOrphanDelayed()
			{
				var delayed = orphanDelayedCallbacks;
				orphanDelayedCallbacks = null;
				for (var i = 0; i < delayed.length; ++i) delayed[i]()
			}

			function updateLineForChanges(cm, lineView, lineN, dims)
			{
				for (var j = 0; j < lineView.changes.length; j++)
				{
					var type = lineView.changes[j];
					"text" == type ? updateLineText(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(cm, lineView) : "widget" == type && updateLineWidgets(cm, lineView, dims)
				}
				lineView.changes = null
			}

			function ensureLineWrapped(lineView)
			{
				if (lineView.node == lineView.text)
				{
					lineView.node = elt("div", null, null, "position: relative");
					lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
					lineView.node.appendChild(lineView.text);
					ie && ie_version < 8 && (lineView.node.style.zIndex = 2)
				}
				return lineView.node
			}

			function updateLineBackground(cm, lineView)
			{
				var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
				cls && (cls += " CodeMirror-linebackground");
				if (lineView.background)
					if (cls) lineView.background.className = cls;
					else
					{
						lineView.background.parentNode.removeChild(lineView.background);
						lineView.background = null
					}
				else if (cls)
				{
					var wrap = ensureLineWrapped(lineView);
					lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
					cm.display.input.setUneditable(lineView.background)
				}
			}

			function getLineContent(cm, lineView)
			{
				var ext = cm.display.externalMeasured;
				if (ext && ext.line == lineView.line)
				{
					cm.display.externalMeasured = null;
					lineView.measure = ext.measure;
					return ext.built
				}
				return buildLineContent(cm, lineView)
			}

			function updateLineText(cm, lineView)
			{
				var cls = lineView.text.className;
				var built = getLineContent(cm, lineView);
				lineView.text == lineView.node && (lineView.node = built.pre);
				lineView.text.parentNode.replaceChild(built.pre, lineView.text);
				lineView.text = built.pre;
				if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass)
				{
					lineView.bgClass = built.bgClass;
					lineView.textClass = built.textClass;
					updateLineClasses(cm, lineView)
				}
				else cls && (lineView.text.className = cls)
			}

			function updateLineClasses(cm, lineView)
			{
				updateLineBackground(cm, lineView);
				lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
				var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
				lineView.text.className = textClass || ""
			}

			function updateLineGutter(cm, lineView, lineN, dims)
			{
				if (lineView.gutter)
				{
					lineView.node.removeChild(lineView.gutter);
					lineView.gutter = null
				}
				if (lineView.gutterBackground)
				{
					lineView.node.removeChild(lineView.gutterBackground);
					lineView.gutterBackground = null
				}
				if (lineView.line.gutterClass)
				{
					var wrap = ensureLineWrapped(lineView);
					lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
					cm.display.input.setUneditable(lineView.gutterBackground);
					wrap.insertBefore(lineView.gutterBackground, lineView.text)
				}
				var markers = lineView.line.gutterMarkers;
				if (cm.options.lineNumbers || markers)
				{
					var wrap$1 = ensureLineWrapped(lineView);
					var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
					cm.display.input.setUneditable(gutterWrap);
					wrap$1.insertBefore(gutterWrap, lineView.text);
					lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass);
					!cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px")));
					if (markers)
						for (var k = 0; k < cm.options.gutters.length; ++k)
						{
							var id = cm.options.gutters[k],
								found = markers.hasOwnProperty(id) && markers[id];
							found && gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"))
						}
				}
			}

			function updateLineWidgets(cm, lineView, dims)
			{
				lineView.alignable && (lineView.alignable = null);
				for (var node = lineView.node.firstChild, next = void 0; node; node = next)
				{
					next = node.nextSibling;
					"CodeMirror-linewidget" == node.className && lineView.node.removeChild(node)
				}
				insertLineWidgets(cm, lineView, dims)
			}

			function buildLineElement(cm, lineView, lineN, dims)
			{
				var built = getLineContent(cm, lineView);
				lineView.text = lineView.node = built.pre;
				built.bgClass && (lineView.bgClass = built.bgClass);
				built.textClass && (lineView.textClass = built.textClass);
				updateLineClasses(cm, lineView);
				updateLineGutter(cm, lineView, lineN, dims);
				insertLineWidgets(cm, lineView, dims);
				return lineView.node
			}

			function insertLineWidgets(cm, lineView, dims)
			{
				insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
				if (lineView.rest)
					for (var i = 0; i < lineView.rest.length; i++) insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false)
			}

			function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove)
			{
				if (!line.widgets) return;
				var wrap = ensureLineWrapped(lineView);
				for (var i = 0, ws = line.widgets; i < ws.length; ++i)
				{
					var widget = ws[i],
						node = elt("div", [widget.node], "CodeMirror-linewidget");
					widget.handleMouseEvents || node.setAttribute("cm-ignore-events", "true");
					positionLineWidget(widget, node, lineView, dims);
					cm.display.input.setUneditable(node);
					allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node);
					signalLater(widget, "redraw")
				}
			}

			function positionLineWidget(widget, node, lineView, dims)
			{
				if (widget.noHScroll)
				{
					(lineView.alignable || (lineView.alignable = [])).push(node);
					var width = dims.wrapperWidth;
					node.style.left = dims.fixedPos + "px";
					if (!widget.coverGutter)
					{
						width -= dims.gutterTotalWidth;
						node.style.paddingLeft = dims.gutterTotalWidth + "px"
					}
					node.style.width = width + "px"
				}
				if (widget.coverGutter)
				{
					node.style.zIndex = 5;
					node.style.position = "relative";
					widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px")
				}
			}

			function widgetHeight(widget)
			{
				if (null != widget.height) return widget.height;
				var cm = widget.doc.cm;
				if (!cm) return 0;
				if (!contains(document.body, widget.node))
				{
					var parentStyle = "position: relative;";
					widget.coverGutter && (parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;");
					widget.noHScroll && (parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;");
					removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle))
				}
				return widget.height = widget.node.parentNode.offsetHeight
			}

			function eventInWidget(display, e)
			{
				for (var n = e_target(e); n != display.wrapper; n = n.parentNode)
					if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == display.sizer && n != display.mover) return true
			}

			function paddingTop(display)
			{
				return display.lineSpace.offsetTop
			}

			function paddingVert(display)
			{
				return display.mover.offsetHeight - display.lineSpace.offsetHeight
			}

			function paddingH(display)
			{
				if (display.cachedPaddingH) return display.cachedPaddingH;
				var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
				var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
				var data = {
					left: parseInt(style.paddingLeft),
					right: parseInt(style.paddingRight)
				};
				isNaN(data.left) || isNaN(data.right) || (display.cachedPaddingH = data);
				return data
			}

			function scrollGap(cm)
			{
				return scrollerGap - cm.display.nativeBarWidth
			}

			function displayWidth(cm)
			{
				return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
			}

			function displayHeight(cm)
			{
				return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
			}

			function ensureLineHeights(cm, lineView, rect)
			{
				var wrapping = cm.options.lineWrapping;
				var curWidth = wrapping && displayWidth(cm);
				if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth)
				{
					var heights = lineView.measure.heights = [];
					if (wrapping)
					{
						lineView.measure.width = curWidth;
						var rects = lineView.text.firstChild.getClientRects();
						for (var i = 0; i < rects.length - 1; i++)
						{
							var cur = rects[i],
								next = rects[i + 1];
							Math.abs(cur.bottom - next.bottom) > 2 && heights.push((cur.bottom + next.top) / 2 - rect.top)
						}
					}
					heights.push(rect.bottom - rect.top)
				}
			}

			function mapFromLineView(lineView, line, lineN)
			{
				if (lineView.line == line) return {
					map: lineView.measure.map,
					cache: lineView.measure.cache
				};
				for (var i = 0; i < lineView.rest.length; i++)
					if (lineView.rest[i] == line) return {
						map: lineView.measure.maps[i],
						cache: lineView.measure.caches[i]
					};
				for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
					if (lineNo(lineView.rest[i$1]) > lineN) return {
						map: lineView.measure.maps[i$1],
						cache: lineView.measure.caches[i$1],
						before: true
					}
			}

			function updateExternalMeasurement(cm, line)
			{
				line = visualLine(line);
				var lineN = lineNo(line);
				var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
				view.lineN = lineN;
				var built = view.built = buildLineContent(cm, view);
				view.text = built.pre;
				removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
				return view
			}

			function measureChar(cm, line, ch, bias)
			{
				return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
			}

			function findViewForLine(cm, lineN)
			{
				if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) return cm.display.view[findViewIndex(cm, lineN)];
				var ext = cm.display.externalMeasured;
				if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) return ext
			}

			function prepareMeasureForLine(cm, line)
			{
				var lineN = lineNo(line);
				var view = findViewForLine(cm, lineN);
				if (view && !view.text) view = null;
				else if (view && view.changes)
				{
					updateLineForChanges(cm, view, lineN, getDimensions(cm));
					cm.curOp.forceUpdate = true
				}
				view || (view = updateExternalMeasurement(cm, line));
				var info = mapFromLineView(view, line, lineN);
				return {
					line: line,
					view: view,
					rect: null,
					map: info.map,
					cache: info.cache,
					before: info.before,
					hasHeights: false
				}
			}

			function measureCharPrepared(cm, prepared, ch, bias, varHeight)
			{
				prepared.before && (ch = -1);
				var found, key = ch + (bias || "");
				if (prepared.cache.hasOwnProperty(key)) found = prepared.cache[key];
				else
				{
					prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect());
					if (!prepared.hasHeights)
					{
						ensureLineHeights(cm, prepared.view, prepared.rect);
						prepared.hasHeights = true
					}
					found = measureCharInner(cm, prepared, ch, bias);
					found.bogus || (prepared.cache[key] = found)
				}
				return {
					left: found.left,
					right: found.right,
					top: varHeight ? found.rtop : found.top,
					bottom: varHeight ? found.rbottom : found.bottom
				}
			}
			var nullRect = {
				left: 0,
				right: 0,
				top: 0,
				bottom: 0
			};

			function nodeAndOffsetInLineMap(map$$1, ch, bias)
			{
				var node, start, end, collapse, mStart, mEnd;
				for (var i = 0; i < map$$1.length; i += 3)
				{
					mStart = map$$1[i];
					mEnd = map$$1[i + 1];
					if (ch < mStart)
					{
						start = 0;
						end = 1;
						collapse = "left"
					}
					else if (ch < mEnd)
					{
						start = ch - mStart;
						end = start + 1
					}
					else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch)
					{
						end = mEnd - mStart;
						start = end - 1;
						ch >= mEnd && (collapse = "right")
					}
					if (null != start)
					{
						node = map$$1[i + 2];
						mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias);
						if ("left" == bias && 0 == start)
							while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft)
							{
								node = map$$1[2 + (i -= 3)];
								collapse = "left"
							}
						if ("right" == bias && start == mEnd - mStart)
							while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft)
							{
								node = map$$1[(i += 3) + 2];
								collapse = "right"
							}
						break
					}
				}
				return {
					node: node,
					start: start,
					end: end,
					collapse: collapse,
					coverStart: mStart,
					coverEnd: mEnd
				}
			}

			function getUsefulRect(rects, bias)
			{
				var rect = nullRect;
				if ("left" == bias)
				{
					for (var i = 0; i < rects.length; i++)
						if ((rect = rects[i]).left != rect.right) break
				}
				else
					for (var i$1 = rects.length - 1; i$1 >= 0; i$1--)
						if ((rect = rects[i$1]).left != rect.right) break;
				return rect
			}

			function measureCharInner(cm, prepared, ch, bias)
			{
				var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
				var node = place.node,
					start = place.start,
					end = place.end,
					collapse = place.collapse;
				var rect;
				if (3 == node.nodeType)
				{
					for (var i$1 = 0; i$1 < 4; i$1++)
					{
						while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
						while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
						rect = ie && ie_version < 9 && 0 == start && end == place.coverEnd - place.coverStart ? node.parentNode.getBoundingClientRect() : getUsefulRect(range(node, start, end).getClientRects(), bias);
						if (rect.left || rect.right || 0 == start) break;
						end = start;
						start -= 1;
						collapse = "right"
					}
					ie && ie_version < 11 && (rect = maybeUpdateRectForZooming(cm.display.measure, rect))
				}
				else
				{
					start > 0 && (collapse = bias = "right");
					var rects;
					rect = cm.options.lineWrapping && (rects = node.getClientRects()).length > 1 ? rects["right" == bias ? rects.length - 1 : 0] : node.getBoundingClientRect()
				}
				if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right))
				{
					var rSpan = node.parentNode.getClientRects()[0];
					rect = rSpan ?
					{
						left: rSpan.left,
						right: rSpan.left + charWidth(cm.display),
						top: rSpan.top,
						bottom: rSpan.bottom
					} : nullRect
				}
				var rtop = rect.top - prepared.rect.top,
					rbot = rect.bottom - prepared.rect.top;
				var mid = (rtop + rbot) / 2;
				var heights = prepared.view.measure.heights;
				var i = 0;
				for (; i < heights.length - 1; i++)
					if (mid < heights[i]) break;
				var top = i ? heights[i - 1] : 0,
					bot = heights[i];
				var result = {
					left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left,
					right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left,
					top: top,
					bottom: bot
				};
				rect.left || rect.right || (result.bogus = true);
				if (!cm.options.singleCursorHeightPerLine)
				{
					result.rtop = rtop;
					result.rbottom = rbot
				}
				return result
			}

			function maybeUpdateRectForZooming(measure, rect)
			{
				if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) return rect;
				var scaleX = screen.logicalXDPI / screen.deviceXDPI;
				var scaleY = screen.logicalYDPI / screen.deviceYDPI;
				return {
					left: rect.left * scaleX,
					right: rect.right * scaleX,
					top: rect.top * scaleY,
					bottom: rect.bottom * scaleY
				}
			}

			function clearLineMeasurementCacheFor(lineView)
			{
				if (lineView.measure)
				{
					lineView.measure.cache = {};
					lineView.measure.heights = null;
					if (lineView.rest)
						for (var i = 0; i < lineView.rest.length; i++) lineView.measure.caches[i] = {}
				}
			}

			function clearLineMeasurementCache(cm)
			{
				cm.display.externalMeasure = null;
				removeChildren(cm.display.lineMeasure);
				for (var i = 0; i < cm.display.view.length; i++) clearLineMeasurementCacheFor(cm.display.view[i])
			}

			function clearCaches(cm)
			{
				clearLineMeasurementCache(cm);
				cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
				cm.options.lineWrapping || (cm.display.maxLineChanged = true);
				cm.display.lineNumChars = null
			}

			function pageScrollX()
			{
				if (chrome && android) return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
				return window.pageXOffset || (document.documentElement || document.body).scrollLeft
			}

			function pageScrollY()
			{
				if (chrome && android) return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
				return window.pageYOffset || (document.documentElement || document.body).scrollTop
			}

			function widgetTopHeight(lineObj)
			{
				var height = 0;
				if (lineObj.widgets)
					for (var i = 0; i < lineObj.widgets.length; ++i) lineObj.widgets[i].above && (height += widgetHeight(lineObj.widgets[i]));
				return height
			}

			function intoCoordSystem(cm, lineObj, rect, context, includeWidgets)
			{
				if (!includeWidgets)
				{
					var height = widgetTopHeight(lineObj);
					rect.top += height;
					rect.bottom += height
				}
				if ("line" == context) return rect;
				context || (context = "local");
				var yOff = _heightAtLine(lineObj);
				"local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset;
				if ("page" == context || "window" == context)
				{
					var lOff = cm.display.lineSpace.getBoundingClientRect();
					yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
					var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
					rect.left += xOff;
					rect.right += xOff
				}
				rect.top += yOff;
				rect.bottom += yOff;
				return rect
			}

			function fromCoordSystem(cm, coords, context)
			{
				if ("div" == context) return coords;
				var left = coords.left,
					top = coords.top;
				if ("page" == context)
				{
					left -= pageScrollX();
					top -= pageScrollY()
				}
				else if ("local" == context || !context)
				{
					var localBox = cm.display.sizer.getBoundingClientRect();
					left += localBox.left;
					top += localBox.top
				}
				var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
				return {
					left: left - lineSpaceBox.left,
					top: top - lineSpaceBox.top
				}
			}

			function _charCoords(cm, pos, context, lineObj, bias)
			{
				lineObj || (lineObj = getLine(cm.doc, pos.line));
				return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
			}

			function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight)
			{
				lineObj = lineObj || getLine(cm.doc, pos.line);
				preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));

				function get(ch, right)
				{
					var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
					right ? m.left = m.right : m.right = m.left;
					return intoCoordSystem(cm, lineObj, m, context)
				}
				var order = getOrder(lineObj, cm.doc.direction),
					ch = pos.ch,
					sticky = pos.sticky;
				if (ch >= lineObj.text.length)
				{
					ch = lineObj.text.length;
					sticky = "before"
				}
				else if (ch <= 0)
				{
					ch = 0;
					sticky = "after"
				}
				if (!order) return get("before" == sticky ? ch - 1 : ch, "before" == sticky);

				function getBidi(ch, partPos, invert)
				{
					var part = order[partPos],
						right = 1 == part.level;
					return get(invert ? ch - 1 : ch, right != invert)
				}
				var partPos = getBidiPartAt(order, ch, sticky);
				var other = bidiOther;
				var val = getBidi(ch, partPos, "before" == sticky);
				null != other && (val.other = getBidi(ch, other, "before" != sticky));
				return val
			}

			function estimateCoords(cm, pos)
			{
				var left = 0;
				pos = _clipPos(cm.doc, pos);
				cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch);
				var lineObj = getLine(cm.doc, pos.line);
				var top = _heightAtLine(lineObj) + paddingTop(cm.display);
				return {
					left: left,
					right: left,
					top: top,
					bottom: top + lineObj.height
				}
			}

			function PosWithInfo(line, ch, sticky, outside, xRel)
			{
				var pos = Pos(line, ch, sticky);
				pos.xRel = xRel;
				outside && (pos.outside = true);
				return pos
			}

			function _coordsChar(cm, x, y)
			{
				var doc = cm.doc;
				y += cm.display.viewOffset;
				if (y < 0) return PosWithInfo(doc.first, 0, null, true, -1);
				var lineN = _lineAtHeight(doc, y),
					last = doc.first + doc.size - 1;
				if (lineN > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1);
				x < 0 && (x = 0);
				var lineObj = getLine(doc, lineN);
				for (;;)
				{
					var found = coordsCharInner(cm, lineObj, lineN, x, y);
					var merged = collapsedSpanAtEnd(lineObj);
					var mergedPos = merged && merged.find(0, true);
					if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) return found;
					lineN = lineNo(lineObj = mergedPos.to.line)
				}
			}

			function wrappedLineExtent(cm, lineObj, preparedMeasure, y)
			{
				y -= widgetTopHeight(lineObj);
				var end = lineObj.text.length;
				var begin = findFirst(function (ch)
				{
					return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y
				}, end, 0);
				end = findFirst(function (ch)
				{
					return measureCharPrepared(cm, preparedMeasure, ch).top > y
				}, begin, end);
				return {
					begin: begin,
					end: end
				}
			}

			function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target)
			{
				preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
				var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
				return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
			}

			function boxIsAfter(box, x, y, left)
			{
				return !(box.bottom <= y) && (box.top > y || (left ? box.left : box.right) > x)
			}

			function coordsCharInner(cm, lineObj, lineNo$$1, x, y)
			{
				y -= _heightAtLine(lineObj);
				var preparedMeasure = prepareMeasureForLine(cm, lineObj);
				var widgetHeight$$1 = widgetTopHeight(lineObj);
				var begin = 0,
					end = lineObj.text.length,
					ltr = true;
				var order = getOrder(lineObj, cm.doc.direction);
				if (order)
				{
					var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
					ltr = 1 != part.level;
					begin = ltr ? part.from : part.to - 1;
					end = ltr ? part.to : part.from - 1
				}
				var chAround = null,
					boxAround = null;
				var ch = findFirst(function (ch)
				{
					var box = measureCharPrepared(cm, preparedMeasure, ch);
					box.top += widgetHeight$$1;
					box.bottom += widgetHeight$$1;
					if (!boxIsAfter(box, x, y, false)) return false;
					if (box.top <= y && box.left <= x)
					{
						chAround = ch;
						boxAround = box
					}
					return true
				}, begin, end);
				var baseX, sticky, outside = false;
				if (boxAround)
				{
					var atLeft = x - boxAround.left < boxAround.right - x,
						atStart = atLeft == ltr;
					ch = chAround + (atStart ? 0 : 1);
					sticky = atStart ? "after" : "before";
					baseX = atLeft ? boxAround.left : boxAround.right
				}
				else
				{
					ltr || ch != end && ch != begin || ch++;
					sticky = 0 == ch ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? "after" : "before";
					var coords = _cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
					baseX = coords.left;
					outside = y < coords.top || y >= coords.bottom
				}
				ch = skipExtendingChars(lineObj.text, ch, 1);
				return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
			}

			function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y)
			{
				var index = findFirst(function (i)
				{
					var part = order[i],
						ltr = 1 != part.level;
					return boxIsAfter(_cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true)
				}, 0, order.length - 1);
				var part = order[index];
				if (index > 0)
				{
					var ltr = 1 != part.level;
					var start = _cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
					boxIsAfter(start, x, y, true) && start.top > y && (part = order[index - 1])
				}
				return part
			}

			function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y)
			{
				var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
				var begin = ref.begin;
				var end = ref.end;
				/\s/.test(lineObj.text.charAt(end - 1)) && end--;
				var part = null,
					closestDist = null;
				for (var i = 0; i < order.length; i++)
				{
					var p = order[i];
					if (p.from >= end || p.to <= begin) continue;
					var ltr = 1 != p.level;
					var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
					var dist = endX < x ? x - endX + 1e9 : endX - x;
					if (!part || closestDist > dist)
					{
						part = p;
						closestDist = dist
					}
				}
				part || (part = order[order.length - 1]);
				part.from < begin && (part = {
					from: begin,
					to: part.to,
					level: part.level
				});
				part.to > end && (part = {
					from: part.from,
					to: end,
					level: part.level
				});
				return part
			}
			var measureText;

			function textHeight(display)
			{
				if (null != display.cachedTextHeight) return display.cachedTextHeight;
				if (null == measureText)
				{
					measureText = elt("pre");
					for (var i = 0; i < 49; ++i)
					{
						measureText.appendChild(document.createTextNode("x"));
						measureText.appendChild(elt("br"))
					}
					measureText.appendChild(document.createTextNode("x"))
				}
				removeChildrenAndAdd(display.measure, measureText);
				var height = measureText.offsetHeight / 50;
				height > 3 && (display.cachedTextHeight = height);
				removeChildren(display.measure);
				return height || 1
			}

			function charWidth(display)
			{
				if (null != display.cachedCharWidth) return display.cachedCharWidth;
				var anchor = elt("span", "xxxxxxxxxx");
				var pre = elt("pre", [anchor]);
				removeChildrenAndAdd(display.measure, pre);
				var rect = anchor.getBoundingClientRect(),
					width = (rect.right - rect.left) / 10;
				width > 2 && (display.cachedCharWidth = width);
				return width || 10
			}

			function getDimensions(cm)
			{
				var d = cm.display,
					left = {},
					width = {};
				var gutterLeft = d.gutters.clientLeft;
				for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i)
				{
					left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
					width[cm.options.gutters[i]] = n.clientWidth
				}
				return {
					fixedPos: compensateForHScroll(d),
					gutterTotalWidth: d.gutters.offsetWidth,
					gutterLeft: left,
					gutterWidth: width,
					wrapperWidth: d.wrapper.clientWidth
				}
			}

			function compensateForHScroll(display)
			{
				return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
			}

			function estimateHeight(cm)
			{
				var th = textHeight(cm.display),
					wrapping = cm.options.lineWrapping;
				var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
				return function (line)
				{
					if (lineIsHidden(cm.doc, line)) return 0;
					var widgetsHeight = 0;
					if (line.widgets)
						for (var i = 0; i < line.widgets.length; i++) line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
					return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th
				}
			}

			function estimateLineHeights(cm)
			{
				var doc = cm.doc,
					est = estimateHeight(cm);
				doc.iter(function (line)
				{
					var estHeight = est(line);
					estHeight != line.height && updateLineHeight(line, estHeight)
				})
			}

			function posFromMouse(cm, e, liberal, forRect)
			{
				var display = cm.display;
				if (!liberal && "true" == e_target(e).getAttribute("cm-not-content")) return null;
				var x, y, space = display.lineSpace.getBoundingClientRect();
				try
				{
					x = e.clientX - space.left;
					y = e.clientY - space.top
				}
				catch (e)
				{
					return null
				}
				var line, coords = _coordsChar(cm, x, y);
				if (forRect && 1 == coords.xRel && (line = getLine(cm.doc, coords.line).text).length == coords.ch)
				{
					var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
					coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))
				}
				return coords
			}

			function findViewIndex(cm, n)
			{
				if (n >= cm.display.viewTo) return null;
				n -= cm.display.viewFrom;
				if (n < 0) return null;
				var view = cm.display.view;
				for (var i = 0; i < view.length; i++)
				{
					n -= view[i].size;
					if (n < 0) return i
				}
			}

			function updateSelection(cm)
			{
				cm.display.input.showSelection(cm.display.input.prepareSelection())
			}

			function prepareSelection(cm, primary)
			{
				void 0 === primary && (primary = true);
				var doc = cm.doc,
					result = {};
				var curFragment = result.cursors = document.createDocumentFragment();
				var selFragment = result.selection = document.createDocumentFragment();
				for (var i = 0; i < doc.sel.ranges.length; i++)
				{
					if (!primary && i == doc.sel.primIndex) continue;
					var range$$1 = doc.sel.ranges[i];
					if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) continue;
					var collapsed = range$$1.empty();
					(collapsed || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range$$1.head, curFragment);
					collapsed || drawSelectionRange(cm, range$$1, selFragment)
				}
				return result
			}

			function drawSelectionCursor(cm, head, output)
			{
				var pos = _cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
				var cursor = output.appendChild(elt("div", "", "CodeMirror-cursor"));
				cursor.style.left = pos.left + "px";
				cursor.style.top = pos.top + "px";
				cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
				if (pos.other)
				{
					var otherCursor = output.appendChild(elt("div", "", "CodeMirror-cursor CodeMirror-secondarycursor"));
					otherCursor.style.display = "";
					otherCursor.style.left = pos.other.left + "px";
					otherCursor.style.top = pos.other.top + "px";
					otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px"
				}
			}

			function cmpCoords(a, b)
			{
				return a.top - b.top || a.left - b.left
			}

			function drawSelectionRange(cm, range$$1, output)
			{
				var display = cm.display,
					doc = cm.doc;
				var fragment = document.createDocumentFragment();
				var padding = paddingH(cm.display),
					leftSide = padding.left;
				var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
				var docLTR = "ltr" == doc.direction;

				function add(left, top, width, bottom)
				{
					top < 0 && (top = 0);
					top = Math.round(top);
					bottom = Math.round(bottom);
					fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"))
				}

				function drawForLine(line, fromArg, toArg)
				{
					var lineObj = getLine(doc, line);
					var lineLen = lineObj.text.length;
					var start, end;

					function coords(ch, bias)
					{
						return _charCoords(cm, Pos(line, ch), "div", lineObj, bias)
					}

					function wrapX(pos, dir, side)
					{
						var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
						var prop = "ltr" == dir == ("after" == side) ? "left" : "right";
						var ch = "after" == side ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
						return coords(ch, prop)[prop]
					}
					var order = getOrder(lineObj, doc.direction);
					iterateBidiSections(order, fromArg || 0, null == toArg ? lineLen : toArg, function (from, to, dir, i)
					{
						var ltr = "ltr" == dir;
						var fromPos = coords(from, ltr ? "left" : "right");
						var toPos = coords(to - 1, ltr ? "right" : "left");
						var openStart = null == fromArg && 0 == from,
							openEnd = null == toArg && to == lineLen;
						var first = 0 == i,
							last = !order || i == order.length - 1;
						if (toPos.top - fromPos.top <= 3)
						{
							var openLeft = (docLTR ? openStart : openEnd) && first;
							var openRight = (docLTR ? openEnd : openStart) && last;
							var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
							var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
							add(left, fromPos.top, right - left, fromPos.bottom)
						}
						else
						{
							var topLeft, topRight, botLeft, botRight;
							if (ltr)
							{
								topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
								topRight = docLTR ? rightSide : wrapX(from, dir, "before");
								botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
								botRight = docLTR && openEnd && last ? rightSide : toPos.right
							}
							else
							{
								topLeft = docLTR ? wrapX(from, dir, "before") : leftSide;
								topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
								botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
								botRight = docLTR ? wrapX(to, dir, "after") : rightSide
							}
							add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
							fromPos.bottom < toPos.top && add(leftSide, fromPos.bottom, null, toPos.top);
							add(botLeft, toPos.top, botRight - botLeft, toPos.bottom)
						}(!start || cmpCoords(fromPos, start) < 0) && (start = fromPos);
						cmpCoords(toPos, start) < 0 && (start = toPos);
						(!end || cmpCoords(fromPos, end) < 0) && (end = fromPos);
						cmpCoords(toPos, end) < 0 && (end = toPos)
					});
					return {
						start: start,
						end: end
					}
				}
				var sFrom = range$$1.from(),
					sTo = range$$1.to();
				if (sFrom.line == sTo.line) drawForLine(sFrom.line, sFrom.ch, sTo.ch);
				else
				{
					var fromLine = getLine(doc, sFrom.line),
						toLine = getLine(doc, sTo.line);
					var singleVLine = visualLine(fromLine) == visualLine(toLine);
					var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
					var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
					if (singleVLine)
						if (leftEnd.top < rightStart.top - 2)
						{
							add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
							add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)
						}
					else add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
					leftEnd.bottom < rightStart.top && add(leftSide, leftEnd.bottom, null, rightStart.top)
				}
				output.appendChild(fragment)
			}

			function restartBlink(cm)
			{
				if (!cm.state.focused) return;
				var display = cm.display;
				clearInterval(display.blinker);
				var on = true;
				display.cursorDiv.style.visibility = "";
				cm.options.cursorBlinkRate > 0 ? display.blinker = setInterval(function ()
				{
					return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"
				}, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden")
			}

			function ensureFocus(cm)
			{
				if (!cm.state.focused)
				{
					cm.display.input.focus();
					onFocus(cm)
				}
			}

			function delayBlurEvent(cm)
			{
				cm.state.delayingBlurEvent = true;
				setTimeout(function ()
				{
					if (cm.state.delayingBlurEvent)
					{
						cm.state.delayingBlurEvent = false;
						onBlur(cm)
					}
				}, 100)
			}

			function onFocus(cm, e)
			{
				cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = false);
				if ("nocursor" == cm.options.readOnly) return;
				if (!cm.state.focused)
				{
					signal(cm, "focus", cm, e);
					cm.state.focused = true;
					addClass(cm.display.wrapper, "CodeMirror-focused");
					if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel)
					{
						cm.display.input.reset();
						webkit && setTimeout(function ()
						{
							return cm.display.input.reset(true)
						}, 20)
					}
					cm.display.input.receivedFocus()
				}
				restartBlink(cm)
			}

			function onBlur(cm, e)
			{
				if (cm.state.delayingBlurEvent) return;
				if (cm.state.focused)
				{
					signal(cm, "blur", cm, e);
					cm.state.focused = false;
					rmClass(cm.display.wrapper, "CodeMirror-focused")
				}
				clearInterval(cm.display.blinker);
				setTimeout(function ()
				{
					cm.state.focused || (cm.display.shift = false)
				}, 150)
			}

			function updateHeightsInViewport(cm)
			{
				var display = cm.display;
				var prevBottom = display.lineDiv.offsetTop;
				for (var i = 0; i < display.view.length; i++)
				{
					var cur = display.view[i],
						height = void 0;
					if (cur.hidden) continue;
					if (ie && ie_version < 8)
					{
						var bot = cur.node.offsetTop + cur.node.offsetHeight;
						height = bot - prevBottom;
						prevBottom = bot
					}
					else
					{
						var box = cur.node.getBoundingClientRect();
						height = box.bottom - box.top
					}
					var diff = cur.line.height - height;
					height < 2 && (height = textHeight(display));
					if (diff > .005 || diff < -.005)
					{
						updateLineHeight(cur.line, height);
						updateWidgetHeight(cur.line);
						if (cur.rest)
							for (var j = 0; j < cur.rest.length; j++) updateWidgetHeight(cur.rest[j])
					}
				}
			}

			function updateWidgetHeight(line)
			{
				if (line.widgets)
					for (var i = 0; i < line.widgets.length; ++i)
					{
						var w = line.widgets[i],
							parent = w.node.parentNode;
						parent && (w.height = parent.offsetHeight)
					}
			}

			function visibleLines(display, doc, viewport)
			{
				var top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop;
				top = Math.floor(top - paddingTop(display));
				var bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight;
				var from = _lineAtHeight(doc, top),
					to = _lineAtHeight(doc, bottom);
				if (viewport && viewport.ensure)
				{
					var ensureFrom = viewport.ensure.from.line,
						ensureTo = viewport.ensure.to.line;
					if (ensureFrom < from)
					{
						from = ensureFrom;
						to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)
					}
					else if (Math.min(ensureTo, doc.lastLine()) >= to)
					{
						from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
						to = ensureTo
					}
				}
				return {
					from: from,
					to: Math.max(to, from + 1)
				}
			}

			function alignHorizontally(cm)
			{
				var display = cm.display,
					view = display.view;
				if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
				var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
				var gutterW = display.gutters.offsetWidth,
					left = comp + "px";
				for (var i = 0; i < view.length; i++)
					if (!view[i].hidden)
					{
						if (cm.options.fixedGutter)
						{
							view[i].gutter && (view[i].gutter.style.left = left);
							view[i].gutterBackground && (view[i].gutterBackground.style.left = left)
						}
						var align = view[i].alignable;
						if (align)
							for (var j = 0; j < align.length; j++) align[j].style.left = left
					}
				cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px")
			}

			function maybeUpdateLineNumberWidth(cm)
			{
				if (!cm.options.lineNumbers) return false;
				var doc = cm.doc,
					last = lineNumberFor(cm.options, doc.first + doc.size - 1),
					display = cm.display;
				if (last.length != display.lineNumChars)
				{
					var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
					var innerW = test.firstChild.offsetWidth,
						padding = test.offsetWidth - innerW;
					display.lineGutter.style.width = "";
					display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
					display.lineNumWidth = display.lineNumInnerWidth + padding;
					display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
					display.lineGutter.style.width = display.lineNumWidth + "px";
					updateGutterSpace(cm);
					return true
				}
				return false
			}

			function maybeScrollWindow(cm, rect)
			{
				if (signalDOMEvent(cm, "scrollCursorIntoView")) return;
				var display = cm.display,
					box = display.sizer.getBoundingClientRect(),
					doScroll = null;
				rect.top + box.top < 0 ? doScroll = true : rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = false);
				if (null != doScroll && !phantom)
				{
					var scrollNode = elt("div", "", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
					cm.display.lineSpace.appendChild(scrollNode);
					scrollNode.scrollIntoView(doScroll);
					cm.display.lineSpace.removeChild(scrollNode)
				}
			}

			function scrollPosIntoView(cm, pos, end, margin)
			{
				null == margin && (margin = 0);
				var rect;
				if (!cm.options.lineWrapping && pos == end)
				{
					pos = pos.ch ? Pos(pos.line, "before" == pos.sticky ? pos.ch - 1 : pos.ch, "after") : pos;
					end = "before" == pos.sticky ? Pos(pos.line, pos.ch + 1, "before") : pos
				}
				for (var limit = 0; limit < 5; limit++)
				{
					var changed = false;
					var coords = _cursorCoords(cm, pos);
					var endCoords = end && end != pos ? _cursorCoords(cm, end) : coords;
					rect = {
						left: Math.min(coords.left, endCoords.left),
						top: Math.min(coords.top, endCoords.top) - margin,
						right: Math.max(coords.left, endCoords.left),
						bottom: Math.max(coords.bottom, endCoords.bottom) + margin
					};
					var scrollPos = calculateScrollPos(cm, rect);
					var startTop = cm.doc.scrollTop,
						startLeft = cm.doc.scrollLeft;
					if (null != scrollPos.scrollTop)
					{
						updateScrollTop(cm, scrollPos.scrollTop);
						Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = true)
					}
					if (null != scrollPos.scrollLeft)
					{
						setScrollLeft(cm, scrollPos.scrollLeft);
						Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = true)
					}
					if (!changed) break
				}
				return rect
			}

			function scrollIntoView(cm, rect)
			{
				var scrollPos = calculateScrollPos(cm, rect);
				null != scrollPos.scrollTop && updateScrollTop(cm, scrollPos.scrollTop);
				null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft)
			}

			function calculateScrollPos(cm, rect)
			{
				var display = cm.display,
					snapMargin = textHeight(cm.display);
				rect.top < 0 && (rect.top = 0);
				var screentop = cm.curOp && null != cm.curOp.scrollTop ? cm.curOp.scrollTop : display.scroller.scrollTop;
				var screen = displayHeight(cm),
					result = {};
				rect.bottom - rect.top > screen && (rect.bottom = rect.top + screen);
				var docBottom = cm.doc.height + paddingVert(display);
				var atTop = rect.top < snapMargin,
					atBottom = rect.bottom > docBottom - snapMargin;
				if (rect.top < screentop) result.scrollTop = atTop ? 0 : rect.top;
				else if (rect.bottom > screentop + screen)
				{
					var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
					newTop != screentop && (result.scrollTop = newTop)
				}
				var screenleft = cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
				var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
				var tooWide = rect.right - rect.left > screenw;
				tooWide && (rect.right = rect.left + screenw);
				rect.left < 10 ? result.scrollLeft = 0 : rect.left < screenleft ? result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)) : rect.right > screenw + screenleft - 3 && (result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw);
				return result
			}

			function addToScrollTop(cm, top)
			{
				if (null == top) return;
				resolveScrollToPos(cm);
				cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc.scrollTop : cm.curOp.scrollTop) + top
			}

			function ensureCursorVisible(cm)
			{
				resolveScrollToPos(cm);
				var cur = cm.getCursor();
				cm.curOp.scrollToPos = {
					from: cur,
					to: cur,
					margin: cm.options.cursorScrollMargin
				}
			}

			function scrollToCoords(cm, x, y)
			{
				null == x && null == y || resolveScrollToPos(cm);
				null != x && (cm.curOp.scrollLeft = x);
				null != y && (cm.curOp.scrollTop = y)
			}

			function scrollToRange(cm, range$$1)
			{
				resolveScrollToPos(cm);
				cm.curOp.scrollToPos = range$$1
			}

			function resolveScrollToPos(cm)
			{
				var range$$1 = cm.curOp.scrollToPos;
				if (range$$1)
				{
					cm.curOp.scrollToPos = null;
					var from = estimateCoords(cm, range$$1.from),
						to = estimateCoords(cm, range$$1.to);
					scrollToCoordsRange(cm, from, to, range$$1.margin)
				}
			}

			function scrollToCoordsRange(cm, from, to, margin)
			{
				var sPos = calculateScrollPos(cm,
				{
					left: Math.min(from.left, to.left),
					top: Math.min(from.top, to.top) - margin,
					right: Math.max(from.right, to.right),
					bottom: Math.max(from.bottom, to.bottom) + margin
				});
				scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop)
			}

			function updateScrollTop(cm, val)
			{
				if (Math.abs(cm.doc.scrollTop - val) < 2) return;
				gecko || updateDisplaySimple(cm,
				{
					top: val
				});
				setScrollTop(cm, val, true);
				gecko && updateDisplaySimple(cm);
				startWorker(cm, 100)
			}

			function setScrollTop(cm, val, forceScroll)
			{
				val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
				if (cm.display.scroller.scrollTop == val && !forceScroll) return;
				cm.doc.scrollTop = val;
				cm.display.scrollbars.setScrollTop(val);
				cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val)
			}

			function setScrollLeft(cm, val, isScroller, forceScroll)
			{
				val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
				if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) return;
				cm.doc.scrollLeft = val;
				alignHorizontally(cm);
				cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val);
				cm.display.scrollbars.setScrollLeft(val)
			}

			function measureForScrollbars(cm)
			{
				var d = cm.display,
					gutterW = d.gutters.offsetWidth;
				var docH = Math.round(cm.doc.height + paddingVert(cm.display));
				return {
					clientHeight: d.scroller.clientHeight,
					viewHeight: d.wrapper.clientHeight,
					scrollWidth: d.scroller.scrollWidth,
					clientWidth: d.scroller.clientWidth,
					viewWidth: d.wrapper.clientWidth,
					barLeft: cm.options.fixedGutter ? gutterW : 0,
					docHeight: docH,
					scrollHeight: docH + scrollGap(cm) + d.barHeight,
					nativeBarWidth: d.nativeBarWidth,
					gutterWidth: gutterW
				}
			}
			var NativeScrollbars = function NativeScrollbars(place, scroll, cm)
			{
				this.cm = cm;
				var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
				var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
				place(vert);
				place(horiz);
				on(vert, "scroll", function ()
				{
					vert.clientHeight && scroll(vert.scrollTop, "vertical")
				});
				on(horiz, "scroll", function ()
				{
					horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal")
				});
				this.checkedZeroWidth = false;
				ie && ie_version < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
			};
			NativeScrollbars.prototype.update = function (measure)
			{
				var needsH = measure.scrollWidth > measure.clientWidth + 1;
				var needsV = measure.scrollHeight > measure.clientHeight + 1;
				var sWidth = measure.nativeBarWidth;
				if (needsV)
				{
					this.vert.style.display = "block";
					this.vert.style.bottom = needsH ? sWidth + "px" : "0";
					var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
					this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px"
				}
				else
				{
					this.vert.style.display = "";
					this.vert.firstChild.style.height = "0"
				}
				if (needsH)
				{
					this.horiz.style.display = "block";
					this.horiz.style.right = needsV ? sWidth + "px" : "0";
					this.horiz.style.left = measure.barLeft + "px";
					var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
					this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px"
				}
				else
				{
					this.horiz.style.display = "";
					this.horiz.firstChild.style.width = "0"
				}
				if (!this.checkedZeroWidth && measure.clientHeight > 0)
				{
					0 == sWidth && this.zeroWidthHack();
					this.checkedZeroWidth = true
				}
				return {
					right: needsV ? sWidth : 0,
					bottom: needsH ? sWidth : 0
				}
			};
			NativeScrollbars.prototype.setScrollLeft = function (pos)
			{
				this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos);
				this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz")
			};
			NativeScrollbars.prototype.setScrollTop = function (pos)
			{
				this.vert.scrollTop != pos && (this.vert.scrollTop = pos);
				this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert")
			};
			NativeScrollbars.prototype.zeroWidthHack = function ()
			{
				var w = mac && !mac_geMountainLion ? "12px" : "18px";
				this.horiz.style.height = this.vert.style.width = w;
				this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
				this.disableHoriz = new Delayed;
				this.disableVert = new Delayed
			};
			NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type)
			{
				bar.style.pointerEvents = "auto";

				function maybeDisable()
				{
					var box = bar.getBoundingClientRect();
					var elt$$1 = "vert" == type ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
					elt$$1 != bar ? bar.style.pointerEvents = "none" : delay.set(1e3, maybeDisable)
				}
				delay.set(1e3, maybeDisable)
			};
			NativeScrollbars.prototype.clear = function ()
			{
				var parent = this.horiz.parentNode;
				parent.removeChild(this.horiz);
				parent.removeChild(this.vert)
			};
			var NullScrollbars = function NullScrollbars()
			{};
			NullScrollbars.prototype.update = function ()
			{
				return {
					bottom: 0,
					right: 0
				}
			};
			NullScrollbars.prototype.setScrollLeft = function () {};
			NullScrollbars.prototype.setScrollTop = function () {};
			NullScrollbars.prototype.clear = function () {};

			function updateScrollbars(cm, measure)
			{
				measure || (measure = measureForScrollbars(cm));
				var startWidth = cm.display.barWidth,
					startHeight = cm.display.barHeight;
				updateScrollbarsInner(cm, measure);
				for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++)
				{
					startWidth != cm.display.barWidth && cm.options.lineWrapping && updateHeightsInViewport(cm);
					updateScrollbarsInner(cm, measureForScrollbars(cm));
					startWidth = cm.display.barWidth;
					startHeight = cm.display.barHeight
				}
			}

			function updateScrollbarsInner(cm, measure)
			{
				var d = cm.display;
				var sizes = d.scrollbars.update(measure);
				d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
				d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
				d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
				if (sizes.right && sizes.bottom)
				{
					d.scrollbarFiller.style.display = "block";
					d.scrollbarFiller.style.height = sizes.bottom + "px";
					d.scrollbarFiller.style.width = sizes.right + "px"
				}
				else d.scrollbarFiller.style.display = "";
				if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter)
				{
					d.gutterFiller.style.display = "block";
					d.gutterFiller.style.height = sizes.bottom + "px";
					d.gutterFiller.style.width = measure.gutterWidth + "px"
				}
				else d.gutterFiller.style.display = ""
			}
			var scrollbarModel = {
				native: NativeScrollbars,
				null: NullScrollbars
			};

			function initScrollbars(cm)
			{
				if (cm.display.scrollbars)
				{
					cm.display.scrollbars.clear();
					cm.display.scrollbars.addClass && rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)
				}
				cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node)
				{
					cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
					on(node, "mousedown", function ()
					{
						cm.state.focused && setTimeout(function ()
						{
							return cm.display.input.focus()
						}, 0)
					});
					node.setAttribute("cm-not-content", "true")
				}, function (pos, axis)
				{
					"horizontal" == axis ? setScrollLeft(cm, pos) : updateScrollTop(cm, pos)
				}, cm);
				cm.display.scrollbars.addClass && addClass(cm.display.wrapper, cm.display.scrollbars.addClass)
			}
			var nextOpId = 0;

			function _startOperation(cm)
			{
				cm.curOp = {
					cm: cm,
					viewChanged: false,
					startHeight: cm.doc.height,
					forceUpdate: false,
					updateInput: null,
					typing: false,
					changeObjs: null,
					cursorActivityHandlers: null,
					cursorActivityCalled: 0,
					selectionChanged: false,
					updateMaxLine: false,
					scrollLeft: null,
					scrollTop: null,
					scrollToPos: null,
					focus: false,
					id: ++nextOpId
				};
				pushOperation(cm.curOp)
			}

			function _endOperation(cm)
			{
				var op = cm.curOp;
				finishOperation(op, function (group)
				{
					for (var i = 0; i < group.ops.length; i++) group.ops[i].cm.curOp = null;
					endOperations(group)
				})
			}

			function endOperations(group)
			{
				var ops = group.ops;
				for (var i = 0; i < ops.length; i++) endOperation_R1(ops[i]);
				for (var i$1 = 0; i$1 < ops.length; i$1++) endOperation_W1(ops[i$1]);
				for (var i$2 = 0; i$2 < ops.length; i$2++) endOperation_R2(ops[i$2]);
				for (var i$3 = 0; i$3 < ops.length; i$3++) endOperation_W2(ops[i$3]);
				for (var i$4 = 0; i$4 < ops.length; i$4++) endOperation_finish(ops[i$4])
			}

			function endOperation_R1(op)
			{
				var cm = op.cm,
					display = cm.display;
				maybeClipScrollbars(cm);
				op.updateMaxLine && findMaxLine(cm);
				op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
				op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate &&
				{
					top: op.scrollTop,
					ensure: op.scrollToPos
				}, op.forceUpdate)
			}

			function endOperation_W1(op)
			{
				op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
			}

			function endOperation_R2(op)
			{
				var cm = op.cm,
					display = cm.display;
				op.updatedDisplay && updateHeightsInViewport(cm);
				op.barMeasure = measureForScrollbars(cm);
				if (display.maxLineChanged && !cm.options.lineWrapping)
				{
					op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
					cm.display.sizerWidth = op.adjustWidthTo;
					op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
					op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))
				}(op.updatedDisplay || op.selectionChanged) && (op.preparedSelection = display.input.prepareSelection())
			}

			function endOperation_W2(op)
			{
				var cm = op.cm;
				if (null != op.adjustWidthTo)
				{
					cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
					op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
					cm.display.maxLineChanged = false
				}
				var takeFocus = op.focus && op.focus == activeElt();
				op.preparedSelection && cm.display.input.showSelection(op.preparedSelection, takeFocus);
				(op.updatedDisplay || op.startHeight != cm.doc.height) && updateScrollbars(cm, op.barMeasure);
				op.updatedDisplay && setDocumentHeight(cm, op.barMeasure);
				op.selectionChanged && restartBlink(cm);
				cm.state.focused && op.updateInput && cm.display.input.reset(op.typing);
				takeFocus && ensureFocus(op.cm)
			}

			function endOperation_finish(op)
			{
				var cm = op.cm,
					display = cm.display,
					doc = cm.doc;
				op.updatedDisplay && postUpdateDisplay(cm, op.update);
				null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null);
				null != op.scrollTop && setScrollTop(cm, op.scrollTop, op.forceScroll);
				null != op.scrollLeft && setScrollLeft(cm, op.scrollLeft, true, true);
				if (op.scrollToPos)
				{
					var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
					maybeScrollWindow(cm, rect)
				}
				var hidden = op.maybeHiddenMarkers,
					unhidden = op.maybeUnhiddenMarkers;
				if (hidden)
					for (var i = 0; i < hidden.length; ++i) hidden[i].lines.length || signal(hidden[i], "hide");
				if (unhidden)
					for (var i$1 = 0; i$1 < unhidden.length; ++i$1) unhidden[i$1].lines.length && signal(unhidden[i$1], "unhide");
				display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop);
				op.changeObjs && signal(cm, "changes", cm, op.changeObjs);
				op.update && op.update.finish()
			}

			function runInOp(cm, f)
			{
				if (cm.curOp) return f();
				_startOperation(cm);
				try
				{
					return f()
				}
				finally
				{
					_endOperation(cm)
				}
			}

			function operation(cm, f)
			{
				return function ()
				{
					if (cm.curOp) return f.apply(cm, arguments);
					_startOperation(cm);
					try
					{
						return f.apply(cm, arguments)
					}
					finally
					{
						_endOperation(cm)
					}
				}
			}

			function methodOp(f)
			{
				return function ()
				{
					if (this.curOp) return f.apply(this, arguments);
					_startOperation(this);
					try
					{
						return f.apply(this, arguments)
					}
					finally
					{
						_endOperation(this)
					}
				}
			}

			function docMethodOp(f)
			{
				return function ()
				{
					var cm = this.cm;
					if (!cm || cm.curOp) return f.apply(this, arguments);
					_startOperation(cm);
					try
					{
						return f.apply(this, arguments)
					}
					finally
					{
						_endOperation(cm)
					}
				}
			}

			function regChange(cm, from, to, lendiff)
			{
				null == from && (from = cm.doc.first);
				null == to && (to = cm.doc.first + cm.doc.size);
				lendiff || (lendiff = 0);
				var display = cm.display;
				lendiff && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from);
				cm.curOp.viewChanged = true;
				if (from >= display.viewTo) sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm);
				else if (to <= display.viewFrom)
					if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) resetView(cm);
					else
					{
						display.viewFrom += lendiff;
						display.viewTo += lendiff
					}
				else if (from <= display.viewFrom && to >= display.viewTo) resetView(cm);
				else if (from <= display.viewFrom)
				{
					var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
					if (cut)
					{
						display.view = display.view.slice(cut.index);
						display.viewFrom = cut.lineN;
						display.viewTo += lendiff
					}
					else resetView(cm)
				}
				else if (to >= display.viewTo)
				{
					var cut$1 = viewCuttingPoint(cm, from, from, -1);
					if (cut$1)
					{
						display.view = display.view.slice(0, cut$1.index);
						display.viewTo = cut$1.lineN
					}
					else resetView(cm)
				}
				else
				{
					var cutTop = viewCuttingPoint(cm, from, from, -1);
					var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
					if (cutTop && cutBot)
					{
						display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
						display.viewTo += lendiff
					}
					else resetView(cm)
				}
				var ext = display.externalMeasured;
				ext && (to < ext.lineN ? ext.lineN += lendiff : from < ext.lineN + ext.size && (display.externalMeasured = null))
			}

			function regLineChange(cm, line, type)
			{
				cm.curOp.viewChanged = true;
				var display = cm.display,
					ext = cm.display.externalMeasured;
				ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null);
				if (line < display.viewFrom || line >= display.viewTo) return;
				var lineView = display.view[findViewIndex(cm, line)];
				if (null == lineView.node) return;
				var arr = lineView.changes || (lineView.changes = []); - 1 == indexOf(arr, type) && arr.push(type)
			}

			function resetView(cm)
			{
				cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
				cm.display.view = [];
				cm.display.viewOffset = 0
			}

			function viewCuttingPoint(cm, oldN, newN, dir)
			{
				var diff, index = findViewIndex(cm, oldN),
					view = cm.display.view;
				if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) return {
					index: index,
					lineN: newN
				};
				var n = cm.display.viewFrom;
				for (var i = 0; i < index; i++) n += view[i].size;
				if (n != oldN)
				{
					if (dir > 0)
					{
						if (index == view.length - 1) return null;
						diff = n + view[index].size - oldN;
						index++
					}
					else diff = n - oldN;
					oldN += diff;
					newN += diff
				}
				while (visualLineNo(cm.doc, newN) != newN)
				{
					if (index == (dir < 0 ? 0 : view.length - 1)) return null;
					newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
					index += dir
				}
				return {
					index: index,
					lineN: newN
				}
			}

			function adjustView(cm, from, to)
			{
				var display = cm.display,
					view = display.view;
				if (0 == view.length || from >= display.viewTo || to <= display.viewFrom)
				{
					display.view = buildViewArray(cm, from, to);
					display.viewFrom = from
				}
				else
				{
					display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from)));
					display.viewFrom = from;
					display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))
				}
				display.viewTo = to
			}

			function countDirtyView(cm)
			{
				var view = cm.display.view,
					dirty = 0;
				for (var i = 0; i < view.length; i++)
				{
					var lineView = view[i];
					lineView.hidden || lineView.node && !lineView.changes || ++dirty
				}
				return dirty
			}

			function startWorker(cm, time)
			{
				cm.doc.highlightFrontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm))
			}

			function highlightWorker(cm)
			{
				var doc = cm.doc;
				if (doc.highlightFrontier >= cm.display.viewTo) return;
				var end = +new Date + cm.options.workTime;
				var context = getContextBefore(cm, doc.highlightFrontier);
				var changedLines = [];
				doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line)
				{
					if (context.line >= cm.display.viewFrom)
					{
						var oldStyles = line.styles;
						var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
						var highlighted = highlightLine(cm, line, context, true);
						resetState && (context.state = resetState);
						line.styles = highlighted.styles;
						var oldCls = line.styleClasses,
							newCls = highlighted.classes;
						newCls ? line.styleClasses = newCls : oldCls && (line.styleClasses = null);
						var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
						for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
						ischange && changedLines.push(context.line);
						line.stateAfter = context.save();
						context.nextLine()
					}
					else
					{
						line.text.length <= cm.options.maxHighlightLength && processLine(cm, line.text, context);
						line.stateAfter = context.line % 5 == 0 ? context.save() : null;
						context.nextLine()
					}
					if (+new Date > end)
					{
						startWorker(cm, cm.options.workDelay);
						return true
					}
				});
				doc.highlightFrontier = context.line;
				doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
				changedLines.length && runInOp(cm, function ()
				{
					for (var i = 0; i < changedLines.length; i++) regLineChange(cm, changedLines[i], "text")
				})
			}
			var DisplayUpdate = function DisplayUpdate(cm, viewport, force)
			{
				var display = cm.display;
				this.viewport = viewport;
				this.visible = visibleLines(display, cm.doc, viewport);
				this.editorIsHidden = !display.wrapper.offsetWidth;
				this.wrapperHeight = display.wrapper.clientHeight;
				this.wrapperWidth = display.wrapper.clientWidth;
				this.oldDisplayWidth = displayWidth(cm);
				this.force = force;
				this.dims = getDimensions(cm);
				this.events = []
			};
			DisplayUpdate.prototype.signal = function (emitter, type)
			{
				hasHandler(emitter, type) && this.events.push(arguments)
			};
			DisplayUpdate.prototype.finish = function ()
			{
				var this$1 = this;
				for (var i = 0; i < this.events.length; i++) signal.apply(null, this$1.events[i])
			};

			function maybeClipScrollbars(cm)
			{
				var display = cm.display;
				if (!display.scrollbarsClipped && display.scroller.offsetWidth)
				{
					display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
					display.heightForcer.style.height = scrollGap(cm) + "px";
					display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
					display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
					display.scrollbarsClipped = true
				}
			}

			function selectionSnapshot(cm)
			{
				if (cm.hasFocus()) return null;
				var active = activeElt();
				if (!active || !contains(cm.display.lineDiv, active)) return null;
				var result = {
					activeElt: active
				};
				if (window.getSelection)
				{
					var sel = window.getSelection();
					if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode))
					{
						result.anchorNode = sel.anchorNode;
						result.anchorOffset = sel.anchorOffset;
						result.focusNode = sel.focusNode;
						result.focusOffset = sel.focusOffset
					}
				}
				return result
			}

			function restoreSelection(snapshot)
			{
				if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) return;
				snapshot.activeElt.focus();
				if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode))
				{
					var sel = window.getSelection(),
						range$$1 = document.createRange();
					range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
					range$$1.collapse(false);
					sel.removeAllRanges();
					sel.addRange(range$$1);
					sel.extend(snapshot.focusNode, snapshot.focusOffset)
				}
			}

			function updateDisplayIfNeeded(cm, update)
			{
				var display = cm.display,
					doc = cm.doc;
				if (update.editorIsHidden)
				{
					resetView(cm);
					return false
				}
				if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && 0 == countDirtyView(cm)) return false;
				if (maybeUpdateLineNumberWidth(cm))
				{
					resetView(cm);
					update.dims = getDimensions(cm)
				}
				var end = doc.first + doc.size;
				var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
				var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
				display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom));
				display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo));
				if (sawCollapsedSpans)
				{
					from = visualLineNo(cm.doc, from);
					to = visualLineEndNo(cm.doc, to)
				}
				var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
				adjustView(cm, from, to);
				display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom));
				cm.display.mover.style.top = display.viewOffset + "px";
				var toUpdate = countDirtyView(cm);
				if (!different && 0 == toUpdate && !update.force && display.renderedView == display.view && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo)) return false;
				var selSnapshot = selectionSnapshot(cm);
				toUpdate > 4 && (display.lineDiv.style.display = "none");
				patchDisplay(cm, display.updateLineNumbers, update.dims);
				toUpdate > 4 && (display.lineDiv.style.display = "");
				display.renderedView = display.view;
				restoreSelection(selSnapshot);
				removeChildren(display.cursorDiv);
				removeChildren(display.selectionDiv);
				display.gutters.style.height = display.sizer.style.minHeight = 0;
				if (different)
				{
					display.lastWrapHeight = update.wrapperHeight;
					display.lastWrapWidth = update.wrapperWidth;
					startWorker(cm, 400)
				}
				display.updateLineNumbers = null;
				return true
			}

			function postUpdateDisplay(cm, update)
			{
				var viewport = update.viewport;
				for (var first = true;; first = false)
				{
					if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm))
					{
						viewport && null != viewport.top && (viewport = {
							top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
						});
						update.visible = visibleLines(cm.display, cm.doc, viewport);
						if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) break
					}
					if (!updateDisplayIfNeeded(cm, update)) break;
					updateHeightsInViewport(cm);
					var barMeasure = measureForScrollbars(cm);
					updateSelection(cm);
					updateScrollbars(cm, barMeasure);
					setDocumentHeight(cm, barMeasure);
					update.force = false
				}
				update.signal(cm, "update", cm);
				if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo)
				{
					update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
					cm.display.reportedViewFrom = cm.display.viewFrom;
					cm.display.reportedViewTo = cm.display.viewTo
				}
			}

			function updateDisplaySimple(cm, viewport)
			{
				var update = new DisplayUpdate(cm, viewport);
				if (updateDisplayIfNeeded(cm, update))
				{
					updateHeightsInViewport(cm);
					postUpdateDisplay(cm, update);
					var barMeasure = measureForScrollbars(cm);
					updateSelection(cm);
					updateScrollbars(cm, barMeasure);
					setDocumentHeight(cm, barMeasure);
					update.finish()
				}
			}

			function patchDisplay(cm, updateNumbersFrom, dims)
			{
				var display = cm.display,
					lineNumbers = cm.options.lineNumbers;
				var container = display.lineDiv,
					cur = container.firstChild;

				function rm(node)
				{
					var next = node.nextSibling;
					webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node);
					return next
				}
				var view = display.view,
					lineN = display.viewFrom;
				for (var i = 0; i < view.length; i++)
				{
					var lineView = view[i];
					if (lineView.hidden);
					else if (lineView.node && lineView.node.parentNode == container)
					{
						while (cur != lineView.node) cur = rm(cur);
						var updateNumber = lineNumbers && null != updateNumbersFrom && updateNumbersFrom <= lineN && lineView.lineNumber;
						if (lineView.changes)
						{
							indexOf(lineView.changes, "gutter") > -1 && (updateNumber = false);
							updateLineForChanges(cm, lineView, lineN, dims)
						}
						if (updateNumber)
						{
							removeChildren(lineView.lineNumber);
							lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))
						}
						cur = lineView.node.nextSibling
					}
					else
					{
						var node = buildLineElement(cm, lineView, lineN, dims);
						container.insertBefore(node, cur)
					}
					lineN += lineView.size
				}
				while (cur) cur = rm(cur)
			}

			function updateGutterSpace(cm)
			{
				var width = cm.display.gutters.offsetWidth;
				cm.display.sizer.style.marginLeft = width + "px"
			}

			function setDocumentHeight(cm, measure)
			{
				cm.display.sizer.style.minHeight = measure.docHeight + "px";
				cm.display.heightForcer.style.top = measure.docHeight + "px";
				cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px"
			}

			function updateGutters(cm)
			{
				var gutters = cm.display.gutters,
					specs = cm.options.gutters;
				removeChildren(gutters);
				var i = 0;
				for (; i < specs.length; ++i)
				{
					var gutterClass = specs[i];
					var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
					if ("CodeMirror-linenumbers" == gutterClass)
					{
						cm.display.lineGutter = gElt;
						gElt.style.width = (cm.display.lineNumWidth || 1) + "px"
					}
				}
				gutters.style.display = i ? "" : "none";
				updateGutterSpace(cm)
			}

			function setGuttersForLineNumbers(options)
			{
				var found = indexOf(options.gutters, "CodeMirror-linenumbers");
				if (-1 == found && options.lineNumbers) options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
				else if (found > -1 && !options.lineNumbers)
				{
					options.gutters = options.gutters.slice(0);
					options.gutters.splice(found, 1)
				}
			}
			var wheelSamples = 0;
			var wheelPixelsPerUnit = null;
			ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);

			function wheelEventDelta(e)
			{
				var dx = e.wheelDeltaX,
					dy = e.wheelDeltaY;
				null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail);
				null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta);
				return {
					x: dx,
					y: dy
				}
			}

			function wheelEventPixels(e)
			{
				var delta = wheelEventDelta(e);
				delta.x *= wheelPixelsPerUnit;
				delta.y *= wheelPixelsPerUnit;
				return delta
			}

			function onScrollWheel(cm, e)
			{
				var delta = wheelEventDelta(e),
					dx = delta.x,
					dy = delta.y;
				var display = cm.display,
					scroll = display.scroller;
				var canScrollX = scroll.scrollWidth > scroll.clientWidth;
				var canScrollY = scroll.scrollHeight > scroll.clientHeight;
				if (!(dx && canScrollX || dy && canScrollY)) return;
				if (dy && mac && webkit) outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode)
					for (var i = 0; i < view.length; i++)
						if (view[i].node == cur)
						{
							cm.display.currentWheelTarget = cur;
							break outer
						}
				if (dx && !gecko && !presto && null != wheelPixelsPerUnit)
				{
					dy && canScrollY && updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
					setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
					(!dy || dy && canScrollY) && e_preventDefault(e);
					display.wheelStartX = null;
					return
				}
				if (dy && null != wheelPixelsPerUnit)
				{
					var pixels = dy * wheelPixelsPerUnit;
					var top = cm.doc.scrollTop,
						bot = top + display.wrapper.clientHeight;
					pixels < 0 ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50);
					updateDisplaySimple(cm,
					{
						top: top,
						bottom: bot
					})
				}
				if (wheelSamples < 20)
					if (null == display.wheelStartX)
					{
						display.wheelStartX = scroll.scrollLeft;
						display.wheelStartY = scroll.scrollTop;
						display.wheelDX = dx;
						display.wheelDY = dy;
						setTimeout(function ()
						{
							if (null == display.wheelStartX) return;
							var movedX = scroll.scrollLeft - display.wheelStartX;
							var movedY = scroll.scrollTop - display.wheelStartY;
							var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
							display.wheelStartX = display.wheelStartY = null;
							if (!sample) return;
							wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
							++wheelSamples
						}, 200)
					}
				else
				{
					display.wheelDX += dx;
					display.wheelDY += dy
				}
			}
			var Selection = function Selection(ranges, primIndex)
			{
				this.ranges = ranges;
				this.primIndex = primIndex
			};
			Selection.prototype.primary = function ()
			{
				return this.ranges[this.primIndex]
			};
			Selection.prototype.equals = function (other)
			{
				var this$1 = this;
				if (other == this) return true;
				if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
				for (var i = 0; i < this.ranges.length; i++)
				{
					var here = this$1.ranges[i],
						there = other.ranges[i];
					if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) return false
				}
				return true
			};
			Selection.prototype.deepCopy = function ()
			{
				var this$1 = this;
				var out = [];
				for (var i = 0; i < this.ranges.length; i++) out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
				return new Selection(out, this.primIndex)
			};
			Selection.prototype.somethingSelected = function ()
			{
				var this$1 = this;
				for (var i = 0; i < this.ranges.length; i++)
					if (!this$1.ranges[i].empty()) return true;
				return false
			};
			Selection.prototype.contains = function (pos, end)
			{
				var this$1 = this;
				end || (end = pos);
				for (var i = 0; i < this.ranges.length; i++)
				{
					var range = this$1.ranges[i];
					if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) return i
				}
				return -1
			};
			var Range = function Range(anchor, head)
			{
				this.anchor = anchor;
				this.head = head
			};
			Range.prototype.from = function ()
			{
				return minPos(this.anchor, this.head)
			};
			Range.prototype.to = function ()
			{
				return maxPos(this.anchor, this.head)
			};
			Range.prototype.empty = function ()
			{
				return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
			};

			function normalizeSelection(ranges, primIndex)
			{
				var prim = ranges[primIndex];
				ranges.sort(function (a, b)
				{
					return cmp(a.from(), b.from())
				});
				primIndex = indexOf(ranges, prim);
				for (var i = 1; i < ranges.length; i++)
				{
					var cur = ranges[i],
						prev = ranges[i - 1];
					if (cmp(prev.to(), cur.from()) >= 0)
					{
						var from = minPos(prev.from(), cur.from()),
							to = maxPos(prev.to(), cur.to());
						var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
						i <= primIndex && --primIndex;
						ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))
					}
				}
				return new Selection(ranges, primIndex)
			}

			function simpleSelection(anchor, head)
			{
				return new Selection([new Range(anchor, head || anchor)], 0)
			}

			function changeEnd(change)
			{
				if (!change.text) return change.to;
				return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0))
			}

			function adjustForChange(pos, change)
			{
				if (cmp(pos, change.from) < 0) return pos;
				if (cmp(pos, change.to) <= 0) return changeEnd(change);
				var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
					ch = pos.ch;
				pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch);
				return Pos(line, ch)
			}

			function computeSelAfterChange(doc, change)
			{
				var out = [];
				for (var i = 0; i < doc.sel.ranges.length; i++)
				{
					var range = doc.sel.ranges[i];
					out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)))
				}
				return normalizeSelection(out, doc.sel.primIndex)
			}

			function offsetPos(pos, old, nw)
			{
				return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch)
			}

			function computeReplacedSel(doc, changes, hint)
			{
				var out = [];
				var oldPrev = Pos(doc.first, 0),
					newPrev = oldPrev;
				for (var i = 0; i < changes.length; i++)
				{
					var change = changes[i];
					var from = offsetPos(change.from, oldPrev, newPrev);
					var to = offsetPos(changeEnd(change), oldPrev, newPrev);
					oldPrev = change.to;
					newPrev = to;
					if ("around" == hint)
					{
						var range = doc.sel.ranges[i],
							inv = cmp(range.head, range.anchor) < 0;
						out[i] = new Range(inv ? to : from, inv ? from : to)
					}
					else out[i] = new Range(from, from)
				}
				return new Selection(out, doc.sel.primIndex)
			}

			function loadMode(cm)
			{
				cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
				resetModeState(cm)
			}

			function resetModeState(cm)
			{
				cm.doc.iter(function (line)
				{
					line.stateAfter && (line.stateAfter = null);
					line.styles && (line.styles = null)
				});
				cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
				startWorker(cm, 100);
				cm.state.modeGen++;
				cm.curOp && regChange(cm)
			}

			function isWholeLineUpdate(doc, change)
			{
				return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
			}

			function updateDoc(doc, change, markedSpans, estimateHeight$$1)
			{
				function spansFor(n)
				{
					return markedSpans ? markedSpans[n] : null
				}

				function update(line, text, spans)
				{
					updateLine(line, text, spans, estimateHeight$$1);
					signalLater(line, "change", line, change)
				}

				function linesFor(start, end)
				{
					var result = [];
					for (var i = start; i < end; ++i) result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
					return result
				}
				var from = change.from,
					to = change.to,
					text = change.text;
				var firstLine = getLine(doc, from.line),
					lastLine = getLine(doc, to.line);
				var lastText = lst(text),
					lastSpans = spansFor(text.length - 1),
					nlines = to.line - from.line;
				if (change.full)
				{
					doc.insert(0, linesFor(0, text.length));
					doc.remove(text.length, doc.size - text.length)
				}
				else if (isWholeLineUpdate(doc, change))
				{
					var added = linesFor(0, text.length - 1);
					update(lastLine, lastLine.text, lastSpans);
					nlines && doc.remove(from.line, nlines);
					added.length && doc.insert(from.line, added)
				}
				else if (firstLine == lastLine)
					if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
					else
					{
						var added$1 = linesFor(1, text.length - 1);
						added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
						update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
						doc.insert(from.line + 1, added$1)
					}
				else if (1 == text.length)
				{
					update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
					doc.remove(from.line + 1, nlines)
				}
				else
				{
					update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
					update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
					var added$2 = linesFor(1, text.length - 1);
					nlines > 1 && doc.remove(from.line + 1, nlines - 1);
					doc.insert(from.line + 1, added$2)
				}
				signalLater(doc, "change", doc, change)
			}

			function linkedDocs(doc, f, sharedHistOnly)
			{
				function propagate(doc, skip, sharedHist)
				{
					if (doc.linked)
						for (var i = 0; i < doc.linked.length; ++i)
						{
							var rel = doc.linked[i];
							if (rel.doc == skip) continue;
							var shared = sharedHist && rel.sharedHist;
							if (sharedHistOnly && !shared) continue;
							f(rel.doc, shared);
							propagate(rel.doc, doc, shared)
						}
				}
				propagate(doc, null, true)
			}

			function attachDoc(cm, doc)
			{
				if (doc.cm) throw new Error("This document is already in use.");
				cm.doc = doc;
				doc.cm = cm;
				estimateLineHeights(cm);
				loadMode(cm);
				setDirectionClass(cm);
				cm.options.lineWrapping || findMaxLine(cm);
				cm.options.mode = doc.modeOption;
				regChange(cm)
			}

			function setDirectionClass(cm)
			{
				("rtl" == cm.doc.direction ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl")
			}

			function directionChanged(cm)
			{
				runInOp(cm, function ()
				{
					setDirectionClass(cm);
					regChange(cm)
				})
			}

			function History(startGen)
			{
				this.done = [];
				this.undone = [];
				this.undoDepth = Infinity;
				this.lastModTime = this.lastSelTime = 0;
				this.lastOp = this.lastSelOp = null;
				this.lastOrigin = this.lastSelOrigin = null;
				this.generation = this.maxGeneration = startGen || 1
			}

			function historyChangeFromChange(doc, change)
			{
				var histChange = {
					from: copyPos(change.from),
					to: changeEnd(change),
					text: getBetween(doc, change.from, change.to)
				};
				attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
				linkedDocs(doc, function (doc)
				{
					return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
				}, true);
				return histChange
			}

			function clearSelectionEvents(array)
			{
				while (array.length)
				{
					var last = lst(array);
					if (!last.ranges) break;
					array.pop()
				}
			}

			function lastChangeEvent(hist, force)
			{
				if (force)
				{
					clearSelectionEvents(hist.done);
					return lst(hist.done)
				}
				if (hist.done.length && !lst(hist.done).ranges) return lst(hist.done);
				if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges)
				{
					hist.done.pop();
					return lst(hist.done)
				}
			}

			function addChangeToHistory(doc, change, selAfter, opId)
			{
				var hist = doc.history;
				hist.undone.length = 0;
				var cur, time = +new Date;
				var last;
				if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || "*" == change.origin.charAt(0))) && (cur = lastChangeEvent(hist, hist.lastOp == opId)))
				{
					last = lst(cur.changes);
					0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? last.to = changeEnd(change) : cur.changes.push(historyChangeFromChange(doc, change))
				}
				else
				{
					var before = lst(hist.done);
					before && before.ranges || pushSelectionToHistory(doc.sel, hist.done);
					cur = {
						changes: [historyChangeFromChange(doc, change)],
						generation: hist.generation
					};
					hist.done.push(cur);
					while (hist.done.length > hist.undoDepth)
					{
						hist.done.shift();
						hist.done[0].ranges || hist.done.shift()
					}
				}
				hist.done.push(selAfter);
				hist.generation = ++hist.maxGeneration;
				hist.lastModTime = hist.lastSelTime = time;
				hist.lastOp = hist.lastSelOp = opId;
				hist.lastOrigin = hist.lastSelOrigin = change.origin;
				last || signal(doc, "historyAdded")
			}

			function selectionEventCanBeMerged(doc, origin, prev, sel)
			{
				var ch = origin.charAt(0);
				return "*" == ch || "+" == ch && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
			}

			function addSelectionToHistory(doc, sel, opId, options)
			{
				var hist = doc.history,
					origin = options && options.origin;
				opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done);
				hist.lastSelTime = +new Date;
				hist.lastSelOrigin = origin;
				hist.lastSelOp = opId;
				options && false !== options.clearRedo && clearSelectionEvents(hist.undone)
			}

			function pushSelectionToHistory(sel, dest)
			{
				var top = lst(dest);
				top && top.ranges && top.equals(sel) || dest.push(sel)
			}

			function attachLocalSpans(doc, change, from, to)
			{
				var existing = change["spans_" + doc.id],
					n = 0;
				doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line)
				{
					line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans);
					++n
				})
			}

			function removeClearedSpans(spans)
			{
				if (!spans) return null;
				var out;
				for (var i = 0; i < spans.length; ++i) spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
				return out ? out.length ? out : null : spans
			}

			function getOldSpans(doc, change)
			{
				var found = change["spans_" + doc.id];
				if (!found) return null;
				var nw = [];
				for (var i = 0; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
				return nw
			}

			function mergeOldSpans(doc, change)
			{
				var old = getOldSpans(doc, change);
				var stretched = stretchSpansOverChange(doc, change);
				if (!old) return stretched;
				if (!stretched) return old;
				for (var i = 0; i < old.length; ++i)
				{
					var oldCur = old[i],
						stretchCur = stretched[i];
					if (oldCur && stretchCur) spans: for (var j = 0; j < stretchCur.length; ++j)
					{
						var span = stretchCur[j];
						for (var k = 0; k < oldCur.length; ++k)
							if (oldCur[k].marker == span.marker) continue spans;
						oldCur.push(span)
					}
					else stretchCur && (old[i] = stretchCur)
				}
				return old
			}

			function copyHistoryArray(events, newGroup, instantiateSel)
			{
				var copy = [];
				for (var i = 0; i < events.length; ++i)
				{
					var event = events[i];
					if (event.ranges)
					{
						copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
						continue
					}
					var changes = event.changes,
						newChanges = [];
					copy.push(
					{
						changes: newChanges
					});
					for (var j = 0; j < changes.length; ++j)
					{
						var change = changes[j],
							m = void 0;
						newChanges.push(
						{
							from: change.from,
							to: change.to,
							text: change.text
						});
						if (newGroup)
							for (var prop in change)
								if ((m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1)
								{
									lst(newChanges)[prop] = change[prop];
									delete change[prop]
								}
					}
				}
				return copy
			}

			function extendRange(range, head, other, extend)
			{
				if (extend)
				{
					var anchor = range.anchor;
					if (other)
					{
						var posBefore = cmp(head, anchor) < 0;
						if (posBefore != cmp(other, anchor) < 0)
						{
							anchor = head;
							head = other
						}
						else posBefore != cmp(head, other) < 0 && (head = other)
					}
					return new Range(anchor, head)
				}
				return new Range(other || head, head)
			}

			function extendSelection(doc, head, other, options, extend)
			{
				null == extend && (extend = doc.cm && (doc.cm.display.shift || doc.extend));
				setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options)
			}

			function extendSelections(doc, heads, options)
			{
				var out = [];
				var extend = doc.cm && (doc.cm.display.shift || doc.extend);
				for (var i = 0; i < doc.sel.ranges.length; i++) out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
				var newSel = normalizeSelection(out, doc.sel.primIndex);
				setSelection(doc, newSel, options)
			}

			function replaceOneSelection(doc, i, range, options)
			{
				var ranges = doc.sel.ranges.slice(0);
				ranges[i] = range;
				setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
			}

			function setSimpleSelection(doc, anchor, head, options)
			{
				setSelection(doc, simpleSelection(anchor, head), options)
			}

			function filterSelectionChange(doc, sel, options)
			{
				var obj = {
					ranges: sel.ranges,
					update: function update(ranges)
					{
						var this$1 = this;
						this.ranges = [];
						for (var i = 0; i < ranges.length; i++) this$1.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head))
					},
					origin: options && options.origin
				};
				signal(doc, "beforeSelectionChange", doc, obj);
				doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
				return obj.ranges != sel.ranges ? normalizeSelection(obj.ranges, obj.ranges.length - 1) : sel
			}

			function setSelectionReplaceHistory(doc, sel, options)
			{
				var done = doc.history.done,
					last = lst(done);
				if (last && last.ranges)
				{
					done[done.length - 1] = sel;
					setSelectionNoUndo(doc, sel, options)
				}
				else setSelection(doc, sel, options)
			}

			function setSelection(doc, sel, options)
			{
				setSelectionNoUndo(doc, sel, options);
				addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
			}

			function setSelectionNoUndo(doc, sel, options)
			{
				(hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = filterSelectionChange(doc, sel, options));
				var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
				setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
				options && false === options.scroll || !doc.cm || ensureCursorVisible(doc.cm)
			}

			function setSelectionInner(doc, sel)
			{
				if (sel.equals(doc.sel)) return;
				doc.sel = sel;
				if (doc.cm)
				{
					doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
					signalCursorActivity(doc.cm)
				}
				signalLater(doc, "cursorActivity", doc)
			}

			function reCheckSelection(doc)
			{
				setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false))
			}

			function skipAtomicInSelection(doc, sel, bias, mayClear)
			{
				var out;
				for (var i = 0; i < sel.ranges.length; i++)
				{
					var range = sel.ranges[i];
					var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
					var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
					var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
					if (out || newAnchor != range.anchor || newHead != range.head)
					{
						out || (out = sel.ranges.slice(0, i));
						out[i] = new Range(newAnchor, newHead)
					}
				}
				return out ? normalizeSelection(out, sel.primIndex) : sel
			}

			function skipAtomicInner(doc, pos, oldPos, dir, mayClear)
			{
				var line = getLine(doc, pos.line);
				if (line.markedSpans)
					for (var i = 0; i < line.markedSpans.length; ++i)
					{
						var sp = line.markedSpans[i],
							m = sp.marker;
						if ((null == sp.from || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch)))
						{
							if (mayClear)
							{
								signal(m, "beforeCursorEnter");
								if (m.explicitlyCleared)
								{
									if (line.markedSpans)
									{
										--i;
										continue
									}
									break
								}
							}
							if (!m.atomic) continue;
							if (oldPos)
							{
								var near = m.find(dir < 0 ? 1 : -1),
									diff = void 0;
								(dir < 0 ? m.inclusiveRight : m.inclusiveLeft) && (near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null));
								if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) return skipAtomicInner(doc, near, pos, dir, mayClear)
							}
							var far = m.find(dir < 0 ? -1 : 1);
							(dir < 0 ? m.inclusiveLeft : m.inclusiveRight) && (far = movePos(doc, far, dir, far.line == pos.line ? line : null));
							return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
						}
					}
				return pos
			}

			function skipAtomic(doc, pos, oldPos, bias, mayClear)
			{
				var dir = bias || 1;
				var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
				if (!found)
				{
					doc.cantEdit = true;
					return Pos(doc.first, 0)
				}
				return found
			}

			function movePos(doc, pos, dir, line)
			{
				return dir < 0 && 0 == pos.ch ? pos.line > doc.first ? _clipPos(doc, Pos(pos.line - 1)) : null : dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length ? pos.line < doc.first + doc.size - 1 ? Pos(pos.line + 1, 0) : null : new Pos(pos.line, pos.ch + dir)
			}

			function selectAll(cm)
			{
				cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
			}

			function filterChange(doc, change, update)
			{
				var obj = {
					canceled: false,
					from: change.from,
					to: change.to,
					text: change.text,
					origin: change.origin,
					cancel: function cancel()
					{
						return obj.canceled = true
					}
				};
				update && (obj.update = function (from, to, text, origin)
				{
					from && (obj.from = _clipPos(doc, from));
					to && (obj.to = _clipPos(doc, to));
					text && (obj.text = text);
					void 0 !== origin && (obj.origin = origin)
				});
				signal(doc, "beforeChange", doc, obj);
				doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj);
				if (obj.canceled) return null;
				return {
					from: obj.from,
					to: obj.to,
					text: obj.text,
					origin: obj.origin
				}
			}

			function makeChange(doc, change, ignoreReadOnly)
			{
				if (doc.cm)
				{
					if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
					if (doc.cm.state.suppressEdits) return
				}
				if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"))
				{
					change = filterChange(doc, change, true);
					if (!change) return
				}
				var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
				if (split)
					for (var i = split.length - 1; i >= 0; --i) makeChangeInner(doc,
					{
						from: split[i].from,
						to: split[i].to,
						text: i ? [""] : change.text,
						origin: change.origin
					});
				else makeChangeInner(doc, change)
			}

			function makeChangeInner(doc, change)
			{
				if (1 == change.text.length && "" == change.text[0] && 0 == cmp(change.from, change.to)) return;
				var selAfter = computeSelAfterChange(doc, change);
				addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
				makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
				var rebased = [];
				linkedDocs(doc, function (doc, sharedHist)
				{
					if (!sharedHist && -1 == indexOf(rebased, doc.history))
					{
						rebaseHist(doc.history, change);
						rebased.push(doc.history)
					}
					makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
				})
			}

			function makeChangeFromHistory(doc, type, allowSelectionOnly)
			{
				var suppress = doc.cm && doc.cm.state.suppressEdits;
				if (suppress && !allowSelectionOnly) return;
				var event, hist = doc.history,
					selAfter = doc.sel;
				var source = "undo" == type ? hist.done : hist.undone,
					dest = "undo" == type ? hist.undone : hist.done;
				var i = 0;
				for (; i < source.length; i++)
				{
					event = source[i];
					if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) break
				}
				if (i == source.length) return;
				hist.lastOrigin = hist.lastSelOrigin = null;
				for (;;)
				{
					event = source.pop();
					if (!event.ranges)
					{
						if (suppress)
						{
							source.push(event);
							return
						}
						break
					}
					pushSelectionToHistory(event, dest);
					if (allowSelectionOnly && !event.equals(doc.sel))
					{
						setSelection(doc, event,
						{
							clearRedo: false
						});
						return
					}
					selAfter = event
				}
				var antiChanges = [];
				pushSelectionToHistory(selAfter, dest);
				dest.push(
				{
					changes: antiChanges,
					generation: hist.generation
				});
				hist.generation = event.generation || ++hist.maxGeneration;
				var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
				var loop = function loop(i)
				{
					var change = event.changes[i];
					change.origin = type;
					if (filter && !filterChange(doc, change, false))
					{
						source.length = 0;
						return {}
					}
					antiChanges.push(historyChangeFromChange(doc, change));
					var after = i ? computeSelAfterChange(doc, change) : lst(source);
					makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
					!i && doc.cm && doc.cm.scrollIntoView(
					{
						from: change.from,
						to: changeEnd(change)
					});
					var rebased = [];
					linkedDocs(doc, function (doc, sharedHist)
					{
						if (!sharedHist && -1 == indexOf(rebased, doc.history))
						{
							rebaseHist(doc.history, change);
							rebased.push(doc.history)
						}
						makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
					})
				};
				for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1)
				{
					var returned = loop(i$1);
					if (returned) return returned.v
				}
			}

			function shiftDoc(doc, distance)
			{
				if (0 == distance) return;
				doc.first += distance;
				doc.sel = new Selection(map(doc.sel.ranges, function (range)
				{
					return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch))
				}), doc.sel.primIndex);
				if (doc.cm)
				{
					regChange(doc.cm, doc.first, doc.first - distance, distance);
					for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) regLineChange(doc.cm, l, "gutter")
				}
			}

			function makeChangeSingleDoc(doc, change, selAfter, spans)
			{
				if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
				if (change.to.line < doc.first)
				{
					shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
					return
				}
				if (change.from.line > doc.lastLine()) return;
				if (change.from.line < doc.first)
				{
					var shift = change.text.length - 1 - (doc.first - change.from.line);
					shiftDoc(doc, shift);
					change = {
						from: Pos(doc.first, 0),
						to: Pos(change.to.line + shift, change.to.ch),
						text: [lst(change.text)],
						origin: change.origin
					}
				}
				var last = doc.lastLine();
				change.to.line > last && (change = {
					from: change.from,
					to: Pos(last, getLine(doc, last).text.length),
					text: [change.text[0]],
					origin: change.origin
				});
				change.removed = getBetween(doc, change.from, change.to);
				selAfter || (selAfter = computeSelAfterChange(doc, change));
				doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans) : updateDoc(doc, change, spans);
				setSelectionNoUndo(doc, selAfter, sel_dontScroll)
			}

			function makeChangeSingleDocInEditor(cm, change, spans)
			{
				var doc = cm.doc,
					display = cm.display,
					from = change.from,
					to = change.to;
				var recomputeMaxLength = false,
					checkWidthStart = from.line;
				if (!cm.options.lineWrapping)
				{
					checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
					doc.iter(checkWidthStart, to.line + 1, function (line)
					{
						if (line == display.maxLine)
						{
							recomputeMaxLength = true;
							return true
						}
					})
				}
				doc.sel.contains(change.from, change.to) > -1 && signalCursorActivity(cm);
				updateDoc(doc, change, spans, estimateHeight(cm));
				if (!cm.options.lineWrapping)
				{
					doc.iter(checkWidthStart, from.line + change.text.length, function (line)
					{
						var len = lineLength(line);
						if (len > display.maxLineLength)
						{
							display.maxLine = line;
							display.maxLineLength = len;
							display.maxLineChanged = true;
							recomputeMaxLength = false
						}
					});
					recomputeMaxLength && (cm.curOp.updateMaxLine = true)
				}
				retreatFrontier(doc, from.line);
				startWorker(cm, 400);
				var lendiff = change.text.length - (to.line - from.line) - 1;
				change.full ? regChange(cm) : from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, lendiff) : regLineChange(cm, from.line, "text");
				var changesHandler = hasHandler(cm, "changes"),
					changeHandler = hasHandler(cm, "change");
				if (changeHandler || changesHandler)
				{
					var obj = {
						from: from,
						to: to,
						text: change.text,
						removed: change.removed,
						origin: change.origin
					};
					changeHandler && signalLater(cm, "change", cm, obj);
					changesHandler && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj)
				}
				cm.display.selForContextMenu = null
			}

			function _replaceRange(doc, code, from, to, origin)
			{
				to || (to = from);
				if (cmp(to, from) < 0)
				{
					var assign;
					assign = [to, from], from = assign[0], to = assign[1]
				}
				"string" == typeof code && (code = doc.splitLines(code));
				makeChange(doc,
				{
					from: from,
					to: to,
					text: code,
					origin: origin
				})
			}

			function rebaseHistSelSingle(pos, from, to, diff)
			{
				if (to < pos.line) pos.line += diff;
				else if (from < pos.line)
				{
					pos.line = from;
					pos.ch = 0
				}
			}

			function rebaseHistArray(array, from, to, diff)
			{
				for (var i = 0; i < array.length; ++i)
				{
					var sub = array[i],
						ok = true;
					if (sub.ranges)
					{
						if (!sub.copied)
						{
							sub = array[i] = sub.deepCopy();
							sub.copied = true
						}
						for (var j = 0; j < sub.ranges.length; j++)
						{
							rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
							rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
						}
						continue
					}
					for (var j$1 = 0; j$1 < sub.changes.length; ++j$1)
					{
						var cur = sub.changes[j$1];
						if (to < cur.from.line)
						{
							cur.from = Pos(cur.from.line + diff, cur.from.ch);
							cur.to = Pos(cur.to.line + diff, cur.to.ch)
						}
						else if (from <= cur.to.line)
						{
							ok = false;
							break
						}
					}
					if (!ok)
					{
						array.splice(0, i + 1);
						i = 0
					}
				}
			}

			function rebaseHist(hist, change)
			{
				var from = change.from.line,
					to = change.to.line,
					diff = change.text.length - (to - from) - 1;
				rebaseHistArray(hist.done, from, to, diff);
				rebaseHistArray(hist.undone, from, to, diff)
			}

			function changeLine(doc, handle, changeType, op)
			{
				var no = handle,
					line = handle;
				"number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle);
				if (null == no) return null;
				op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType);
				return line
			}

			function LeafChunk(lines)
			{
				var this$1 = this;
				this.lines = lines;
				this.parent = null;
				var height = 0;
				for (var i = 0; i < lines.length; ++i)
				{
					lines[i].parent = this$1;
					height += lines[i].height
				}
				this.height = height
			}
			LeafChunk.prototype = {
				chunkSize: function chunkSize()
				{
					return this.lines.length
				},
				removeInner: function removeInner(at, n)
				{
					var this$1 = this;
					for (var i = at, e = at + n; i < e; ++i)
					{
						var line = this$1.lines[i];
						this$1.height -= line.height;
						cleanUpLine(line);
						signalLater(line, "delete")
					}
					this.lines.splice(at, n)
				},
				collapse: function collapse(lines)
				{
					lines.push.apply(lines, this.lines)
				},
				insertInner: function insertInner(at, lines, height)
				{
					var this$1 = this;
					this.height += height;
					this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
					for (var i = 0; i < lines.length; ++i) lines[i].parent = this$1
				},
				iterN: function iterN(at, n, op)
				{
					var this$1 = this;
					for (var e = at + n; at < e; ++at)
						if (op(this$1.lines[at])) return true
				}
			};

			function BranchChunk(children)
			{
				var this$1 = this;
				this.children = children;
				var size = 0,
					height = 0;
				for (var i = 0; i < children.length; ++i)
				{
					var ch = children[i];
					size += ch.chunkSize();
					height += ch.height;
					ch.parent = this$1
				}
				this.size = size;
				this.height = height;
				this.parent = null
			}
			BranchChunk.prototype = {
				chunkSize: function chunkSize()
				{
					return this.size
				},
				removeInner: function removeInner(at, n)
				{
					var this$1 = this;
					this.size -= n;
					for (var i = 0; i < this.children.length; ++i)
					{
						var child = this$1.children[i],
							sz = child.chunkSize();
						if (at < sz)
						{
							var rm = Math.min(n, sz - at),
								oldHeight = child.height;
							child.removeInner(at, rm);
							this$1.height -= oldHeight - child.height;
							if (sz == rm)
							{
								this$1.children.splice(i--, 1);
								child.parent = null
							}
							if (0 == (n -= rm)) break;
							at = 0
						}
						else at -= sz
					}
					if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk)))
					{
						var lines = [];
						this.collapse(lines);
						this.children = [new LeafChunk(lines)];
						this.children[0].parent = this
					}
				},
				collapse: function collapse(lines)
				{
					var this$1 = this;
					for (var i = 0; i < this.children.length; ++i) this$1.children[i].collapse(lines)
				},
				insertInner: function insertInner(at, lines, height)
				{
					var this$1 = this;
					this.size += lines.length;
					this.height += height;
					for (var i = 0; i < this.children.length; ++i)
					{
						var child = this$1.children[i],
							sz = child.chunkSize();
						if (at <= sz)
						{
							child.insertInner(at, lines, height);
							if (child.lines && child.lines.length > 50)
							{
								var remaining = child.lines.length % 25 + 25;
								for (var pos = remaining; pos < child.lines.length;)
								{
									var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
									child.height -= leaf.height;
									this$1.children.splice(++i, 0, leaf);
									leaf.parent = this$1
								}
								child.lines = child.lines.slice(0, remaining);
								this$1.maybeSpill()
							}
							break
						}
						at -= sz
					}
				},
				maybeSpill: function maybeSpill()
				{
					if (this.children.length <= 10) return;
					var me = this;
					do {
						var spilled = me.children.splice(me.children.length - 5, 5);
						var sibling = new BranchChunk(spilled);
						if (me.parent)
						{
							me.size -= sibling.size;
							me.height -= sibling.height;
							var myIndex = indexOf(me.parent.children, me);
							me.parent.children.splice(myIndex + 1, 0, sibling)
						}
						else
						{
							var copy = new BranchChunk(me.children);
							copy.parent = me;
							me.children = [copy, sibling];
							me = copy
						}
						sibling.parent = me.parent
					} while (me.children.length > 10);
					me.parent.maybeSpill()
				},
				iterN: function iterN(at, n, op)
				{
					var this$1 = this;
					for (var i = 0; i < this.children.length; ++i)
					{
						var child = this$1.children[i],
							sz = child.chunkSize();
						if (at < sz)
						{
							var used = Math.min(n, sz - at);
							if (child.iterN(at, used, op)) return true;
							if (0 == (n -= used)) break;
							at = 0
						}
						else at -= sz
					}
				}
			};
			var LineWidget = function LineWidget(doc, node, options)
			{
				var this$1 = this;
				if (options)
					for (var opt in options) options.hasOwnProperty(opt) && (this$1[opt] = options[opt]);
				this.doc = doc;
				this.node = node
			};
			LineWidget.prototype.clear = function ()
			{
				var this$1 = this;
				var cm = this.doc.cm,
					ws = this.line.widgets,
					line = this.line,
					no = lineNo(line);
				if (null == no || !ws) return;
				for (var i = 0; i < ws.length; ++i) ws[i] == this$1 && ws.splice(i--, 1);
				ws.length || (line.widgets = null);
				var height = widgetHeight(this);
				updateLineHeight(line, Math.max(0, line.height - height));
				if (cm)
				{
					runInOp(cm, function ()
					{
						adjustScrollWhenAboveVisible(cm, line, -height);
						regLineChange(cm, no, "widget")
					});
					signalLater(cm, "lineWidgetCleared", cm, this, no)
				}
			};
			LineWidget.prototype.changed = function ()
			{
				var this$1 = this;
				var oldH = this.height,
					cm = this.doc.cm,
					line = this.line;
				this.height = null;
				var diff = widgetHeight(this) - oldH;
				if (!diff) return;
				updateLineHeight(line, line.height + diff);
				cm && runInOp(cm, function ()
				{
					cm.curOp.forceUpdate = true;
					adjustScrollWhenAboveVisible(cm, line, diff);
					signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line))
				})
			};
			eventMixin(LineWidget);

			function adjustScrollWhenAboveVisible(cm, line, diff)
			{
				_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollTop(cm, diff)
			}

			function addLineWidget(doc, handle, node, options)
			{
				var widget = new LineWidget(doc, node, options);
				var cm = doc.cm;
				cm && widget.noHScroll && (cm.display.alignWidgets = true);
				changeLine(doc, handle, "widget", function (line)
				{
					var widgets = line.widgets || (line.widgets = []);
					null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
					widget.line = line;
					if (cm && !lineIsHidden(doc, line))
					{
						var aboveVisible = _heightAtLine(line) < doc.scrollTop;
						updateLineHeight(line, line.height + widgetHeight(widget));
						aboveVisible && addToScrollTop(cm, widget.height);
						cm.curOp.forceUpdate = true
					}
					return true
				});
				cm && signalLater(cm, "lineWidgetAdded", cm, widget, "number" == typeof handle ? handle : lineNo(handle));
				return widget
			}
			var nextMarkerId = 0;
			var TextMarker = function TextMarker(doc, type)
			{
				this.lines = [];
				this.type = type;
				this.doc = doc;
				this.id = ++nextMarkerId
			};
			TextMarker.prototype.clear = function ()
			{
				var this$1 = this;
				if (this.explicitlyCleared) return;
				var cm = this.doc.cm,
					withOp = cm && !cm.curOp;
				withOp && _startOperation(cm);
				if (hasHandler(this, "clear"))
				{
					var found = this.find();
					found && signalLater(this, "clear", found.from, found.to)
				}
				var min = null,
					max = null;
				for (var i = 0; i < this.lines.length; ++i)
				{
					var line = this$1.lines[i];
					var span = getMarkedSpanFor(line.markedSpans, this$1);
					if (cm && !this$1.collapsed) regLineChange(cm, lineNo(line), "text");
					else if (cm)
					{
						null != span.to && (max = lineNo(line));
						null != span.from && (min = lineNo(line))
					}
					line.markedSpans = removeMarkedSpan(line.markedSpans, span);
					null == span.from && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm && updateLineHeight(line, textHeight(cm.display))
				}
				if (cm && this.collapsed && !cm.options.lineWrapping)
					for (var i$1 = 0; i$1 < this.lines.length; ++i$1)
					{
						var visual = visualLine(this$1.lines[i$1]),
							len = lineLength(visual);
						if (len > cm.display.maxLineLength)
						{
							cm.display.maxLine = visual;
							cm.display.maxLineLength = len;
							cm.display.maxLineChanged = true
						}
					}
				null != min && cm && this.collapsed && regChange(cm, min, max + 1);
				this.lines.length = 0;
				this.explicitlyCleared = true;
				if (this.atomic && this.doc.cantEdit)
				{
					this.doc.cantEdit = false;
					cm && reCheckSelection(cm.doc)
				}
				cm && signalLater(cm, "markerCleared", cm, this, min, max);
				withOp && _endOperation(cm);
				this.parent && this.parent.clear()
			};
			TextMarker.prototype.find = function (side, lineObj)
			{
				var this$1 = this;
				null == side && "bookmark" == this.type && (side = 1);
				var from, to;
				for (var i = 0; i < this.lines.length; ++i)
				{
					var line = this$1.lines[i];
					var span = getMarkedSpanFor(line.markedSpans, this$1);
					if (null != span.from)
					{
						from = Pos(lineObj ? line : lineNo(line), span.from);
						if (-1 == side) return from
					}
					if (null != span.to)
					{
						to = Pos(lineObj ? line : lineNo(line), span.to);
						if (1 == side) return to
					}
				}
				return from &&
				{
					from: from,
					to: to
				}
			};
			TextMarker.prototype.changed = function ()
			{
				var this$1 = this;
				var pos = this.find(-1, true),
					widget = this,
					cm = this.doc.cm;
				if (!pos || !cm) return;
				runInOp(cm, function ()
				{
					var line = pos.line,
						lineN = lineNo(pos.line);
					var view = findViewForLine(cm, lineN);
					if (view)
					{
						clearLineMeasurementCacheFor(view);
						cm.curOp.selectionChanged = cm.curOp.forceUpdate = true
					}
					cm.curOp.updateMaxLine = true;
					if (!lineIsHidden(widget.doc, line) && null != widget.height)
					{
						var oldHeight = widget.height;
						widget.height = null;
						var dHeight = widgetHeight(widget) - oldHeight;
						dHeight && updateLineHeight(line, line.height + dHeight)
					}
					signalLater(cm, "markerChanged", cm, this$1)
				})
			};
			TextMarker.prototype.attachLine = function (line)
			{
				if (!this.lines.length && this.doc.cm)
				{
					var op = this.doc.cm.curOp;
					op.maybeHiddenMarkers && -1 != indexOf(op.maybeHiddenMarkers, this) || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this)
				}
				this.lines.push(line)
			};
			TextMarker.prototype.detachLine = function (line)
			{
				this.lines.splice(indexOf(this.lines, line), 1);
				if (!this.lines.length && this.doc.cm)
				{
					var op = this.doc.cm.curOp;
					(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
				}
			};
			eventMixin(TextMarker);

			function _markText(doc, from, to, options, type)
			{
				if (options && options.shared) return markTextShared(doc, from, to, options, type);
				if (doc.cm && !doc.cm.curOp) return operation(doc.cm, _markText)(doc, from, to, options, type);
				var marker = new TextMarker(doc, type),
					diff = cmp(from, to);
				options && copyObj(options, marker, false);
				if (diff > 0 || 0 == diff && false !== marker.clearWhenEmpty) return marker;
				if (marker.replacedWith)
				{
					marker.collapsed = true;
					marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
					options.handleMouseEvents || marker.widgetNode.setAttribute("cm-ignore-events", "true");
					options.insertLeft && (marker.widgetNode.insertLeft = true)
				}
				if (marker.collapsed)
				{
					if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
					seeCollapsedSpans()
				}
				marker.addToHistory && addChangeToHistory(doc,
				{
					from: from,
					to: to,
					origin: "markText"
				}, doc.sel, NaN);
				var updateMaxLine, curLine = from.line,
					cm = doc.cm;
				doc.iter(curLine, to.line + 1, function (line)
				{
					cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = true);
					marker.collapsed && curLine != from.line && updateLineHeight(line, 0);
					addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
					++curLine
				});
				marker.collapsed && doc.iter(from.line, to.line + 1, function (line)
				{
					lineIsHidden(doc, line) && updateLineHeight(line, 0)
				});
				marker.clearOnEnter && on(marker, "beforeCursorEnter", function ()
				{
					return marker.clear()
				});
				if (marker.readOnly)
				{
					seeReadOnlySpans();
					(doc.history.done.length || doc.history.undone.length) && doc.clearHistory()
				}
				if (marker.collapsed)
				{
					marker.id = ++nextMarkerId;
					marker.atomic = true
				}
				if (cm)
				{
					updateMaxLine && (cm.curOp.updateMaxLine = true);
					if (marker.collapsed) regChange(cm, from.line, to.line + 1);
					else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
						for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
					marker.atomic && reCheckSelection(cm.doc);
					signalLater(cm, "markerAdded", cm, marker)
				}
				return marker
			}
			var SharedTextMarker = function SharedTextMarker(markers, primary)
			{
				var this$1 = this;
				this.markers = markers;
				this.primary = primary;
				for (var i = 0; i < markers.length; ++i) markers[i].parent = this$1
			};
			SharedTextMarker.prototype.clear = function ()
			{
				var this$1 = this;
				if (this.explicitlyCleared) return;
				this.explicitlyCleared = true;
				for (var i = 0; i < this.markers.length; ++i) this$1.markers[i].clear();
				signalLater(this, "clear")
			};
			SharedTextMarker.prototype.find = function (side, lineObj)
			{
				return this.primary.find(side, lineObj)
			};
			eventMixin(SharedTextMarker);

			function markTextShared(doc, from, to, options, type)
			{
				options = copyObj(options);
				options.shared = false;
				var markers = [_markText(doc, from, to, options, type)],
					primary = markers[0];
				var widget = options.widgetNode;
				linkedDocs(doc, function (doc)
				{
					widget && (options.widgetNode = widget.cloneNode(true));
					markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));
					for (var i = 0; i < doc.linked.length; ++i)
						if (doc.linked[i].isParent) return;
					primary = lst(markers)
				});
				return new SharedTextMarker(markers, primary)
			}

			function findSharedMarkers(doc)
			{
				return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m)
				{
					return m.parent
				})
			}

			function copySharedMarkers(doc, markers)
			{
				for (var i = 0; i < markers.length; i++)
				{
					var marker = markers[i],
						pos = marker.find();
					var mFrom = doc.clipPos(pos.from),
						mTo = doc.clipPos(pos.to);
					if (cmp(mFrom, mTo))
					{
						var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
						marker.markers.push(subMark);
						subMark.parent = marker
					}
				}
			}

			function detachSharedMarkers(markers)
			{
				var loop = function loop(i)
				{
					var marker = markers[i],
						linked = [marker.primary.doc];
					linkedDocs(marker.primary.doc, function (d)
					{
						return linked.push(d)
					});
					for (var j = 0; j < marker.markers.length; j++)
					{
						var subMarker = marker.markers[j];
						if (-1 == indexOf(linked, subMarker.doc))
						{
							subMarker.parent = null;
							marker.markers.splice(j--, 1)
						}
					}
				};
				for (var i = 0; i < markers.length; i++) loop(i)
			}
			var nextDocId = 0;
			var Doc = function Doc(text, mode, firstLine, lineSep, direction)
			{
				if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep, direction);
				null == firstLine && (firstLine = 0);
				BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
				this.first = firstLine;
				this.scrollTop = this.scrollLeft = 0;
				this.cantEdit = false;
				this.cleanGeneration = 1;
				this.modeFrontier = this.highlightFrontier = firstLine;
				var start = Pos(firstLine, 0);
				this.sel = simpleSelection(start);
				this.history = new History(null);
				this.id = ++nextDocId;
				this.modeOption = mode;
				this.lineSep = lineSep;
				this.direction = "rtl" == direction ? "rtl" : "ltr";
				this.extend = false;
				"string" == typeof text && (text = this.splitLines(text));
				updateDoc(this,
				{
					from: start,
					to: start,
					text: text
				});
				setSelection(this, simpleSelection(start), sel_dontScroll)
			};
			Doc.prototype = createObj(BranchChunk.prototype,
			{
				constructor: Doc,
				iter: function iter(from, to, op)
				{
					op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from)
				},
				insert: function insert(at, lines)
				{
					var height = 0;
					for (var i = 0; i < lines.length; ++i) height += lines[i].height;
					this.insertInner(at - this.first, lines, height)
				},
				remove: function remove(at, n)
				{
					this.removeInner(at - this.first, n)
				},
				getValue: function getValue(lineSep)
				{
					var lines = getLines(this, this.first, this.first + this.size);
					if (false === lineSep) return lines;
					return lines.join(lineSep || this.lineSeparator())
				},
				setValue: docMethodOp(function (code)
				{
					var top = Pos(this.first, 0),
						last = this.first + this.size - 1;
					makeChange(this,
					{
						from: top,
						to: Pos(last, getLine(this, last).text.length),
						text: this.splitLines(code),
						origin: "setValue",
						full: true
					}, true);
					this.cm && scrollToCoords(this.cm, 0, 0);
					setSelection(this, simpleSelection(top), sel_dontScroll)
				}),
				replaceRange: function replaceRange(code, from, to, origin)
				{
					from = _clipPos(this, from);
					to = to ? _clipPos(this, to) : from;
					_replaceRange(this, code, from, to, origin)
				},
				getRange: function getRange(from, to, lineSep)
				{
					var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));
					if (false === lineSep) return lines;
					return lines.join(lineSep || this.lineSeparator())
				},
				getLine: function getLine(line)
				{
					var l = this.getLineHandle(line);
					return l && l.text
				},
				getLineHandle: function getLineHandle(line)
				{
					if (isLine(this, line)) return getLine(this, line)
				},
				getLineNumber: function getLineNumber(line)
				{
					return lineNo(line)
				},
				getLineHandleVisualStart: function getLineHandleVisualStart(line)
				{
					"number" == typeof line && (line = getLine(this, line));
					return visualLine(line)
				},
				lineCount: function lineCount()
				{
					return this.size
				},
				firstLine: function firstLine()
				{
					return this.first
				},
				lastLine: function lastLine()
				{
					return this.first + this.size - 1
				},
				clipPos: function clipPos(pos)
				{
					return _clipPos(this, pos)
				},
				getCursor: function getCursor(start)
				{
					var pos, range$$1 = this.sel.primary();
					pos = null == start || "head" == start ? range$$1.head : "anchor" == start ? range$$1.anchor : "end" == start || "to" == start || false === start ? range$$1.to() : range$$1.from();
					return pos
				},
				listSelections: function listSelections()
				{
					return this.sel.ranges
				},
				somethingSelected: function somethingSelected()
				{
					return this.sel.somethingSelected()
				},
				setCursor: docMethodOp(function (line, ch, options)
				{
					setSimpleSelection(this, _clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options)
				}),
				setSelection: docMethodOp(function (anchor, head, options)
				{
					setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options)
				}),
				extendSelection: docMethodOp(function (head, other, options)
				{
					extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options)
				}),
				extendSelections: docMethodOp(function (heads, options)
				{
					extendSelections(this, clipPosArray(this, heads), options)
				}),
				extendSelectionsBy: docMethodOp(function (f, options)
				{
					var heads = map(this.sel.ranges, f);
					extendSelections(this, clipPosArray(this, heads), options)
				}),
				setSelections: docMethodOp(function (ranges, primary, options)
				{
					var this$1 = this;
					if (!ranges.length) return;
					var out = [];
					for (var i = 0; i < ranges.length; i++) out[i] = new Range(_clipPos(this$1, ranges[i].anchor), _clipPos(this$1, ranges[i].head));
					null == primary && (primary = Math.min(ranges.length - 1, this.sel.primIndex));
					setSelection(this, normalizeSelection(out, primary), options)
				}),
				addSelection: docMethodOp(function (anchor, head, options)
				{
					var ranges = this.sel.ranges.slice(0);
					ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));
					setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)
				}),
				getSelection: function getSelection(lineSep)
				{
					var this$1 = this;
					var lines, ranges = this.sel.ranges;
					for (var i = 0; i < ranges.length; i++)
					{
						var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
						lines = lines ? lines.concat(sel) : sel
					}
					return false === lineSep ? lines : lines.join(lineSep || this.lineSeparator())
				},
				getSelections: function getSelections(lineSep)
				{
					var this$1 = this;
					var parts = [],
						ranges = this.sel.ranges;
					for (var i = 0; i < ranges.length; i++)
					{
						var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
						false !== lineSep && (sel = sel.join(lineSep || this$1.lineSeparator()));
						parts[i] = sel
					}
					return parts
				},
				replaceSelection: function replaceSelection(code, collapse, origin)
				{
					var dup = [];
					for (var i = 0; i < this.sel.ranges.length; i++) dup[i] = code;
					this.replaceSelections(dup, collapse, origin || "+input")
				},
				replaceSelections: docMethodOp(function (code, collapse, origin)
				{
					var this$1 = this;
					var changes = [],
						sel = this.sel;
					for (var i = 0; i < sel.ranges.length; i++)
					{
						var range$$1 = sel.ranges[i];
						changes[i] = {
							from: range$$1.from(),
							to: range$$1.to(),
							text: this$1.splitLines(code[i]),
							origin: origin
						}
					}
					var newSel = collapse && "end" != collapse && computeReplacedSel(this, changes, collapse);
					for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) makeChange(this$1, changes[i$1]);
					newSel ? setSelectionReplaceHistory(this, newSel) : this.cm && ensureCursorVisible(this.cm)
				}),
				undo: docMethodOp(function ()
				{
					makeChangeFromHistory(this, "undo")
				}),
				redo: docMethodOp(function ()
				{
					makeChangeFromHistory(this, "redo")
				}),
				undoSelection: docMethodOp(function ()
				{
					makeChangeFromHistory(this, "undo", true)
				}),
				redoSelection: docMethodOp(function ()
				{
					makeChangeFromHistory(this, "redo", true)
				}),
				setExtending: function setExtending(val)
				{
					this.extend = val
				},
				getExtending: function getExtending()
				{
					return this.extend
				},
				historySize: function historySize()
				{
					var hist = this.history,
						done = 0,
						undone = 0;
					for (var i = 0; i < hist.done.length; i++) hist.done[i].ranges || ++done;
					for (var i$1 = 0; i$1 < hist.undone.length; i$1++) hist.undone[i$1].ranges || ++undone;
					return {
						undo: done,
						redo: undone
					}
				},
				clearHistory: function clearHistory()
				{
					this.history = new History(this.history.maxGeneration)
				},
				markClean: function markClean()
				{
					this.cleanGeneration = this.changeGeneration(true)
				},
				changeGeneration: function changeGeneration(forceSplit)
				{
					forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null);
					return this.history.generation
				},
				isClean: function isClean(gen)
				{
					return this.history.generation == (gen || this.cleanGeneration)
				},
				getHistory: function getHistory()
				{
					return {
						done: copyHistoryArray(this.history.done),
						undone: copyHistoryArray(this.history.undone)
					}
				},
				setHistory: function setHistory(histData)
				{
					var hist = this.history = new History(this.history.maxGeneration);
					hist.done = copyHistoryArray(histData.done.slice(0), null, true);
					hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)
				},
				setGutterMarker: docMethodOp(function (line, gutterID, value)
				{
					return changeLine(this, line, "gutter", function (line)
					{
						var markers = line.gutterMarkers || (line.gutterMarkers = {});
						markers[gutterID] = value;
						!value && isEmpty(markers) && (line.gutterMarkers = null);
						return true
					})
				}),
				clearGutter: docMethodOp(function (gutterID)
				{
					var this$1 = this;
					this.iter(function (line)
					{
						line.gutterMarkers && line.gutterMarkers[gutterID] && changeLine(this$1, line, "gutter", function ()
						{
							line.gutterMarkers[gutterID] = null;
							isEmpty(line.gutterMarkers) && (line.gutterMarkers = null);
							return true
						})
					})
				}),
				lineInfo: function lineInfo(line)
				{
					var n;
					if ("number" == typeof line)
					{
						if (!isLine(this, line)) return null;
						n = line;
						line = getLine(this, line);
						if (!line) return null
					}
					else
					{
						n = lineNo(line);
						if (null == n) return null
					}
					return {
						line: n,
						handle: line,
						text: line.text,
						gutterMarkers: line.gutterMarkers,
						textClass: line.textClass,
						bgClass: line.bgClass,
						wrapClass: line.wrapClass,
						widgets: line.widgets
					}
				},
				addLineClass: docMethodOp(function (handle, where, cls)
				{
					return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function (line)
					{
						var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
						if (line[prop])
						{
							if (classTest(cls).test(line[prop])) return false;
							line[prop] += " " + cls
						}
						else line[prop] = cls;
						return true
					})
				}),
				removeLineClass: docMethodOp(function (handle, where, cls)
				{
					return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function (line)
					{
						var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
						var cur = line[prop];
						if (!cur) return false;
						if (null == cls) line[prop] = null;
						else
						{
							var found = cur.match(classTest(cls));
							if (!found) return false;
							var end = found.index + found[0].length;
							line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null
						}
						return true
					})
				}),
				addLineWidget: docMethodOp(function (handle, node, options)
				{
					return addLineWidget(this, handle, node, options)
				}),
				removeLineWidget: function removeLineWidget(widget)
				{
					widget.clear()
				},
				markText: function markText(from, to, options)
				{
					return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || "range")
				},
				setBookmark: function setBookmark(pos, options)
				{
					var realOpts = {
						replacedWith: options && (null == options.nodeType ? options.widget : options),
						insertLeft: options && options.insertLeft,
						clearWhenEmpty: false,
						shared: options && options.shared,
						handleMouseEvents: options && options.handleMouseEvents
					};
					pos = _clipPos(this, pos);
					return _markText(this, pos, pos, realOpts, "bookmark")
				},
				findMarksAt: function findMarksAt(pos)
				{
					pos = _clipPos(this, pos);
					var markers = [],
						spans = getLine(this, pos.line).markedSpans;
					if (spans)
						for (var i = 0; i < spans.length; ++i)
						{
							var span = spans[i];
							(null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker)
						}
					return markers
				},
				findMarks: function findMarks(from, to, filter)
				{
					from = _clipPos(this, from);
					to = _clipPos(this, to);
					var found = [],
						lineNo$$1 = from.line;
					this.iter(from.line, to.line + 1, function (line)
					{
						var spans = line.markedSpans;
						if (spans)
							for (var i = 0; i < spans.length; i++)
							{
								var span = spans[i];
								null != span.to && lineNo$$1 == from.line && from.ch >= span.to || null == span.from && lineNo$$1 != from.line || null != span.from && lineNo$$1 == to.line && span.from >= to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker)
							}++lineNo$$1
					});
					return found
				},
				getAllMarks: function getAllMarks()
				{
					var markers = [];
					this.iter(function (line)
					{
						var sps = line.markedSpans;
						if (sps)
							for (var i = 0; i < sps.length; ++i) null != sps[i].from && markers.push(sps[i].marker)
					});
					return markers
				},
				posFromIndex: function posFromIndex(off)
				{
					var ch, lineNo$$1 = this.first,
						sepSize = this.lineSeparator().length;
					this.iter(function (line)
					{
						var sz = line.text.length + sepSize;
						if (sz > off)
						{
							ch = off;
							return true
						}
						off -= sz;
						++lineNo$$1
					});
					return _clipPos(this, Pos(lineNo$$1, ch))
				},
				indexFromPos: function indexFromPos(coords)
				{
					coords = _clipPos(this, coords);
					var index = coords.ch;
					if (coords.line < this.first || coords.ch < 0) return 0;
					var sepSize = this.lineSeparator().length;
					this.iter(this.first, coords.line, function (line)
					{
						index += line.text.length + sepSize
					});
					return index
				},
				copy: function copy(copyHistory)
				{
					var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
					doc.scrollTop = this.scrollTop;
					doc.scrollLeft = this.scrollLeft;
					doc.sel = this.sel;
					doc.extend = false;
					if (copyHistory)
					{
						doc.history.undoDepth = this.history.undoDepth;
						doc.setHistory(this.getHistory())
					}
					return doc
				},
				linkedDoc: function linkedDoc(options)
				{
					options || (options = {});
					var from = this.first,
						to = this.first + this.size;
					null != options.from && options.from > from && (from = options.from);
					null != options.to && options.to < to && (to = options.to);
					var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
					options.sharedHist && (copy.history = this.history);
					(this.linked || (this.linked = [])).push(
					{
						doc: copy,
						sharedHist: options.sharedHist
					});
					copy.linked = [
					{
						doc: this,
						isParent: true,
						sharedHist: options.sharedHist
					}];
					copySharedMarkers(copy, findSharedMarkers(this));
					return copy
				},
				unlinkDoc: function unlinkDoc(other)
				{
					var this$1 = this;
					other instanceof CodeMirror$1 && (other = other.doc);
					if (this.linked)
						for (var i = 0; i < this.linked.length; ++i)
						{
							var link = this$1.linked[i];
							if (link.doc != other) continue;
							this$1.linked.splice(i, 1);
							other.unlinkDoc(this$1);
							detachSharedMarkers(findSharedMarkers(this$1));
							break
						}
					if (other.history == this.history)
					{
						var splitIds = [other.id];
						linkedDocs(other, function (doc)
						{
							return splitIds.push(doc.id)
						}, true);
						other.history = new History(null);
						other.history.done = copyHistoryArray(this.history.done, splitIds);
						other.history.undone = copyHistoryArray(this.history.undone, splitIds)
					}
				},
				iterLinkedDocs: function iterLinkedDocs(f)
				{
					linkedDocs(this, f)
				},
				getMode: function getMode()
				{
					return this.mode
				},
				getEditor: function getEditor()
				{
					return this.cm
				},
				splitLines: function splitLines(str)
				{
					if (this.lineSep) return str.split(this.lineSep);
					return splitLinesAuto(str)
				},
				lineSeparator: function lineSeparator()
				{
					return this.lineSep || "\n"
				},
				setDirection: docMethodOp(function (dir)
				{
					"rtl" != dir && (dir = "ltr");
					if (dir == this.direction) return;
					this.direction = dir;
					this.iter(function (line)
					{
						return line.order = null
					});
					this.cm && directionChanged(this.cm)
				})
			});
			Doc.prototype.eachLine = Doc.prototype.iter;
			var lastDrop = 0;

			function onDrop(e)
			{
				var cm = this;
				clearDragCursor(cm);
				if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;
				e_preventDefault(e);
				ie && (lastDrop = +new Date);
				var pos = posFromMouse(cm, e, true),
					files = e.dataTransfer.files;
				if (!pos || cm.isReadOnly()) return;
				if (files && files.length && window.FileReader && window.File)
				{
					var n = files.length,
						text = Array(n),
						read = 0;
					var loadFile = function loadFile(file, i)
					{
						if (cm.options.allowDropFileTypes && -1 == indexOf(cm.options.allowDropFileTypes, file.type)) return;
						var reader = new FileReader;
						reader.onload = operation(cm, function ()
						{
							var content = reader.result;
							/[\x00-\x08\x0e-\x1f]{2}/.test(content) && (content = "");
							text[i] = content;
							if (++read == n)
							{
								pos = _clipPos(cm.doc, pos);
								var change = {
									from: pos,
									to: pos,
									text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
									origin: "paste"
								};
								makeChange(cm.doc, change);
								setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))
							}
						});
						reader.readAsText(file)
					};
					for (var i = 0; i < n; ++i) loadFile(files[i], i)
				}
				else
				{
					if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1)
					{
						cm.state.draggingText(e);
						setTimeout(function ()
						{
							return cm.display.input.focus()
						}, 20);
						return
					}
					try
					{
						var text$1 = e.dataTransfer.getData("Text");
						if (text$1)
						{
							var selected;
							cm.state.draggingText && !cm.state.draggingText.copy && (selected = cm.listSelections());
							setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
							if (selected)
								for (var i$1 = 0; i$1 < selected.length; ++i$1) _replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
							cm.replaceSelection(text$1, "around", "paste");
							cm.display.input.focus()
						}
					}
					catch (e)
					{}
				}
			}

			function onDragStart(cm, e)
			{
				if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100))
				{
					e_stop(e);
					return
				}
				if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;
				e.dataTransfer.setData("Text", cm.getSelection());
				e.dataTransfer.effectAllowed = "copyMove";
				if (e.dataTransfer.setDragImage && !safari)
				{
					var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
					img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
					if (presto)
					{
						img.width = img.height = 1;
						cm.display.wrapper.appendChild(img);
						img._top = img.offsetTop
					}
					e.dataTransfer.setDragImage(img, 0, 0);
					presto && img.parentNode.removeChild(img)
				}
			}

			function onDragOver(cm, e)
			{
				var pos = posFromMouse(cm, e);
				if (!pos) return;
				var frag = document.createDocumentFragment();
				drawSelectionCursor(cm, pos, frag);
				if (!cm.display.dragCursor)
				{
					cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
					cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)
				}
				removeChildrenAndAdd(cm.display.dragCursor, frag)
			}

			function clearDragCursor(cm)
			{
				if (cm.display.dragCursor)
				{
					cm.display.lineSpace.removeChild(cm.display.dragCursor);
					cm.display.dragCursor = null
				}
			}

			function forEachCodeMirror(f)
			{
				if (!document.getElementsByClassName) return;
				var byClass = document.getElementsByClassName("CodeMirror");
				for (var i = 0; i < byClass.length; i++)
				{
					var cm = byClass[i].CodeMirror;
					cm && f(cm)
				}
			}
			var globalsRegistered = false;

			function ensureGlobalHandlers()
			{
				if (globalsRegistered) return;
				registerGlobalHandlers();
				globalsRegistered = true
			}

			function registerGlobalHandlers()
			{
				var resizeTimer;
				on(window, "resize", function ()
				{
					null == resizeTimer && (resizeTimer = setTimeout(function ()
					{
						resizeTimer = null;
						forEachCodeMirror(onResize)
					}, 100))
				});
				on(window, "blur", function ()
				{
					return forEachCodeMirror(onBlur)
				})
			}

			function onResize(cm)
			{
				var d = cm.display;
				if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth) return;
				d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
				d.scrollbarsClipped = false;
				cm.setSize()
			}
			var keyNames = {
				3: "Pause",
				8: "Backspace",
				9: "Tab",
				13: "Enter",
				16: "Shift",
				17: "Ctrl",
				18: "Alt",
				19: "Pause",
				20: "CapsLock",
				27: "Esc",
				32: "Space",
				33: "PageUp",
				34: "PageDown",
				35: "End",
				36: "Home",
				37: "Left",
				38: "Up",
				39: "Right",
				40: "Down",
				44: "PrintScrn",
				45: "Insert",
				46: "Delete",
				59: ";",
				61: "=",
				91: "Mod",
				92: "Mod",
				93: "Mod",
				106: "*",
				107: "=",
				109: "-",
				110: ".",
				111: "/",
				127: "Delete",
				145: "ScrollLock",
				173: "-",
				186: ";",
				187: "=",
				188: ",",
				189: "-",
				190: ".",
				191: "/",
				192: "`",
				219: "[",
				220: "\\",
				221: "]",
				222: "'",
				63232: "Up",
				63233: "Down",
				63234: "Left",
				63235: "Right",
				63272: "Delete",
				63273: "Home",
				63275: "End",
				63276: "PageUp",
				63277: "PageDown",
				63302: "Insert"
			};
			for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
			for (var i$1 = 65; i$1 <= 90; i$1++) keyNames[i$1] = String.fromCharCode(i$1);
			for (var i$2 = 1; i$2 <= 12; i$2++) keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
			var keyMap = {};
			keyMap.basic = {
				Left: "goCharLeft",
				Right: "goCharRight",
				Up: "goLineUp",
				Down: "goLineDown",
				End: "goLineEnd",
				Home: "goLineStartSmart",
				PageUp: "goPageUp",
				PageDown: "goPageDown",
				Delete: "delCharAfter",
				Backspace: "delCharBefore",
				"Shift-Backspace": "delCharBefore",
				Tab: "defaultTab",
				"Shift-Tab": "indentAuto",
				Enter: "newlineAndIndent",
				Insert: "toggleOverwrite",
				Esc: "singleSelection"
			};
			keyMap.pcDefault = {
				"Ctrl-A": "selectAll",
				"Ctrl-D": "deleteLine",
				"Ctrl-Z": "undo",
				"Shift-Ctrl-Z": "redo",
				"Ctrl-Y": "redo",
				"Ctrl-Home": "goDocStart",
				"Ctrl-End": "goDocEnd",
				"Ctrl-Up": "goLineUp",
				"Ctrl-Down": "goLineDown",
				"Ctrl-Left": "goGroupLeft",
				"Ctrl-Right": "goGroupRight",
				"Alt-Left": "goLineStart",
				"Alt-Right": "goLineEnd",
				"Ctrl-Backspace": "delGroupBefore",
				"Ctrl-Delete": "delGroupAfter",
				"Ctrl-S": "save",
				"Ctrl-F": "find",
				"Ctrl-G": "findNext",
				"Shift-Ctrl-G": "findPrev",
				"Shift-Ctrl-F": "replace",
				"Shift-Ctrl-R": "replaceAll",
				"Ctrl-[": "indentLess",
				"Ctrl-]": "indentMore",
				"Ctrl-U": "undoSelection",
				"Shift-Ctrl-U": "redoSelection",
				"Alt-U": "redoSelection",
				fallthrough: "basic"
			};
			keyMap.emacsy = {
				"Ctrl-F": "goCharRight",
				"Ctrl-B": "goCharLeft",
				"Ctrl-P": "goLineUp",
				"Ctrl-N": "goLineDown",
				"Alt-F": "goWordRight",
				"Alt-B": "goWordLeft",
				"Ctrl-A": "goLineStart",
				"Ctrl-E": "goLineEnd",
				"Ctrl-V": "goPageDown",
				"Shift-Ctrl-V": "goPageUp",
				"Ctrl-D": "delCharAfter",
				"Ctrl-H": "delCharBefore",
				"Alt-D": "delWordAfter",
				"Alt-Backspace": "delWordBefore",
				"Ctrl-K": "killLine",
				"Ctrl-T": "transposeChars",
				"Ctrl-O": "openLine"
			};
			keyMap.macDefault = {
				"Cmd-A": "selectAll",
				"Cmd-D": "deleteLine",
				"Cmd-Z": "undo",
				"Shift-Cmd-Z": "redo",
				"Cmd-Y": "redo",
				"Cmd-Home": "goDocStart",
				"Cmd-Up": "goDocStart",
				"Cmd-End": "goDocEnd",
				"Cmd-Down": "goDocEnd",
				"Alt-Left": "goGroupLeft",
				"Alt-Right": "goGroupRight",
				"Cmd-Left": "goLineLeft",
				"Cmd-Right": "goLineRight",
				"Alt-Backspace": "delGroupBefore",
				"Ctrl-Alt-Backspace": "delGroupAfter",
				"Alt-Delete": "delGroupAfter",
				"Cmd-S": "save",
				"Cmd-F": "find",
				"Cmd-G": "findNext",
				"Shift-Cmd-G": "findPrev",
				"Cmd-Alt-F": "replace",
				"Shift-Cmd-Alt-F": "replaceAll",
				"Cmd-[": "indentLess",
				"Cmd-]": "indentMore",
				"Cmd-Backspace": "delWrappedLineLeft",
				"Cmd-Delete": "delWrappedLineRight",
				"Cmd-U": "undoSelection",
				"Shift-Cmd-U": "redoSelection",
				"Ctrl-Up": "goDocStart",
				"Ctrl-Down": "goDocEnd",
				fallthrough: ["basic", "emacsy"]
			};
			keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

			function normalizeKeyName(name)
			{
				var parts = name.split(/-(?!$)/);
				name = parts[parts.length - 1];
				var alt, ctrl, shift, cmd;
				for (var i = 0; i < parts.length - 1; i++)
				{
					var mod = parts[i];
					if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
					else if (/^a(lt)?$/i.test(mod)) alt = true;
					else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
					else
					{
						if (!/^s(hift)?$/i.test(mod)) throw new Error("Unrecognized modifier name: " + mod);
						shift = true
					}
				}
				alt && (name = "Alt-" + name);
				ctrl && (name = "Ctrl-" + name);
				cmd && (name = "Cmd-" + name);
				shift && (name = "Shift-" + name);
				return name
			}

			function normalizeKeyMap(keymap)
			{
				var copy = {};
				for (var keyname in keymap)
					if (keymap.hasOwnProperty(keyname))
					{
						var value = keymap[keyname];
						if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
						if ("..." == value)
						{
							delete keymap[keyname];
							continue
						}
						var keys = map(keyname.split(" "), normalizeKeyName);
						for (var i = 0; i < keys.length; i++)
						{
							var val = void 0,
								name = void 0;
							if (i == keys.length - 1)
							{
								name = keys.join(" ");
								val = value
							}
							else
							{
								name = keys.slice(0, i + 1).join(" ");
								val = "..."
							}
							var prev = copy[name];
							if (prev)
							{
								if (prev != val) throw new Error("Inconsistent bindings for " + name)
							}
							else copy[name] = val
						}
						delete keymap[keyname]
					}
				for (var prop in copy) keymap[prop] = copy[prop];
				return keymap
			}

			function lookupKey(key, map$$1, handle, context)
			{
				map$$1 = getKeyMap(map$$1);
				var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
				if (false === found) return "nothing";
				if ("..." === found) return "multi";
				if (null != found && handle(found)) return "handled";
				if (map$$1.fallthrough)
				{
					if ("[object Array]" != Object.prototype.toString.call(map$$1.fallthrough)) return lookupKey(key, map$$1.fallthrough, handle, context);
					for (var i = 0; i < map$$1.fallthrough.length; i++)
					{
						var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
						if (result) return result
					}
				}
			}

			function isModifierKey(value)
			{
				var name = "string" == typeof value ? value : keyNames[value.keyCode];
				return "Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name
			}

			function addModifierNames(name, event, noShift)
			{
				var base = name;
				event.altKey && "Alt" != base && (name = "Alt-" + name);
				(flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name);
				(flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Cmd" != base && (name = "Cmd-" + name);
				!noShift && event.shiftKey && "Shift" != base && (name = "Shift-" + name);
				return name
			}

			function keyName(event, noShift)
			{
				if (presto && 34 == event.keyCode && event["char"]) return false;
				var name = keyNames[event.keyCode];
				if (null == name || event.altGraphKey) return false;
				3 == event.keyCode && event.code && (name = event.code);
				return addModifierNames(name, event, noShift)
			}

			function getKeyMap(val)
			{
				return "string" == typeof val ? keyMap[val] : val
			}

			function deleteNearSelection(cm, compute)
			{
				var ranges = cm.doc.sel.ranges,
					kill = [];
				for (var i = 0; i < ranges.length; i++)
				{
					var toKill = compute(ranges[i]);
					while (kill.length && cmp(toKill.from, lst(kill).to) <= 0)
					{
						var replaced = kill.pop();
						if (cmp(replaced.from, toKill.from) < 0)
						{
							toKill.from = replaced.from;
							break
						}
					}
					kill.push(toKill)
				}
				runInOp(cm, function ()
				{
					for (var i = kill.length - 1; i >= 0; i--) _replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
					ensureCursorVisible(cm)
				})
			}

			function moveCharLogically(line, ch, dir)
			{
				var target = skipExtendingChars(line.text, ch + dir, dir);
				return target < 0 || target > line.text.length ? null : target
			}

			function moveLogically(line, start, dir)
			{
				var ch = moveCharLogically(line, start.ch, dir);
				return null == ch ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
			}

			function endOfLine(visually, cm, lineObj, lineNo, dir)
			{
				if (visually)
				{
					var order = getOrder(lineObj, cm.doc.direction);
					if (order)
					{
						var part = dir < 0 ? lst(order) : order[0];
						var moveInStorageOrder = dir < 0 == (1 == part.level);
						var sticky = moveInStorageOrder ? "after" : "before";
						var ch;
						if (part.level > 0 || "rtl" == cm.doc.direction)
						{
							var prep = prepareMeasureForLine(cm, lineObj);
							ch = dir < 0 ? lineObj.text.length - 1 : 0;
							var targetTop = measureCharPrepared(cm, prep, ch).top;
							ch = findFirst(function (ch)
							{
								return measureCharPrepared(cm, prep, ch).top == targetTop
							}, dir < 0 == (1 == part.level) ? part.from : part.to - 1, ch);
							"before" == sticky && (ch = moveCharLogically(lineObj, ch, 1))
						}
						else ch = dir < 0 ? part.to : part.from;
						return new Pos(lineNo, ch, sticky)
					}
				}
				return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
			}

			function moveVisually(cm, line, start, dir)
			{
				var bidi = getOrder(line, cm.doc.direction);
				if (!bidi) return moveLogically(line, start, dir);
				if (start.ch >= line.text.length)
				{
					start.ch = line.text.length;
					start.sticky = "before"
				}
				else if (start.ch <= 0)
				{
					start.ch = 0;
					start.sticky = "after"
				}
				var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
					part = bidi[partPos];
				if ("ltr" == cm.doc.direction && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) return moveLogically(line, start, dir);
				var mv = function mv(pos, dir)
				{
					return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir)
				};
				var prep;
				var getWrappedLineExtent = function getWrappedLineExtent(ch)
				{
					if (!cm.options.lineWrapping) return {
						begin: 0,
						end: line.text.length
					};
					prep = prep || prepareMeasureForLine(cm, line);
					return wrappedLineExtentChar(cm, line, prep, ch)
				};
				var wrappedLineExtent = getWrappedLineExtent("before" == start.sticky ? mv(start, -1) : start.ch);
				if ("rtl" == cm.doc.direction || 1 == part.level)
				{
					var moveInStorageOrder = 1 == part.level == dir < 0;
					var ch = mv(start, moveInStorageOrder ? 1 : -1);
					if (null != ch && (moveInStorageOrder ? ch <= part.to && ch <= wrappedLineExtent.end : ch >= part.from && ch >= wrappedLineExtent.begin))
					{
						var sticky = moveInStorageOrder ? "before" : "after";
						return new Pos(start.line, ch, sticky)
					}
				}
				var searchInVisualLine = function searchInVisualLine(partPos, dir, wrappedLineExtent)
				{
					var getRes = function getRes(ch, moveInStorageOrder)
					{
						return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after")
					};
					for (; partPos >= 0 && partPos < bidi.length; partPos += dir)
					{
						var part = bidi[partPos];
						var moveInStorageOrder = dir > 0 == (1 != part.level);
						var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
						if (part.from <= ch && ch < part.to) return getRes(ch, moveInStorageOrder);
						ch = moveInStorageOrder ? part.from : mv(part.to, -1);
						if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) return getRes(ch, moveInStorageOrder)
					}
				};
				var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
				if (res) return res;
				var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
				if (null != nextCh && !(dir > 0 && nextCh == line.text.length))
				{
					res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
					if (res) return res
				}
				return null
			}
			var commands = {
				selectAll: selectAll,
				singleSelection: function singleSelection(cm)
				{
					return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll)
				},
				killLine: function killLine(cm)
				{
					return deleteNearSelection(cm, function (range)
					{
						if (range.empty())
						{
							var len = getLine(cm.doc, range.head.line).text.length;
							return range.head.ch == len && range.head.line < cm.lastLine() ?
							{
								from: range.head,
								to: Pos(range.head.line + 1, 0)
							} :
							{
								from: range.head,
								to: Pos(range.head.line, len)
							}
						}
						return {
							from: range.from(),
							to: range.to()
						}
					})
				},
				deleteLine: function deleteLine(cm)
				{
					return deleteNearSelection(cm, function (range)
					{
						return {
							from: Pos(range.from().line, 0),
							to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))
						}
					})
				},
				delLineLeft: function delLineLeft(cm)
				{
					return deleteNearSelection(cm, function (range)
					{
						return {
							from: Pos(range.from().line, 0),
							to: range.from()
						}
					})
				},
				delWrappedLineLeft: function delWrappedLineLeft(cm)
				{
					return deleteNearSelection(cm, function (range)
					{
						var top = cm.charCoords(range.head, "div").top + 5;
						var leftPos = cm.coordsChar(
						{
							left: 0,
							top: top
						}, "div");
						return {
							from: leftPos,
							to: range.from()
						}
					})
				},
				delWrappedLineRight: function delWrappedLineRight(cm)
				{
					return deleteNearSelection(cm, function (range)
					{
						var top = cm.charCoords(range.head, "div").top + 5;
						var rightPos = cm.coordsChar(
						{
							left: cm.display.lineDiv.offsetWidth + 100,
							top: top
						}, "div");
						return {
							from: range.from(),
							to: rightPos
						}
					})
				},
				undo: function undo(cm)
				{
					return cm.undo()
				},
				redo: function redo(cm)
				{
					return cm.redo()
				},
				undoSelection: function undoSelection(cm)
				{
					return cm.undoSelection()
				},
				redoSelection: function redoSelection(cm)
				{
					return cm.redoSelection()
				},
				goDocStart: function goDocStart(cm)
				{
					return cm.extendSelection(Pos(cm.firstLine(), 0))
				},
				goDocEnd: function goDocEnd(cm)
				{
					return cm.extendSelection(Pos(cm.lastLine()))
				},
				goLineStart: function goLineStart(cm)
				{
					return cm.extendSelectionsBy(function (range)
					{
						return lineStart(cm, range.head.line)
					},
					{
						origin: "+move",
						bias: 1
					})
				},
				goLineStartSmart: function goLineStartSmart(cm)
				{
					return cm.extendSelectionsBy(function (range)
					{
						return lineStartSmart(cm, range.head)
					},
					{
						origin: "+move",
						bias: 1
					})
				},
				goLineEnd: function goLineEnd(cm)
				{
					return cm.extendSelectionsBy(function (range)
					{
						return lineEnd(cm, range.head.line)
					},
					{
						origin: "+move",
						bias: -1
					})
				},
				goLineRight: function goLineRight(cm)
				{
					return cm.extendSelectionsBy(function (range)
					{
						var top = cm.cursorCoords(range.head, "div").top + 5;
						return cm.coordsChar(
						{
							left: cm.display.lineDiv.offsetWidth + 100,
							top: top
						}, "div")
					}, sel_move)
				},
				goLineLeft: function goLineLeft(cm)
				{
					return cm.extendSelectionsBy(function (range)
					{
						var top = cm.cursorCoords(range.head, "div").top + 5;
						return cm.coordsChar(
						{
							left: 0,
							top: top
						}, "div")
					}, sel_move)
				},
				goLineLeftSmart: function goLineLeftSmart(cm)
				{
					return cm.extendSelectionsBy(function (range)
					{
						var top = cm.cursorCoords(range.head, "div").top + 5;
						var pos = cm.coordsChar(
						{
							left: 0,
							top: top
						}, "div");
						if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
						return pos
					}, sel_move)
				},
				goLineUp: function goLineUp(cm)
				{
					return cm.moveV(-1, "line")
				},
				goLineDown: function goLineDown(cm)
				{
					return cm.moveV(1, "line")
				},
				goPageUp: function goPageUp(cm)
				{
					return cm.moveV(-1, "page")
				},
				goPageDown: function goPageDown(cm)
				{
					return cm.moveV(1, "page")
				},
				goCharLeft: function goCharLeft(cm)
				{
					return cm.moveH(-1, "char")
				},
				goCharRight: function goCharRight(cm)
				{
					return cm.moveH(1, "char")
				},
				goColumnLeft: function goColumnLeft(cm)
				{
					return cm.moveH(-1, "column")
				},
				goColumnRight: function goColumnRight(cm)
				{
					return cm.moveH(1, "column")
				},
				goWordLeft: function goWordLeft(cm)
				{
					return cm.moveH(-1, "word")
				},
				goGroupRight: function goGroupRight(cm)
				{
					return cm.moveH(1, "group")
				},
				goGroupLeft: function goGroupLeft(cm)
				{
					return cm.moveH(-1, "group")
				},
				goWordRight: function goWordRight(cm)
				{
					return cm.moveH(1, "word")
				},
				delCharBefore: function delCharBefore(cm)
				{
					return cm.deleteH(-1, "char")
				},
				delCharAfter: function delCharAfter(cm)
				{
					return cm.deleteH(1, "char")
				},
				delWordBefore: function delWordBefore(cm)
				{
					return cm.deleteH(-1, "word")
				},
				delWordAfter: function delWordAfter(cm)
				{
					return cm.deleteH(1, "word")
				},
				delGroupBefore: function delGroupBefore(cm)
				{
					return cm.deleteH(-1, "group")
				},
				delGroupAfter: function delGroupAfter(cm)
				{
					return cm.deleteH(1, "group")
				},
				indentAuto: function indentAuto(cm)
				{
					return cm.indentSelection("smart")
				},
				indentMore: function indentMore(cm)
				{
					return cm.indentSelection("add")
				},
				indentLess: function indentLess(cm)
				{
					return cm.indentSelection("subtract")
				},
				insertTab: function insertTab(cm)
				{
					return cm.replaceSelection("\t")
				},
				insertSoftTab: function insertSoftTab(cm)
				{
					var spaces = [],
						ranges = cm.listSelections(),
						tabSize = cm.options.tabSize;
					for (var i = 0; i < ranges.length; i++)
					{
						var pos = ranges[i].from();
						var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
						spaces.push(spaceStr(tabSize - col % tabSize))
					}
					cm.replaceSelections(spaces)
				},
				defaultTab: function defaultTab(cm)
				{
					cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab")
				},
				transposeChars: function transposeChars(cm)
				{
					return runInOp(cm, function ()
					{
						var ranges = cm.listSelections(),
							newSel = [];
						for (var i = 0; i < ranges.length; i++)
						{
							if (!ranges[i].empty()) continue;
							var cur = ranges[i].head,
								line = getLine(cm.doc, cur.line).text;
							if (line)
							{
								cur.ch == line.length && (cur = new Pos(cur.line, cur.ch - 1));
								if (cur.ch > 0)
								{
									cur = new Pos(cur.line, cur.ch + 1);
									cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose")
								}
								else if (cur.line > cm.doc.first)
								{
									var prev = getLine(cm.doc, cur.line - 1).text;
									if (prev)
									{
										cur = new Pos(cur.line, 1);
										cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose")
									}
								}
							}
							newSel.push(new Range(cur, cur))
						}
						cm.setSelections(newSel)
					})
				},
				newlineAndIndent: function newlineAndIndent(cm)
				{
					return runInOp(cm, function ()
					{
						var sels = cm.listSelections();
						for (var i = sels.length - 1; i >= 0; i--) cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
						sels = cm.listSelections();
						for (var i$1 = 0; i$1 < sels.length; i$1++) cm.indentLine(sels[i$1].from().line, null, true);
						ensureCursorVisible(cm)
					})
				},
				openLine: function openLine(cm)
				{
					return cm.replaceSelection("\n", "start")
				},
				toggleOverwrite: function toggleOverwrite(cm)
				{
					return cm.toggleOverwrite()
				}
			};

			function lineStart(cm, lineN)
			{
				var line = getLine(cm.doc, lineN);
				var visual = visualLine(line);
				visual != line && (lineN = lineNo(visual));
				return endOfLine(true, cm, visual, lineN, 1)
			}

			function lineEnd(cm, lineN)
			{
				var line = getLine(cm.doc, lineN);
				var visual = visualLineEnd(line);
				visual != line && (lineN = lineNo(visual));
				return endOfLine(true, cm, line, lineN, -1)
			}

			function lineStartSmart(cm, pos)
			{
				var start = lineStart(cm, pos.line);
				var line = getLine(cm.doc, start.line);
				var order = getOrder(line, cm.doc.direction);
				if (!order || 0 == order[0].level)
				{
					var firstNonWS = Math.max(0, line.text.search(/\S/));
					var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
					return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
				}
				return start
			}

			function doHandleBinding(cm, bound, dropShift)
			{
				if ("string" == typeof bound)
				{
					bound = commands[bound];
					if (!bound) return false
				}
				cm.display.input.ensurePolled();
				var prevShift = cm.display.shift,
					done = false;
				try
				{
					cm.isReadOnly() && (cm.state.suppressEdits = true);
					dropShift && (cm.display.shift = false);
					done = bound(cm) != Pass
				}
				finally
				{
					cm.display.shift = prevShift;
					cm.state.suppressEdits = false
				}
				return done
			}

			function lookupKeyForEditor(cm, name, handle)
			{
				for (var i = 0; i < cm.state.keyMaps.length; i++)
				{
					var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
					if (result) return result
				}
				return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm)
			}
			var stopSeq = new Delayed;

			function dispatchKey(cm, name, e, handle)
			{
				var seq = cm.state.keySeq;
				if (seq)
				{
					if (isModifierKey(name)) return "handled";
					/\'$/.test(name) ? cm.state.keySeq = null : stopSeq.set(50, function ()
					{
						if (cm.state.keySeq == seq)
						{
							cm.state.keySeq = null;
							cm.display.input.reset()
						}
					});
					if (dispatchKeyInner(cm, seq + " " + name, e, handle)) return true
				}
				return dispatchKeyInner(cm, name, e, handle)
			}

			function dispatchKeyInner(cm, name, e, handle)
			{
				var result = lookupKeyForEditor(cm, name, handle);
				"multi" == result && (cm.state.keySeq = name);
				"handled" == result && signalLater(cm, "keyHandled", cm, name, e);
				if ("handled" == result || "multi" == result)
				{
					e_preventDefault(e);
					restartBlink(cm)
				}
				return !!result
			}

			function handleKeyBinding(cm, e)
			{
				var name = keyName(e, true);
				if (!name) return false;
				return e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function (b)
				{
					return doHandleBinding(cm, b, true)
				}) || dispatchKey(cm, name, e, function (b)
				{
					if ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b)
				}) : dispatchKey(cm, name, e, function (b)
				{
					return doHandleBinding(cm, b)
				})
			}

			function handleCharBinding(cm, e, ch)
			{
				return dispatchKey(cm, "'" + ch + "'", e, function (b)
				{
					return doHandleBinding(cm, b, true)
				})
			}
			var lastStoppedKey = null;

			function onKeyDown(e)
			{
				var cm = this;
				cm.curOp.focus = activeElt();
				if (signalDOMEvent(cm, e)) return;
				ie && ie_version < 11 && 27 == e.keyCode && (e.returnValue = false);
				var code = e.keyCode;
				cm.display.shift = 16 == code || e.shiftKey;
				var handled = handleKeyBinding(cm, e);
				if (presto)
				{
					lastStoppedKey = handled ? code : null;
					!handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")
				}
				18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || showCrossHair(cm)
			}

			function showCrossHair(cm)
			{
				var lineDiv = cm.display.lineDiv;
				addClass(lineDiv, "CodeMirror-crosshair");

				function up(e)
				{
					if (18 == e.keyCode || !e.altKey)
					{
						rmClass(lineDiv, "CodeMirror-crosshair");
						off(document, "keyup", up);
						off(document, "mouseover", up)
					}
				}
				on(document, "keyup", up);
				on(document, "mouseover", up)
			}

			function onKeyUp(e)
			{
				16 == e.keyCode && (this.doc.sel.shift = false);
				signalDOMEvent(this, e)
			}

			function onKeyPress(e)
			{
				var cm = this;
				if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
				var keyCode = e.keyCode,
					charCode = e.charCode;
				if (presto && keyCode == lastStoppedKey)
				{
					lastStoppedKey = null;
					e_preventDefault(e);
					return
				}
				if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) return;
				var ch = String.fromCharCode(null == charCode ? keyCode : charCode);
				if ("\b" == ch) return;
				if (handleCharBinding(cm, e, ch)) return;
				cm.display.input.onKeyPress(e)
			}
			var DOUBLECLICK_DELAY = 400;
			var PastClick = function PastClick(time, pos, button)
			{
				this.time = time;
				this.pos = pos;
				this.button = button
			};
			PastClick.prototype.compare = function (time, pos, button)
			{
				return this.time + DOUBLECLICK_DELAY > time && 0 == cmp(pos, this.pos) && button == this.button
			};
			var lastClick;
			var lastDoubleClick;

			function clickRepeat(pos, button)
			{
				var now = +new Date;
				if (lastDoubleClick && lastDoubleClick.compare(now, pos, button))
				{
					lastClick = lastDoubleClick = null;
					return "triple"
				}
				if (lastClick && lastClick.compare(now, pos, button))
				{
					lastDoubleClick = new PastClick(now, pos, button);
					lastClick = null;
					return "double"
				}
				lastClick = new PastClick(now, pos, button);
				lastDoubleClick = null;
				return "single"
			}

			function onMouseDown(e)
			{
				var cm = this,
					display = cm.display;
				if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;
				display.input.ensurePolled();
				display.shift = e.shiftKey;
				if (eventInWidget(display, e))
				{
					if (!webkit)
					{
						display.scroller.draggable = false;
						setTimeout(function ()
						{
							return display.scroller.draggable = true
						}, 100)
					}
					return
				}
				if (clickInGutter(cm, e)) return;
				var pos = posFromMouse(cm, e),
					button = e_button(e),
					repeat = pos ? clickRepeat(pos, button) : "single";
				window.focus();
				1 == button && cm.state.selectingText && cm.state.selectingText(e);
				if (pos && handleMappedButton(cm, button, pos, repeat, e)) return;
				if (1 == button) pos ? leftButtonDown(cm, pos, repeat, e) : e_target(e) == display.scroller && e_preventDefault(e);
				else if (2 == button)
				{
					pos && extendSelection(cm.doc, pos);
					setTimeout(function ()
					{
						return display.input.focus()
					}, 20)
				}
				else 3 == button && (captureRightClick ? onContextMenu(cm, e) : delayBlurEvent(cm))
			}

			function handleMappedButton(cm, button, pos, repeat, event)
			{
				var name = "Click";
				"double" == repeat ? name = "Double" + name : "triple" == repeat && (name = "Triple" + name);
				name = (1 == button ? "Left" : 2 == button ? "Middle" : "Right") + name;
				return dispatchKey(cm, addModifierNames(name, event), event, function (bound)
				{
					"string" == typeof bound && (bound = commands[bound]);
					if (!bound) return false;
					var done = false;
					try
					{
						cm.isReadOnly() && (cm.state.suppressEdits = true);
						done = bound(cm, pos) != Pass
					}
					finally
					{
						cm.state.suppressEdits = false
					}
					return done
				})
			}

			function configureMouse(cm, repeat, event)
			{
				var option = cm.getOption("configureMouse");
				var value = option ? option(cm, repeat, event) :
				{};
				if (null == value.unit)
				{
					var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
					value.unit = rect ? "rectangle" : "single" == repeat ? "char" : "double" == repeat ? "word" : "line"
				}(null == value.extend || cm.doc.extend) && (value.extend = cm.doc.extend || event.shiftKey);
				null == value.addNew && (value.addNew = mac ? event.metaKey : event.ctrlKey);
				null == value.moveOnDrag && (value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey));
				return value
			}

			function leftButtonDown(cm, pos, repeat, event)
			{
				ie ? setTimeout(bind(ensureFocus, cm), 0) : cm.curOp.focus = activeElt();
				var behavior = configureMouse(cm, repeat, event);
				var contained, sel = cm.doc.sel;
				cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && "single" == repeat && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0) ? leftButtonStartDrag(cm, event, pos, behavior) : leftButtonSelect(cm, event, pos, behavior)
			}

			function leftButtonStartDrag(cm, event, pos, behavior)
			{
				var display = cm.display,
					moved = false;
				var dragEnd = operation(cm, function (e)
				{
					webkit && (display.scroller.draggable = false);
					cm.state.draggingText = false;
					off(display.wrapper.ownerDocument, "mouseup", dragEnd);
					off(display.wrapper.ownerDocument, "mousemove", mouseMove);
					off(display.scroller, "dragstart", dragStart);
					off(display.scroller, "drop", dragEnd);
					if (!moved)
					{
						e_preventDefault(e);
						behavior.addNew || extendSelection(cm.doc, pos, null, null, behavior.extend);
						webkit || ie && 9 == ie_version ? setTimeout(function ()
						{
							display.wrapper.ownerDocument.body.focus();
							display.input.focus()
						}, 20) : display.input.focus()
					}
				});
				var mouseMove = function mouseMove(e2)
				{
					moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10
				};
				var dragStart = function dragStart()
				{
					return moved = true
				};
				webkit && (display.scroller.draggable = true);
				cm.state.draggingText = dragEnd;
				dragEnd.copy = !behavior.moveOnDrag;
				display.scroller.dragDrop && display.scroller.dragDrop();
				on(display.wrapper.ownerDocument, "mouseup", dragEnd);
				on(display.wrapper.ownerDocument, "mousemove", mouseMove);
				on(display.scroller, "dragstart", dragStart);
				on(display.scroller, "drop", dragEnd);
				delayBlurEvent(cm);
				setTimeout(function ()
				{
					return display.input.focus()
				}, 20)
			}

			function rangeForUnit(cm, pos, unit)
			{
				if ("char" == unit) return new Range(pos, pos);
				if ("word" == unit) return cm.findWordAt(pos);
				if ("line" == unit) return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
				var result = unit(cm, pos);
				return new Range(result.from, result.to)
			}

			function leftButtonSelect(cm, event, start, behavior)
			{
				var display = cm.display,
					doc = cm.doc;
				e_preventDefault(event);
				var ourRange, ourIndex, startSel = doc.sel,
					ranges = startSel.ranges;
				if (behavior.addNew && !behavior.extend)
				{
					ourIndex = doc.sel.contains(start);
					ourRange = ourIndex > -1 ? ranges[ourIndex] : new Range(start, start)
				}
				else
				{
					ourRange = doc.sel.primary();
					ourIndex = doc.sel.primIndex
				}
				if ("rectangle" == behavior.unit)
				{
					behavior.addNew || (ourRange = new Range(start, start));
					start = posFromMouse(cm, event, true, true);
					ourIndex = -1
				}
				else
				{
					var range$$1 = rangeForUnit(cm, start, behavior.unit);
					ourRange = behavior.extend ? extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend) : range$$1
				}
				if (behavior.addNew)
					if (-1 == ourIndex)
					{
						ourIndex = ranges.length;
						setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
						{
							scroll: false,
							origin: "*mouse"
						})
					}
				else if (ranges.length > 1 && ranges[ourIndex].empty() && "char" == behavior.unit && !behavior.extend)
				{
					setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
					{
						scroll: false,
						origin: "*mouse"
					});
					startSel = doc.sel
				}
				else replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
				else
				{
					ourIndex = 0;
					setSelection(doc, new Selection([ourRange], 0), sel_mouse);
					startSel = doc.sel
				}
				var lastPos = start;

				function extendTo(pos)
				{
					if (0 == cmp(lastPos, pos)) return;
					lastPos = pos;
					if ("rectangle" == behavior.unit)
					{
						var ranges = [],
							tabSize = cm.options.tabSize;
						var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
						var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
						var left = Math.min(startCol, posCol),
							right = Math.max(startCol, posCol);
						for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++)
						{
							var text = getLine(doc, line).text,
								leftPos = findColumn(text, left, tabSize);
							left == right ? ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))))
						}
						ranges.length || ranges.push(new Range(start, start));
						setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
						{
							origin: "*mouse",
							scroll: false
						});
						cm.scrollIntoView(pos)
					}
					else
					{
						var oldRange = ourRange;
						var range$$1 = rangeForUnit(cm, pos, behavior.unit);
						var head, anchor = oldRange.anchor;
						if (cmp(range$$1.anchor, anchor) > 0)
						{
							head = range$$1.head;
							anchor = minPos(oldRange.from(), range$$1.anchor)
						}
						else
						{
							head = range$$1.anchor;
							anchor = maxPos(oldRange.to(), range$$1.head)
						}
						var ranges$1 = startSel.ranges.slice(0);
						ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head));
						setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)
					}
				}
				var editorSize = display.wrapper.getBoundingClientRect();
				var counter = 0;

				function extend(e)
				{
					var curCount = ++counter;
					var cur = posFromMouse(cm, e, true, "rectangle" == behavior.unit);
					if (!cur) return;
					if (0 != cmp(cur, lastPos))
					{
						cm.curOp.focus = activeElt();
						extendTo(cur);
						var visible = visibleLines(display, doc);
						(cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function ()
						{
							counter == curCount && extend(e)
						}), 150)
					}
					else
					{
						var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
						outside && setTimeout(operation(cm, function ()
						{
							if (counter != curCount) return;
							display.scroller.scrollTop += outside;
							extend(e)
						}), 50)
					}
				}

				function done(e)
				{
					cm.state.selectingText = false;
					counter = Infinity;
					e_preventDefault(e);
					display.input.focus();
					off(display.wrapper.ownerDocument, "mousemove", move);
					off(display.wrapper.ownerDocument, "mouseup", up);
					doc.history.lastSelOrigin = null
				}
				var move = operation(cm, function (e)
				{
					e_button(e) ? extend(e) : done(e)
				});
				var up = operation(cm, done);
				cm.state.selectingText = up;
				on(display.wrapper.ownerDocument, "mousemove", move);
				on(display.wrapper.ownerDocument, "mouseup", up)
			}

			function bidiSimplify(cm, range$$1)
			{
				var anchor = range$$1.anchor;
				var head = range$$1.head;
				var anchorLine = getLine(cm.doc, anchor.line);
				if (0 == cmp(anchor, head) && anchor.sticky == head.sticky) return range$$1;
				var order = getOrder(anchorLine);
				if (!order) return range$$1;
				var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
					part = order[index];
				if (part.from != anchor.ch && part.to != anchor.ch) return range$$1;
				var boundary = index + (part.from == anchor.ch == (1 != part.level) ? 0 : 1);
				if (0 == boundary || boundary == order.length) return range$$1;
				var leftSide;
				if (head.line != anchor.line) leftSide = (head.line - anchor.line) * ("ltr" == cm.doc.direction ? 1 : -1) > 0;
				else
				{
					var headIndex = getBidiPartAt(order, head.ch, head.sticky);
					var dir = headIndex - index || (head.ch - anchor.ch) * (1 == part.level ? -1 : 1);
					leftSide = headIndex == boundary - 1 || headIndex == boundary ? dir < 0 : dir > 0
				}
				var usePart = order[boundary + (leftSide ? -1 : 0)];
				var from = leftSide == (1 == usePart.level);
				var ch = from ? usePart.from : usePart.to,
					sticky = from ? "after" : "before";
				return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
			}

			function gutterEvent(cm, e, type, prevent)
			{
				var mX, mY;
				if (e.touches)
				{
					mX = e.touches[0].clientX;
					mY = e.touches[0].clientY
				}
				else try
				{
					mX = e.clientX;
					mY = e.clientY
				}
				catch (e)
				{
					return false
				}
				if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
				prevent && e_preventDefault(e);
				var display = cm.display;
				var lineBox = display.lineDiv.getBoundingClientRect();
				if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
				mY -= lineBox.top - display.viewOffset;
				for (var i = 0; i < cm.options.gutters.length; ++i)
				{
					var g = display.gutters.childNodes[i];
					if (g && g.getBoundingClientRect().right >= mX)
					{
						var line = _lineAtHeight(cm.doc, mY);
						var gutter = cm.options.gutters[i];
						signal(cm, type, cm, line, gutter, e);
						return e_defaultPrevented(e)
					}
				}
			}

			function clickInGutter(cm, e)
			{
				return gutterEvent(cm, e, "gutterClick", true)
			}

			function onContextMenu(cm, e)
			{
				if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
				if (signalDOMEvent(cm, e, "contextmenu")) return;
				cm.display.input.onContextMenu(e)
			}

			function contextMenuInGutter(cm, e)
			{
				if (!hasHandler(cm, "gutterContextMenu")) return false;
				return gutterEvent(cm, e, "gutterContextMenu", false)
			}

			function themeChanged(cm)
			{
				cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
				clearCaches(cm)
			}
			var Init = {
				toString: function toString()
				{
					return "CodeMirror.Init"
				}
			};
			var defaults = {};
			var optionHandlers = {};

			function defineOptions(CodeMirror)
			{
				var optionHandlers = CodeMirror.optionHandlers;

				function option(name, deflt, handle, notOnInit)
				{
					CodeMirror.defaults[name] = deflt;
					handle && (optionHandlers[name] = notOnInit ? function (cm, val, old)
					{
						old != Init && handle(cm, val, old)
					} : handle)
				}
				CodeMirror.defineOption = option;
				CodeMirror.Init = Init;
				option("value", "", function (cm, val)
				{
					return cm.setValue(val)
				}, true);
				option("mode", null, function (cm, val)
				{
					cm.doc.modeOption = val;
					loadMode(cm)
				}, true);
				option("indentUnit", 2, loadMode, true);
				option("indentWithTabs", false);
				option("smartIndent", true);
				option("tabSize", 4, function (cm)
				{
					resetModeState(cm);
					clearCaches(cm);
					regChange(cm)
				}, true);
				option("lineSeparator", null, function (cm, val)
				{
					cm.doc.lineSep = val;
					if (!val) return;
					var newBreaks = [],
						lineNo = cm.doc.first;
					cm.doc.iter(function (line)
					{
						for (var pos = 0;;)
						{
							var found = line.text.indexOf(val, pos);
							if (-1 == found) break;
							pos = found + val.length;
							newBreaks.push(Pos(lineNo, found))
						}
						lineNo++
					});
					for (var i = newBreaks.length - 1; i >= 0; i--) _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
				});
				option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old)
				{
					cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
					old != Init && cm.refresh()
				});
				option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm)
				{
					return cm.refresh()
				}, true);
				option("electricChars", true);
				option("inputStyle", mobile ? "contenteditable" : "textarea", function ()
				{
					throw new Error("inputStyle can not (yet) be changed in a running editor")
				}, true);
				option("spellcheck", false, function (cm, val)
				{
					return cm.getInputField().spellcheck = val
				}, true);
				option("rtlMoveVisually", !windows);
				option("wholeLineUpdateBefore", true);
				option("theme", "default", function (cm)
				{
					themeChanged(cm);
					guttersChanged(cm)
				}, true);
				option("keyMap", "default", function (cm, val, old)
				{
					var next = getKeyMap(val);
					var prev = old != Init && getKeyMap(old);
					prev && prev.detach && prev.detach(cm, next);
					next.attach && next.attach(cm, prev || null)
				});
				option("extraKeys", null);
				option("configureMouse", null);
				option("lineWrapping", false, wrappingChanged, true);
				option("gutters", [], function (cm)
				{
					setGuttersForLineNumbers(cm.options);
					guttersChanged(cm)
				}, true);
				option("fixedGutter", true, function (cm, val)
				{
					cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
					cm.refresh()
				}, true);
				option("coverGutterNextToScrollbar", false, function (cm)
				{
					return updateScrollbars(cm)
				}, true);
				option("scrollbarStyle", "native", function (cm)
				{
					initScrollbars(cm);
					updateScrollbars(cm);
					cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
					cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)
				}, true);
				option("lineNumbers", false, function (cm)
				{
					setGuttersForLineNumbers(cm.options);
					guttersChanged(cm)
				}, true);
				option("firstLineNumber", 1, guttersChanged, true);
				option("lineNumberFormatter", function (integer)
				{
					return integer
				}, guttersChanged, true);
				option("showCursorWhenSelecting", false, updateSelection, true);
				option("resetSelectionOnContextMenu", true);
				option("lineWiseCopyCut", true);
				option("pasteLinesPerSelection", true);
				option("readOnly", false, function (cm, val)
				{
					if ("nocursor" == val)
					{
						onBlur(cm);
						cm.display.input.blur()
					}
					cm.display.input.readOnlyChanged(val)
				});
				option("disableInput", false, function (cm, val)
				{
					val || cm.display.input.reset()
				}, true);
				option("dragDrop", true, dragDropChanged);
				option("allowDropFileTypes", null);
				option("cursorBlinkRate", 530);
				option("cursorScrollMargin", 0);
				option("cursorHeight", 1, updateSelection, true);
				option("singleCursorHeightPerLine", true, updateSelection, true);
				option("workTime", 100);
				option("workDelay", 100);
				option("flattenSpans", true, resetModeState, true);
				option("addModeClass", false, resetModeState, true);
				option("pollInterval", 100);
				option("undoDepth", 200, function (cm, val)
				{
					return cm.doc.history.undoDepth = val
				});
				option("historyEventDelay", 1250);
				option("viewportMargin", 10, function (cm)
				{
					return cm.refresh()
				}, true);
				option("maxHighlightLength", 1e4, resetModeState, true);
				option("moveInputWithCursor", true, function (cm, val)
				{
					val || cm.display.input.resetPosition()
				});
				option("tabindex", null, function (cm, val)
				{
					return cm.display.input.getField().tabIndex = val || ""
				});
				option("autofocus", null);
				option("direction", "ltr", function (cm, val)
				{
					return cm.doc.setDirection(val)
				}, true)
			}

			function guttersChanged(cm)
			{
				updateGutters(cm);
				regChange(cm);
				alignHorizontally(cm)
			}

			function dragDropChanged(cm, value, old)
			{
				var wasOn = old && old != Init;
				if (!value != !wasOn)
				{
					var funcs = cm.display.dragFunctions;
					var toggle = value ? on : off;
					toggle(cm.display.scroller, "dragstart", funcs.start);
					toggle(cm.display.scroller, "dragenter", funcs.enter);
					toggle(cm.display.scroller, "dragover", funcs.over);
					toggle(cm.display.scroller, "dragleave", funcs.leave);
					toggle(cm.display.scroller, "drop", funcs.drop)
				}
			}

			function wrappingChanged(cm)
			{
				if (cm.options.lineWrapping)
				{
					addClass(cm.display.wrapper, "CodeMirror-wrap");
					cm.display.sizer.style.minWidth = "";
					cm.display.sizerWidth = null
				}
				else
				{
					rmClass(cm.display.wrapper, "CodeMirror-wrap");
					findMaxLine(cm)
				}
				estimateLineHeights(cm);
				regChange(cm);
				clearCaches(cm);
				setTimeout(function ()
				{
					return updateScrollbars(cm)
				}, 100)
			}

			function CodeMirror$1(place, options)
			{
				var this$1 = this;
				if (!(this instanceof CodeMirror$1)) return new CodeMirror$1(place, options);
				this.options = options = options ? copyObj(options) :
				{};
				copyObj(defaults, options, false);
				setGuttersForLineNumbers(options);
				var doc = options.value;
				"string" == typeof doc && (doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction));
				this.doc = doc;
				var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
				var display = this.display = new Display(place, doc, input);
				display.wrapper.CodeMirror = this;
				updateGutters(this);
				themeChanged(this);
				options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap");
				initScrollbars(this);
				this.state = {
					keyMaps: [],
					overlays: [],
					modeGen: 0,
					overwrite: false,
					delayingBlurEvent: false,
					focused: false,
					suppressEdits: false,
					pasteIncoming: false,
					cutIncoming: false,
					selectingText: false,
					draggingText: false,
					highlight: new Delayed,
					keySeq: null,
					specialChars: null
				};
				options.autofocus && !mobile && display.input.focus();
				ie && ie_version < 11 && setTimeout(function ()
				{
					return this$1.display.input.reset(true)
				}, 20);
				registerEventHandlers(this);
				ensureGlobalHandlers();
				_startOperation(this);
				this.curOp.forceUpdate = true;
				attachDoc(this, doc);
				options.autofocus && !mobile || this.hasFocus() ? setTimeout(bind(onFocus, this), 20) : onBlur(this);
				for (var opt in optionHandlers) optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this$1, options[opt], Init);
				maybeUpdateLineNumberWidth(this);
				options.finishInit && options.finishInit(this);
				for (var i = 0; i < initHooks.length; ++i) initHooks[i](this$1);
				_endOperation(this);
				webkit && options.lineWrapping && "optimizelegibility" == getComputedStyle(display.lineDiv).textRendering && (display.lineDiv.style.textRendering = "auto")
			}
			CodeMirror$1.defaults = defaults;
			CodeMirror$1.optionHandlers = optionHandlers;

			function registerEventHandlers(cm)
			{
				var d = cm.display;
				on(d.scroller, "mousedown", operation(cm, onMouseDown));
				on(d.scroller, "dblclick", ie && ie_version < 11 ? operation(cm, function (e)
				{
					if (signalDOMEvent(cm, e)) return;
					var pos = posFromMouse(cm, e);
					if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
					e_preventDefault(e);
					var word = cm.findWordAt(pos);
					extendSelection(cm.doc, word.anchor, word.head)
				}) : function (e)
				{
					return signalDOMEvent(cm, e) || e_preventDefault(e)
				});
				captureRightClick || on(d.scroller, "contextmenu", function (e)
				{
					return onContextMenu(cm, e)
				});
				var touchFinished, prevTouch = {
					end: 0
				};

				function finishTouch()
				{
					if (d.activeTouch)
					{
						touchFinished = setTimeout(function ()
						{
							return d.activeTouch = null
						}, 1e3);
						prevTouch = d.activeTouch;
						prevTouch.end = +new Date
					}
				}

				function isMouseLikeTouchEvent(e)
				{
					if (1 != e.touches.length) return false;
					var touch = e.touches[0];
					return touch.radiusX <= 1 && touch.radiusY <= 1
				}

				function farAway(touch, other)
				{
					if (null == other.left) return true;
					var dx = other.left - touch.left,
						dy = other.top - touch.top;
					return dx * dx + dy * dy > 400
				}
				on(d.scroller, "touchstart", function (e)
				{
					if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e))
					{
						d.input.ensurePolled();
						clearTimeout(touchFinished);
						var now = +new Date;
						d.activeTouch = {
							start: now,
							moved: false,
							prev: now - prevTouch.end <= 300 ? prevTouch : null
						};
						if (1 == e.touches.length)
						{
							d.activeTouch.left = e.touches[0].pageX;
							d.activeTouch.top = e.touches[0].pageY
						}
					}
				});
				on(d.scroller, "touchmove", function ()
				{
					d.activeTouch && (d.activeTouch.moved = true)
				});
				on(d.scroller, "touchend", function (e)
				{
					var touch = d.activeTouch;
					if (touch && !eventInWidget(d, e) && null != touch.left && !touch.moved && new Date - touch.start < 300)
					{
						var range, pos = cm.coordsChar(d.activeTouch, "page");
						range = !touch.prev || farAway(touch, touch.prev) ? new Range(pos, pos) : !touch.prev.prev || farAway(touch, touch.prev.prev) ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
						cm.setSelection(range.anchor, range.head);
						cm.focus();
						e_preventDefault(e)
					}
					finishTouch()
				});
				on(d.scroller, "touchcancel", finishTouch);
				on(d.scroller, "scroll", function ()
				{
					if (d.scroller.clientHeight)
					{
						updateScrollTop(cm, d.scroller.scrollTop);
						setScrollLeft(cm, d.scroller.scrollLeft, true);
						signal(cm, "scroll", cm)
					}
				});
				on(d.scroller, "mousewheel", function (e)
				{
					return onScrollWheel(cm, e)
				});
				on(d.scroller, "DOMMouseScroll", function (e)
				{
					return onScrollWheel(cm, e)
				});
				on(d.wrapper, "scroll", function ()
				{
					return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0
				});
				d.dragFunctions = {
					enter: function enter(e)
					{
						signalDOMEvent(cm, e) || e_stop(e)
					},
					over: function over(e)
					{
						if (!signalDOMEvent(cm, e))
						{
							onDragOver(cm, e);
							e_stop(e)
						}
					},
					start: function start(e)
					{
						return onDragStart(cm, e)
					},
					drop: operation(cm, onDrop),
					leave: function leave(e)
					{
						signalDOMEvent(cm, e) || clearDragCursor(cm)
					}
				};
				var inp = d.input.getField();
				on(inp, "keyup", function (e)
				{
					return onKeyUp.call(cm, e)
				});
				on(inp, "keydown", operation(cm, onKeyDown));
				on(inp, "keypress", operation(cm, onKeyPress));
				on(inp, "focus", function (e)
				{
					return onFocus(cm, e)
				});
				on(inp, "blur", function (e)
				{
					return onBlur(cm, e)
				})
			}
			var initHooks = [];
			CodeMirror$1.defineInitHook = function (f)
			{
				return initHooks.push(f)
			};

			function indentLine(cm, n, how, aggressive)
			{
				var state, doc = cm.doc;
				null == how && (how = "add");
				"smart" == how && (doc.mode.indent ? state = getContextBefore(cm, n).state : how = "prev");
				var tabSize = cm.options.tabSize;
				var line = getLine(doc, n),
					curSpace = countColumn(line.text, null, tabSize);
				line.stateAfter && (line.stateAfter = null);
				var indentation, curSpaceString = line.text.match(/^\s*/)[0];
				if (aggressive || /\S/.test(line.text))
				{
					if ("smart" == how)
					{
						indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
						if (indentation == Pass || indentation > 150)
						{
							if (!aggressive) return;
							how = "prev"
						}
					}
				}
				else
				{
					indentation = 0;
					how = "not"
				}
				"prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how);
				indentation = Math.max(0, indentation);
				var indentString = "",
					pos = 0;
				if (cm.options.indentWithTabs)
					for (var i = Math.floor(indentation / tabSize); i; --i)
					{
						pos += tabSize;
						indentString += "\t"
					}
				pos < indentation && (indentString += spaceStr(indentation - pos));
				if (indentString != curSpaceString)
				{
					_replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
					line.stateAfter = null;
					return true
				}
				for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++)
				{
					var range = doc.sel.ranges[i$1];
					if (range.head.line == n && range.head.ch < curSpaceString.length)
					{
						var pos$1 = Pos(n, curSpaceString.length);
						replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
						break
					}
				}
			}
			var lastCopied = null;

			function setLastCopied(newLastCopied)
			{
				lastCopied = newLastCopied
			}

			function applyTextInput(cm, inserted, deleted, sel, origin)
			{
				var doc = cm.doc;
				cm.display.shift = false;
				sel || (sel = doc.sel);
				var paste = cm.state.pasteIncoming || "paste" == origin;
				var textLines = splitLinesAuto(inserted),
					multiPaste = null;
				if (paste && sel.ranges.length > 1)
					if (lastCopied && lastCopied.text.join("\n") == inserted)
					{
						if (sel.ranges.length % lastCopied.text.length == 0)
						{
							multiPaste = [];
							for (var i = 0; i < lastCopied.text.length; i++) multiPaste.push(doc.splitLines(lastCopied.text[i]))
						}
					}
				else textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection && (multiPaste = map(textLines, function (l)
				{
					return [l]
				}));
				var updateInput;
				for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--)
				{
					var range$$1 = sel.ranges[i$1];
					var from = range$$1.from(),
						to = range$$1.to();
					range$$1.empty() && (deleted && deleted > 0 ? from = Pos(from.line, from.ch - deleted) : cm.state.overwrite && !paste ? to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) : lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted && (from = to = Pos(from.line, 0)));
					updateInput = cm.curOp.updateInput;
					var changeEvent = {
						from: from,
						to: to,
						text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
						origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
					};
					makeChange(cm.doc, changeEvent);
					signalLater(cm, "inputRead", cm, changeEvent)
				}
				inserted && !paste && triggerElectric(cm, inserted);
				ensureCursorVisible(cm);
				cm.curOp.updateInput = updateInput;
				cm.curOp.typing = true;
				cm.state.pasteIncoming = cm.state.cutIncoming = false
			}

			function handlePaste(e, cm)
			{
				var pasted = e.clipboardData && e.clipboardData.getData("Text");
				if (pasted)
				{
					e.preventDefault();
					cm.isReadOnly() || cm.options.disableInput || runInOp(cm, function ()
					{
						return applyTextInput(cm, pasted, 0, null, "paste")
					});
					return true
				}
			}

			function triggerElectric(cm, inserted)
			{
				if (!cm.options.electricChars || !cm.options.smartIndent) return;
				var sel = cm.doc.sel;
				for (var i = sel.ranges.length - 1; i >= 0; i--)
				{
					var range$$1 = sel.ranges[i];
					if (range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line) continue;
					var mode = cm.getModeAt(range$$1.head);
					var indented = false;
					if (mode.electricChars)
					{
						for (var j = 0; j < mode.electricChars.length; j++)
							if (inserted.indexOf(mode.electricChars.charAt(j)) > -1)
							{
								indented = indentLine(cm, range$$1.head.line, "smart");
								break
							}
					}
					else mode.electricInput && mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)) && (indented = indentLine(cm, range$$1.head.line, "smart"));
					indented && signalLater(cm, "electricInput", cm, range$$1.head.line)
				}
			}

			function copyableRanges(cm)
			{
				var text = [],
					ranges = [];
				for (var i = 0; i < cm.doc.sel.ranges.length; i++)
				{
					var line = cm.doc.sel.ranges[i].head.line;
					var lineRange = {
						anchor: Pos(line, 0),
						head: Pos(line + 1, 0)
					};
					ranges.push(lineRange);
					text.push(cm.getRange(lineRange.anchor, lineRange.head))
				}
				return {
					text: text,
					ranges: ranges
				}
			}

			function disableBrowserMagic(field, spellcheck)
			{
				field.setAttribute("autocorrect", "off");
				field.setAttribute("autocapitalize", "off");
				field.setAttribute("spellcheck", !!spellcheck)
			}

			function hiddenTextarea()
			{
				var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
				var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
				webkit ? te.style.width = "1000px" : te.setAttribute("wrap", "off");
				ios && (te.style.border = "1px solid black");
				disableBrowserMagic(te);
				return div
			}
			var addEditorMethods = function addEditorMethods(CodeMirror)
			{
				var optionHandlers = CodeMirror.optionHandlers;
				var helpers = CodeMirror.helpers = {};
				CodeMirror.prototype = {
					constructor: CodeMirror,
					focus: function focus()
					{
						window.focus();
						this.display.input.focus()
					},
					setOption: function setOption(option, value)
					{
						var options = this.options,
							old = options[option];
						if (options[option] == value && "mode" != option) return;
						options[option] = value;
						optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old);
						signal(this, "optionChange", this, option)
					},
					getOption: function getOption(option)
					{
						return this.options[option]
					},
					getDoc: function getDoc()
					{
						return this.doc
					},
					addKeyMap: function addKeyMap(map$$1, bottom)
					{
						this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1))
					},
					removeKeyMap: function removeKeyMap(map$$1)
					{
						var maps = this.state.keyMaps;
						for (var i = 0; i < maps.length; ++i)
							if (maps[i] == map$$1 || maps[i].name == map$$1)
							{
								maps.splice(i, 1);
								return true
							}
					},
					addOverlay: methodOp(function (spec, options)
					{
						var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
						if (mode.startState) throw new Error("Overlays may not be stateful.");
						insertSorted(this.state.overlays,
						{
							mode: mode,
							modeSpec: spec,
							opaque: options && options.opaque,
							priority: options && options.priority || 0
						}, function (overlay)
						{
							return overlay.priority
						});
						this.state.modeGen++;
						regChange(this)
					}),
					removeOverlay: methodOp(function (spec)
					{
						var this$1 = this;
						var overlays = this.state.overlays;
						for (var i = 0; i < overlays.length; ++i)
						{
							var cur = overlays[i].modeSpec;
							if (cur == spec || "string" == typeof spec && cur.name == spec)
							{
								overlays.splice(i, 1);
								this$1.state.modeGen++;
								regChange(this$1);
								return
							}
						}
					}),
					indentLine: methodOp(function (n, dir, aggressive)
					{
						"string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract");
						isLine(this.doc, n) && indentLine(this, n, dir, aggressive)
					}),
					indentSelection: methodOp(function (how)
					{
						var this$1 = this;
						var ranges = this.doc.sel.ranges,
							end = -1;
						for (var i = 0; i < ranges.length; i++)
						{
							var range$$1 = ranges[i];
							if (range$$1.empty())
							{
								if (range$$1.head.line > end)
								{
									indentLine(this$1, range$$1.head.line, how, true);
									end = range$$1.head.line;
									i == this$1.doc.sel.primIndex && ensureCursorVisible(this$1)
								}
							}
							else
							{
								var from = range$$1.from(),
									to = range$$1.to();
								var start = Math.max(end, from.line);
								end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
								for (var j = start; j < end; ++j) indentLine(this$1, j, how);
								var newRanges = this$1.doc.sel.ranges;
								0 == from.ch && ranges.length == newRanges.length && newRanges[i].from().ch > 0 && replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll)
							}
						}
					}),
					getTokenAt: function getTokenAt(pos, precise)
					{
						return takeToken(this, pos, precise)
					},
					getLineTokens: function getLineTokens(line, precise)
					{
						return takeToken(this, Pos(line), precise, true)
					},
					getTokenTypeAt: function getTokenTypeAt(pos)
					{
						pos = _clipPos(this.doc, pos);
						var styles = getLineStyles(this, getLine(this.doc, pos.line));
						var before = 0,
							after = (styles.length - 1) / 2,
							ch = pos.ch;
						var type;
						if (0 == ch) type = styles[2];
						else
							for (;;)
							{
								var mid = before + after >> 1;
								if ((mid ? styles[2 * mid - 1] : 0) >= ch) after = mid;
								else
								{
									if (!(styles[2 * mid + 1] < ch))
									{
										type = styles[2 * mid + 2];
										break
									}
									before = mid + 1
								}
							}
						var cut = type ? type.indexOf("overlay ") : -1;
						return cut < 0 ? type : 0 == cut ? null : type.slice(0, cut - 1)
					},
					getModeAt: function getModeAt(pos)
					{
						var mode = this.doc.mode;
						if (!mode.innerMode) return mode;
						return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
					},
					getHelper: function getHelper(pos, type)
					{
						return this.getHelpers(pos, type)[0]
					},
					getHelpers: function getHelpers(pos, type)
					{
						var this$1 = this;
						var found = [];
						if (!helpers.hasOwnProperty(type)) return found;
						var help = helpers[type],
							mode = this.getModeAt(pos);
						if ("string" == typeof mode[type]) help[mode[type]] && found.push(help[mode[type]]);
						else if (mode[type])
							for (var i = 0; i < mode[type].length; i++)
							{
								var val = help[mode[type][i]];
								val && found.push(val)
							}
						else mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
						for (var i$1 = 0; i$1 < help._global.length; i$1++)
						{
							var cur = help._global[i$1];
							cur.pred(mode, this$1) && -1 == indexOf(found, cur.val) && found.push(cur.val)
						}
						return found
					},
					getStateAfter: function getStateAfter(line, precise)
					{
						var doc = this.doc;
						line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line);
						return getContextBefore(this, line + 1, precise).state
					},
					cursorCoords: function cursorCoords(start, mode)
					{
						var pos, range$$1 = this.doc.sel.primary();
						pos = null == start ? range$$1.head : "object" == ("undefined" === typeof start ? "undefined" : _typeof(start)) ? _clipPos(this.doc, start) : start ? range$$1.from() : range$$1.to();
						return _cursorCoords(this, pos, mode || "page")
					},
					charCoords: function charCoords(pos, mode)
					{
						return _charCoords(this, _clipPos(this.doc, pos), mode || "page")
					},
					coordsChar: function coordsChar(coords, mode)
					{
						coords = fromCoordSystem(this, coords, mode || "page");
						return _coordsChar(this, coords.left, coords.top)
					},
					lineAtHeight: function lineAtHeight(height, mode)
					{
						height = fromCoordSystem(this,
						{
							top: height,
							left: 0
						}, mode || "page").top;
						return _lineAtHeight(this.doc, height + this.display.viewOffset)
					},
					heightAtLine: function heightAtLine(line, mode, includeWidgets)
					{
						var lineObj, end = false;
						if ("number" == typeof line)
						{
							var last = this.doc.first + this.doc.size - 1;
							if (line < this.doc.first) line = this.doc.first;
							else if (line > last)
							{
								line = last;
								end = true
							}
							lineObj = getLine(this.doc, line)
						}
						else lineObj = line;
						return intoCoordSystem(this, lineObj,
						{
							top: 0,
							left: 0
						}, mode || "page", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0)
					},
					defaultTextHeight: function defaultTextHeight()
					{
						return textHeight(this.display)
					},
					defaultCharWidth: function defaultCharWidth()
					{
						return charWidth(this.display)
					},
					getViewport: function getViewport()
					{
						return {
							from: this.display.viewFrom,
							to: this.display.viewTo
						}
					},
					addWidget: function addWidget(pos, node, scroll, vert, horiz)
					{
						var display = this.display;
						pos = _cursorCoords(this, _clipPos(this.doc, pos));
						var top = pos.bottom,
							left = pos.left;
						node.style.position = "absolute";
						node.setAttribute("cm-ignore-events", "true");
						this.display.input.setUneditable(node);
						display.sizer.appendChild(node);
						if ("over" == vert) top = pos.top;
						else if ("above" == vert || "near" == vert)
						{
							var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
								hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
							("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom);
							left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth)
						}
						node.style.top = top + "px";
						node.style.left = node.style.right = "";
						if ("right" == horiz)
						{
							left = display.sizer.clientWidth - node.offsetWidth;
							node.style.right = "0px"
						}
						else
						{
							"left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2);
							node.style.left = left + "px"
						}
						scroll && scrollIntoView(this,
						{
							left: left,
							top: top,
							right: left + node.offsetWidth,
							bottom: top + node.offsetHeight
						})
					},
					triggerOnKeyDown: methodOp(onKeyDown),
					triggerOnKeyPress: methodOp(onKeyPress),
					triggerOnKeyUp: onKeyUp,
					triggerOnMouseDown: methodOp(onMouseDown),
					execCommand: function execCommand(cmd)
					{
						if (commands.hasOwnProperty(cmd)) return commands[cmd].call(null, this)
					},
					triggerElectric: methodOp(function (text)
					{
						triggerElectric(this, text)
					}),
					findPosH: function findPosH(from, amount, unit, visually)
					{
						var this$1 = this;
						var dir = 1;
						if (amount < 0)
						{
							dir = -1;
							amount = -amount
						}
						var cur = _clipPos(this.doc, from);
						for (var i = 0; i < amount; ++i)
						{
							cur = _findPosH(this$1.doc, cur, dir, unit, visually);
							if (cur.hitSide) break
						}
						return cur
					},
					moveH: methodOp(function (dir, unit)
					{
						var this$1 = this;
						this.extendSelectionsBy(function (range$$1)
						{
							return this$1.display.shift || this$1.doc.extend || range$$1.empty() ? _findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) : dir < 0 ? range$$1.from() : range$$1.to()
						}, sel_move)
					}),
					deleteH: methodOp(function (dir, unit)
					{
						var sel = this.doc.sel,
							doc = this.doc;
						sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function (range$$1)
						{
							var other = _findPosH(doc, range$$1.head, dir, unit, false);
							return dir < 0 ?
							{
								from: other,
								to: range$$1.head
							} :
							{
								from: range$$1.head,
								to: other
							}
						})
					}),
					findPosV: function findPosV(from, amount, unit, goalColumn)
					{
						var this$1 = this;
						var dir = 1,
							x = goalColumn;
						if (amount < 0)
						{
							dir = -1;
							amount = -amount
						}
						var cur = _clipPos(this.doc, from);
						for (var i = 0; i < amount; ++i)
						{
							var coords = _cursorCoords(this$1, cur, "div");
							null == x ? x = coords.left : coords.left = x;
							cur = _findPosV(this$1, coords, dir, unit);
							if (cur.hitSide) break
						}
						return cur
					},
					moveV: methodOp(function (dir, unit)
					{
						var this$1 = this;
						var doc = this.doc,
							goals = [];
						var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
						doc.extendSelectionsBy(function (range$$1)
						{
							if (collapse) return dir < 0 ? range$$1.from() : range$$1.to();
							var headPos = _cursorCoords(this$1, range$$1.head, "div");
							null != range$$1.goalColumn && (headPos.left = range$$1.goalColumn);
							goals.push(headPos.left);
							var pos = _findPosV(this$1, headPos, dir, unit);
							"page" == unit && range$$1 == doc.sel.primary() && addToScrollTop(this$1, _charCoords(this$1, pos, "div").top - headPos.top);
							return pos
						}, sel_move);
						if (goals.length)
							for (var i = 0; i < doc.sel.ranges.length; i++) doc.sel.ranges[i].goalColumn = goals[i]
					}),
					findWordAt: function findWordAt(pos)
					{
						var doc = this.doc,
							line = getLine(doc, pos.line).text;
						var start = pos.ch,
							end = pos.ch;
						if (line)
						{
							var helper = this.getHelper(pos, "wordChars");
							"before" != pos.sticky && end != line.length || !start ? ++end : --start;
							var startChar = line.charAt(start);
							var check = isWordChar(startChar, helper) ? function (ch)
							{
								return isWordChar(ch, helper)
							} : /\s/.test(startChar) ? function (ch)
							{
								return /\s/.test(ch)
							} : function (ch)
							{
								return !/\s/.test(ch) && !isWordChar(ch)
							};
							while (start > 0 && check(line.charAt(start - 1))) --start;
							while (end < line.length && check(line.charAt(end))) ++end
						}
						return new Range(Pos(pos.line, start), Pos(pos.line, end))
					},
					toggleOverwrite: function toggleOverwrite(value)
					{
						if (null != value && value == this.state.overwrite) return;
						(this.state.overwrite = !this.state.overwrite) ? addClass(this.display.cursorDiv, "CodeMirror-overwrite"): rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
						signal(this, "overwriteToggle", this, this.state.overwrite)
					},
					hasFocus: function hasFocus()
					{
						return this.display.input.getField() == activeElt()
					},
					isReadOnly: function isReadOnly()
					{
						return !!(this.options.readOnly || this.doc.cantEdit)
					},
					scrollTo: methodOp(function (x, y)
					{
						scrollToCoords(this, x, y)
					}),
					getScrollInfo: function getScrollInfo()
					{
						var scroller = this.display.scroller;
						return {
							left: scroller.scrollLeft,
							top: scroller.scrollTop,
							height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
							width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
							clientHeight: displayHeight(this),
							clientWidth: displayWidth(this)
						}
					},
					scrollIntoView: methodOp(function (range$$1, margin)
					{
						if (null == range$$1)
						{
							range$$1 = {
								from: this.doc.sel.primary().head,
								to: null
							};
							null == margin && (margin = this.options.cursorScrollMargin)
						}
						else "number" == typeof range$$1 ? range$$1 = {
							from: Pos(range$$1, 0),
							to: null
						} : null == range$$1.from && (range$$1 = {
							from: range$$1,
							to: null
						});
						range$$1.to || (range$$1.to = range$$1.from);
						range$$1.margin = margin || 0;
						null != range$$1.from.line ? scrollToRange(this, range$$1) : scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin)
					}),
					setSize: methodOp(function (width, height)
					{
						var this$1 = this;
						var interpret = function interpret(val)
						{
							return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val
						};
						null != width && (this.display.wrapper.style.width = interpret(width));
						null != height && (this.display.wrapper.style.height = interpret(height));
						this.options.lineWrapping && clearLineMeasurementCache(this);
						var lineNo$$1 = this.display.viewFrom;
						this.doc.iter(lineNo$$1, this.display.viewTo, function (line)
						{
							if (line.widgets)
								for (var i = 0; i < line.widgets.length; i++)
									if (line.widgets[i].noHScroll)
									{
										regLineChange(this$1, lineNo$$1, "widget");
										break
									}++lineNo$$1
						});
						this.curOp.forceUpdate = true;
						signal(this, "refresh", this)
					}),
					operation: function operation(f)
					{
						return runInOp(this, f)
					},
					startOperation: function startOperation()
					{
						return _startOperation(this)
					},
					endOperation: function endOperation()
					{
						return _endOperation(this)
					},
					refresh: methodOp(function ()
					{
						var oldHeight = this.display.cachedTextHeight;
						regChange(this);
						this.curOp.forceUpdate = true;
						clearCaches(this);
						scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
						updateGutterSpace(this);
						(null == oldHeight || Math.abs(oldHeight - textHeight(this.display)) > .5) && estimateLineHeights(this);
						signal(this, "refresh", this)
					}),
					swapDoc: methodOp(function (doc)
					{
						var old = this.doc;
						old.cm = null;
						attachDoc(this, doc);
						clearCaches(this);
						this.display.input.reset();
						scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
						this.curOp.forceScroll = true;
						signalLater(this, "swapDoc", this, old);
						return old
					}),
					getInputField: function getInputField()
					{
						return this.display.input.getField()
					},
					getWrapperElement: function getWrapperElement()
					{
						return this.display.wrapper
					},
					getScrollerElement: function getScrollerElement()
					{
						return this.display.scroller
					},
					getGutterElement: function getGutterElement()
					{
						return this.display.gutters
					}
				};
				eventMixin(CodeMirror);
				CodeMirror.registerHelper = function (type, name, value)
				{
					helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {
						_global: []
					});
					helpers[type][name] = value
				};
				CodeMirror.registerGlobalHelper = function (type, name, predicate, value)
				{
					CodeMirror.registerHelper(type, name, value);
					helpers[type]._global.push(
					{
						pred: predicate,
						val: value
					})
				}
			};

			function _findPosH(doc, pos, dir, unit, visually)
			{
				var oldPos = pos;
				var origDir = dir;
				var lineObj = getLine(doc, pos.line);

				function findNextLine()
				{
					var l = pos.line + dir;
					if (l < doc.first || l >= doc.first + doc.size) return false;
					pos = new Pos(l, pos.ch, pos.sticky);
					return lineObj = getLine(doc, l)
				}

				function moveOnce(boundToLine)
				{
					var next;
					next = visually ? moveVisually(doc.cm, lineObj, pos, dir) : moveLogically(lineObj, pos, dir);
					if (null == next)
					{
						if (boundToLine || !findNextLine()) return false;
						pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir)
					}
					else pos = next;
					return true
				}
				if ("char" == unit) moveOnce();
				else if ("column" == unit) moveOnce(true);
				else if ("word" == unit || "group" == unit)
				{
					var sawType = null,
						group = "group" == unit;
					var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
					for (var first = true;; first = false)
					{
						if (dir < 0 && !moveOnce(!first)) break;
						var cur = lineObj.text.charAt(pos.ch) || "\n";
						var type = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
						!group || first || type || (type = "s");
						if (sawType && sawType != type)
						{
							if (dir < 0)
							{
								dir = 1;
								moveOnce();
								pos.sticky = "after"
							}
							break
						}
						type && (sawType = type);
						if (dir > 0 && !moveOnce(!first)) break
					}
				}
				var result = skipAtomic(doc, pos, oldPos, origDir, true);
				equalCursorPos(oldPos, result) && (result.hitSide = true);
				return result
			}

			function _findPosV(cm, pos, dir, unit)
			{
				var y, doc = cm.doc,
					x = pos.left;
				if ("page" == unit)
				{
					var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
					var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
					y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount
				}
				else "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
				var target;
				for (;;)
				{
					target = _coordsChar(cm, x, y);
					if (!target.outside) break;
					if (dir < 0 ? y <= 0 : y >= doc.height)
					{
						target.hitSide = true;
						break
					}
					y += 5 * dir
				}
				return target
			}
			var ContentEditableInput = function ContentEditableInput(cm)
			{
				this.cm = cm;
				this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
				this.polling = new Delayed;
				this.composing = null;
				this.gracePeriod = false;
				this.readDOMTimeout = null
			};
			ContentEditableInput.prototype.init = function (display)
			{
				var this$1 = this;
				var input = this,
					cm = input.cm;
				var div = input.div = display.lineDiv;
				disableBrowserMagic(div, cm.options.spellcheck);
				on(div, "paste", function (e)
				{
					if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return;
					ie_version <= 11 && setTimeout(operation(cm, function ()
					{
						return this$1.updateFromDOM()
					}), 20)
				});
				on(div, "compositionstart", function (e)
				{
					this$1.composing = {
						data: e.data,
						done: false
					}
				});
				on(div, "compositionupdate", function (e)
				{
					this$1.composing || (this$1.composing = {
						data: e.data,
						done: false
					})
				});
				on(div, "compositionend", function (e)
				{
					if (this$1.composing)
					{
						e.data != this$1.composing.data && this$1.readFromDOMSoon();
						this$1.composing.done = true
					}
				});
				on(div, "touchstart", function ()
				{
					return input.forceCompositionEnd()
				});
				on(div, "input", function ()
				{
					this$1.composing || this$1.readFromDOMSoon()
				});

				function onCopyCut(e)
				{
					if (signalDOMEvent(cm, e)) return;
					if (cm.somethingSelected())
					{
						setLastCopied(
						{
							lineWise: false,
							text: cm.getSelections()
						});
						"cut" == e.type && cm.replaceSelection("", null, "cut")
					}
					else
					{
						if (!cm.options.lineWiseCopyCut) return;
						var ranges = copyableRanges(cm);
						setLastCopied(
						{
							lineWise: true,
							text: ranges.text
						});
						"cut" == e.type && cm.operation(function ()
						{
							cm.setSelections(ranges.ranges, 0, sel_dontScroll);
							cm.replaceSelection("", null, "cut")
						})
					}
					if (e.clipboardData)
					{
						e.clipboardData.clearData();
						var content = lastCopied.text.join("\n");
						e.clipboardData.setData("Text", content);
						if (e.clipboardData.getData("Text") == content)
						{
							e.preventDefault();
							return
						}
					}
					var kludge = hiddenTextarea(),
						te = kludge.firstChild;
					cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
					te.value = lastCopied.text.join("\n");
					var hadFocus = document.activeElement;
					selectInput(te);
					setTimeout(function ()
					{
						cm.display.lineSpace.removeChild(kludge);
						hadFocus.focus();
						hadFocus == div && input.showPrimarySelection()
					}, 50)
				}
				on(div, "copy", onCopyCut);
				on(div, "cut", onCopyCut)
			};
			ContentEditableInput.prototype.prepareSelection = function ()
			{
				var result = prepareSelection(this.cm, false);
				result.focus = this.cm.state.focused;
				return result
			};
			ContentEditableInput.prototype.showSelection = function (info, takeFocus)
			{
				if (!info || !this.cm.display.view.length) return;
				(info.focus || takeFocus) && this.showPrimarySelection();
				this.showMultipleSelections(info)
			};
			ContentEditableInput.prototype.showPrimarySelection = function ()
			{
				var sel = window.getSelection(),
					cm = this.cm,
					prim = cm.doc.sel.primary();
				var from = prim.from(),
					to = prim.to();
				if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom)
				{
					sel.removeAllRanges();
					return
				}
				var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
				var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
				if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && 0 == cmp(minPos(curAnchor, curFocus), from) && 0 == cmp(maxPos(curAnchor, curFocus), to)) return;
				var view = cm.display.view;
				var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) ||
				{
					node: view[0].measure.map[2],
					offset: 0
				};
				var end = to.line < cm.display.viewTo && posToDOM(cm, to);
				if (!end)
				{
					var measure = view[view.length - 1].measure;
					var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
					end = {
						node: map$$1[map$$1.length - 1],
						offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]
					}
				}
				if (!start || !end)
				{
					sel.removeAllRanges();
					return
				}
				var rng, old = sel.rangeCount && sel.getRangeAt(0);
				try
				{
					rng = range(start.node, start.offset, end.offset, end.node)
				}
				catch (e)
				{}
				if (rng)
				{
					if (!gecko && cm.state.focused)
					{
						sel.collapse(start.node, start.offset);
						if (!rng.collapsed)
						{
							sel.removeAllRanges();
							sel.addRange(rng)
						}
					}
					else
					{
						sel.removeAllRanges();
						sel.addRange(rng)
					}
					old && null == sel.anchorNode ? sel.addRange(old) : gecko && this.startGracePeriod()
				}
				this.rememberSelection()
			};
			ContentEditableInput.prototype.startGracePeriod = function ()
			{
				var this$1 = this;
				clearTimeout(this.gracePeriod);
				this.gracePeriod = setTimeout(function ()
				{
					this$1.gracePeriod = false;
					this$1.selectionChanged() && this$1.cm.operation(function ()
					{
						return this$1.cm.curOp.selectionChanged = true
					})
				}, 20)
			};
			ContentEditableInput.prototype.showMultipleSelections = function (info)
			{
				removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
				removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)
			};
			ContentEditableInput.prototype.rememberSelection = function ()
			{
				var sel = window.getSelection();
				this.lastAnchorNode = sel.anchorNode;
				this.lastAnchorOffset = sel.anchorOffset;
				this.lastFocusNode = sel.focusNode;
				this.lastFocusOffset = sel.focusOffset
			};
			ContentEditableInput.prototype.selectionInEditor = function ()
			{
				var sel = window.getSelection();
				if (!sel.rangeCount) return false;
				var node = sel.getRangeAt(0).commonAncestorContainer;
				return contains(this.div, node)
			};
			ContentEditableInput.prototype.focus = function ()
			{
				if ("nocursor" != this.cm.options.readOnly)
				{
					this.selectionInEditor() || this.showSelection(this.prepareSelection(), true);
					this.div.focus()
				}
			};
			ContentEditableInput.prototype.blur = function ()
			{
				this.div.blur()
			};
			ContentEditableInput.prototype.getField = function ()
			{
				return this.div
			};
			ContentEditableInput.prototype.supportsTouch = function ()
			{
				return true
			};
			ContentEditableInput.prototype.receivedFocus = function ()
			{
				var input = this;
				this.selectionInEditor() ? this.pollSelection() : runInOp(this.cm, function ()
				{
					return input.cm.curOp.selectionChanged = true
				});

				function poll()
				{
					if (input.cm.state.focused)
					{
						input.pollSelection();
						input.polling.set(input.cm.options.pollInterval, poll)
					}
				}
				this.polling.set(this.cm.options.pollInterval, poll)
			};
			ContentEditableInput.prototype.selectionChanged = function ()
			{
				var sel = window.getSelection();
				return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
			};
			ContentEditableInput.prototype.pollSelection = function ()
			{
				if (null != this.readDOMTimeout || this.gracePeriod || !this.selectionChanged()) return;
				var sel = window.getSelection(),
					cm = this.cm;
				if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode))
				{
					this.cm.triggerOnKeyDown(
					{
						type: "keydown",
						keyCode: 8,
						preventDefault: Math.abs
					});
					this.blur();
					this.focus();
					return
				}
				if (this.composing) return;
				this.rememberSelection();
				var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
				var head = domToPos(cm, sel.focusNode, sel.focusOffset);
				anchor && head && runInOp(cm, function ()
				{
					setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
					(anchor.bad || head.bad) && (cm.curOp.selectionChanged = true)
				})
			};
			ContentEditableInput.prototype.pollContent = function ()
			{
				if (null != this.readDOMTimeout)
				{
					clearTimeout(this.readDOMTimeout);
					this.readDOMTimeout = null
				}
				var cm = this.cm,
					display = cm.display,
					sel = cm.doc.sel.primary();
				var from = sel.from(),
					to = sel.to();
				0 == from.ch && from.line > cm.firstLine() && (from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length));
				to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine() && (to = Pos(to.line + 1, 0));
				if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;
				var fromIndex, fromLine, fromNode;
				if (from.line == display.viewFrom || 0 == (fromIndex = findViewIndex(cm, from.line)))
				{
					fromLine = lineNo(display.view[0].line);
					fromNode = display.view[0].node
				}
				else
				{
					fromLine = lineNo(display.view[fromIndex].line);
					fromNode = display.view[fromIndex - 1].node.nextSibling
				}
				var toIndex = findViewIndex(cm, to.line);
				var toLine, toNode;
				if (toIndex == display.view.length - 1)
				{
					toLine = display.viewTo - 1;
					toNode = display.lineDiv.lastChild
				}
				else
				{
					toLine = lineNo(display.view[toIndex + 1].line) - 1;
					toNode = display.view[toIndex + 1].node.previousSibling
				}
				if (!fromNode) return false;
				var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
				var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
				while (newText.length > 1 && oldText.length > 1)
					if (lst(newText) == lst(oldText))
					{
						newText.pop();
						oldText.pop();
						toLine--
					}
				else
				{
					if (newText[0] != oldText[0]) break;
					newText.shift();
					oldText.shift();
					fromLine++
				}
				var cutFront = 0,
					cutEnd = 0;
				var newTop = newText[0],
					oldTop = oldText[0],
					maxCutFront = Math.min(newTop.length, oldTop.length);
				while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) ++cutFront;
				var newBot = lst(newText),
					oldBot = lst(oldText);
				var maxCutEnd = Math.min(newBot.length - (1 == newText.length ? cutFront : 0), oldBot.length - (1 == oldText.length ? cutFront : 0));
				while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) ++cutEnd;
				if (1 == newText.length && 1 == oldText.length && fromLine == from.line)
					while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
					{
						cutFront--;
						cutEnd++
					}
				newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
				newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
				var chFrom = Pos(fromLine, cutFront);
				var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
				if (newText.length > 1 || newText[0] || cmp(chFrom, chTo))
				{
					_replaceRange(cm.doc, newText, chFrom, chTo, "+input");
					return true
				}
			};
			ContentEditableInput.prototype.ensurePolled = function ()
			{
				this.forceCompositionEnd()
			};
			ContentEditableInput.prototype.reset = function ()
			{
				this.forceCompositionEnd()
			};
			ContentEditableInput.prototype.forceCompositionEnd = function ()
			{
				if (!this.composing) return;
				clearTimeout(this.readDOMTimeout);
				this.composing = null;
				this.updateFromDOM();
				this.div.blur();
				this.div.focus()
			};
			ContentEditableInput.prototype.readFromDOMSoon = function ()
			{
				var this$1 = this;
				if (null != this.readDOMTimeout) return;
				this.readDOMTimeout = setTimeout(function ()
				{
					this$1.readDOMTimeout = null;
					if (this$1.composing)
					{
						if (!this$1.composing.done) return;
						this$1.composing = null
					}
					this$1.updateFromDOM()
				}, 80)
			};
			ContentEditableInput.prototype.updateFromDOM = function ()
			{
				var this$1 = this;
				!this.cm.isReadOnly() && this.pollContent() || runInOp(this.cm, function ()
				{
					return regChange(this$1.cm)
				})
			};
			ContentEditableInput.prototype.setUneditable = function (node)
			{
				node.contentEditable = "false"
			};
			ContentEditableInput.prototype.onKeyPress = function (e)
			{
				if (0 == e.charCode || this.composing) return;
				e.preventDefault();
				this.cm.isReadOnly() || operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0)
			};
			ContentEditableInput.prototype.readOnlyChanged = function (val)
			{
				this.div.contentEditable = String("nocursor" != val)
			};
			ContentEditableInput.prototype.onContextMenu = function () {};
			ContentEditableInput.prototype.resetPosition = function () {};
			ContentEditableInput.prototype.needsContentAttribute = true;

			function posToDOM(cm, pos)
			{
				var view = findViewForLine(cm, pos.line);
				if (!view || view.hidden) return null;
				var line = getLine(cm.doc, pos.line);
				var info = mapFromLineView(view, line, pos.line);
				var order = getOrder(line, cm.doc.direction),
					side = "left";
				if (order)
				{
					var partPos = getBidiPartAt(order, pos.ch);
					side = partPos % 2 ? "right" : "left"
				}
				var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
				result.offset = "right" == result.collapse ? result.end : result.start;
				return result
			}

			function isInGutter(node)
			{
				for (var scan = node; scan; scan = scan.parentNode)
					if (/CodeMirror-gutter-wrapper/.test(scan.className)) return true;
				return false
			}

			function badPos(pos, bad)
			{
				bad && (pos.bad = true);
				return pos
			}

			function domTextBetween(cm, from, to, fromLine, toLine)
			{
				var text = "",
					closing = false,
					lineSep = cm.doc.lineSeparator();

				function recognizeMarker(id)
				{
					return function (marker)
					{
						return marker.id == id
					}
				}

				function close()
				{
					if (closing)
					{
						text += lineSep;
						closing = false
					}
				}

				function addText(str)
				{
					if (str)
					{
						close();
						text += str
					}
				}

				function walk(node)
				{
					if (1 == node.nodeType)
					{
						var cmText = node.getAttribute("cm-text");
						if (null != cmText)
						{
							addText(cmText || node.textContent.replace(/\u200b/g, ""));
							return
						}
						var range$$1, markerID = node.getAttribute("cm-marker");
						if (markerID)
						{
							var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
							found.length && (range$$1 = found[0].find(0)) && addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep));
							return
						}
						if ("false" == node.getAttribute("contenteditable")) return;
						var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
						isBlock && close();
						for (var i = 0; i < node.childNodes.length; i++) walk(node.childNodes[i]);
						isBlock && (closing = true)
					}
					else 3 == node.nodeType && addText(node.nodeValue)
				}
				for (;;)
				{
					walk(from);
					if (from == to) break;
					from = from.nextSibling
				}
				return text
			}

			function domToPos(cm, node, offset)
			{
				var lineNode;
				if (node == cm.display.lineDiv)
				{
					lineNode = cm.display.lineDiv.childNodes[offset];
					if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
					node = null;
					offset = 0
				}
				else
					for (lineNode = node;; lineNode = lineNode.parentNode)
					{
						if (!lineNode || lineNode == cm.display.lineDiv) return null;
						if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break
					}
				for (var i = 0; i < cm.display.view.length; i++)
				{
					var lineView = cm.display.view[i];
					if (lineView.node == lineNode) return locateNodeInLineView(lineView, node, offset)
				}
			}

			function locateNodeInLineView(lineView, node, offset)
			{
				var wrapper = lineView.text.firstChild,
					bad = false;
				if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
				if (node == wrapper)
				{
					bad = true;
					node = wrapper.childNodes[offset];
					offset = 0;
					if (!node)
					{
						var line = lineView.rest ? lst(lineView.rest) : lineView.line;
						return badPos(Pos(lineNo(line), line.text.length), bad)
					}
				}
				var textNode = 3 == node.nodeType ? node : null,
					topNode = node;
				if (!textNode && 1 == node.childNodes.length && 3 == node.firstChild.nodeType)
				{
					textNode = node.firstChild;
					offset && (offset = textNode.nodeValue.length)
				}
				while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
				var measure = lineView.measure,
					maps = measure.maps;

				function find(textNode, topNode, offset)
				{
					for (var i = -1; i < (maps ? maps.length : 0); i++)
					{
						var map$$1 = i < 0 ? measure.map : maps[i];
						for (var j = 0; j < map$$1.length; j += 3)
						{
							var curNode = map$$1[j + 2];
							if (curNode == textNode || curNode == topNode)
							{
								var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
								var ch = map$$1[j] + offset;
								(offset < 0 || curNode != textNode) && (ch = map$$1[j + (offset ? 1 : 0)]);
								return Pos(line, ch)
							}
						}
					}
				}
				var found = find(textNode, topNode, offset);
				if (found) return badPos(found, bad);
				for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling)
				{
					found = find(after, after.firstChild, 0);
					if (found) return badPos(Pos(found.line, found.ch - dist), bad);
					dist += after.textContent.length
				}
				for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling)
				{
					found = find(before, before.firstChild, -1);
					if (found) return badPos(Pos(found.line, found.ch + dist$1), bad);
					dist$1 += before.textContent.length
				}
			}
			var TextareaInput = function TextareaInput(cm)
			{
				this.cm = cm;
				this.prevInput = "";
				this.pollingFast = false;
				this.polling = new Delayed;
				this.hasSelection = false;
				this.composing = null
			};
			TextareaInput.prototype.init = function (display)
			{
				var this$1 = this;
				var input = this,
					cm = this.cm;
				this.createField(display);
				var te = this.textarea;
				display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
				ios && (te.style.width = "0px");
				on(te, "input", function ()
				{
					ie && ie_version >= 9 && this$1.hasSelection && (this$1.hasSelection = null);
					input.poll()
				});
				on(te, "paste", function (e)
				{
					if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return;
					cm.state.pasteIncoming = true;
					input.fastPoll()
				});

				function prepareCopyCut(e)
				{
					if (signalDOMEvent(cm, e)) return;
					if (cm.somethingSelected()) setLastCopied(
					{
						lineWise: false,
						text: cm.getSelections()
					});
					else
					{
						if (!cm.options.lineWiseCopyCut) return;
						var ranges = copyableRanges(cm);
						setLastCopied(
						{
							lineWise: true,
							text: ranges.text
						});
						if ("cut" == e.type) cm.setSelections(ranges.ranges, null, sel_dontScroll);
						else
						{
							input.prevInput = "";
							te.value = ranges.text.join("\n");
							selectInput(te)
						}
					}
					"cut" == e.type && (cm.state.cutIncoming = true)
				}
				on(te, "cut", prepareCopyCut);
				on(te, "copy", prepareCopyCut);
				on(display.scroller, "paste", function (e)
				{
					if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;
					cm.state.pasteIncoming = true;
					input.focus()
				});
				on(display.lineSpace, "selectstart", function (e)
				{
					eventInWidget(display, e) || e_preventDefault(e)
				});
				on(te, "compositionstart", function ()
				{
					var start = cm.getCursor("from");
					input.composing && input.composing.range.clear();
					input.composing = {
						start: start,
						range: cm.markText(start, cm.getCursor("to"),
						{
							className: "CodeMirror-composing"
						})
					}
				});
				on(te, "compositionend", function ()
				{
					if (input.composing)
					{
						input.poll();
						input.composing.range.clear();
						input.composing = null
					}
				})
			};
			TextareaInput.prototype.createField = function (_display)
			{
				this.wrapper = hiddenTextarea();
				this.textarea = this.wrapper.firstChild
			};
			TextareaInput.prototype.prepareSelection = function ()
			{
				var cm = this.cm,
					display = cm.display,
					doc = cm.doc;
				var result = prepareSelection(cm);
				if (cm.options.moveInputWithCursor)
				{
					var headPos = _cursorCoords(cm, doc.sel.primary().head, "div");
					var wrapOff = display.wrapper.getBoundingClientRect(),
						lineOff = display.lineDiv.getBoundingClientRect();
					result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
					result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left))
				}
				return result
			};
			TextareaInput.prototype.showSelection = function (drawn)
			{
				var cm = this.cm,
					display = cm.display;
				removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
				removeChildrenAndAdd(display.selectionDiv, drawn.selection);
				if (null != drawn.teTop)
				{
					this.wrapper.style.top = drawn.teTop + "px";
					this.wrapper.style.left = drawn.teLeft + "px"
				}
			};
			TextareaInput.prototype.reset = function (typing)
			{
				if (this.contextMenuPending || this.composing) return;
				var cm = this.cm;
				if (cm.somethingSelected())
				{
					this.prevInput = "";
					var content = cm.getSelection();
					this.textarea.value = content;
					cm.state.focused && selectInput(this.textarea);
					ie && ie_version >= 9 && (this.hasSelection = content)
				}
				else if (!typing)
				{
					this.prevInput = this.textarea.value = "";
					ie && ie_version >= 9 && (this.hasSelection = null)
				}
			};
			TextareaInput.prototype.getField = function ()
			{
				return this.textarea
			};
			TextareaInput.prototype.supportsTouch = function ()
			{
				return false
			};
			TextareaInput.prototype.focus = function ()
			{
				if ("nocursor" != this.cm.options.readOnly && (!mobile || activeElt() != this.textarea)) try
				{
					this.textarea.focus()
				}
				catch (e)
				{}
			};
			TextareaInput.prototype.blur = function ()
			{
				this.textarea.blur()
			};
			TextareaInput.prototype.resetPosition = function ()
			{
				this.wrapper.style.top = this.wrapper.style.left = 0
			};
			TextareaInput.prototype.receivedFocus = function ()
			{
				this.slowPoll()
			};
			TextareaInput.prototype.slowPoll = function ()
			{
				var this$1 = this;
				if (this.pollingFast) return;
				this.polling.set(this.cm.options.pollInterval, function ()
				{
					this$1.poll();
					this$1.cm.state.focused && this$1.slowPoll()
				})
			};
			TextareaInput.prototype.fastPoll = function ()
			{
				var missed = false,
					input = this;
				input.pollingFast = true;

				function p()
				{
					var changed = input.poll();
					if (changed || missed)
					{
						input.pollingFast = false;
						input.slowPoll()
					}
					else
					{
						missed = true;
						input.polling.set(60, p)
					}
				}
				input.polling.set(20, p)
			};
			TextareaInput.prototype.poll = function ()
			{
				var this$1 = this;
				var cm = this.cm,
					input = this.textarea,
					prevInput = this.prevInput;
				if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) return false;
				var text = input.value;
				if (text == prevInput && !cm.somethingSelected()) return false;
				if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text))
				{
					cm.display.input.reset();
					return false
				}
				if (cm.doc.sel == cm.display.selForContextMenu)
				{
					var first = text.charCodeAt(0);
					8203 != first || prevInput || (prevInput = "");
					if (8666 == first)
					{
						this.reset();
						return this.cm.execCommand("undo")
					}
				}
				var same = 0,
					l = Math.min(prevInput.length, text.length);
				while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
				runInOp(cm, function ()
				{
					applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
					text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = this$1.prevInput = "" : this$1.prevInput = text;
					if (this$1.composing)
					{
						this$1.composing.range.clear();
						this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
						{
							className: "CodeMirror-composing"
						})
					}
				});
				return true
			};
			TextareaInput.prototype.ensurePolled = function ()
			{
				this.pollingFast && this.poll() && (this.pollingFast = false)
			};
			TextareaInput.prototype.onKeyPress = function ()
			{
				ie && ie_version >= 9 && (this.hasSelection = null);
				this.fastPoll()
			};
			TextareaInput.prototype.onContextMenu = function (e)
			{
				var input = this,
					cm = input.cm,
					display = cm.display,
					te = input.textarea;
				var pos = posFromMouse(cm, e),
					scrollPos = display.scroller.scrollTop;
				if (!pos || presto) return;
				var reset = cm.options.resetSelectionOnContextMenu;
				reset && -1 == cm.doc.sel.contains(pos) && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
				var oldCSS = te.style.cssText,
					oldWrapperCSS = input.wrapper.style.cssText;
				input.wrapper.style.cssText = "position: absolute";
				var wrapperBox = input.wrapper.getBoundingClientRect();
				te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
				var oldScrollY;
				webkit && (oldScrollY = window.scrollY);
				display.input.focus();
				webkit && window.scrollTo(null, oldScrollY);
				display.input.reset();
				cm.somethingSelected() || (te.value = input.prevInput = " ");
				input.contextMenuPending = true;
				display.selForContextMenu = cm.doc.sel;
				clearTimeout(display.detectingSelectAll);

				function prepareSelectAllHack()
				{
					if (null != te.selectionStart)
					{
						var selected = cm.somethingSelected();
						var extval = "" + (selected ? te.value : "");
						te.value = "";
						te.value = extval;
						input.prevInput = selected ? "" : "";
						te.selectionStart = 1;
						te.selectionEnd = extval.length;
						display.selForContextMenu = cm.doc.sel
					}
				}

				function rehide()
				{
					input.contextMenuPending = false;
					input.wrapper.style.cssText = oldWrapperCSS;
					te.style.cssText = oldCSS;
					ie && ie_version < 9 && display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
					if (null != te.selectionStart)
					{
						(!ie || ie && ie_version < 9) && prepareSelectAllHack();
						var i = 0,
							poll = function poll()
							{
								if (display.selForContextMenu == cm.doc.sel && 0 == te.selectionStart && te.selectionEnd > 0 && "" == input.prevInput) operation(cm, selectAll)(cm);
								else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
								else
								{
									display.selForContextMenu = null;
									display.input.reset()
								}
							};
						display.detectingSelectAll = setTimeout(poll, 200)
					}
				}
				ie && ie_version >= 9 && prepareSelectAllHack();
				if (captureRightClick)
				{
					e_stop(e);
					var mouseup = function mouseup()
					{
						off(window, "mouseup", mouseup);
						setTimeout(rehide, 20)
					};
					on(window, "mouseup", mouseup)
				}
				else setTimeout(rehide, 50)
			};
			TextareaInput.prototype.readOnlyChanged = function (val)
			{
				val || this.reset();
				this.textarea.disabled = "nocursor" == val
			};
			TextareaInput.prototype.setUneditable = function () {};
			TextareaInput.prototype.needsContentAttribute = false;

			function fromTextArea(textarea, options)
			{
				options = options ? copyObj(options) :
				{};
				options.value = textarea.value;
				!options.tabindex && textarea.tabIndex && (options.tabindex = textarea.tabIndex);
				!options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder);
				if (null == options.autofocus)
				{
					var hasFocus = activeElt();
					options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body
				}

				function save()
				{
					textarea.value = cm.getValue()
				}
				var realSubmit;
				if (textarea.form)
				{
					on(textarea.form, "submit", save);
					if (!options.leaveSubmitMethodAlone)
					{
						var form = textarea.form;
						realSubmit = form.submit;
						try
						{
							var wrappedSubmit = form.submit = function ()
							{
								save();
								form.submit = realSubmit;
								form.submit();
								form.submit = wrappedSubmit
							}
						}
						catch (e)
						{}
					}
				}
				options.finishInit = function (cm)
				{
					cm.save = save;
					cm.getTextArea = function ()
					{
						return textarea
					};
					cm.toTextArea = function ()
					{
						cm.toTextArea = isNaN;
						save();
						textarea.parentNode.removeChild(cm.getWrapperElement());
						textarea.style.display = "";
						if (textarea.form)
						{
							off(textarea.form, "submit", save);
							"function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit)
						}
					}
				};
				textarea.style.display = "none";
				var cm = CodeMirror$1(function (node)
				{
					return textarea.parentNode.insertBefore(node, textarea.nextSibling)
				}, options);
				return cm
			}

			function addLegacyProps(CodeMirror)
			{
				CodeMirror.off = off;
				CodeMirror.on = on;
				CodeMirror.wheelEventPixels = wheelEventPixels;
				CodeMirror.Doc = Doc;
				CodeMirror.splitLines = splitLinesAuto;
				CodeMirror.countColumn = countColumn;
				CodeMirror.findColumn = findColumn;
				CodeMirror.isWordChar = isWordCharBasic;
				CodeMirror.Pass = Pass;
				CodeMirror.signal = signal;
				CodeMirror.Line = Line;
				CodeMirror.changeEnd = changeEnd;
				CodeMirror.scrollbarModel = scrollbarModel;
				CodeMirror.Pos = Pos;
				CodeMirror.cmpPos = cmp;
				CodeMirror.modes = modes;
				CodeMirror.mimeModes = mimeModes;
				CodeMirror.resolveMode = resolveMode;
				CodeMirror.getMode = getMode;
				CodeMirror.modeExtensions = modeExtensions;
				CodeMirror.extendMode = extendMode;
				CodeMirror.copyState = copyState;
				CodeMirror.startState = startState;
				CodeMirror.innerMode = innerMode;
				CodeMirror.commands = commands;
				CodeMirror.keyMap = keyMap;
				CodeMirror.keyName = keyName;
				CodeMirror.isModifierKey = isModifierKey;
				CodeMirror.lookupKey = lookupKey;
				CodeMirror.normalizeKeyMap = normalizeKeyMap;
				CodeMirror.StringStream = StringStream;
				CodeMirror.SharedTextMarker = SharedTextMarker;
				CodeMirror.TextMarker = TextMarker;
				CodeMirror.LineWidget = LineWidget;
				CodeMirror.e_preventDefault = e_preventDefault;
				CodeMirror.e_stopPropagation = e_stopPropagation;
				CodeMirror.e_stop = e_stop;
				CodeMirror.addClass = addClass;
				CodeMirror.contains = contains;
				CodeMirror.rmClass = rmClass;
				CodeMirror.keyNames = keyNames
			}
			defineOptions(CodeMirror$1);
			addEditorMethods(CodeMirror$1);
			var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
			for (var prop in Doc.prototype) Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror$1.prototype[prop] = function (method)
			{
				return function ()
				{
					return method.apply(this.doc, arguments)
				}
			}(Doc.prototype[prop]));
			eventMixin(Doc);
			CodeMirror$1.inputStyles = {
				textarea: TextareaInput,
				contenteditable: ContentEditableInput
			};
			CodeMirror$1.defineMode = function (name)
			{
				CodeMirror$1.defaults.mode || "null" == name || (CodeMirror$1.defaults.mode = name);
				defineMode.apply(this, arguments)
			};
			CodeMirror$1.defineMIME = defineMIME;
			CodeMirror$1.defineMode("null", function ()
			{
				return {
					token: function token(stream)
					{
						return stream.skipToEnd()
					}
				}
			});
			CodeMirror$1.defineMIME("text/plain", "null");
			CodeMirror$1.defineExtension = function (name, func)
			{
				CodeMirror$1.prototype[name] = func
			};
			CodeMirror$1.defineDocExtension = function (name, func)
			{
				Doc.prototype[name] = func
			};
			CodeMirror$1.fromTextArea = fromTextArea;
			addLegacyProps(CodeMirror$1);
			CodeMirror$1.version = "5.37.0";
			return CodeMirror$1
		}, void("object" === _typeof(exports) && "undefined" !== typeof module ? module.exports = factory() : !(__WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)));
		var factory
	},
	64: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});

		function isString(val)
		{
			return "[object String]" === Object.prototype.toString.call(val)
		}
		exports.isString = isString;

		function isNumber(val)
		{
			return "[object Number]" === Object.prototype.toString.call(val)
		}
		exports.isNumber = isNumber;

		function isBoolean(val)
		{
			return "[object Boolean]" === Object.prototype.toString.call(val)
		}
		exports.isBoolean = isBoolean;

		function isUndefined(val)
		{
			return "[object Undefined]" === Object.prototype.toString.call(val)
		}
		exports.isUndefined = isUndefined;

		function isObject(val)
		{
			return "[object Object]" === Object.prototype.toString.call(val)
		}
		exports.isObject = isObject;

		function isArray(val)
		{
			return "[object Array]" === Object.prototype.toString.call(val)
		}
		exports.isArray = isArray;

		function isInteger(value)
		{
			return "number" === typeof value && isFinite(value) && Math.floor(value) === value
		}
		exports.isInteger = isInteger;

		function getCodePoint(str, index)
		{
			if (index < 0 || index >= str.length) throw new Error("invalid index for specified string");
			var first = str.charCodeAt(index);
			if (first >= 55296 && first <= 56319 && str.length > index + 1)
			{
				var second = str.charCodeAt(index + 1);
				if (second >= 56320 && second <= 57343) return 1024 * (first - 55296) + second - 56320 + 65536
			}
			return first
		}
		exports.getCodePoint = getCodePoint
	},
	645: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.healthCheck = healthCheck;

		function healthCheck($window)
		{
			if (!$window.sessionStorage.getItem("healthCheck"))
			{
				$window.sessionStorage.setItem("healthCheck", "executed");
				return true
			}
			return false
		}
	},
	646: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		exports.TabNames = {
			welcome: "Welcome",
			general: "Security events",
			fim: "Integrity monitoring",
			pm: "Policy monitoring",
			vuls: "Vulnerabilities",
			oscap: "OpenSCAP",
			audit: "System auditing",
			ciscat: "CIS-CAT",
			pci: "PCI DSS",
			gdpr: "GDPR",
			aws: "Amazon AWS",
			virustotal: "VirusTotal",
			configuration: "Configuration",
			syscollector: "Inventory data",
			api: "API configuration",
			extensions: "Extensions",
			pattern: "Index pattern",
			about: "About",
			status: "Status",
			ruleset: "Ruleset",
			rules: "Rules",
			decoders: "Decoders",
			logs: "1_Logs",
			groups: "Groups",
			monitoring: "Cluster",
			reporting: "Reporting",
			"registration-service": "Registration service",
			cluster: "Cluster",
			"wazuh-modules": "Wazuh modules",
			"active-response": "Active response",
			integrations: "Integrations",
			"database-output": "Database output",
			alerts: "Alerts",
			"global-configuration": "Global configuration",
			"integrity-monitoring": "Integrity monitoring",
			"policy-monitoring": "Policy monitoring",
			"log-collection": "Log collection",
			agentless: "Agentless",
			inventory: "Inventory",
			osquery: "Osquery",
			"open-scap": "OpenSCAP",
			"cis-cat": "CIS-CAT",
			"vulnerability-detector": "Vulnerabilities",
			"aws-s3": "Amazon S3",
			command: "Threat-Analytics commands",
			client: "Client configuration",
			"client-buffer": "Anti-flooding settings"
		}
	},
	647: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlComment = function (_super)
		{
			__extends(XmlComment, _super);

			function XmlComment(content)
			{
				var _this = _super.call(this) || this;
				_this.content = content;
				return _this
			}
			Object.defineProperty(XmlComment.prototype, "content",
			{
				get: function ()
				{
					return this._content
				},
				set: function (content)
				{
					if (!utils_1.isString(content)) throw new TypeError("content should be a string");
					if (!validate_1.validateChar(content)) throw new Error("content should not contain characters not allowed in XML");
					if (!/^([^-]|-[^-])*$/.test(content)) throw new Error("content should not contain the string '--' or end with '-'");
					this._content = content
				},
				enumerable: true,
				configurable: true
			});
			XmlComment.prototype.children = function ()
			{
				throw new Error("XmlComment nodes cannot have children")
			};
			XmlComment.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlComment nodes cannot have children")
			};
			XmlComment.prototype.removeChild = function (node)
			{
				throw new Error("XmlComment nodes cannot have children")
			};
			XmlComment.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlComment nodes cannot have children")
			};
			XmlComment.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return "<!--" + this.content + "-->"
			};
			return XmlComment
		}(XmlNode_1.default);
		exports.default = XmlComment
	},
	648: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlProcInst = function (_super)
		{
			__extends(XmlProcInst, _super);

			function XmlProcInst(target, content)
			{
				var _this = _super.call(this) || this;
				_this.target = target;
				_this.content = content;
				return _this
			}
			Object.defineProperty(XmlProcInst.prototype, "target",
			{
				get: function ()
				{
					return this._target
				},
				set: function (target)
				{
					if (!utils_1.isString(target)) throw new TypeError("target should be a string");
					if (!validate_1.validateChar(target)) throw new Error("target should not contain characters not allowed in XML");
					if ("xml" === target) throw new Error("target should not be the string 'xml'");
					this._target = target
				},
				enumerable: true,
				configurable: true
			});
			Object.defineProperty(XmlProcInst.prototype, "content",
			{
				get: function ()
				{
					return this._content
				},
				set: function (content)
				{
					if (!utils_1.isString(content) && !utils_1.isUndefined(content)) throw new TypeError("data should be a string or undefined");
					if (utils_1.isString(content))
					{
						if (!validate_1.validateChar(content)) throw new Error("data should not contain characters not allowed in XML");
						if (/\?>/.test(content)) throw new Error("data should not contain the string '?>'")
					}
					this._content = content
				},
				enumerable: true,
				configurable: true
			});
			XmlProcInst.prototype.children = function ()
			{
				throw new Error("XmlProcInst nodes cannot have children")
			};
			XmlProcInst.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlProcInst nodes cannot have children")
			};
			XmlProcInst.prototype.removeChild = function (node)
			{
				throw new Error("XmlProcInst nodes cannot have children")
			};
			XmlProcInst.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlProcInst nodes cannot have children")
			};
			XmlProcInst.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return void 0 === this.content ? "<?" + this.target + "?>" : "<?" + this.target + " " + this.content + "?>"
			};
			return XmlProcInst
		}(XmlNode_1.default);
		exports.default = XmlProcInst
	},
	72: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var XmlNode = function ()
		{
			function XmlNode()
			{
				this._parent = void 0;
				this._children = []
			}
			Object.defineProperty(XmlNode.prototype, "parent",
			{
				get: function ()
				{
					return this._parent
				},
				enumerable: true,
				configurable: true
			});
			XmlNode.prototype.children = function ()
			{
				return this._children.slice()
			};
			XmlNode.prototype.insertChild = function (node, index)
			{
				void 0 === index && (index = this._children.length);
				if (!(node instanceof XmlNode)) throw new TypeError("node should be an instance of XmlNode");
				if (!utils_1.isNumber(index) || !utils_1.isInteger(index)) throw new TypeError("index should be an integer");
				if (index < 0 || index > this._children.length) throw new RangeError("index should respect children array bounds");
				if (-1 === this._children.indexOf(node))
				{
					utils_1.isUndefined(node.parent) || node.parent.removeChild(node);
					node._parent = this;
					this._children.splice(index, 0, node);
					return node
				}
				return
			};
			XmlNode.prototype.next = function ()
			{
				if (utils_1.isUndefined(this.parent)) return;
				if (this.parent._children.indexOf(this) === this.parent._children.length - 1) return;
				return this.parent._children[this.parent._children.indexOf(this) + 1]
			};
			XmlNode.prototype.prev = function ()
			{
				if (utils_1.isUndefined(this.parent)) return;
				if (0 === this.parent._children.indexOf(this)) return;
				return this.parent._children[this.parent._children.indexOf(this) - 1]
			};
			XmlNode.prototype.remove = function ()
			{
				if (!utils_1.isUndefined(this.parent))
				{
					var parent_1 = this.parent;
					this.parent.removeChild(this);
					return parent_1
				}
				return
			};
			XmlNode.prototype.removeChild = function (node)
			{
				if (!(node instanceof XmlNode)) throw new Error("node should be an instance of XmlNode");
				var index = this._children.indexOf(node);
				if (-1 !== index)
				{
					node._parent = void 0;
					this._children.splice(index, 1);
					return true
				}
				return false
			};
			XmlNode.prototype.removeChildAtIndex = function (index)
			{
				if (!utils_1.isNumber(index) || !utils_1.isInteger(index)) throw new TypeError("index should be a number");
				if (index < 0 || index >= this._children.length) throw new RangeError("index should respect children array bounds");
				var node = this._children[index];
				node._parent = void 0;
				this._children.splice(index, 1);
				return node
			};
			XmlNode.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				throw new Error("toString not implemented for XmlNode")
			};
			XmlNode.prototype.top = function ()
			{
				return utils_1.isUndefined(this.parent) ? this : this.parent.top()
			};
			XmlNode.prototype.up = function ()
			{
				return this.parent
			};
			return XmlNode
		}();
		exports.default = XmlNode
	},
	954: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var _createClass = function ()
		{
			function defineProperties(target, props)
			{
				for (var i = 0; i < props.length; i++)
				{
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					"value" in descriptor && (descriptor.writable = true);
					Object.defineProperty(target, descriptor.key, descriptor)
				}
			}
			return function (Constructor, protoProps, staticProps)
			{
				protoProps && defineProperties(Constructor.prototype, protoProps);
				staticProps && defineProperties(Constructor, staticProps);
				return Constructor
			}
		}();

		function _classCallCheck(instance, Constructor)
		{
			if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
		}
		exports.FilterHandler = function ()
		{
			function FilterHandler(pattern)
			{
				_classCallCheck(this, FilterHandler);
				this.pattern = pattern
			}
			_createClass(FilterHandler, [
			{
				key: "base",
				value: function base()
				{
					return {
						meta:
						{
							removable: false,
							index: this.pattern,
							negate: false,
							disabled: false,
							alias: null,
							type: "phrase",
							key: null,
							value: null,
							params:
							{
								query: null,
								type: "phrase"
							}
						},
						query:
						{
							match: null
						},
						$state:
						{
							store: "appState"
						}
					}
				}
			},
			{
				key: "agentQuery",
				value: function agentQuery(agent)
				{
					var result = this.base();
					result.meta.key = "agent.id";
					result.meta.value = agent;
					result.meta.params.query = agent;
					result.query.match = {
						"agent.id":
						{
							query: agent,
							type: "phrase"
						}
					};
					return result
				}
			},
			{
				key: "nodeQuery",
				value: function nodeQuery(node)
				{
					var result = this.base();
					result.meta.key = "cluster.node";
					result.meta.value = node;
					result.meta.params.query = node;
					result.query.match = {
						"cluster.node":
						{
							query: node,
							type: "phrase"
						}
					};
					return result
				}
			},
			{
				key: "ruleGroupQuery",
				value: function ruleGroupQuery(group)
				{
					var result = this.base();
					result.meta.key = "rule.groups";
					result.meta.value = group;
					result.meta.params.query = group;
					result.query.match = {
						"rule.groups":
						{
							query: group,
							type: "phrase"
						}
					};
					return result
				}
			},
			{
				key: "ruleIdQuery",
				value: function ruleIdQuery(ruleId)
				{
					var result = this.base();
					result.meta.removable = true;
					result.meta.key = "rule.id";
					result.meta.value = ruleId;
					result.meta.params.query = ruleId;
					result.query.match = {
						"rule.id":
						{
							query: ruleId,
							type: "phrase"
						}
					};
					return result
				}
			},
			{
				key: "managerQuery",
				value: function managerQuery(manager, isCluster)
				{
					var result = this.base();
					result.meta.key = isCluster ? "cluster.name" : "manager.name";
					result.meta.value = manager;
					result.meta.params.query = manager;
					result.query.match = isCluster ?
					{
						"cluster.name":
						{
							query: manager,
							type: "phrase"
						}
					} :
					{
						"manager.name":
						{
							query: manager,
							type: "phrase"
						}
					};
					return result
				}
			},
			{
				key: "pciQuery",
				value: function pciQuery()
				{
					var result = this.base();
					result.meta.type = "exists";
					result.meta.value = "exists";
					result.meta.key = "rule.pci_dss";
					result.exists = {
						field: "rule.pci_dss"
					};
					delete result.query;
					return result
				}
			},
			{
				key: "gdprQuery",
				value: function gdprQuery()
				{
					var result = this.base();
					result.meta.type = "exists";
					result.meta.value = "exists";
					result.meta.key = "rule.gdpr";
					result.exists = {
						field: "rule.gdpr"
					};
					delete result.query;
					return result
				}
			}]);
			return FilterHandler
		}()
	},
	955: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});

		function escapeAmpersands(str)
		{
			return str.replace(/&/g, "&amp;")
		}
		exports.escapeAmpersands = escapeAmpersands;

		function escapeLeftAngleBrackets(str)
		{
			return str.replace(/</g, "&lt;")
		}
		exports.escapeLeftAngleBrackets = escapeLeftAngleBrackets;

		function escapeRightAngleBracketsInCdataTerminator(str)
		{
			return str.replace(/]]>/g, "]]&gt;")
		}
		exports.escapeRightAngleBracketsInCdataTerminator = escapeRightAngleBracketsInCdataTerminator;

		function escapeSingleQuotes(str)
		{
			return str.replace(/'/g, "&apos;")
		}
		exports.escapeSingleQuotes = escapeSingleQuotes;

		function escapeDoubleQuotes(str)
		{
			return str.replace(/"/g, "&quot;")
		}
		exports.escapeDoubleQuotes = escapeDoubleQuotes
	},
	956: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var escape_1 = __webpack_require__(955);
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlAttributeText = function (_super)
		{
			__extends(XmlAttributeText, _super);

			function XmlAttributeText(text)
			{
				var _this = _super.call(this) || this;
				_this.text = text;
				return _this
			}
			Object.defineProperty(XmlAttributeText.prototype, "text",
			{
				get: function ()
				{
					return this._text
				},
				set: function (text)
				{
					if (!utils_1.isString(text)) throw new TypeError("text should be a string");
					if (!validate_1.validateChar(text)) throw new Error("text should not contain characters not allowed in XML");
					this._text = text
				},
				enumerable: true,
				configurable: true
			});
			XmlAttributeText.prototype.children = function ()
			{
				throw new Error("XmlAttributeText nodes cannot have children")
			};
			XmlAttributeText.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlAttributeText nodes cannot have children")
			};
			XmlAttributeText.prototype.removeChild = function (node)
			{
				throw new Error("XmlAttributeText nodes cannot have children")
			};
			XmlAttributeText.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlAttributeText nodes cannot have children")
			};
			XmlAttributeText.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				var str = this.text;
				str = escape_1.escapeAmpersands(str);
				str = escape_1.escapeLeftAngleBrackets(str);
				return str
			};
			return XmlAttributeText
		}(XmlNode_1.default);
		exports.default = XmlAttributeText
	},
	957: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlCharRef = function (_super)
		{
			__extends(XmlCharRef, _super);

			function XmlCharRef(char, hex)
			{
				void 0 === hex && (hex = false);
				var _this = _super.call(this) || this;
				_this.char = char;
				_this.hex = hex;
				return _this
			}
			Object.defineProperty(XmlCharRef.prototype, "char",
			{
				get: function ()
				{
					return this._char
				},
				set: function (char)
				{
					if (!utils_1.isString(char)) throw new TypeError("char should be a string");
					if (!validate_1.validateSingleChar(char)) throw new Error("char should contain a single character, and this character should be allowed in XML");
					this._char = char
				},
				enumerable: true,
				configurable: true
			});
			Object.defineProperty(XmlCharRef.prototype, "hex",
			{
				get: function ()
				{
					return this._hex
				},
				set: function (hex)
				{
					if (!utils_1.isBoolean(hex)) throw new TypeError("hex should be a boolean");
					this._hex = hex
				},
				enumerable: true,
				configurable: true
			});
			XmlCharRef.prototype.children = function ()
			{
				throw new Error("XmlCharRef nodes cannot have children")
			};
			XmlCharRef.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlCharRef nodes cannot have children")
			};
			XmlCharRef.prototype.removeChild = function (node)
			{
				throw new Error("XmlCharRef nodes cannot have children")
			};
			XmlCharRef.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlCharRef nodes cannot have children")
			};
			XmlCharRef.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				var char;
				char = 1 === this.char.length ? this.char.charCodeAt(0) : utils_1.getCodePoint(this.char, 0);
				return this.hex ? "&#x" + char.toString(16) + ";" : "&#" + char + ";"
			};
			return XmlCharRef
		}(XmlNode_1.default);
		exports.default = XmlCharRef
	},
	958: function (module, exports, __webpack_require__)
	{
		"use strict";
		var __extends = this && this.__extends || (extendStatics = Object.setPrototypeOf ||
			{
				__proto__: []
			}
			instanceof Array && function (d, b)
			{
				d.__proto__ = b
			} || function (d, b)
			{
				for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
			},
			function (d, b)
			{
				extendStatics(d, b);

				function __()
				{
					this.constructor = d
				}
				d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
			});
		var extendStatics;
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});
		var utils_1 = __webpack_require__(64);
		var validate_1 = __webpack_require__(98);
		var XmlNode_1 = __webpack_require__(72);
		var XmlEntityRef = function (_super)
		{
			__extends(XmlEntityRef, _super);

			function XmlEntityRef(entity)
			{
				var _this = _super.call(this) || this;
				_this.entity = entity;
				return _this
			}
			Object.defineProperty(XmlEntityRef.prototype, "entity",
			{
				get: function ()
				{
					return this._entity
				},
				set: function (entity)
				{
					if (!utils_1.isString(entity)) throw new TypeError("entity should be a string");
					if (!validate_1.validateName(entity)) throw new Error("entity should not contain characters not allowed in XML names");
					this._entity = entity
				},
				enumerable: true,
				configurable: true
			});
			XmlEntityRef.prototype.children = function ()
			{
				throw new Error("XmlEntityRef nodes cannot have children")
			};
			XmlEntityRef.prototype.insertChild = function (node, index)
			{
				throw new Error("XmlEntityRef nodes cannot have children")
			};
			XmlEntityRef.prototype.removeChild = function (node)
			{
				throw new Error("XmlEntityRef nodes cannot have children")
			};
			XmlEntityRef.prototype.removeChildAtIndex = function (index)
			{
				throw new Error("XmlEntityRef nodes cannot have children")
			};
			XmlEntityRef.prototype.toString = function (options)
			{
				void 0 === options && (options = {});
				return "&" + this.entity + ";"
			};
			return XmlEntityRef
		}(XmlNode_1.default);
		exports.default = XmlEntityRef
	},
	98: function (module, exports, __webpack_require__)
	{
		"use strict";
		Object.defineProperty(exports, "__esModule",
		{
			value: true
		});

		function validateChar(str)
		{
			var charRegex = "\\u0009|\\u000A|\\u000D|[\\u0020-\\uD7FF]|[\\uE000-\\uFFFD]";
			var surrogateCharRegex = "[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]";
			return new RegExp("^((" + charRegex + ")|(" + surrogateCharRegex + "))*$").test(str)
		}
		exports.validateChar = validateChar;

		function validateSingleChar(str)
		{
			return 1 === str.length ? new RegExp("^\\u0009|\\u000A|\\u000D|[\\u0020-\\uD7FF]|[\\uE000-\\uFFFD]$").test(str) : 2 === str.length && new RegExp("^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$").test(str)
		}
		exports.validateSingleChar = validateSingleChar;

		function validateName(str)
		{
			if (0 === str.length) return false;
			var nameStartChar = ":|[A-Z]|_|[a-z]|[\\u00C0-\\u00D6]|[\\u00D8-\\u00F6]|[\\u00F8-\\u02FF]|[\\u0370-\\u037D]|[\\u037F-\\u1FFF]|[\\u200C-\\u200D]|[\\u2070-\\u218F]|[\\u2C00-\\u2FEF]|[\\u3001-\\uD7FF]|[\\uF900-\\uFDCF]|[\\uFDF0-\\uFFFD]";
			var nameStartCharWithSurrogatePair = "[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]";
			var nameChar = nameStartChar + "|-|\\.|[0-9]|\\u00B7|[\\u0300-\\u036F]|[\\u203F-\\u2040]";
			var nameCharWithSurrogatePair = nameChar + "|" + nameStartCharWithSurrogatePair;
			if (new RegExp("^" + nameStartChar + "$").test(str.charAt(0)))
			{
				if (1 === str.length) return true;
				return new RegExp("^(" + nameCharWithSurrogatePair + ")+$").test(str.substr(1))
			}
			if (str.length >= 2 && new RegExp("^" + nameStartCharWithSurrogatePair + "$").test(str.substr(0, 2)))
			{
				if (2 === str.length) return true;
				return new RegExp("^(" + nameCharWithSurrogatePair + ")+$").test(str.substr(2))
			}
			return false
		}
		exports.validateName = validateName
	}
}, [4372]);
